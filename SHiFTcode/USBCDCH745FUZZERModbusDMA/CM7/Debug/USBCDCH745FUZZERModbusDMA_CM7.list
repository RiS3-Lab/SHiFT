
USBCDCH745FUZZERModbusDMA_CM7.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .privileged_functions 00008000  08000000  08000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         0000d224  08008000  08008000  00018000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .ARM.extab    00000000  08015224  08015224  00047404  2**0
                  CONTENTS
  3 .ARM          00000008  08015224  08015224  00025224  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .preinit_array 00000000  0801522c  0801522c  00047404  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .init_array   00000008  0801522c  0801522c  0002522c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .fini_array   00000008  08015234  08015234  00025234  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .privileged_data 00008000  24000000  0801523c  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         000005b4  24008000  0801d23c  00038000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00024c1c  24010000  0801d7f0  00040000  2**16
                  ALLOC
 10 ._user_heap_stack 00001400  24036000  24036000  00046000  2**13
                  ALLOC
 11 ._asan_var    00000004  24037400  24037400  00047400  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .ARM.attributes 0000002e  00000000  00000000  00047404  2**0
                  CONTENTS, READONLY
 13 .debug_info   0005108f  00000000  00000000  00047432  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 000094ba  00000000  00000000  000984c1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loc    0003b882  00000000  00000000  000a197b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 000022b0  00000000  00000000  000dd200  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_ranges 00007540  00000000  00000000  000df4b0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  0004535f  00000000  00000000  000e69f0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   0004b4d7  00000000  00000000  0012bd4f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    0019a58c  00000000  00000000  00177226  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000049  00000000  00000000  003117b2  2**0
                  CONTENTS, READONLY
 22 .debug_frame  00007e24  00000000  00000000  003117fc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .privileged_functions:

08000000 <g_pfnVectors>:
 8000000:	00 00 08 24 41 ac 00 08 85 9f 00 08 a5 9f 00 08     ...$A...........
 8000010:	65 9f 00 08 c5 9f 00 08 e5 9f 00 08 00 00 00 00     e...............
	...
 800002c:	15 57 00 08 4d ab 00 08 00 00 00 00 41 56 00 08     .W..M.......AV..
 800003c:	e5 56 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     .V..............
 800004c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800005c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800006c:	51 ab 00 08 5d ab 00 08 69 ab 00 08 91 ac 00 08     Q...]...i.......
 800007c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800008c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800009c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 80000ac:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 80000bc:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 80000cc:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 80000dc:	75 ab 00 08 91 ac 00 08 91 ac 00 08 00 00 00 00     u...............
 80000ec:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 80000fc:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800010c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800011c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800012c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800013c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 00 00 00 00     ................
 800014c:	00 00 00 00 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800015c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800016c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800017c:	00 00 00 00 81 ab 00 08 91 ac 00 08 91 ac 00 08     ................
 800018c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800019c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 80001ac:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 80001bc:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 80001cc:	91 ac 00 08 91 ac 00 08 8d ab 00 08 91 ac 00 08     ................
 80001dc:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 80001ec:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 80001fc:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800020c:	91 ac 00 08 91 ac 00 08 99 ab 00 08 91 ac 00 08     ................
 800021c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800022c:	00 00 00 00 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800023c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800024c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800025c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800026c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800027c:	91 ac 00 08 91 ac 00 08 91 ac 00 08 91 ac 00 08     ................
 800028c:	00 00 00 00 91 ac 00 08 91 ac 00 08                 ............

08000298 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
 8000298:	b538      	push	{r3, r4, r5, lr}
    configASSERT( xEventGroup );
 800029a:	b1b8      	cbz	r0, 80002cc <vEventGroupClearBitsCallback+0x34>
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 800029c:	f011 4f7f 	tst.w	r1, #4278190080	; 0xff000000
 80002a0:	460c      	mov	r4, r1
 80002a2:	d008      	beq.n	80002b6 <vEventGroupClearBitsCallback+0x1e>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
    uint32_t ulNewBASEPRI;

    __asm volatile
 80002a4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80002a8:	f383 8811 	msr	BASEPRI, r3
 80002ac:	f3bf 8f6f 	isb	sy
 80002b0:	f3bf 8f4f 	dsb	sy
 80002b4:	e7fe      	b.n	80002b4 <vEventGroupClearBitsCallback+0x1c>
    taskENTER_CRITICAL();
 80002b6:	4605      	mov	r5, r0
 80002b8:	f009 fc9e 	bl	8009bf8 <vPortEnterCritical>
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 80002bc:	682b      	ldr	r3, [r5, #0]
 80002be:	ea23 0304 	bic.w	r3, r3, r4
 80002c2:	602b      	str	r3, [r5, #0]
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
}
 80002c4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    taskEXIT_CRITICAL();
 80002c8:	f009 bcac 	b.w	8009c24 <vPortExitCritical>
 80002cc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80002d0:	f383 8811 	msr	BASEPRI, r3
 80002d4:	f3bf 8f6f 	isb	sy
 80002d8:	f3bf 8f4f 	dsb	sy
    configASSERT( xEventGroup );
 80002dc:	e7fe      	b.n	80002dc <vEventGroupClearBitsCallback+0x44>
 80002de:	bf00      	nop

080002e0 <vEventGroupSetBitsCallback>:
    configASSERT( xEventGroup );
 80002e0:	2800      	cmp	r0, #0
 80002e2:	d03d      	beq.n	8000360 <vEventGroupSetBitsCallback+0x80>
{
 80002e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 80002e8:	f011 467f 	ands.w	r6, r1, #4278190080	; 0xff000000
 80002ec:	4688      	mov	r8, r1
 80002ee:	d008      	beq.n	8000302 <vEventGroupSetBitsCallback+0x22>
 80002f0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80002f4:	f383 8811 	msr	BASEPRI, r3
 80002f8:	f3bf 8f6f 	isb	sy
 80002fc:	f3bf 8f4f 	dsb	sy
 8000300:	e7fe      	b.n	8000300 <vEventGroupSetBitsCallback+0x20>
 8000302:	4605      	mov	r5, r0
    vTaskSuspendAll();
 8000304:	f003 f92c 	bl	8003560 <vTaskSuspendAll>
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000308:	f105 070c 	add.w	r7, r5, #12
        pxEventBits->uxEventBits |= uxBitsToSet;
 800030c:	682b      	ldr	r3, [r5, #0]
        pxListItem = listGET_HEAD_ENTRY( pxList );
 800030e:	692c      	ldr	r4, [r5, #16]
        pxEventBits->uxEventBits |= uxBitsToSet;
 8000310:	ea48 0303 	orr.w	r3, r8, r3
        while( pxListItem != pxListEnd )
 8000314:	42a7      	cmp	r7, r4
        pxEventBits->uxEventBits |= uxBitsToSet;
 8000316:	602b      	str	r3, [r5, #0]
        while( pxListItem != pxListEnd )
 8000318:	d10c      	bne.n	8000334 <vEventGroupSetBitsCallback+0x54>
 800031a:	e01c      	b.n	8000356 <vEventGroupSetBitsCallback+0x76>
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 800031c:	ea1c 0f03 	tst.w	ip, r3
 8000320:	d006      	beq.n	8000330 <vEventGroupSetBitsCallback+0x50>
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 8000322:	01d3      	lsls	r3, r2, #7
                    uxBitsToClear |= uxBitsWaitedFor;
 8000324:	bf48      	it	mi
 8000326:	ea46 060c 	orrmi.w	r6, r6, ip
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 800032a:	f004 f9e1 	bl	80046f0 <vTaskRemoveFromUnorderedEventList>
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 800032e:	682b      	ldr	r3, [r5, #0]
        while( pxListItem != pxListEnd )
 8000330:	42a7      	cmp	r7, r4
 8000332:	d00e      	beq.n	8000352 <vEventGroupSetBitsCallback+0x72>
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 8000334:	4620      	mov	r0, r4
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 8000336:	f043 7100 	orr.w	r1, r3, #33554432	; 0x2000000
            pxNext = listGET_NEXT( pxListItem );
 800033a:	6864      	ldr	r4, [r4, #4]
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 800033c:	6802      	ldr	r2, [r0, #0]
            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 800033e:	f012 6f80 	tst.w	r2, #67108864	; 0x4000000
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 8000342:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 8000346:	d0e9      	beq.n	800031c <vEventGroupSetBitsCallback+0x3c>
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 8000348:	ea3c 0e03 	bics.w	lr, ip, r3
 800034c:	d0e9      	beq.n	8000322 <vEventGroupSetBitsCallback+0x42>
        while( pxListItem != pxListEnd )
 800034e:	42a7      	cmp	r7, r4
 8000350:	d1f0      	bne.n	8000334 <vEventGroupSetBitsCallback+0x54>
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 8000352:	ea23 0306 	bic.w	r3, r3, r6
 8000356:	602b      	str	r3, [r5, #0]
}
 8000358:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    ( void ) xTaskResumeAll();
 800035c:	f003 bd9e 	b.w	8003e9c <xTaskResumeAll>
 8000360:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000364:	f383 8811 	msr	BASEPRI, r3
 8000368:	f3bf 8f6f 	isb	sy
 800036c:	f3bf 8f4f 	dsb	sy
    configASSERT( xEventGroup );
 8000370:	e7fe      	b.n	8000370 <vEventGroupSetBitsCallback+0x90>
 8000372:	bf00      	nop

08000374 <xEventGroupCreate>:
    {
 8000374:	b538      	push	{r3, r4, r5, lr}
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
 8000376:	2020      	movs	r0, #32
 8000378:	f005 faf2 	bl	8005960 <pvPortMalloc>
        if( pxEventBits != NULL )
 800037c:	4604      	mov	r4, r0
 800037e:	b128      	cbz	r0, 800038c <xEventGroupCreate+0x18>
            pxEventBits->uxEventBits = 0;
 8000380:	2500      	movs	r5, #0
 8000382:	f840 5b04 	str.w	r5, [r0], #4
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 8000386:	f000 f9ef 	bl	8000768 <vListInitialise>
                    pxEventBits->ucStaticallyAllocated = pdFALSE;
 800038a:	7725      	strb	r5, [r4, #28]
    }
 800038c:	4620      	mov	r0, r4
 800038e:	bd38      	pop	{r3, r4, r5, pc}

08000390 <xEventGroupCreateStatic>:
        configASSERT( pxEventGroupBuffer );
 8000390:	b178      	cbz	r0, 80003b2 <xEventGroupCreateStatic+0x22>
                volatile size_t xSize = sizeof( StaticEventGroup_t );
 8000392:	2320      	movs	r3, #32
    {
 8000394:	b510      	push	{r4, lr}
 8000396:	b082      	sub	sp, #8
                volatile size_t xSize = sizeof( StaticEventGroup_t );
 8000398:	9301      	str	r3, [sp, #4]
                configASSERT( xSize == sizeof( EventGroup_t ) );
 800039a:	9b01      	ldr	r3, [sp, #4]
 800039c:	2b20      	cmp	r3, #32
 800039e:	d011      	beq.n	80003c4 <xEventGroupCreateStatic+0x34>
 80003a0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80003a4:	f383 8811 	msr	BASEPRI, r3
 80003a8:	f3bf 8f6f 	isb	sy
 80003ac:	f3bf 8f4f 	dsb	sy
 80003b0:	e7fe      	b.n	80003b0 <xEventGroupCreateStatic+0x20>
 80003b2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80003b6:	f383 8811 	msr	BASEPRI, r3
 80003ba:	f3bf 8f6f 	isb	sy
 80003be:	f3bf 8f4f 	dsb	sy
        configASSERT( pxEventGroupBuffer );
 80003c2:	e7fe      	b.n	80003c2 <xEventGroupCreateStatic+0x32>
            pxEventBits->uxEventBits = 0;
 80003c4:	2300      	movs	r3, #0
 80003c6:	4604      	mov	r4, r0
 80003c8:	f840 3b04 	str.w	r3, [r0], #4
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 80003cc:	f000 f9cc 	bl	8000768 <vListInitialise>
                    pxEventBits->ucStaticallyAllocated = pdTRUE;
 80003d0:	2301      	movs	r3, #1
    }
 80003d2:	4620      	mov	r0, r4
                    pxEventBits->ucStaticallyAllocated = pdTRUE;
 80003d4:	7723      	strb	r3, [r4, #28]
    }
 80003d6:	b002      	add	sp, #8
 80003d8:	bd10      	pop	{r4, pc}
 80003da:	bf00      	nop

080003dc <xEventGroupWaitBits>:
{
 80003dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    configASSERT( xEventGroup );
 80003e0:	b1b0      	cbz	r0, 8000410 <xEventGroupWaitBits+0x34>
    configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 80003e2:	f011 487f 	ands.w	r8, r1, #4278190080	; 0xff000000
 80003e6:	460c      	mov	r4, r1
 80003e8:	d109      	bne.n	80003fe <xEventGroupWaitBits+0x22>
    configASSERT( uxBitsToWaitFor != 0 );
 80003ea:	b9d1      	cbnz	r1, 8000422 <xEventGroupWaitBits+0x46>
 80003ec:	f04f 0350 	mov.w	r3, #80	; 0x50
 80003f0:	f383 8811 	msr	BASEPRI, r3
 80003f4:	f3bf 8f6f 	isb	sy
 80003f8:	f3bf 8f4f 	dsb	sy
 80003fc:	e7fe      	b.n	80003fc <xEventGroupWaitBits+0x20>
 80003fe:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000402:	f383 8811 	msr	BASEPRI, r3
 8000406:	f3bf 8f6f 	isb	sy
 800040a:	f3bf 8f4f 	dsb	sy
    configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 800040e:	e7fe      	b.n	800040e <xEventGroupWaitBits+0x32>
 8000410:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000414:	f383 8811 	msr	BASEPRI, r3
 8000418:	f3bf 8f6f 	isb	sy
 800041c:	f3bf 8f4f 	dsb	sy
    configASSERT( xEventGroup );
 8000420:	e7fe      	b.n	8000420 <xEventGroupWaitBits+0x44>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8000422:	4617      	mov	r7, r2
 8000424:	461e      	mov	r6, r3
 8000426:	4605      	mov	r5, r0
 8000428:	f004 fab8 	bl	800499c <xTaskGetSchedulerState>
 800042c:	b950      	cbnz	r0, 8000444 <xEventGroupWaitBits+0x68>
 800042e:	9b08      	ldr	r3, [sp, #32]
 8000430:	b143      	cbz	r3, 8000444 <xEventGroupWaitBits+0x68>
 8000432:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000436:	f383 8811 	msr	BASEPRI, r3
 800043a:	f3bf 8f6f 	isb	sy
 800043e:	f3bf 8f4f 	dsb	sy
 8000442:	e7fe      	b.n	8000442 <xEventGroupWaitBits+0x66>
    vTaskSuspendAll();
 8000444:	f003 f88c 	bl	8003560 <vTaskSuspendAll>
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 8000448:	f8d5 9000 	ldr.w	r9, [r5]
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    BaseType_t xWaitConditionMet = pdFALSE;

    if( xWaitForAllBits == pdFALSE )
 800044c:	b36e      	cbz	r6, 80004aa <xEventGroupWaitBits+0xce>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 800044e:	ea34 0309 	bics.w	r3, r4, r9
 8000452:	d02d      	beq.n	80004b0 <xEventGroupWaitBits+0xd4>
        else if( xTicksToWait == ( TickType_t ) 0 )
 8000454:	9b08      	ldr	r3, [sp, #32]
 8000456:	b393      	cbz	r3, 80004be <xEventGroupWaitBits+0xe2>
            if( xClearOnExit != pdFALSE )
 8000458:	2f00      	cmp	r7, #0
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 800045a:	461a      	mov	r2, r3
 800045c:	f105 0004 	add.w	r0, r5, #4
            if( xClearOnExit != pdFALSE )
 8000460:	bf16      	itet	ne
 8000462:	f04f 7880 	movne.w	r8, #16777216	; 0x1000000
 8000466:	f04f 6180 	moveq.w	r1, #67108864	; 0x4000000
 800046a:	f04f 61a0 	movne.w	r1, #83886080	; 0x5000000
            if( xWaitForAllBits != pdFALSE )
 800046e:	2e00      	cmp	r6, #0
 8000470:	bf08      	it	eq
 8000472:	4641      	moveq	r1, r8
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 8000474:	4321      	orrs	r1, r4
 8000476:	f004 f81f 	bl	80044b8 <vTaskPlaceOnUnorderedEventList>
    xAlreadyYielded = xTaskResumeAll();
 800047a:	f003 fd0f 	bl	8003e9c <xTaskResumeAll>
        if( xAlreadyYielded == pdFALSE )
 800047e:	b948      	cbnz	r0, 8000494 <xEventGroupWaitBits+0xb8>
            portYIELD_WITHIN_API();
 8000480:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8000484:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000488:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800048c:	f3bf 8f4f 	dsb	sy
 8000490:	f3bf 8f6f 	isb	sy
        uxReturn = uxTaskResetEventItemValue();
 8000494:	f004 fa64 	bl	8004960 <uxTaskResetEventItemValue>
        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 8000498:	f010 7f00 	tst.w	r0, #33554432	; 0x2000000
        uxReturn = uxTaskResetEventItemValue();
 800049c:	4681      	mov	r9, r0
        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 800049e:	d011      	beq.n	80004c4 <xEventGroupWaitBits+0xe8>
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 80004a0:	f029 497f 	bic.w	r9, r9, #4278190080	; 0xff000000
}
 80004a4:	4648      	mov	r0, r9
 80004a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 80004aa:	ea14 0f09 	tst.w	r4, r9
 80004ae:	d0d1      	beq.n	8000454 <xEventGroupWaitBits+0x78>
            if( xClearOnExit != pdFALSE )
 80004b0:	b12f      	cbz	r7, 80004be <xEventGroupWaitBits+0xe2>
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 80004b2:	ea29 0404 	bic.w	r4, r9, r4
 80004b6:	602c      	str	r4, [r5, #0]
    xAlreadyYielded = xTaskResumeAll();
 80004b8:	f003 fcf0 	bl	8003e9c <xTaskResumeAll>
    if( xTicksToWait != ( TickType_t ) 0 )
 80004bc:	e7f2      	b.n	80004a4 <xEventGroupWaitBits+0xc8>
    xAlreadyYielded = xTaskResumeAll();
 80004be:	f003 fced 	bl	8003e9c <xTaskResumeAll>
    if( xTicksToWait != ( TickType_t ) 0 )
 80004c2:	e7ef      	b.n	80004a4 <xEventGroupWaitBits+0xc8>
            taskENTER_CRITICAL();
 80004c4:	f009 fb98 	bl	8009bf8 <vPortEnterCritical>
                uxReturn = pxEventBits->uxEventBits;
 80004c8:	f8d5 9000 	ldr.w	r9, [r5]
    if( xWaitForAllBits == pdFALSE )
 80004cc:	b94e      	cbnz	r6, 80004e2 <xEventGroupWaitBits+0x106>
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 80004ce:	ea14 0f09 	tst.w	r4, r9
 80004d2:	d003      	beq.n	80004dc <xEventGroupWaitBits+0x100>
                    if( xClearOnExit != pdFALSE )
 80004d4:	b117      	cbz	r7, 80004dc <xEventGroupWaitBits+0x100>
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 80004d6:	ea29 0404 	bic.w	r4, r9, r4
 80004da:	602c      	str	r4, [r5, #0]
            taskEXIT_CRITICAL();
 80004dc:	f009 fba2 	bl	8009c24 <vPortExitCritical>
 80004e0:	e7de      	b.n	80004a0 <xEventGroupWaitBits+0xc4>
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 80004e2:	ea34 0309 	bics.w	r3, r4, r9
 80004e6:	d1f9      	bne.n	80004dc <xEventGroupWaitBits+0x100>
 80004e8:	e7f4      	b.n	80004d4 <xEventGroupWaitBits+0xf8>
 80004ea:	bf00      	nop

080004ec <xEventGroupClearBits>:
    configASSERT( xEventGroup );
 80004ec:	b1c0      	cbz	r0, 8000520 <xEventGroupClearBits+0x34>
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 80004ee:	f011 4f7f 	tst.w	r1, #4278190080	; 0xff000000
{
 80004f2:	b570      	push	{r4, r5, r6, lr}
 80004f4:	460c      	mov	r4, r1
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 80004f6:	d008      	beq.n	800050a <xEventGroupClearBits+0x1e>
 80004f8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80004fc:	f383 8811 	msr	BASEPRI, r3
 8000500:	f3bf 8f6f 	isb	sy
 8000504:	f3bf 8f4f 	dsb	sy
 8000508:	e7fe      	b.n	8000508 <xEventGroupClearBits+0x1c>
    taskENTER_CRITICAL();
 800050a:	4606      	mov	r6, r0
 800050c:	f009 fb74 	bl	8009bf8 <vPortEnterCritical>
        uxReturn = pxEventBits->uxEventBits;
 8000510:	6835      	ldr	r5, [r6, #0]
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 8000512:	ea25 0404 	bic.w	r4, r5, r4
 8000516:	6034      	str	r4, [r6, #0]
    taskEXIT_CRITICAL();
 8000518:	f009 fb84 	bl	8009c24 <vPortExitCritical>
}
 800051c:	4628      	mov	r0, r5
 800051e:	bd70      	pop	{r4, r5, r6, pc}
 8000520:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000524:	f383 8811 	msr	BASEPRI, r3
 8000528:	f3bf 8f6f 	isb	sy
 800052c:	f3bf 8f4f 	dsb	sy
    configASSERT( xEventGroup );
 8000530:	e7fe      	b.n	8000530 <xEventGroupClearBits+0x44>
 8000532:	bf00      	nop

08000534 <xEventGroupClearBitsFromISR>:
    {
 8000534:	4684      	mov	ip, r0
 8000536:	460a      	mov	r2, r1
        xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL ); /*lint !e9087 Can't avoid cast to void* as a generic callback function not specific to this use case. Callback casts back to original type so safe. */
 8000538:	2300      	movs	r3, #0
 800053a:	4802      	ldr	r0, [pc, #8]	; (8000544 <xEventGroupClearBitsFromISR+0x10>)
 800053c:	4661      	mov	r1, ip
 800053e:	f004 be23 	b.w	8005188 <xTimerPendFunctionCallFromISR>
 8000542:	bf00      	nop
 8000544:	08000299 	.word	0x08000299

08000548 <xEventGroupSetBits>:
    configASSERT( xEventGroup );
 8000548:	2800      	cmp	r0, #0
 800054a:	d03e      	beq.n	80005ca <xEventGroupSetBits+0x82>
{
 800054c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 8000550:	f011 467f 	ands.w	r6, r1, #4278190080	; 0xff000000
 8000554:	4688      	mov	r8, r1
 8000556:	d008      	beq.n	800056a <xEventGroupSetBits+0x22>
 8000558:	f04f 0350 	mov.w	r3, #80	; 0x50
 800055c:	f383 8811 	msr	BASEPRI, r3
 8000560:	f3bf 8f6f 	isb	sy
 8000564:	f3bf 8f4f 	dsb	sy
 8000568:	e7fe      	b.n	8000568 <xEventGroupSetBits+0x20>
 800056a:	4605      	mov	r5, r0
    vTaskSuspendAll();
 800056c:	f002 fff8 	bl	8003560 <vTaskSuspendAll>
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000570:	f105 070c 	add.w	r7, r5, #12
        pxEventBits->uxEventBits |= uxBitsToSet;
 8000574:	682b      	ldr	r3, [r5, #0]
        pxListItem = listGET_HEAD_ENTRY( pxList );
 8000576:	692c      	ldr	r4, [r5, #16]
        pxEventBits->uxEventBits |= uxBitsToSet;
 8000578:	ea48 0303 	orr.w	r3, r8, r3
        while( pxListItem != pxListEnd )
 800057c:	42a7      	cmp	r7, r4
        pxEventBits->uxEventBits |= uxBitsToSet;
 800057e:	602b      	str	r3, [r5, #0]
        while( pxListItem != pxListEnd )
 8000580:	d10c      	bne.n	800059c <xEventGroupSetBits+0x54>
 8000582:	e01c      	b.n	80005be <xEventGroupSetBits+0x76>
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 8000584:	ea1c 0f03 	tst.w	ip, r3
 8000588:	d006      	beq.n	8000598 <xEventGroupSetBits+0x50>
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 800058a:	01d3      	lsls	r3, r2, #7
                    uxBitsToClear |= uxBitsWaitedFor;
 800058c:	bf48      	it	mi
 800058e:	ea46 060c 	orrmi.w	r6, r6, ip
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 8000592:	f004 f8ad 	bl	80046f0 <vTaskRemoveFromUnorderedEventList>
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 8000596:	682b      	ldr	r3, [r5, #0]
        while( pxListItem != pxListEnd )
 8000598:	42a7      	cmp	r7, r4
 800059a:	d00e      	beq.n	80005ba <xEventGroupSetBits+0x72>
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 800059c:	4620      	mov	r0, r4
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 800059e:	f043 7100 	orr.w	r1, r3, #33554432	; 0x2000000
            pxNext = listGET_NEXT( pxListItem );
 80005a2:	6864      	ldr	r4, [r4, #4]
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 80005a4:	6802      	ldr	r2, [r0, #0]
            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 80005a6:	f012 6f80 	tst.w	r2, #67108864	; 0x4000000
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 80005aa:	f022 4c7f 	bic.w	ip, r2, #4278190080	; 0xff000000
            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 80005ae:	d0e9      	beq.n	8000584 <xEventGroupSetBits+0x3c>
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 80005b0:	ea3c 0e03 	bics.w	lr, ip, r3
 80005b4:	d0e9      	beq.n	800058a <xEventGroupSetBits+0x42>
        while( pxListItem != pxListEnd )
 80005b6:	42a7      	cmp	r7, r4
 80005b8:	d1f0      	bne.n	800059c <xEventGroupSetBits+0x54>
        pxEventBits->uxEventBits &= ~uxBitsToClear;
 80005ba:	ea23 0306 	bic.w	r3, r3, r6
 80005be:	602b      	str	r3, [r5, #0]
    ( void ) xTaskResumeAll();
 80005c0:	f003 fc6c 	bl	8003e9c <xTaskResumeAll>
}
 80005c4:	6828      	ldr	r0, [r5, #0]
 80005c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80005ca:	f04f 0350 	mov.w	r3, #80	; 0x50
 80005ce:	f383 8811 	msr	BASEPRI, r3
 80005d2:	f3bf 8f6f 	isb	sy
 80005d6:	f3bf 8f4f 	dsb	sy
    configASSERT( xEventGroup );
 80005da:	e7fe      	b.n	80005da <xEventGroupSetBits+0x92>

080005dc <xEventGroupSetBitsFromISR>:
#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )

    BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup,
                                          const EventBits_t uxBitsToSet,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
 80005dc:	4684      	mov	ip, r0
 80005de:	4613      	mov	r3, r2
        BaseType_t xReturn;

        traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
        xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken ); /*lint !e9087 Can't avoid cast to void* as a generic callback function not specific to this use case. Callback casts back to original type so safe. */
 80005e0:	4802      	ldr	r0, [pc, #8]	; (80005ec <xEventGroupSetBitsFromISR+0x10>)
 80005e2:	460a      	mov	r2, r1
 80005e4:	4661      	mov	r1, ip
 80005e6:	f004 bdcf 	b.w	8005188 <xTimerPendFunctionCallFromISR>
 80005ea:	bf00      	nop
 80005ec:	080002e1 	.word	0x080002e1

080005f0 <xEventGroupSync>:
    configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 80005f0:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 80005f4:	d008      	beq.n	8000608 <xEventGroupSync+0x18>
 80005f6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80005fa:	f383 8811 	msr	BASEPRI, r3
 80005fe:	f3bf 8f6f 	isb	sy
 8000602:	f3bf 8f4f 	dsb	sy
 8000606:	e7fe      	b.n	8000606 <xEventGroupSync+0x16>
{
 8000608:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800060c:	4614      	mov	r4, r2
    configASSERT( uxBitsToWaitFor != 0 );
 800060e:	b942      	cbnz	r2, 8000622 <xEventGroupSync+0x32>
 8000610:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000614:	f383 8811 	msr	BASEPRI, r3
 8000618:	f3bf 8f6f 	isb	sy
 800061c:	f3bf 8f4f 	dsb	sy
 8000620:	e7fe      	b.n	8000620 <xEventGroupSync+0x30>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8000622:	4607      	mov	r7, r0
 8000624:	460e      	mov	r6, r1
 8000626:	461d      	mov	r5, r3
 8000628:	f004 f9b8 	bl	800499c <xTaskGetSchedulerState>
 800062c:	b9e0      	cbnz	r0, 8000668 <xEventGroupSync+0x78>
 800062e:	b145      	cbz	r5, 8000642 <xEventGroupSync+0x52>
 8000630:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000634:	f383 8811 	msr	BASEPRI, r3
 8000638:	f3bf 8f6f 	isb	sy
 800063c:	f3bf 8f4f 	dsb	sy
 8000640:	e7fe      	b.n	8000640 <xEventGroupSync+0x50>
    vTaskSuspendAll();
 8000642:	f002 ff8d 	bl	8003560 <vTaskSuspendAll>
        uxOriginalBitValue = pxEventBits->uxEventBits;
 8000646:	683b      	ldr	r3, [r7, #0]
        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 8000648:	4631      	mov	r1, r6
 800064a:	4638      	mov	r0, r7
        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 800064c:	ea46 0803 	orr.w	r8, r6, r3
        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 8000650:	f7ff ff7a 	bl	8000548 <xEventGroupSetBits>
        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 8000654:	ea34 0308 	bics.w	r3, r4, r8
 8000658:	d02f      	beq.n	80006ba <xEventGroupSync+0xca>
                uxReturn = pxEventBits->uxEventBits;
 800065a:	f8d7 8000 	ldr.w	r8, [r7]
    xAlreadyYielded = xTaskResumeAll();
 800065e:	f003 fc1d 	bl	8003e9c <xTaskResumeAll>
}
 8000662:	4640      	mov	r0, r8
 8000664:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    vTaskSuspendAll();
 8000668:	f002 ff7a 	bl	8003560 <vTaskSuspendAll>
        uxOriginalBitValue = pxEventBits->uxEventBits;
 800066c:	683b      	ldr	r3, [r7, #0]
        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 800066e:	4631      	mov	r1, r6
 8000670:	4638      	mov	r0, r7
        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 8000672:	ea43 0806 	orr.w	r8, r3, r6
        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 8000676:	f7ff ff67 	bl	8000548 <xEventGroupSetBits>
        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 800067a:	ea34 0308 	bics.w	r3, r4, r8
 800067e:	d01c      	beq.n	80006ba <xEventGroupSync+0xca>
            if( xTicksToWait != ( TickType_t ) 0 )
 8000680:	2d00      	cmp	r5, #0
 8000682:	d0ea      	beq.n	800065a <xEventGroupSync+0x6a>
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
 8000684:	462a      	mov	r2, r5
 8000686:	f044 61a0 	orr.w	r1, r4, #83886080	; 0x5000000
 800068a:	1d38      	adds	r0, r7, #4
 800068c:	f003 ff14 	bl	80044b8 <vTaskPlaceOnUnorderedEventList>
    xAlreadyYielded = xTaskResumeAll();
 8000690:	f003 fc04 	bl	8003e9c <xTaskResumeAll>
        if( xAlreadyYielded == pdFALSE )
 8000694:	b948      	cbnz	r0, 80006aa <xEventGroupSync+0xba>
            portYIELD_WITHIN_API();
 8000696:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800069a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800069e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80006a2:	f3bf 8f4f 	dsb	sy
 80006a6:	f3bf 8f6f 	isb	sy
        uxReturn = uxTaskResetEventItemValue();
 80006aa:	f004 f959 	bl	8004960 <uxTaskResetEventItemValue>
        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 80006ae:	0183      	lsls	r3, r0, #6
        uxReturn = uxTaskResetEventItemValue();
 80006b0:	4605      	mov	r5, r0
        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 80006b2:	d509      	bpl.n	80006c8 <xEventGroupSync+0xd8>
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 80006b4:	f025 487f 	bic.w	r8, r5, #4278190080	; 0xff000000
    return uxReturn;
 80006b8:	e7d3      	b.n	8000662 <xEventGroupSync+0x72>
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 80006ba:	683b      	ldr	r3, [r7, #0]
 80006bc:	ea23 0304 	bic.w	r3, r3, r4
 80006c0:	603b      	str	r3, [r7, #0]
    xAlreadyYielded = xTaskResumeAll();
 80006c2:	f003 fbeb 	bl	8003e9c <xTaskResumeAll>
    if( xTicksToWait != ( TickType_t ) 0 )
 80006c6:	e7cc      	b.n	8000662 <xEventGroupSync+0x72>
            taskENTER_CRITICAL();
 80006c8:	f009 fa96 	bl	8009bf8 <vPortEnterCritical>
                uxReturn = pxEventBits->uxEventBits;
 80006cc:	683d      	ldr	r5, [r7, #0]
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
 80006ce:	ea34 0305 	bics.w	r3, r4, r5
 80006d2:	d102      	bne.n	80006da <xEventGroupSync+0xea>
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 80006d4:	ea25 0404 	bic.w	r4, r5, r4
 80006d8:	603c      	str	r4, [r7, #0]
            taskEXIT_CRITICAL();
 80006da:	f009 faa3 	bl	8009c24 <vPortExitCritical>
            xTimeoutOccurred = pdTRUE;
 80006de:	e7e9      	b.n	80006b4 <xEventGroupSync+0xc4>

080006e0 <xEventGroupGetBitsFromISR>:

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
    uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

    __asm volatile
 80006e0:	f3ef 8311 	mrs	r3, BASEPRI
 80006e4:	f04f 0250 	mov.w	r2, #80	; 0x50
 80006e8:	f382 8811 	msr	BASEPRI, r2
 80006ec:	f3bf 8f6f 	isb	sy
 80006f0:	f3bf 8f4f 	dsb	sy
        uxReturn = pxEventBits->uxEventBits;
 80006f4:	6800      	ldr	r0, [r0, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
    __asm volatile
 80006f6:	f383 8811 	msr	BASEPRI, r3
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
 80006fa:	4770      	bx	lr

080006fc <vEventGroupDelete>:
{
 80006fc:	b538      	push	{r3, r4, r5, lr}
    configASSERT( pxEventBits );
 80006fe:	b1c8      	cbz	r0, 8000734 <vEventGroupDelete+0x38>
    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
 8000700:	4604      	mov	r4, r0
    vTaskSuspendAll();
 8000702:	f002 ff2d 	bl	8003560 <vTaskSuspendAll>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 8000706:	6863      	ldr	r3, [r4, #4]
 8000708:	b1eb      	cbz	r3, 8000746 <vEventGroupDelete+0x4a>
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 800070a:	f104 050c 	add.w	r5, r4, #12
 800070e:	e003      	b.n	8000718 <vEventGroupDelete+0x1c>
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 8000710:	f003 ffee 	bl	80046f0 <vTaskRemoveFromUnorderedEventList>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 8000714:	6863      	ldr	r3, [r4, #4]
 8000716:	b1b3      	cbz	r3, 8000746 <vEventGroupDelete+0x4a>
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 8000718:	6920      	ldr	r0, [r4, #16]
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 800071a:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 800071e:	42a8      	cmp	r0, r5
 8000720:	d1f6      	bne.n	8000710 <vEventGroupDelete+0x14>
    __asm volatile
 8000722:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000726:	f383 8811 	msr	BASEPRI, r3
 800072a:	f3bf 8f6f 	isb	sy
 800072e:	f3bf 8f4f 	dsb	sy
 8000732:	e7fe      	b.n	8000732 <vEventGroupDelete+0x36>
 8000734:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000738:	f383 8811 	msr	BASEPRI, r3
 800073c:	f3bf 8f6f 	isb	sy
 8000740:	f3bf 8f4f 	dsb	sy
    configASSERT( pxEventBits );
 8000744:	e7fe      	b.n	8000744 <vEventGroupDelete+0x48>
                if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 8000746:	7f23      	ldrb	r3, [r4, #28]
 8000748:	b11b      	cbz	r3, 8000752 <vEventGroupDelete+0x56>
}
 800074a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ( void ) xTaskResumeAll();
 800074e:	f003 bba5 	b.w	8003e9c <xTaskResumeAll>
                    vPortFree( pxEventBits );
 8000752:	4620      	mov	r0, r4
 8000754:	f005 f9b4 	bl	8005ac0 <vPortFree>
 8000758:	e7f7      	b.n	800074a <vEventGroupDelete+0x4e>
 800075a:	bf00      	nop

0800075c <uxEventGroupGetNumber>:
    UBaseType_t uxEventGroupGetNumber( void * xEventGroup )
    {
        UBaseType_t xReturn;
        EventGroup_t const * pxEventBits = ( EventGroup_t * ) xEventGroup; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */

        if( xEventGroup == NULL )
 800075c:	b100      	cbz	r0, 8000760 <uxEventGroupGetNumber+0x4>
        {
            xReturn = 0;
        }
        else
        {
            xReturn = pxEventBits->uxEventGroupNumber;
 800075e:	6980      	ldr	r0, [r0, #24]
        }

        return xReturn;
    }
 8000760:	4770      	bx	lr
 8000762:	bf00      	nop

08000764 <vEventGroupSetNumber>:
#if ( configUSE_TRACE_FACILITY == 1 )

    void vEventGroupSetNumber( void * xEventGroup,
                               UBaseType_t uxEventGroupNumber )
    {
        ( ( EventGroup_t * ) xEventGroup )->uxEventGroupNumber = uxEventGroupNumber; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
 8000764:	6181      	str	r1, [r0, #24]
    }
 8000766:	4770      	bx	lr

08000768 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000768:	f100 0308 	add.w	r3, r0, #8

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 800076c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8000770:	2200      	movs	r2, #0
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 8000772:	6081      	str	r1, [r0, #8]
    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8000774:	6002      	str	r2, [r0, #0]
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000776:	6043      	str	r3, [r0, #4]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000778:	e9c0 3303 	strd	r3, r3, [r0, #12]

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 800077c:	4770      	bx	lr
 800077e:	bf00      	nop

08000780 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
 8000780:	2300      	movs	r3, #0
 8000782:	6103      	str	r3, [r0, #16]

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8000784:	4770      	bx	lr
 8000786:	bf00      	nop

08000788 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
 8000788:	b430      	push	{r4, r5}
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800078a:	680d      	ldr	r5, [r1, #0]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
 800078c:	1c6b      	adds	r3, r5, #1
 800078e:	d010      	beq.n	80007b2 <vListInsert+0x2a>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 8000790:	f100 0308 	add.w	r3, r0, #8
 8000794:	461c      	mov	r4, r3
 8000796:	685b      	ldr	r3, [r3, #4]
 8000798:	681a      	ldr	r2, [r3, #0]
 800079a:	42aa      	cmp	r2, r5
 800079c:	d9fa      	bls.n	8000794 <vListInsert+0xc>

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;

    ( pxList->uxNumberOfItems )++;
 800079e:	6802      	ldr	r2, [r0, #0]
    pxNewListItem->pxNext = pxIterator->pxNext;
 80007a0:	604b      	str	r3, [r1, #4]
    ( pxList->uxNumberOfItems )++;
 80007a2:	3201      	adds	r2, #1
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 80007a4:	6099      	str	r1, [r3, #8]
    pxNewListItem->pxPrevious = pxIterator;
 80007a6:	608c      	str	r4, [r1, #8]
    pxIterator->pxNext = pxNewListItem;
 80007a8:	6061      	str	r1, [r4, #4]
    pxNewListItem->pxContainer = pxList;
 80007aa:	6108      	str	r0, [r1, #16]
    ( pxList->uxNumberOfItems )++;
 80007ac:	6002      	str	r2, [r0, #0]
}
 80007ae:	bc30      	pop	{r4, r5}
 80007b0:	4770      	bx	lr
        pxIterator = pxList->xListEnd.pxPrevious;
 80007b2:	6904      	ldr	r4, [r0, #16]
    pxNewListItem->pxNext = pxIterator->pxNext;
 80007b4:	6863      	ldr	r3, [r4, #4]
 80007b6:	e7f2      	b.n	800079e <vListInsert+0x16>

080007b8 <vListInsertEnd>:
    ListItem_t * const pxIndex = pxList->pxIndex;
 80007b8:	6843      	ldr	r3, [r0, #4]
    ( pxList->uxNumberOfItems )++;
 80007ba:	6802      	ldr	r2, [r0, #0]
{
 80007bc:	b410      	push	{r4}
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80007be:	689c      	ldr	r4, [r3, #8]
    ( pxList->uxNumberOfItems )++;
 80007c0:	3201      	adds	r2, #1
    pxNewListItem->pxNext = pxIndex;
 80007c2:	604b      	str	r3, [r1, #4]
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80007c4:	608c      	str	r4, [r1, #8]
    pxIndex->pxPrevious->pxNext = pxNewListItem;
 80007c6:	689c      	ldr	r4, [r3, #8]
 80007c8:	6061      	str	r1, [r4, #4]
    pxIndex->pxPrevious = pxNewListItem;
 80007ca:	6099      	str	r1, [r3, #8]
}
 80007cc:	f85d 4b04 	ldr.w	r4, [sp], #4
    pxNewListItem->pxContainer = pxList;
 80007d0:	6108      	str	r0, [r1, #16]
    ( pxList->uxNumberOfItems )++;
 80007d2:	6002      	str	r2, [r0, #0]
}
 80007d4:	4770      	bx	lr
 80007d6:	bf00      	nop

080007d8 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
 80007d8:	6903      	ldr	r3, [r0, #16]
{
 80007da:	b410      	push	{r4}

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
 80007dc:	685c      	ldr	r4, [r3, #4]
    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80007de:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
    if( pxList->pxIndex == pxItemToRemove )
 80007e2:	4284      	cmp	r4, r0

    pxItemToRemove->pxContainer = NULL;
    ( pxList->uxNumberOfItems )--;

    return pxList->uxNumberOfItems;
}
 80007e4:	f85d 4b04 	ldr.w	r4, [sp], #4
    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80007e8:	608a      	str	r2, [r1, #8]
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 80007ea:	6051      	str	r1, [r2, #4]
    pxItemToRemove->pxContainer = NULL;
 80007ec:	f04f 0100 	mov.w	r1, #0
        pxList->pxIndex = pxItemToRemove->pxPrevious;
 80007f0:	bf08      	it	eq
 80007f2:	605a      	streq	r2, [r3, #4]
    ( pxList->uxNumberOfItems )--;
 80007f4:	681a      	ldr	r2, [r3, #0]
    pxItemToRemove->pxContainer = NULL;
 80007f6:	6101      	str	r1, [r0, #16]
    ( pxList->uxNumberOfItems )--;
 80007f8:	3a01      	subs	r2, #1
 80007fa:	601a      	str	r2, [r3, #0]
    return pxList->uxNumberOfItems;
 80007fc:	6818      	ldr	r0, [r3, #0]
}
 80007fe:	4770      	bx	lr

08000800 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
 8000800:	b570      	push	{r4, r5, r6, lr}
 8000802:	4615      	mov	r5, r2

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8000804:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
 8000806:	4604      	mov	r4, r0
    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8000808:	6b86      	ldr	r6, [r0, #56]	; 0x38
    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800080a:	b92a      	cbnz	r2, 8000818 <prvCopyDataToQueue+0x18>
    {
        #if ( configUSE_MUTEXES == 1 )
            {
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800080c:	6805      	ldr	r5, [r0, #0]
 800080e:	b365      	cbz	r5, 800086a <prvCopyDataToQueue+0x6a>
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8000810:	3601      	adds	r6, #1
    BaseType_t xReturn = pdFALSE;
 8000812:	4610      	mov	r0, r2
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8000814:	63a6      	str	r6, [r4, #56]	; 0x38

    return xReturn;
}
 8000816:	bd70      	pop	{r4, r5, r6, pc}
    else if( xPosition == queueSEND_TO_BACK )
 8000818:	b97d      	cbnz	r5, 800083a <prvCopyDataToQueue+0x3a>
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 800081a:	6840      	ldr	r0, [r0, #4]
 800081c:	f013 fd6a 	bl	80142f4 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8000820:	6863      	ldr	r3, [r4, #4]
 8000822:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8000824:	4413      	add	r3, r2
        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8000826:	68a2      	ldr	r2, [r4, #8]
 8000828:	4293      	cmp	r3, r2
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 800082a:	6063      	str	r3, [r4, #4]
        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800082c:	d319      	bcc.n	8000862 <prvCopyDataToQueue+0x62>
            pxQueue->pcWriteTo = pxQueue->pcHead;
 800082e:	6822      	ldr	r2, [r4, #0]
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8000830:	3601      	adds	r6, #1
    BaseType_t xReturn = pdFALSE;
 8000832:	4628      	mov	r0, r5
            pxQueue->pcWriteTo = pxQueue->pcHead;
 8000834:	6062      	str	r2, [r4, #4]
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8000836:	63a6      	str	r6, [r4, #56]	; 0x38
}
 8000838:	bd70      	pop	{r4, r5, r6, pc}
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 800083a:	68c0      	ldr	r0, [r0, #12]
 800083c:	f013 fd5a 	bl	80142f4 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 8000840:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8000842:	68e3      	ldr	r3, [r4, #12]
 8000844:	4251      	negs	r1, r2
 8000846:	1a9b      	subs	r3, r3, r2
        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8000848:	6822      	ldr	r2, [r4, #0]
 800084a:	4293      	cmp	r3, r2
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 800084c:	60e3      	str	r3, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800084e:	d202      	bcs.n	8000856 <prvCopyDataToQueue+0x56>
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 8000850:	68a3      	ldr	r3, [r4, #8]
 8000852:	440b      	add	r3, r1
 8000854:	60e3      	str	r3, [r4, #12]
        if( xPosition == queueOVERWRITE )
 8000856:	2d02      	cmp	r5, #2
 8000858:	d00d      	beq.n	8000876 <prvCopyDataToQueue+0x76>
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 800085a:	3601      	adds	r6, #1
    BaseType_t xReturn = pdFALSE;
 800085c:	2000      	movs	r0, #0
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 800085e:	63a6      	str	r6, [r4, #56]	; 0x38
}
 8000860:	bd70      	pop	{r4, r5, r6, pc}
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8000862:	3601      	adds	r6, #1
    BaseType_t xReturn = pdFALSE;
 8000864:	4628      	mov	r0, r5
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8000866:	63a6      	str	r6, [r4, #56]	; 0x38
}
 8000868:	bd70      	pop	{r4, r5, r6, pc}
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 800086a:	6880      	ldr	r0, [r0, #8]
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 800086c:	3601      	adds	r6, #1
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 800086e:	f004 f8ff 	bl	8004a70 <xTaskPriorityDisinherit>
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
 8000872:	60a5      	str	r5, [r4, #8]
 8000874:	e7ce      	b.n	8000814 <prvCopyDataToQueue+0x14>
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8000876:	2e01      	cmp	r6, #1
    BaseType_t xReturn = pdFALSE;
 8000878:	f04f 0000 	mov.w	r0, #0
 800087c:	bf38      	it	cc
 800087e:	2601      	movcc	r6, #1
 8000880:	e7c8      	b.n	8000814 <prvCopyDataToQueue+0x14>
 8000882:	bf00      	nop

08000884 <xQueueGenericSend>:
{
 8000884:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000888:	b084      	sub	sp, #16
 800088a:	9201      	str	r2, [sp, #4]
    configASSERT( pxQueue );
 800088c:	2800      	cmp	r0, #0
 800088e:	f000 8103 	beq.w	8000a98 <xQueueGenericSend+0x214>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8000892:	4688      	mov	r8, r1
 8000894:	4604      	mov	r4, r0
 8000896:	461f      	mov	r7, r3
 8000898:	2900      	cmp	r1, #0
 800089a:	f000 8097 	beq.w	80009cc <xQueueGenericSend+0x148>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800089e:	2f02      	cmp	r7, #2
 80008a0:	d10b      	bne.n	80008ba <xQueueGenericSend+0x36>
 80008a2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80008a4:	2b01      	cmp	r3, #1
 80008a6:	d008      	beq.n	80008ba <xQueueGenericSend+0x36>
 80008a8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80008ac:	f383 8811 	msr	BASEPRI, r3
 80008b0:	f3bf 8f6f 	isb	sy
 80008b4:	f3bf 8f4f 	dsb	sy
 80008b8:	e7fe      	b.n	80008b8 <xQueueGenericSend+0x34>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80008ba:	f004 f86f 	bl	800499c <xTaskGetSchedulerState>
 80008be:	2800      	cmp	r0, #0
 80008c0:	f000 80f3 	beq.w	8000aaa <xQueueGenericSend+0x226>
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80008c4:	f1a7 0902 	sub.w	r9, r7, #2
 80008c8:	2500      	movs	r5, #0
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80008ca:	f104 0624 	add.w	r6, r4, #36	; 0x24
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80008ce:	fab9 f989 	clz	r9, r9
 80008d2:	ea4f 1959 	mov.w	r9, r9, lsr #5
        taskENTER_CRITICAL();
 80008d6:	f009 f98f 	bl	8009bf8 <vPortEnterCritical>
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80008da:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80008dc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80008de:	429a      	cmp	r2, r3
 80008e0:	f0c0 80f0 	bcc.w	8000ac4 <xQueueGenericSend+0x240>
 80008e4:	f1b9 0f00 	cmp.w	r9, #0
 80008e8:	f040 80ec 	bne.w	8000ac4 <xQueueGenericSend+0x240>
                if( xTicksToWait == ( TickType_t ) 0 )
 80008ec:	9b01      	ldr	r3, [sp, #4]
 80008ee:	2b00      	cmp	r3, #0
 80008f0:	f000 8101 	beq.w	8000af6 <xQueueGenericSend+0x272>
                else if( xEntryTimeSet == pdFALSE )
 80008f4:	2d00      	cmp	r5, #0
 80008f6:	f000 80cb 	beq.w	8000a90 <xQueueGenericSend+0x20c>
        taskEXIT_CRITICAL();
 80008fa:	f009 f993 	bl	8009c24 <vPortExitCritical>
        vTaskSuspendAll();
 80008fe:	f002 fe2f 	bl	8003560 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 8000902:	f009 f979 	bl	8009bf8 <vPortEnterCritical>
 8000906:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800090a:	2bff      	cmp	r3, #255	; 0xff
 800090c:	d102      	bne.n	8000914 <xQueueGenericSend+0x90>
 800090e:	2300      	movs	r3, #0
 8000910:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8000914:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8000918:	2bff      	cmp	r3, #255	; 0xff
 800091a:	d102      	bne.n	8000922 <xQueueGenericSend+0x9e>
 800091c:	2300      	movs	r3, #0
 800091e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8000922:	f009 f97f 	bl	8009c24 <vPortExitCritical>
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8000926:	a901      	add	r1, sp, #4
 8000928:	a802      	add	r0, sp, #8
 800092a:	f003 f9b7 	bl	8003c9c <xTaskCheckForTimeOut>
 800092e:	2800      	cmp	r0, #0
 8000930:	f040 80e5 	bne.w	8000afe <xQueueGenericSend+0x27a>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 8000934:	f009 f960 	bl	8009bf8 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8000938:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800093a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800093c:	429a      	cmp	r2, r3
 800093e:	d052      	beq.n	80009e6 <xQueueGenericSend+0x162>
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
 8000940:	f009 f970 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 8000944:	f009 f958 	bl	8009bf8 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 8000948:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
 800094c:	b255      	sxtb	r5, r2
        while( cTxLock > queueLOCKED_UNMODIFIED )
 800094e:	2d00      	cmp	r5, #0
 8000950:	dc04      	bgt.n	800095c <xQueueGenericSend+0xd8>
 8000952:	e011      	b.n	8000978 <xQueueGenericSend+0xf4>
            --cTxLock;
 8000954:	1e6a      	subs	r2, r5, #1
 8000956:	b2d3      	uxtb	r3, r2
 8000958:	b255      	sxtb	r5, r2
        while( cTxLock > queueLOCKED_UNMODIFIED )
 800095a:	b16b      	cbz	r3, 8000978 <xQueueGenericSend+0xf4>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800095c:	6a63      	ldr	r3, [r4, #36]	; 0x24
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800095e:	4630      	mov	r0, r6
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000960:	b153      	cbz	r3, 8000978 <xQueueGenericSend+0xf4>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000962:	f003 fe45 	bl	80045f0 <xTaskRemoveFromEventList>
 8000966:	2800      	cmp	r0, #0
 8000968:	d0f4      	beq.n	8000954 <xQueueGenericSend+0xd0>
                            vTaskMissedYield();
 800096a:	f004 f80f 	bl	800498c <vTaskMissedYield>
            --cTxLock;
 800096e:	1e6a      	subs	r2, r5, #1
 8000970:	b2d3      	uxtb	r3, r2
 8000972:	b255      	sxtb	r5, r2
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000974:	2b00      	cmp	r3, #0
 8000976:	d1f1      	bne.n	800095c <xQueueGenericSend+0xd8>
        pxQueue->cTxLock = queueUNLOCKED;
 8000978:	23ff      	movs	r3, #255	; 0xff
 800097a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    taskEXIT_CRITICAL();
 800097e:	f009 f951 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 8000982:	f009 f939 	bl	8009bf8 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8000986:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 800098a:	b255      	sxtb	r5, r2
        while( cRxLock > queueLOCKED_UNMODIFIED )
 800098c:	2d00      	cmp	r5, #0
 800098e:	dd14      	ble.n	80009ba <xQueueGenericSend+0x136>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000990:	f104 0a10 	add.w	sl, r4, #16
 8000994:	e003      	b.n	800099e <xQueueGenericSend+0x11a>
                --cRxLock;
 8000996:	1e6a      	subs	r2, r5, #1
 8000998:	b2d3      	uxtb	r3, r2
 800099a:	b255      	sxtb	r5, r2
        while( cRxLock > queueLOCKED_UNMODIFIED )
 800099c:	b16b      	cbz	r3, 80009ba <xQueueGenericSend+0x136>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800099e:	6923      	ldr	r3, [r4, #16]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80009a0:	4650      	mov	r0, sl
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80009a2:	b153      	cbz	r3, 80009ba <xQueueGenericSend+0x136>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80009a4:	f003 fe24 	bl	80045f0 <xTaskRemoveFromEventList>
 80009a8:	2800      	cmp	r0, #0
 80009aa:	d0f4      	beq.n	8000996 <xQueueGenericSend+0x112>
                    vTaskMissedYield();
 80009ac:	f003 ffee 	bl	800498c <vTaskMissedYield>
                --cRxLock;
 80009b0:	1e6a      	subs	r2, r5, #1
 80009b2:	b2d3      	uxtb	r3, r2
 80009b4:	b255      	sxtb	r5, r2
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80009b6:	2b00      	cmp	r3, #0
 80009b8:	d1f1      	bne.n	800099e <xQueueGenericSend+0x11a>
        pxQueue->cRxLock = queueUNLOCKED;
 80009ba:	23ff      	movs	r3, #255	; 0xff
 80009bc:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    taskEXIT_CRITICAL();
 80009c0:	f009 f930 	bl	8009c24 <vPortExitCritical>
                ( void ) xTaskResumeAll();
 80009c4:	f003 fa6a 	bl	8003e9c <xTaskResumeAll>
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80009c8:	2501      	movs	r5, #1
 80009ca:	e784      	b.n	80008d6 <xQueueGenericSend+0x52>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80009cc:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80009ce:	2b00      	cmp	r3, #0
 80009d0:	f43f af65 	beq.w	800089e <xQueueGenericSend+0x1a>
 80009d4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80009d8:	f383 8811 	msr	BASEPRI, r3
 80009dc:	f3bf 8f6f 	isb	sy
 80009e0:	f3bf 8f4f 	dsb	sy
 80009e4:	e7fe      	b.n	80009e4 <xQueueGenericSend+0x160>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 80009e6:	f104 0a10 	add.w	sl, r4, #16
    taskEXIT_CRITICAL();
 80009ea:	f009 f91b 	bl	8009c24 <vPortExitCritical>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 80009ee:	9901      	ldr	r1, [sp, #4]
 80009f0:	4650      	mov	r0, sl
 80009f2:	f003 fd17 	bl	8004424 <vTaskPlaceOnEventList>
    taskENTER_CRITICAL();
 80009f6:	f009 f8ff 	bl	8009bf8 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 80009fa:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80009fe:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000a00:	2d00      	cmp	r5, #0
 8000a02:	dc04      	bgt.n	8000a0e <xQueueGenericSend+0x18a>
 8000a04:	e011      	b.n	8000a2a <xQueueGenericSend+0x1a6>
            --cTxLock;
 8000a06:	1e6b      	subs	r3, r5, #1
 8000a08:	b2da      	uxtb	r2, r3
 8000a0a:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000a0c:	b16a      	cbz	r2, 8000a2a <xQueueGenericSend+0x1a6>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000a0e:	6a63      	ldr	r3, [r4, #36]	; 0x24
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000a10:	4630      	mov	r0, r6
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000a12:	b153      	cbz	r3, 8000a2a <xQueueGenericSend+0x1a6>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000a14:	f003 fdec 	bl	80045f0 <xTaskRemoveFromEventList>
 8000a18:	2800      	cmp	r0, #0
 8000a1a:	d0f4      	beq.n	8000a06 <xQueueGenericSend+0x182>
                            vTaskMissedYield();
 8000a1c:	f003 ffb6 	bl	800498c <vTaskMissedYield>
            --cTxLock;
 8000a20:	1e6b      	subs	r3, r5, #1
 8000a22:	b2da      	uxtb	r2, r3
 8000a24:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000a26:	2a00      	cmp	r2, #0
 8000a28:	d1f1      	bne.n	8000a0e <xQueueGenericSend+0x18a>
        pxQueue->cTxLock = queueUNLOCKED;
 8000a2a:	23ff      	movs	r3, #255	; 0xff
 8000a2c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    taskEXIT_CRITICAL();
 8000a30:	f009 f8f8 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 8000a34:	f009 f8e0 	bl	8009bf8 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8000a38:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8000a3c:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000a3e:	2d00      	cmp	r5, #0
 8000a40:	dc04      	bgt.n	8000a4c <xQueueGenericSend+0x1c8>
 8000a42:	e011      	b.n	8000a68 <xQueueGenericSend+0x1e4>
                --cRxLock;
 8000a44:	1e6b      	subs	r3, r5, #1
 8000a46:	b2da      	uxtb	r2, r3
 8000a48:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000a4a:	b16a      	cbz	r2, 8000a68 <xQueueGenericSend+0x1e4>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000a4c:	6923      	ldr	r3, [r4, #16]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000a4e:	4650      	mov	r0, sl
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000a50:	b153      	cbz	r3, 8000a68 <xQueueGenericSend+0x1e4>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000a52:	f003 fdcd 	bl	80045f0 <xTaskRemoveFromEventList>
 8000a56:	2800      	cmp	r0, #0
 8000a58:	d0f4      	beq.n	8000a44 <xQueueGenericSend+0x1c0>
                    vTaskMissedYield();
 8000a5a:	f003 ff97 	bl	800498c <vTaskMissedYield>
                --cRxLock;
 8000a5e:	1e6b      	subs	r3, r5, #1
 8000a60:	b2da      	uxtb	r2, r3
 8000a62:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000a64:	2a00      	cmp	r2, #0
 8000a66:	d1f1      	bne.n	8000a4c <xQueueGenericSend+0x1c8>
        pxQueue->cRxLock = queueUNLOCKED;
 8000a68:	23ff      	movs	r3, #255	; 0xff
 8000a6a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    taskEXIT_CRITICAL();
 8000a6e:	f009 f8d9 	bl	8009c24 <vPortExitCritical>
                if( xTaskResumeAll() == pdFALSE )
 8000a72:	f003 fa13 	bl	8003e9c <xTaskResumeAll>
 8000a76:	2800      	cmp	r0, #0
 8000a78:	d1a6      	bne.n	80009c8 <xQueueGenericSend+0x144>
                    portYIELD_WITHIN_API();
 8000a7a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8000a7e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000a82:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8000a86:	f3bf 8f4f 	dsb	sy
 8000a8a:	f3bf 8f6f 	isb	sy
 8000a8e:	e79b      	b.n	80009c8 <xQueueGenericSend+0x144>
                    vTaskInternalSetTimeOutState( &xTimeOut );
 8000a90:	a802      	add	r0, sp, #8
 8000a92:	f004 f8bf 	bl	8004c14 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 8000a96:	e730      	b.n	80008fa <xQueueGenericSend+0x76>
 8000a98:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000a9c:	f383 8811 	msr	BASEPRI, r3
 8000aa0:	f3bf 8f6f 	isb	sy
 8000aa4:	f3bf 8f4f 	dsb	sy
    configASSERT( pxQueue );
 8000aa8:	e7fe      	b.n	8000aa8 <xQueueGenericSend+0x224>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8000aaa:	9b01      	ldr	r3, [sp, #4]
 8000aac:	2b00      	cmp	r3, #0
 8000aae:	f43f af09 	beq.w	80008c4 <xQueueGenericSend+0x40>
 8000ab2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000ab6:	f383 8811 	msr	BASEPRI, r3
 8000aba:	f3bf 8f6f 	isb	sy
 8000abe:	f3bf 8f4f 	dsb	sy
 8000ac2:	e7fe      	b.n	8000ac2 <xQueueGenericSend+0x23e>
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8000ac4:	463a      	mov	r2, r7
 8000ac6:	4641      	mov	r1, r8
 8000ac8:	4620      	mov	r0, r4
 8000aca:	f7ff fe99 	bl	8000800 <prvCopyDataToQueue>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000ace:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8000ad0:	2b00      	cmp	r3, #0
 8000ad2:	d152      	bne.n	8000b7a <xQueueGenericSend+0x2f6>
                        else if( xYieldRequired != pdFALSE )
 8000ad4:	b148      	cbz	r0, 8000aea <xQueueGenericSend+0x266>
                            queueYIELD_IF_USING_PREEMPTION();
 8000ad6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8000ada:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000ade:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8000ae2:	f3bf 8f4f 	dsb	sy
 8000ae6:	f3bf 8f6f 	isb	sy
                taskEXIT_CRITICAL();
 8000aea:	f009 f89b 	bl	8009c24 <vPortExitCritical>
                return pdPASS;
 8000aee:	2001      	movs	r0, #1
}
 8000af0:	b004      	add	sp, #16
 8000af2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                    taskEXIT_CRITICAL();
 8000af6:	f009 f895 	bl	8009c24 <vPortExitCritical>
                    return errQUEUE_FULL;
 8000afa:	4648      	mov	r0, r9
 8000afc:	e7f8      	b.n	8000af0 <xQueueGenericSend+0x26c>
    taskENTER_CRITICAL();
 8000afe:	f009 f87b 	bl	8009bf8 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 8000b02:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8000b06:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000b08:	2d00      	cmp	r5, #0
 8000b0a:	dd10      	ble.n	8000b2e <xQueueGenericSend+0x2aa>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000b0c:	f104 0624 	add.w	r6, r4, #36	; 0x24
 8000b10:	e003      	b.n	8000b1a <xQueueGenericSend+0x296>
            --cTxLock;
 8000b12:	1e6b      	subs	r3, r5, #1
 8000b14:	b2da      	uxtb	r2, r3
 8000b16:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000b18:	b14a      	cbz	r2, 8000b2e <xQueueGenericSend+0x2aa>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000b1a:	6a63      	ldr	r3, [r4, #36]	; 0x24
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000b1c:	4630      	mov	r0, r6
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000b1e:	b133      	cbz	r3, 8000b2e <xQueueGenericSend+0x2aa>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000b20:	f003 fd66 	bl	80045f0 <xTaskRemoveFromEventList>
 8000b24:	2800      	cmp	r0, #0
 8000b26:	d0f4      	beq.n	8000b12 <xQueueGenericSend+0x28e>
                            vTaskMissedYield();
 8000b28:	f003 ff30 	bl	800498c <vTaskMissedYield>
 8000b2c:	e7f1      	b.n	8000b12 <xQueueGenericSend+0x28e>
        pxQueue->cTxLock = queueUNLOCKED;
 8000b2e:	23ff      	movs	r3, #255	; 0xff
 8000b30:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    taskEXIT_CRITICAL();
 8000b34:	f009 f876 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 8000b38:	f009 f85e 	bl	8009bf8 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8000b3c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8000b40:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000b42:	2d00      	cmp	r5, #0
 8000b44:	dd10      	ble.n	8000b68 <xQueueGenericSend+0x2e4>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000b46:	f104 0610 	add.w	r6, r4, #16
 8000b4a:	e003      	b.n	8000b54 <xQueueGenericSend+0x2d0>
                --cRxLock;
 8000b4c:	1e6b      	subs	r3, r5, #1
 8000b4e:	b2da      	uxtb	r2, r3
 8000b50:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000b52:	b14a      	cbz	r2, 8000b68 <xQueueGenericSend+0x2e4>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000b54:	6923      	ldr	r3, [r4, #16]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000b56:	4630      	mov	r0, r6
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000b58:	b133      	cbz	r3, 8000b68 <xQueueGenericSend+0x2e4>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000b5a:	f003 fd49 	bl	80045f0 <xTaskRemoveFromEventList>
 8000b5e:	2800      	cmp	r0, #0
 8000b60:	d0f4      	beq.n	8000b4c <xQueueGenericSend+0x2c8>
                    vTaskMissedYield();
 8000b62:	f003 ff13 	bl	800498c <vTaskMissedYield>
 8000b66:	e7f1      	b.n	8000b4c <xQueueGenericSend+0x2c8>
        pxQueue->cRxLock = queueUNLOCKED;
 8000b68:	23ff      	movs	r3, #255	; 0xff
 8000b6a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    taskEXIT_CRITICAL();
 8000b6e:	f009 f859 	bl	8009c24 <vPortExitCritical>
            ( void ) xTaskResumeAll();
 8000b72:	f003 f993 	bl	8003e9c <xTaskResumeAll>
            return errQUEUE_FULL;
 8000b76:	2000      	movs	r0, #0
 8000b78:	e7ba      	b.n	8000af0 <xQueueGenericSend+0x26c>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000b7a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8000b7e:	f003 fd37 	bl	80045f0 <xTaskRemoveFromEventList>
 8000b82:	2800      	cmp	r0, #0
 8000b84:	d0b1      	beq.n	8000aea <xQueueGenericSend+0x266>
 8000b86:	e7a6      	b.n	8000ad6 <xQueueGenericSend+0x252>

08000b88 <xQueuePeek>:
{
 8000b88:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8000b8c:	b085      	sub	sp, #20
 8000b8e:	9201      	str	r2, [sp, #4]
    configASSERT( ( pxQueue ) );
 8000b90:	2800      	cmp	r0, #0
 8000b92:	f000 8144 	beq.w	8000e1e <xQueuePeek+0x296>
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8000b96:	460f      	mov	r7, r1
 8000b98:	4604      	mov	r4, r0
 8000b9a:	2900      	cmp	r1, #0
 8000b9c:	d07a      	beq.n	8000c94 <xQueuePeek+0x10c>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8000b9e:	f003 fefd 	bl	800499c <xTaskGetSchedulerState>
 8000ba2:	2800      	cmp	r0, #0
 8000ba4:	f000 8082 	beq.w	8000cac <xQueuePeek+0x124>
        taskENTER_CRITICAL();
 8000ba8:	f009 f826 	bl	8009bf8 <vPortEnterCritical>
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8000bac:	f8d4 8038 	ldr.w	r8, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8000bb0:	f1b8 0f00 	cmp.w	r8, #0
 8000bb4:	f040 813c 	bne.w	8000e30 <xQueuePeek+0x2a8>
                if( xTicksToWait == ( TickType_t ) 0 )
 8000bb8:	9b01      	ldr	r3, [sp, #4]
 8000bba:	2b00      	cmp	r3, #0
 8000bbc:	f000 80d4 	beq.w	8000d68 <xQueuePeek+0x1e0>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000bc0:	f104 0624 	add.w	r6, r4, #36	; 0x24
                    vTaskInternalSetTimeOutState( &xTimeOut );
 8000bc4:	a802      	add	r0, sp, #8
 8000bc6:	f004 f825 	bl	8004c14 <vTaskInternalSetTimeOutState>
        taskEXIT_CRITICAL();
 8000bca:	f009 f82b 	bl	8009c24 <vPortExitCritical>
        vTaskSuspendAll();
 8000bce:	f002 fcc7 	bl	8003560 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 8000bd2:	f009 f811 	bl	8009bf8 <vPortEnterCritical>
 8000bd6:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8000bda:	2bff      	cmp	r3, #255	; 0xff
 8000bdc:	d101      	bne.n	8000be2 <xQueuePeek+0x5a>
 8000bde:	f884 8044 	strb.w	r8, [r4, #68]	; 0x44
 8000be2:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8000be6:	2bff      	cmp	r3, #255	; 0xff
 8000be8:	d101      	bne.n	8000bee <xQueuePeek+0x66>
 8000bea:	f884 8045 	strb.w	r8, [r4, #69]	; 0x45
 8000bee:	f009 f819 	bl	8009c24 <vPortExitCritical>
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8000bf2:	a901      	add	r1, sp, #4
 8000bf4:	a802      	add	r0, sp, #8
 8000bf6:	f003 f851 	bl	8003c9c <xTaskCheckForTimeOut>
 8000bfa:	2800      	cmp	r0, #0
 8000bfc:	d163      	bne.n	8000cc6 <xQueuePeek+0x13e>
    taskENTER_CRITICAL();
 8000bfe:	f008 fffb 	bl	8009bf8 <vPortEnterCritical>
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 8000c02:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000c04:	2b00      	cmp	r3, #0
 8000c06:	f000 80b5 	beq.w	8000d74 <xQueuePeek+0x1ec>
    taskEXIT_CRITICAL();
 8000c0a:	f009 f80b 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 8000c0e:	f008 fff3 	bl	8009bf8 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 8000c12:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8000c16:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000c18:	2d00      	cmp	r5, #0
 8000c1a:	dc04      	bgt.n	8000c26 <xQueuePeek+0x9e>
 8000c1c:	e011      	b.n	8000c42 <xQueuePeek+0xba>
            --cTxLock;
 8000c1e:	1e6b      	subs	r3, r5, #1
 8000c20:	b2da      	uxtb	r2, r3
 8000c22:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000c24:	b16a      	cbz	r2, 8000c42 <xQueuePeek+0xba>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000c26:	6a63      	ldr	r3, [r4, #36]	; 0x24
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000c28:	4630      	mov	r0, r6
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000c2a:	b153      	cbz	r3, 8000c42 <xQueuePeek+0xba>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000c2c:	f003 fce0 	bl	80045f0 <xTaskRemoveFromEventList>
 8000c30:	2800      	cmp	r0, #0
 8000c32:	d0f4      	beq.n	8000c1e <xQueuePeek+0x96>
                            vTaskMissedYield();
 8000c34:	f003 feaa 	bl	800498c <vTaskMissedYield>
            --cTxLock;
 8000c38:	1e6b      	subs	r3, r5, #1
 8000c3a:	b2da      	uxtb	r2, r3
 8000c3c:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000c3e:	2a00      	cmp	r2, #0
 8000c40:	d1f1      	bne.n	8000c26 <xQueuePeek+0x9e>
        pxQueue->cTxLock = queueUNLOCKED;
 8000c42:	23ff      	movs	r3, #255	; 0xff
 8000c44:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    taskEXIT_CRITICAL();
 8000c48:	f008 ffec 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 8000c4c:	f008 ffd4 	bl	8009bf8 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8000c50:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8000c54:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000c56:	2d00      	cmp	r5, #0
 8000c58:	dd14      	ble.n	8000c84 <xQueuePeek+0xfc>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000c5a:	f104 0910 	add.w	r9, r4, #16
 8000c5e:	e003      	b.n	8000c68 <xQueuePeek+0xe0>
                --cRxLock;
 8000c60:	1e6b      	subs	r3, r5, #1
 8000c62:	b2da      	uxtb	r2, r3
 8000c64:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000c66:	b16a      	cbz	r2, 8000c84 <xQueuePeek+0xfc>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000c68:	6923      	ldr	r3, [r4, #16]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000c6a:	4648      	mov	r0, r9
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000c6c:	b153      	cbz	r3, 8000c84 <xQueuePeek+0xfc>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000c6e:	f003 fcbf 	bl	80045f0 <xTaskRemoveFromEventList>
 8000c72:	2800      	cmp	r0, #0
 8000c74:	d0f4      	beq.n	8000c60 <xQueuePeek+0xd8>
                    vTaskMissedYield();
 8000c76:	f003 fe89 	bl	800498c <vTaskMissedYield>
                --cRxLock;
 8000c7a:	1e6b      	subs	r3, r5, #1
 8000c7c:	b2da      	uxtb	r2, r3
 8000c7e:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000c80:	2a00      	cmp	r2, #0
 8000c82:	d1f1      	bne.n	8000c68 <xQueuePeek+0xe0>
        pxQueue->cRxLock = queueUNLOCKED;
 8000c84:	23ff      	movs	r3, #255	; 0xff
 8000c86:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    taskEXIT_CRITICAL();
 8000c8a:	f008 ffcb 	bl	8009c24 <vPortExitCritical>
                ( void ) xTaskResumeAll();
 8000c8e:	f003 f905 	bl	8003e9c <xTaskResumeAll>
        taskENTER_CRITICAL();
 8000c92:	e060      	b.n	8000d56 <xQueuePeek+0x1ce>
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8000c94:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8000c96:	2b00      	cmp	r3, #0
 8000c98:	d081      	beq.n	8000b9e <xQueuePeek+0x16>
 8000c9a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000c9e:	f383 8811 	msr	BASEPRI, r3
 8000ca2:	f3bf 8f6f 	isb	sy
 8000ca6:	f3bf 8f4f 	dsb	sy
 8000caa:	e7fe      	b.n	8000caa <xQueuePeek+0x122>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8000cac:	9b01      	ldr	r3, [sp, #4]
 8000cae:	2b00      	cmp	r3, #0
 8000cb0:	f43f af7a 	beq.w	8000ba8 <xQueuePeek+0x20>
 8000cb4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000cb8:	f383 8811 	msr	BASEPRI, r3
 8000cbc:	f3bf 8f6f 	isb	sy
 8000cc0:	f3bf 8f4f 	dsb	sy
 8000cc4:	e7fe      	b.n	8000cc4 <xQueuePeek+0x13c>
    taskENTER_CRITICAL();
 8000cc6:	f008 ff97 	bl	8009bf8 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 8000cca:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8000cce:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000cd0:	2d00      	cmp	r5, #0
 8000cd2:	dc04      	bgt.n	8000cde <xQueuePeek+0x156>
 8000cd4:	e011      	b.n	8000cfa <xQueuePeek+0x172>
            --cTxLock;
 8000cd6:	1e6b      	subs	r3, r5, #1
 8000cd8:	b2da      	uxtb	r2, r3
 8000cda:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000cdc:	b16a      	cbz	r2, 8000cfa <xQueuePeek+0x172>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000cde:	6a63      	ldr	r3, [r4, #36]	; 0x24
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000ce0:	4630      	mov	r0, r6
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000ce2:	b153      	cbz	r3, 8000cfa <xQueuePeek+0x172>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000ce4:	f003 fc84 	bl	80045f0 <xTaskRemoveFromEventList>
 8000ce8:	2800      	cmp	r0, #0
 8000cea:	d0f4      	beq.n	8000cd6 <xQueuePeek+0x14e>
                            vTaskMissedYield();
 8000cec:	f003 fe4e 	bl	800498c <vTaskMissedYield>
            --cTxLock;
 8000cf0:	1e6b      	subs	r3, r5, #1
 8000cf2:	b2da      	uxtb	r2, r3
 8000cf4:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000cf6:	2a00      	cmp	r2, #0
 8000cf8:	d1f1      	bne.n	8000cde <xQueuePeek+0x156>
        pxQueue->cTxLock = queueUNLOCKED;
 8000cfa:	23ff      	movs	r3, #255	; 0xff
 8000cfc:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    taskEXIT_CRITICAL();
 8000d00:	f008 ff90 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 8000d04:	f008 ff78 	bl	8009bf8 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8000d08:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8000d0c:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000d0e:	2d00      	cmp	r5, #0
 8000d10:	dd14      	ble.n	8000d3c <xQueuePeek+0x1b4>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000d12:	f104 0910 	add.w	r9, r4, #16
 8000d16:	e003      	b.n	8000d20 <xQueuePeek+0x198>
                --cRxLock;
 8000d18:	1e6b      	subs	r3, r5, #1
 8000d1a:	b2da      	uxtb	r2, r3
 8000d1c:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000d1e:	b16a      	cbz	r2, 8000d3c <xQueuePeek+0x1b4>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000d20:	6923      	ldr	r3, [r4, #16]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000d22:	4648      	mov	r0, r9
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000d24:	b153      	cbz	r3, 8000d3c <xQueuePeek+0x1b4>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000d26:	f003 fc63 	bl	80045f0 <xTaskRemoveFromEventList>
 8000d2a:	2800      	cmp	r0, #0
 8000d2c:	d0f4      	beq.n	8000d18 <xQueuePeek+0x190>
                    vTaskMissedYield();
 8000d2e:	f003 fe2d 	bl	800498c <vTaskMissedYield>
                --cRxLock;
 8000d32:	1e6b      	subs	r3, r5, #1
 8000d34:	b2da      	uxtb	r2, r3
 8000d36:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000d38:	2a00      	cmp	r2, #0
 8000d3a:	d1f1      	bne.n	8000d20 <xQueuePeek+0x198>
        pxQueue->cRxLock = queueUNLOCKED;
 8000d3c:	23ff      	movs	r3, #255	; 0xff
 8000d3e:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    taskEXIT_CRITICAL();
 8000d42:	f008 ff6f 	bl	8009c24 <vPortExitCritical>
            ( void ) xTaskResumeAll();
 8000d46:	f003 f8a9 	bl	8003e9c <xTaskResumeAll>
    taskENTER_CRITICAL();
 8000d4a:	f008 ff55 	bl	8009bf8 <vPortEnterCritical>
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 8000d4e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000d50:	b153      	cbz	r3, 8000d68 <xQueuePeek+0x1e0>
    taskEXIT_CRITICAL();
 8000d52:	f008 ff67 	bl	8009c24 <vPortExitCritical>
        taskENTER_CRITICAL();
 8000d56:	f008 ff4f 	bl	8009bf8 <vPortEnterCritical>
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8000d5a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8000d5c:	2b00      	cmp	r3, #0
 8000d5e:	d167      	bne.n	8000e30 <xQueuePeek+0x2a8>
                if( xTicksToWait == ( TickType_t ) 0 )
 8000d60:	9b01      	ldr	r3, [sp, #4]
 8000d62:	2b00      	cmp	r3, #0
 8000d64:	f47f af31 	bne.w	8000bca <xQueuePeek+0x42>
                    taskEXIT_CRITICAL();
 8000d68:	f008 ff5c 	bl	8009c24 <vPortExitCritical>
                    return errQUEUE_EMPTY;
 8000d6c:	2000      	movs	r0, #0
}
 8000d6e:	b005      	add	sp, #20
 8000d70:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    taskEXIT_CRITICAL();
 8000d74:	f008 ff56 	bl	8009c24 <vPortExitCritical>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8000d78:	9901      	ldr	r1, [sp, #4]
 8000d7a:	4630      	mov	r0, r6
 8000d7c:	f003 fb52 	bl	8004424 <vTaskPlaceOnEventList>
    taskENTER_CRITICAL();
 8000d80:	f008 ff3a 	bl	8009bf8 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 8000d84:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8000d88:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000d8a:	2d00      	cmp	r5, #0
 8000d8c:	dc04      	bgt.n	8000d98 <xQueuePeek+0x210>
 8000d8e:	e011      	b.n	8000db4 <xQueuePeek+0x22c>
            --cTxLock;
 8000d90:	1e6b      	subs	r3, r5, #1
 8000d92:	b2da      	uxtb	r2, r3
 8000d94:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000d96:	b16a      	cbz	r2, 8000db4 <xQueuePeek+0x22c>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000d98:	6a63      	ldr	r3, [r4, #36]	; 0x24
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000d9a:	4630      	mov	r0, r6
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000d9c:	b153      	cbz	r3, 8000db4 <xQueuePeek+0x22c>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000d9e:	f003 fc27 	bl	80045f0 <xTaskRemoveFromEventList>
 8000da2:	2800      	cmp	r0, #0
 8000da4:	d0f4      	beq.n	8000d90 <xQueuePeek+0x208>
                            vTaskMissedYield();
 8000da6:	f003 fdf1 	bl	800498c <vTaskMissedYield>
            --cTxLock;
 8000daa:	1e6b      	subs	r3, r5, #1
 8000dac:	b2da      	uxtb	r2, r3
 8000dae:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000db0:	2a00      	cmp	r2, #0
 8000db2:	d1f1      	bne.n	8000d98 <xQueuePeek+0x210>
        pxQueue->cTxLock = queueUNLOCKED;
 8000db4:	23ff      	movs	r3, #255	; 0xff
 8000db6:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    taskEXIT_CRITICAL();
 8000dba:	f008 ff33 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 8000dbe:	f008 ff1b 	bl	8009bf8 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8000dc2:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8000dc6:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000dc8:	2d00      	cmp	r5, #0
 8000dca:	dd14      	ble.n	8000df6 <xQueuePeek+0x26e>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000dcc:	f104 0910 	add.w	r9, r4, #16
 8000dd0:	e003      	b.n	8000dda <xQueuePeek+0x252>
                --cRxLock;
 8000dd2:	1e6b      	subs	r3, r5, #1
 8000dd4:	b2da      	uxtb	r2, r3
 8000dd6:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000dd8:	b16a      	cbz	r2, 8000df6 <xQueuePeek+0x26e>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000dda:	6923      	ldr	r3, [r4, #16]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000ddc:	4648      	mov	r0, r9
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000dde:	b153      	cbz	r3, 8000df6 <xQueuePeek+0x26e>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000de0:	f003 fc06 	bl	80045f0 <xTaskRemoveFromEventList>
 8000de4:	2800      	cmp	r0, #0
 8000de6:	d0f4      	beq.n	8000dd2 <xQueuePeek+0x24a>
                    vTaskMissedYield();
 8000de8:	f003 fdd0 	bl	800498c <vTaskMissedYield>
                --cRxLock;
 8000dec:	1e6b      	subs	r3, r5, #1
 8000dee:	b2da      	uxtb	r2, r3
 8000df0:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000df2:	2a00      	cmp	r2, #0
 8000df4:	d1f1      	bne.n	8000dda <xQueuePeek+0x252>
        pxQueue->cRxLock = queueUNLOCKED;
 8000df6:	23ff      	movs	r3, #255	; 0xff
 8000df8:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    taskEXIT_CRITICAL();
 8000dfc:	f008 ff12 	bl	8009c24 <vPortExitCritical>
                if( xTaskResumeAll() == pdFALSE )
 8000e00:	f003 f84c 	bl	8003e9c <xTaskResumeAll>
 8000e04:	2800      	cmp	r0, #0
 8000e06:	d1a6      	bne.n	8000d56 <xQueuePeek+0x1ce>
                    portYIELD_WITHIN_API();
 8000e08:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8000e0c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000e10:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8000e14:	f3bf 8f4f 	dsb	sy
 8000e18:	f3bf 8f6f 	isb	sy
        taskENTER_CRITICAL();
 8000e1c:	e79b      	b.n	8000d56 <xQueuePeek+0x1ce>
 8000e1e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000e22:	f383 8811 	msr	BASEPRI, r3
 8000e26:	f3bf 8f6f 	isb	sy
 8000e2a:	f3bf 8f4f 	dsb	sy
    configASSERT( ( pxQueue ) );
 8000e2e:	e7fe      	b.n	8000e2e <xQueuePeek+0x2a6>
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8000e30:	6c22      	ldr	r2, [r4, #64]	; 0x40
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 8000e32:	68e5      	ldr	r5, [r4, #12]
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8000e34:	b14a      	cbz	r2, 8000e4a <xQueuePeek+0x2c2>
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8000e36:	18a9      	adds	r1, r5, r2
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8000e38:	68a3      	ldr	r3, [r4, #8]
 8000e3a:	4299      	cmp	r1, r3
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8000e3c:	60e1      	str	r1, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8000e3e:	d301      	bcc.n	8000e44 <xQueuePeek+0x2bc>
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 8000e40:	6821      	ldr	r1, [r4, #0]
 8000e42:	60e1      	str	r1, [r4, #12]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8000e44:	4638      	mov	r0, r7
 8000e46:	f013 fa55 	bl	80142f4 <memcpy>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000e4a:	6a63      	ldr	r3, [r4, #36]	; 0x24
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 8000e4c:	60e5      	str	r5, [r4, #12]
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000e4e:	b91b      	cbnz	r3, 8000e58 <xQueuePeek+0x2d0>
                taskEXIT_CRITICAL();
 8000e50:	f008 fee8 	bl	8009c24 <vPortExitCritical>
                return pdPASS;
 8000e54:	2001      	movs	r0, #1
 8000e56:	e78a      	b.n	8000d6e <xQueuePeek+0x1e6>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000e58:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8000e5c:	f003 fbc8 	bl	80045f0 <xTaskRemoveFromEventList>
 8000e60:	2800      	cmp	r0, #0
 8000e62:	d0f5      	beq.n	8000e50 <xQueuePeek+0x2c8>
                        queueYIELD_IF_USING_PREEMPTION();
 8000e64:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8000e68:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000e6c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8000e70:	f3bf 8f4f 	dsb	sy
 8000e74:	f3bf 8f6f 	isb	sy
 8000e78:	e7ea      	b.n	8000e50 <xQueuePeek+0x2c8>
 8000e7a:	bf00      	nop

08000e7c <xQueuePeekFromISR>:
{
 8000e7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    configASSERT( pxQueue );
 8000e7e:	b1c0      	cbz	r0, 8000eb2 <xQueuePeekFromISR+0x36>
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8000e80:	4604      	mov	r4, r0
 8000e82:	460d      	mov	r5, r1
    configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 8000e84:	6c03      	ldr	r3, [r0, #64]	; 0x40
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8000e86:	b149      	cbz	r1, 8000e9c <xQueuePeekFromISR+0x20>
    configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 8000e88:	b9e3      	cbnz	r3, 8000ec4 <xQueuePeekFromISR+0x48>
 8000e8a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000e8e:	f383 8811 	msr	BASEPRI, r3
 8000e92:	f3bf 8f6f 	isb	sy
 8000e96:	f3bf 8f4f 	dsb	sy
 8000e9a:	e7fe      	b.n	8000e9a <xQueuePeekFromISR+0x1e>
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8000e9c:	2b00      	cmp	r3, #0
 8000e9e:	d0f4      	beq.n	8000e8a <xQueuePeekFromISR+0xe>
 8000ea0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000ea4:	f383 8811 	msr	BASEPRI, r3
 8000ea8:	f3bf 8f6f 	isb	sy
 8000eac:	f3bf 8f4f 	dsb	sy
 8000eb0:	e7fe      	b.n	8000eb0 <xQueuePeekFromISR+0x34>
 8000eb2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000eb6:	f383 8811 	msr	BASEPRI, r3
 8000eba:	f3bf 8f6f 	isb	sy
 8000ebe:	f3bf 8f4f 	dsb	sy
    configASSERT( pxQueue );
 8000ec2:	e7fe      	b.n	8000ec2 <xQueuePeekFromISR+0x46>
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8000ec4:	f008 feec 	bl	8009ca0 <vPortValidateInterruptPriority>
    __asm volatile
 8000ec8:	f3ef 8611 	mrs	r6, BASEPRI
 8000ecc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000ed0:	f383 8811 	msr	BASEPRI, r3
 8000ed4:	f3bf 8f6f 	isb	sy
 8000ed8:	f3bf 8f4f 	dsb	sy
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 8000edc:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8000ede:	b910      	cbnz	r0, 8000ee6 <xQueuePeekFromISR+0x6a>
    __asm volatile
 8000ee0:	f386 8811 	msr	BASEPRI, r6
}
 8000ee4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8000ee6:	6c22      	ldr	r2, [r4, #64]	; 0x40
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 8000ee8:	68e7      	ldr	r7, [r4, #12]
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8000eea:	b14a      	cbz	r2, 8000f00 <xQueuePeekFromISR+0x84>
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8000eec:	18b9      	adds	r1, r7, r2
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8000eee:	68a3      	ldr	r3, [r4, #8]
 8000ef0:	4299      	cmp	r1, r3
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8000ef2:	60e1      	str	r1, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8000ef4:	d301      	bcc.n	8000efa <xQueuePeekFromISR+0x7e>
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 8000ef6:	6821      	ldr	r1, [r4, #0]
 8000ef8:	60e1      	str	r1, [r4, #12]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8000efa:	4628      	mov	r0, r5
 8000efc:	f013 f9fa 	bl	80142f4 <memcpy>
            xReturn = pdPASS;
 8000f00:	2001      	movs	r0, #1
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 8000f02:	60e7      	str	r7, [r4, #12]
            xReturn = pdPASS;
 8000f04:	e7ec      	b.n	8000ee0 <xQueuePeekFromISR+0x64>
 8000f06:	bf00      	nop

08000f08 <xQueueReceive>:
{
 8000f08:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8000f0c:	b085      	sub	sp, #20
 8000f0e:	9201      	str	r2, [sp, #4]
    configASSERT( ( pxQueue ) );
 8000f10:	2800      	cmp	r0, #0
 8000f12:	f000 815f 	beq.w	80011d4 <xQueueReceive+0x2cc>
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8000f16:	460f      	mov	r7, r1
 8000f18:	4604      	mov	r4, r0
 8000f1a:	2900      	cmp	r1, #0
 8000f1c:	f000 8094 	beq.w	8001048 <xQueueReceive+0x140>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8000f20:	f003 fd3c 	bl	800499c <xTaskGetSchedulerState>
 8000f24:	2800      	cmp	r0, #0
 8000f26:	f000 809c 	beq.w	8001062 <xQueueReceive+0x15a>
        taskENTER_CRITICAL();
 8000f2a:	f008 fe65 	bl	8009bf8 <vPortEnterCritical>
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8000f2e:	6ba5      	ldr	r5, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8000f30:	2d00      	cmp	r5, #0
 8000f32:	d172      	bne.n	800101a <xQueueReceive+0x112>
                if( xTicksToWait == ( TickType_t ) 0 )
 8000f34:	9b01      	ldr	r3, [sp, #4]
 8000f36:	2b00      	cmp	r3, #0
 8000f38:	f000 80f1 	beq.w	800111e <xQueueReceive+0x216>
        prvLockQueue( pxQueue );
 8000f3c:	46a8      	mov	r8, r5
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000f3e:	f104 0624 	add.w	r6, r4, #36	; 0x24
                    vTaskInternalSetTimeOutState( &xTimeOut );
 8000f42:	a802      	add	r0, sp, #8
 8000f44:	f003 fe66 	bl	8004c14 <vTaskInternalSetTimeOutState>
        taskEXIT_CRITICAL();
 8000f48:	f008 fe6c 	bl	8009c24 <vPortExitCritical>
        vTaskSuspendAll();
 8000f4c:	f002 fb08 	bl	8003560 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 8000f50:	f008 fe52 	bl	8009bf8 <vPortEnterCritical>
 8000f54:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8000f58:	2bff      	cmp	r3, #255	; 0xff
 8000f5a:	d101      	bne.n	8000f60 <xQueueReceive+0x58>
 8000f5c:	f884 8044 	strb.w	r8, [r4, #68]	; 0x44
 8000f60:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8000f64:	2bff      	cmp	r3, #255	; 0xff
 8000f66:	d101      	bne.n	8000f6c <xQueueReceive+0x64>
 8000f68:	f884 8045 	strb.w	r8, [r4, #69]	; 0x45
 8000f6c:	f008 fe5a 	bl	8009c24 <vPortExitCritical>
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8000f70:	a901      	add	r1, sp, #4
 8000f72:	a802      	add	r0, sp, #8
 8000f74:	f002 fe92 	bl	8003c9c <xTaskCheckForTimeOut>
 8000f78:	2800      	cmp	r0, #0
 8000f7a:	d17f      	bne.n	800107c <xQueueReceive+0x174>
    taskENTER_CRITICAL();
 8000f7c:	f008 fe3c 	bl	8009bf8 <vPortEnterCritical>
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 8000f80:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000f82:	2b00      	cmp	r3, #0
 8000f84:	f000 80d1 	beq.w	800112a <xQueueReceive+0x222>
    taskEXIT_CRITICAL();
 8000f88:	f008 fe4c 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 8000f8c:	f008 fe34 	bl	8009bf8 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 8000f90:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8000f94:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000f96:	2d00      	cmp	r5, #0
 8000f98:	dc04      	bgt.n	8000fa4 <xQueueReceive+0x9c>
 8000f9a:	e011      	b.n	8000fc0 <xQueueReceive+0xb8>
            --cTxLock;
 8000f9c:	1e6b      	subs	r3, r5, #1
 8000f9e:	b2da      	uxtb	r2, r3
 8000fa0:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000fa2:	b16a      	cbz	r2, 8000fc0 <xQueueReceive+0xb8>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000fa4:	6a63      	ldr	r3, [r4, #36]	; 0x24
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000fa6:	4630      	mov	r0, r6
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8000fa8:	b153      	cbz	r3, 8000fc0 <xQueueReceive+0xb8>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000faa:	f003 fb21 	bl	80045f0 <xTaskRemoveFromEventList>
 8000fae:	2800      	cmp	r0, #0
 8000fb0:	d0f4      	beq.n	8000f9c <xQueueReceive+0x94>
                            vTaskMissedYield();
 8000fb2:	f003 fceb 	bl	800498c <vTaskMissedYield>
            --cTxLock;
 8000fb6:	1e6b      	subs	r3, r5, #1
 8000fb8:	b2da      	uxtb	r2, r3
 8000fba:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000fbc:	2a00      	cmp	r2, #0
 8000fbe:	d1f1      	bne.n	8000fa4 <xQueueReceive+0x9c>
        pxQueue->cTxLock = queueUNLOCKED;
 8000fc0:	23ff      	movs	r3, #255	; 0xff
 8000fc2:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    taskEXIT_CRITICAL();
 8000fc6:	f008 fe2d 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 8000fca:	f008 fe15 	bl	8009bf8 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8000fce:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8000fd2:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000fd4:	2d00      	cmp	r5, #0
 8000fd6:	dd14      	ble.n	8001002 <xQueueReceive+0xfa>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000fd8:	f104 0910 	add.w	r9, r4, #16
 8000fdc:	e003      	b.n	8000fe6 <xQueueReceive+0xde>
                --cRxLock;
 8000fde:	1e6b      	subs	r3, r5, #1
 8000fe0:	b2da      	uxtb	r2, r3
 8000fe2:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000fe4:	b16a      	cbz	r2, 8001002 <xQueueReceive+0xfa>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000fe6:	6923      	ldr	r3, [r4, #16]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000fe8:	4648      	mov	r0, r9
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000fea:	b153      	cbz	r3, 8001002 <xQueueReceive+0xfa>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000fec:	f003 fb00 	bl	80045f0 <xTaskRemoveFromEventList>
 8000ff0:	2800      	cmp	r0, #0
 8000ff2:	d0f4      	beq.n	8000fde <xQueueReceive+0xd6>
                    vTaskMissedYield();
 8000ff4:	f003 fcca 	bl	800498c <vTaskMissedYield>
                --cRxLock;
 8000ff8:	1e6b      	subs	r3, r5, #1
 8000ffa:	b2da      	uxtb	r2, r3
 8000ffc:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8000ffe:	2a00      	cmp	r2, #0
 8001000:	d1f1      	bne.n	8000fe6 <xQueueReceive+0xde>
        pxQueue->cRxLock = queueUNLOCKED;
 8001002:	23ff      	movs	r3, #255	; 0xff
 8001004:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    taskEXIT_CRITICAL();
 8001008:	f008 fe0c 	bl	8009c24 <vPortExitCritical>
                ( void ) xTaskResumeAll();
 800100c:	f002 ff46 	bl	8003e9c <xTaskResumeAll>
        taskENTER_CRITICAL();
 8001010:	f008 fdf2 	bl	8009bf8 <vPortEnterCritical>
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001014:	6ba5      	ldr	r5, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8001016:	2d00      	cmp	r5, #0
 8001018:	d07d      	beq.n	8001116 <xQueueReceive+0x20e>
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800101a:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800101c:	b152      	cbz	r2, 8001034 <xQueueReceive+0x12c>
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 800101e:	68e1      	ldr	r1, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8001020:	68a3      	ldr	r3, [r4, #8]
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8001022:	4411      	add	r1, r2
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8001024:	4299      	cmp	r1, r3
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8001026:	60e1      	str	r1, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8001028:	d301      	bcc.n	800102e <xQueueReceive+0x126>
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 800102a:	6821      	ldr	r1, [r4, #0]
 800102c:	60e1      	str	r1, [r4, #12]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 800102e:	4638      	mov	r0, r7
 8001030:	f013 f960 	bl	80142f4 <memcpy>
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8001034:	3d01      	subs	r5, #1
 8001036:	63a5      	str	r5, [r4, #56]	; 0x38
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001038:	6923      	ldr	r3, [r4, #16]
 800103a:	2b00      	cmp	r3, #0
 800103c:	f040 80d3 	bne.w	80011e6 <xQueueReceive+0x2de>
                taskEXIT_CRITICAL();
 8001040:	f008 fdf0 	bl	8009c24 <vPortExitCritical>
                return pdPASS;
 8001044:	2001      	movs	r0, #1
 8001046:	e06d      	b.n	8001124 <xQueueReceive+0x21c>
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8001048:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800104a:	2b00      	cmp	r3, #0
 800104c:	f43f af68 	beq.w	8000f20 <xQueueReceive+0x18>
    __asm volatile
 8001050:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001054:	f383 8811 	msr	BASEPRI, r3
 8001058:	f3bf 8f6f 	isb	sy
 800105c:	f3bf 8f4f 	dsb	sy
 8001060:	e7fe      	b.n	8001060 <xQueueReceive+0x158>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8001062:	9b01      	ldr	r3, [sp, #4]
 8001064:	2b00      	cmp	r3, #0
 8001066:	f43f af60 	beq.w	8000f2a <xQueueReceive+0x22>
 800106a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800106e:	f383 8811 	msr	BASEPRI, r3
 8001072:	f3bf 8f6f 	isb	sy
 8001076:	f3bf 8f4f 	dsb	sy
 800107a:	e7fe      	b.n	800107a <xQueueReceive+0x172>
    taskENTER_CRITICAL();
 800107c:	f008 fdbc 	bl	8009bf8 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 8001080:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8001084:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8001086:	2d00      	cmp	r5, #0
 8001088:	dc04      	bgt.n	8001094 <xQueueReceive+0x18c>
 800108a:	e011      	b.n	80010b0 <xQueueReceive+0x1a8>
            --cTxLock;
 800108c:	1e6b      	subs	r3, r5, #1
 800108e:	b2da      	uxtb	r2, r3
 8001090:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8001092:	b16a      	cbz	r2, 80010b0 <xQueueReceive+0x1a8>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001094:	6a63      	ldr	r3, [r4, #36]	; 0x24
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001096:	4630      	mov	r0, r6
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001098:	b153      	cbz	r3, 80010b0 <xQueueReceive+0x1a8>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800109a:	f003 faa9 	bl	80045f0 <xTaskRemoveFromEventList>
 800109e:	2800      	cmp	r0, #0
 80010a0:	d0f4      	beq.n	800108c <xQueueReceive+0x184>
                            vTaskMissedYield();
 80010a2:	f003 fc73 	bl	800498c <vTaskMissedYield>
            --cTxLock;
 80010a6:	1e6b      	subs	r3, r5, #1
 80010a8:	b2da      	uxtb	r2, r3
 80010aa:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 80010ac:	2a00      	cmp	r2, #0
 80010ae:	d1f1      	bne.n	8001094 <xQueueReceive+0x18c>
        pxQueue->cTxLock = queueUNLOCKED;
 80010b0:	23ff      	movs	r3, #255	; 0xff
 80010b2:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    taskEXIT_CRITICAL();
 80010b6:	f008 fdb5 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 80010ba:	f008 fd9d 	bl	8009bf8 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 80010be:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80010c2:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80010c4:	2d00      	cmp	r5, #0
 80010c6:	dd14      	ble.n	80010f2 <xQueueReceive+0x1ea>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80010c8:	f104 0910 	add.w	r9, r4, #16
 80010cc:	e003      	b.n	80010d6 <xQueueReceive+0x1ce>
                --cRxLock;
 80010ce:	1e6b      	subs	r3, r5, #1
 80010d0:	b2da      	uxtb	r2, r3
 80010d2:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80010d4:	b16a      	cbz	r2, 80010f2 <xQueueReceive+0x1ea>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80010d6:	6923      	ldr	r3, [r4, #16]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80010d8:	4648      	mov	r0, r9
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80010da:	b153      	cbz	r3, 80010f2 <xQueueReceive+0x1ea>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80010dc:	f003 fa88 	bl	80045f0 <xTaskRemoveFromEventList>
 80010e0:	2800      	cmp	r0, #0
 80010e2:	d0f4      	beq.n	80010ce <xQueueReceive+0x1c6>
                    vTaskMissedYield();
 80010e4:	f003 fc52 	bl	800498c <vTaskMissedYield>
                --cRxLock;
 80010e8:	1e6b      	subs	r3, r5, #1
 80010ea:	b2da      	uxtb	r2, r3
 80010ec:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80010ee:	2a00      	cmp	r2, #0
 80010f0:	d1f1      	bne.n	80010d6 <xQueueReceive+0x1ce>
        pxQueue->cRxLock = queueUNLOCKED;
 80010f2:	23ff      	movs	r3, #255	; 0xff
 80010f4:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    taskEXIT_CRITICAL();
 80010f8:	f008 fd94 	bl	8009c24 <vPortExitCritical>
            ( void ) xTaskResumeAll();
 80010fc:	f002 fece 	bl	8003e9c <xTaskResumeAll>
    taskENTER_CRITICAL();
 8001100:	f008 fd7a 	bl	8009bf8 <vPortEnterCritical>
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 8001104:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001106:	b153      	cbz	r3, 800111e <xQueueReceive+0x216>
    taskEXIT_CRITICAL();
 8001108:	f008 fd8c 	bl	8009c24 <vPortExitCritical>
        taskENTER_CRITICAL();
 800110c:	f008 fd74 	bl	8009bf8 <vPortEnterCritical>
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001110:	6ba5      	ldr	r5, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8001112:	2d00      	cmp	r5, #0
 8001114:	d181      	bne.n	800101a <xQueueReceive+0x112>
                if( xTicksToWait == ( TickType_t ) 0 )
 8001116:	9b01      	ldr	r3, [sp, #4]
 8001118:	2b00      	cmp	r3, #0
 800111a:	f47f af15 	bne.w	8000f48 <xQueueReceive+0x40>
                    taskEXIT_CRITICAL();
 800111e:	f008 fd81 	bl	8009c24 <vPortExitCritical>
                    return errQUEUE_EMPTY;
 8001122:	2000      	movs	r0, #0
}
 8001124:	b005      	add	sp, #20
 8001126:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    taskEXIT_CRITICAL();
 800112a:	f008 fd7b 	bl	8009c24 <vPortExitCritical>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800112e:	9901      	ldr	r1, [sp, #4]
 8001130:	4630      	mov	r0, r6
 8001132:	f003 f977 	bl	8004424 <vTaskPlaceOnEventList>
    taskENTER_CRITICAL();
 8001136:	f008 fd5f 	bl	8009bf8 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 800113a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800113e:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8001140:	2d00      	cmp	r5, #0
 8001142:	dc04      	bgt.n	800114e <xQueueReceive+0x246>
 8001144:	e011      	b.n	800116a <xQueueReceive+0x262>
            --cTxLock;
 8001146:	1e6b      	subs	r3, r5, #1
 8001148:	b2da      	uxtb	r2, r3
 800114a:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 800114c:	b16a      	cbz	r2, 800116a <xQueueReceive+0x262>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800114e:	6a63      	ldr	r3, [r4, #36]	; 0x24
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001150:	4630      	mov	r0, r6
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001152:	b153      	cbz	r3, 800116a <xQueueReceive+0x262>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001154:	f003 fa4c 	bl	80045f0 <xTaskRemoveFromEventList>
 8001158:	2800      	cmp	r0, #0
 800115a:	d0f4      	beq.n	8001146 <xQueueReceive+0x23e>
                            vTaskMissedYield();
 800115c:	f003 fc16 	bl	800498c <vTaskMissedYield>
            --cTxLock;
 8001160:	1e6b      	subs	r3, r5, #1
 8001162:	b2da      	uxtb	r2, r3
 8001164:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8001166:	2a00      	cmp	r2, #0
 8001168:	d1f1      	bne.n	800114e <xQueueReceive+0x246>
        pxQueue->cTxLock = queueUNLOCKED;
 800116a:	23ff      	movs	r3, #255	; 0xff
 800116c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    taskEXIT_CRITICAL();
 8001170:	f008 fd58 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 8001174:	f008 fd40 	bl	8009bf8 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8001178:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800117c:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 800117e:	2d00      	cmp	r5, #0
 8001180:	dd14      	ble.n	80011ac <xQueueReceive+0x2a4>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001182:	f104 0910 	add.w	r9, r4, #16
 8001186:	e003      	b.n	8001190 <xQueueReceive+0x288>
                --cRxLock;
 8001188:	1e6b      	subs	r3, r5, #1
 800118a:	b2da      	uxtb	r2, r3
 800118c:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 800118e:	b16a      	cbz	r2, 80011ac <xQueueReceive+0x2a4>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001190:	6923      	ldr	r3, [r4, #16]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001192:	4648      	mov	r0, r9
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001194:	b153      	cbz	r3, 80011ac <xQueueReceive+0x2a4>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001196:	f003 fa2b 	bl	80045f0 <xTaskRemoveFromEventList>
 800119a:	2800      	cmp	r0, #0
 800119c:	d0f4      	beq.n	8001188 <xQueueReceive+0x280>
                    vTaskMissedYield();
 800119e:	f003 fbf5 	bl	800498c <vTaskMissedYield>
                --cRxLock;
 80011a2:	1e6b      	subs	r3, r5, #1
 80011a4:	b2da      	uxtb	r2, r3
 80011a6:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80011a8:	2a00      	cmp	r2, #0
 80011aa:	d1f1      	bne.n	8001190 <xQueueReceive+0x288>
        pxQueue->cRxLock = queueUNLOCKED;
 80011ac:	23ff      	movs	r3, #255	; 0xff
 80011ae:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    taskEXIT_CRITICAL();
 80011b2:	f008 fd37 	bl	8009c24 <vPortExitCritical>
                if( xTaskResumeAll() == pdFALSE )
 80011b6:	f002 fe71 	bl	8003e9c <xTaskResumeAll>
 80011ba:	2800      	cmp	r0, #0
 80011bc:	d1a6      	bne.n	800110c <xQueueReceive+0x204>
                    portYIELD_WITHIN_API();
 80011be:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80011c2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80011c6:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80011ca:	f3bf 8f4f 	dsb	sy
 80011ce:	f3bf 8f6f 	isb	sy
        taskENTER_CRITICAL();
 80011d2:	e79b      	b.n	800110c <xQueueReceive+0x204>
 80011d4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80011d8:	f383 8811 	msr	BASEPRI, r3
 80011dc:	f3bf 8f6f 	isb	sy
 80011e0:	f3bf 8f4f 	dsb	sy
    configASSERT( ( pxQueue ) );
 80011e4:	e7fe      	b.n	80011e4 <xQueueReceive+0x2dc>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80011e6:	f104 0010 	add.w	r0, r4, #16
 80011ea:	f003 fa01 	bl	80045f0 <xTaskRemoveFromEventList>
 80011ee:	2800      	cmp	r0, #0
 80011f0:	f43f af26 	beq.w	8001040 <xQueueReceive+0x138>
                        queueYIELD_IF_USING_PREEMPTION();
 80011f4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80011f8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80011fc:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8001200:	f3bf 8f4f 	dsb	sy
 8001204:	f3bf 8f6f 	isb	sy
 8001208:	e71a      	b.n	8001040 <xQueueReceive+0x138>
 800120a:	bf00      	nop

0800120c <uxQueueMessagesWaiting>:
    configASSERT( xQueue );
 800120c:	b158      	cbz	r0, 8001226 <uxQueueMessagesWaiting+0x1a>
{
 800120e:	b510      	push	{r4, lr}
 8001210:	4604      	mov	r4, r0
 8001212:	b082      	sub	sp, #8
    taskENTER_CRITICAL();
 8001214:	f008 fcf0 	bl	8009bf8 <vPortEnterCritical>
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 8001218:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800121a:	9001      	str	r0, [sp, #4]
    taskEXIT_CRITICAL();
 800121c:	f008 fd02 	bl	8009c24 <vPortExitCritical>
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8001220:	9801      	ldr	r0, [sp, #4]
 8001222:	b002      	add	sp, #8
 8001224:	bd10      	pop	{r4, pc}
 8001226:	f04f 0350 	mov.w	r3, #80	; 0x50
 800122a:	f383 8811 	msr	BASEPRI, r3
 800122e:	f3bf 8f6f 	isb	sy
 8001232:	f3bf 8f4f 	dsb	sy
    configASSERT( xQueue );
 8001236:	e7fe      	b.n	8001236 <uxQueueMessagesWaiting+0x2a>

08001238 <uxQueueSpacesAvailable>:
    configASSERT( pxQueue );
 8001238:	b168      	cbz	r0, 8001256 <uxQueueSpacesAvailable+0x1e>
{
 800123a:	b510      	push	{r4, lr}
 800123c:	4604      	mov	r4, r0
 800123e:	b082      	sub	sp, #8
    taskENTER_CRITICAL();
 8001240:	f008 fcda 	bl	8009bf8 <vPortEnterCritical>
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 8001244:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001246:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8001248:	1ac0      	subs	r0, r0, r3
 800124a:	9001      	str	r0, [sp, #4]
    taskEXIT_CRITICAL();
 800124c:	f008 fcea 	bl	8009c24 <vPortExitCritical>
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8001250:	9801      	ldr	r0, [sp, #4]
 8001252:	b002      	add	sp, #8
 8001254:	bd10      	pop	{r4, pc}
 8001256:	f04f 0350 	mov.w	r3, #80	; 0x50
 800125a:	f383 8811 	msr	BASEPRI, r3
 800125e:	f3bf 8f6f 	isb	sy
 8001262:	f3bf 8f4f 	dsb	sy
    configASSERT( pxQueue );
 8001266:	e7fe      	b.n	8001266 <uxQueueSpacesAvailable+0x2e>

08001268 <vQueueDelete>:
    configASSERT( pxQueue );
 8001268:	b1e0      	cbz	r0, 80012a4 <vQueueDelete+0x3c>

        /* See if the handle of the queue being unregistered in actually in the
         * registry. */
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
        {
            if( xQueueRegistry[ ux ].xHandle == xQueue )
 800126a:	4b1f      	ldr	r3, [pc, #124]	; (80012e8 <vQueueDelete+0x80>)
 800126c:	685a      	ldr	r2, [r3, #4]
 800126e:	4290      	cmp	r0, r2
 8001270:	d02c      	beq.n	80012cc <vQueueDelete+0x64>
 8001272:	68da      	ldr	r2, [r3, #12]
 8001274:	4290      	cmp	r0, r2
 8001276:	d020      	beq.n	80012ba <vQueueDelete+0x52>
 8001278:	695a      	ldr	r2, [r3, #20]
 800127a:	4290      	cmp	r0, r2
 800127c:	d028      	beq.n	80012d0 <vQueueDelete+0x68>
 800127e:	69da      	ldr	r2, [r3, #28]
 8001280:	4290      	cmp	r0, r2
 8001282:	d027      	beq.n	80012d4 <vQueueDelete+0x6c>
 8001284:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001286:	4290      	cmp	r0, r2
 8001288:	d026      	beq.n	80012d8 <vQueueDelete+0x70>
 800128a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800128c:	4290      	cmp	r0, r2
 800128e:	d025      	beq.n	80012dc <vQueueDelete+0x74>
 8001290:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001292:	4290      	cmp	r0, r2
 8001294:	d024      	beq.n	80012e0 <vQueueDelete+0x78>
 8001296:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001298:	4290      	cmp	r0, r2
 800129a:	d023      	beq.n	80012e4 <vQueueDelete+0x7c>
            if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 800129c:	f890 3046 	ldrb.w	r3, [r0, #70]	; 0x46
 80012a0:	b14b      	cbz	r3, 80012b6 <vQueueDelete+0x4e>
}
 80012a2:	4770      	bx	lr
 80012a4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80012a8:	f383 8811 	msr	BASEPRI, r3
 80012ac:	f3bf 8f6f 	isb	sy
 80012b0:	f3bf 8f4f 	dsb	sy
    configASSERT( pxQueue );
 80012b4:	e7fe      	b.n	80012b4 <vQueueDelete+0x4c>
                vPortFree( pxQueue );
 80012b6:	f004 bc03 	b.w	8005ac0 <vPortFree>
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80012ba:	2201      	movs	r2, #1
            {
                /* Set the name to NULL to show that this slot if free again. */
                xQueueRegistry[ ux ].pcQueueName = NULL;
 80012bc:	2100      	movs	r1, #0

                /* Set the handle to NULL to ensure the same queue handle cannot
                 * appear in the registry twice if it is added, removed, then
                 * added again. */
                xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 80012be:	eb03 0cc2 	add.w	ip, r3, r2, lsl #3
                xQueueRegistry[ ux ].pcQueueName = NULL;
 80012c2:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
                xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 80012c6:	f8cc 1004 	str.w	r1, [ip, #4]
                break;
 80012ca:	e7e7      	b.n	800129c <vQueueDelete+0x34>
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80012cc:	2200      	movs	r2, #0
 80012ce:	e7f5      	b.n	80012bc <vQueueDelete+0x54>
 80012d0:	2202      	movs	r2, #2
 80012d2:	e7f3      	b.n	80012bc <vQueueDelete+0x54>
 80012d4:	2203      	movs	r2, #3
 80012d6:	e7f1      	b.n	80012bc <vQueueDelete+0x54>
 80012d8:	2204      	movs	r2, #4
 80012da:	e7ef      	b.n	80012bc <vQueueDelete+0x54>
 80012dc:	2205      	movs	r2, #5
 80012de:	e7ed      	b.n	80012bc <vQueueDelete+0x54>
 80012e0:	2206      	movs	r2, #6
 80012e2:	e7eb      	b.n	80012bc <vQueueDelete+0x54>
 80012e4:	2207      	movs	r2, #7
 80012e6:	e7e9      	b.n	80012bc <vQueueDelete+0x54>
 80012e8:	24000000 	.word	0x24000000

080012ec <xQueueGenericSendFromISR>:
    configASSERT( pxQueue );
 80012ec:	2800      	cmp	r0, #0
 80012ee:	d04d      	beq.n	800138c <xQueueGenericSendFromISR+0xa0>
{
 80012f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80012f4:	460e      	mov	r6, r1
 80012f6:	4604      	mov	r4, r0
 80012f8:	4617      	mov	r7, r2
 80012fa:	461d      	mov	r5, r3
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80012fc:	b339      	cbz	r1, 800134e <xQueueGenericSendFromISR+0x62>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80012fe:	2d02      	cmp	r5, #2
 8001300:	d10b      	bne.n	800131a <xQueueGenericSendFromISR+0x2e>
 8001302:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001304:	2b01      	cmp	r3, #1
 8001306:	d008      	beq.n	800131a <xQueueGenericSendFromISR+0x2e>
 8001308:	f04f 0350 	mov.w	r3, #80	; 0x50
 800130c:	f383 8811 	msr	BASEPRI, r3
 8001310:	f3bf 8f6f 	isb	sy
 8001314:	f3bf 8f4f 	dsb	sy
 8001318:	e7fe      	b.n	8001318 <xQueueGenericSendFromISR+0x2c>
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800131a:	f008 fcc1 	bl	8009ca0 <vPortValidateInterruptPriority>
    __asm volatile
 800131e:	f3ef 8811 	mrs	r8, BASEPRI
 8001322:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001326:	f383 8811 	msr	BASEPRI, r3
 800132a:	f3bf 8f6f 	isb	sy
 800132e:	f3bf 8f4f 	dsb	sy
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8001332:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8001334:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001336:	429a      	cmp	r2, r3
 8001338:	d315      	bcc.n	8001366 <xQueueGenericSendFromISR+0x7a>
 800133a:	f1a5 0002 	sub.w	r0, r5, #2
 800133e:	fab0 f080 	clz	r0, r0
 8001342:	0940      	lsrs	r0, r0, #5
 8001344:	b978      	cbnz	r0, 8001366 <xQueueGenericSendFromISR+0x7a>
    __asm volatile
 8001346:	f388 8811 	msr	BASEPRI, r8
}
 800134a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800134e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001350:	2b00      	cmp	r3, #0
 8001352:	d0d4      	beq.n	80012fe <xQueueGenericSendFromISR+0x12>
    __asm volatile
 8001354:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001358:	f383 8811 	msr	BASEPRI, r3
 800135c:	f3bf 8f6f 	isb	sy
 8001360:	f3bf 8f4f 	dsb	sy
 8001364:	e7fe      	b.n	8001364 <xQueueGenericSendFromISR+0x78>
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8001366:	462a      	mov	r2, r5
            const int8_t cTxLock = pxQueue->cTxLock;
 8001368:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800136c:	4631      	mov	r1, r6
 800136e:	4620      	mov	r0, r4
            const int8_t cTxLock = pxQueue->cTxLock;
 8001370:	b26d      	sxtb	r5, r5
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001372:	6ba3      	ldr	r3, [r4, #56]	; 0x38
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8001374:	f7ff fa44 	bl	8000800 <prvCopyDataToQueue>
            if( cTxLock == queueUNLOCKED )
 8001378:	1c6b      	adds	r3, r5, #1
 800137a:	d010      	beq.n	800139e <xQueueGenericSendFromISR+0xb2>
                configASSERT( cTxLock != queueINT8_MAX );
 800137c:	2d7f      	cmp	r5, #127	; 0x7f
 800137e:	d012      	beq.n	80013a6 <xQueueGenericSendFromISR+0xba>
                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8001380:	1c6b      	adds	r3, r5, #1
            xReturn = pdPASS;
 8001382:	2001      	movs	r0, #1
                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8001384:	b25b      	sxtb	r3, r3
 8001386:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800138a:	e7dc      	b.n	8001346 <xQueueGenericSendFromISR+0x5a>
 800138c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001390:	f383 8811 	msr	BASEPRI, r3
 8001394:	f3bf 8f6f 	isb	sy
 8001398:	f3bf 8f4f 	dsb	sy
    configASSERT( pxQueue );
 800139c:	e7fe      	b.n	800139c <xQueueGenericSendFromISR+0xb0>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800139e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80013a0:	b953      	cbnz	r3, 80013b8 <xQueueGenericSendFromISR+0xcc>
            xReturn = pdPASS;
 80013a2:	2001      	movs	r0, #1
 80013a4:	e7cf      	b.n	8001346 <xQueueGenericSendFromISR+0x5a>
 80013a6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80013aa:	f383 8811 	msr	BASEPRI, r3
 80013ae:	f3bf 8f6f 	isb	sy
 80013b2:	f3bf 8f4f 	dsb	sy
                configASSERT( cTxLock != queueINT8_MAX );
 80013b6:	e7fe      	b.n	80013b6 <xQueueGenericSendFromISR+0xca>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80013b8:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80013bc:	f003 f918 	bl	80045f0 <xTaskRemoveFromEventList>
                                if( pxHigherPriorityTaskWoken != NULL )
 80013c0:	2800      	cmp	r0, #0
 80013c2:	d0ee      	beq.n	80013a2 <xQueueGenericSendFromISR+0xb6>
 80013c4:	2f00      	cmp	r7, #0
 80013c6:	d0ec      	beq.n	80013a2 <xQueueGenericSendFromISR+0xb6>
                                    *pxHigherPriorityTaskWoken = pdTRUE;
 80013c8:	2301      	movs	r3, #1
            xReturn = pdPASS;
 80013ca:	4618      	mov	r0, r3
                                    *pxHigherPriorityTaskWoken = pdTRUE;
 80013cc:	603b      	str	r3, [r7, #0]
 80013ce:	e7ba      	b.n	8001346 <xQueueGenericSendFromISR+0x5a>

080013d0 <xQueueGiveFromISR>:
    configASSERT( pxQueue );
 80013d0:	b370      	cbz	r0, 8001430 <xQueueGiveFromISR+0x60>
    configASSERT( pxQueue->uxItemSize == 0 );
 80013d2:	6c03      	ldr	r3, [r0, #64]	; 0x40
{
 80013d4:	b570      	push	{r4, r5, r6, lr}
 80013d6:	4606      	mov	r6, r0
    configASSERT( pxQueue->uxItemSize == 0 );
 80013d8:	b143      	cbz	r3, 80013ec <xQueueGiveFromISR+0x1c>
 80013da:	f04f 0350 	mov.w	r3, #80	; 0x50
 80013de:	f383 8811 	msr	BASEPRI, r3
 80013e2:	f3bf 8f6f 	isb	sy
 80013e6:	f3bf 8f4f 	dsb	sy
 80013ea:	e7fe      	b.n	80013ea <xQueueGiveFromISR+0x1a>
    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 80013ec:	6803      	ldr	r3, [r0, #0]
 80013ee:	460c      	mov	r4, r1
 80013f0:	b33b      	cbz	r3, 8001442 <xQueueGiveFromISR+0x72>
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80013f2:	f008 fc55 	bl	8009ca0 <vPortValidateInterruptPriority>
    __asm volatile
 80013f6:	f3ef 8511 	mrs	r5, BASEPRI
 80013fa:	f04f 0350 	mov.w	r3, #80	; 0x50
 80013fe:	f383 8811 	msr	BASEPRI, r3
 8001402:	f3bf 8f6f 	isb	sy
 8001406:	f3bf 8f4f 	dsb	sy
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800140a:	6bb3      	ldr	r3, [r6, #56]	; 0x38
        if( uxMessagesWaiting < pxQueue->uxLength )
 800140c:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
 800140e:	429a      	cmp	r2, r3
 8001410:	d923      	bls.n	800145a <xQueueGiveFromISR+0x8a>
            const int8_t cTxLock = pxQueue->cTxLock;
 8001412:	f896 2045 	ldrb.w	r2, [r6, #69]	; 0x45
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8001416:	3301      	adds	r3, #1
            if( cTxLock == queueUNLOCKED )
 8001418:	2aff      	cmp	r2, #255	; 0xff
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 800141a:	63b3      	str	r3, [r6, #56]	; 0x38
            const int8_t cTxLock = pxQueue->cTxLock;
 800141c:	b253      	sxtb	r3, r2
            if( cTxLock == queueUNLOCKED )
 800141e:	d021      	beq.n	8001464 <xQueueGiveFromISR+0x94>
                configASSERT( cTxLock != queueINT8_MAX );
 8001420:	2b7f      	cmp	r3, #127	; 0x7f
 8001422:	d023      	beq.n	800146c <xQueueGiveFromISR+0x9c>
                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8001424:	1c5a      	adds	r2, r3, #1
            xReturn = pdPASS;
 8001426:	2301      	movs	r3, #1
                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8001428:	b252      	sxtb	r2, r2
 800142a:	f886 2045 	strb.w	r2, [r6, #69]	; 0x45
 800142e:	e015      	b.n	800145c <xQueueGiveFromISR+0x8c>
    __asm volatile
 8001430:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001434:	f383 8811 	msr	BASEPRI, r3
 8001438:	f3bf 8f6f 	isb	sy
 800143c:	f3bf 8f4f 	dsb	sy
    configASSERT( pxQueue );
 8001440:	e7fe      	b.n	8001440 <xQueueGiveFromISR+0x70>
    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 8001442:	6883      	ldr	r3, [r0, #8]
 8001444:	2b00      	cmp	r3, #0
 8001446:	d0d4      	beq.n	80013f2 <xQueueGiveFromISR+0x22>
 8001448:	f04f 0350 	mov.w	r3, #80	; 0x50
 800144c:	f383 8811 	msr	BASEPRI, r3
 8001450:	f3bf 8f6f 	isb	sy
 8001454:	f3bf 8f4f 	dsb	sy
 8001458:	e7fe      	b.n	8001458 <xQueueGiveFromISR+0x88>
            xReturn = errQUEUE_FULL;
 800145a:	2300      	movs	r3, #0
    __asm volatile
 800145c:	f385 8811 	msr	BASEPRI, r5
}
 8001460:	4618      	mov	r0, r3
 8001462:	bd70      	pop	{r4, r5, r6, pc}
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001464:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8001466:	b953      	cbnz	r3, 800147e <xQueueGiveFromISR+0xae>
            xReturn = pdPASS;
 8001468:	2301      	movs	r3, #1
 800146a:	e7f7      	b.n	800145c <xQueueGiveFromISR+0x8c>
    __asm volatile
 800146c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001470:	f383 8811 	msr	BASEPRI, r3
 8001474:	f3bf 8f6f 	isb	sy
 8001478:	f3bf 8f4f 	dsb	sy
                configASSERT( cTxLock != queueINT8_MAX );
 800147c:	e7fe      	b.n	800147c <xQueueGiveFromISR+0xac>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800147e:	f106 0024 	add.w	r0, r6, #36	; 0x24
 8001482:	f003 f8b5 	bl	80045f0 <xTaskRemoveFromEventList>
                                if( pxHigherPriorityTaskWoken != NULL )
 8001486:	2800      	cmp	r0, #0
 8001488:	d0ee      	beq.n	8001468 <xQueueGiveFromISR+0x98>
 800148a:	2c00      	cmp	r4, #0
 800148c:	d0ec      	beq.n	8001468 <xQueueGiveFromISR+0x98>
                                    *pxHigherPriorityTaskWoken = pdTRUE;
 800148e:	2201      	movs	r2, #1
            xReturn = pdPASS;
 8001490:	4613      	mov	r3, r2
                                    *pxHigherPriorityTaskWoken = pdTRUE;
 8001492:	6022      	str	r2, [r4, #0]
 8001494:	e7e2      	b.n	800145c <xQueueGiveFromISR+0x8c>
 8001496:	bf00      	nop

08001498 <xQueueReceiveFromISR>:
{
 8001498:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    configASSERT( pxQueue );
 800149c:	b310      	cbz	r0, 80014e4 <xQueueReceiveFromISR+0x4c>
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800149e:	460e      	mov	r6, r1
 80014a0:	4604      	mov	r4, r0
 80014a2:	4617      	mov	r7, r2
 80014a4:	b191      	cbz	r1, 80014cc <xQueueReceiveFromISR+0x34>
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80014a6:	f008 fbfb 	bl	8009ca0 <vPortValidateInterruptPriority>
    __asm volatile
 80014aa:	f3ef 8811 	mrs	r8, BASEPRI
 80014ae:	f04f 0350 	mov.w	r3, #80	; 0x50
 80014b2:	f383 8811 	msr	BASEPRI, r3
 80014b6:	f3bf 8f6f 	isb	sy
 80014ba:	f3bf 8f4f 	dsb	sy
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80014be:	6ba5      	ldr	r5, [r4, #56]	; 0x38
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80014c0:	b9cd      	cbnz	r5, 80014f6 <xQueueReceiveFromISR+0x5e>
            xReturn = pdFAIL;
 80014c2:	4628      	mov	r0, r5
    __asm volatile
 80014c4:	f388 8811 	msr	BASEPRI, r8
}
 80014c8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80014cc:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80014ce:	2b00      	cmp	r3, #0
 80014d0:	d0e9      	beq.n	80014a6 <xQueueReceiveFromISR+0xe>
    __asm volatile
 80014d2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80014d6:	f383 8811 	msr	BASEPRI, r3
 80014da:	f3bf 8f6f 	isb	sy
 80014de:	f3bf 8f4f 	dsb	sy
 80014e2:	e7fe      	b.n	80014e2 <xQueueReceiveFromISR+0x4a>
 80014e4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80014e8:	f383 8811 	msr	BASEPRI, r3
 80014ec:	f3bf 8f6f 	isb	sy
 80014f0:	f3bf 8f4f 	dsb	sy
    configASSERT( pxQueue );
 80014f4:	e7fe      	b.n	80014f4 <xQueueReceiveFromISR+0x5c>
            const int8_t cRxLock = pxQueue->cRxLock;
 80014f6:	f894 9044 	ldrb.w	r9, [r4, #68]	; 0x44
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 80014fa:	6c22      	ldr	r2, [r4, #64]	; 0x40
            const int8_t cRxLock = pxQueue->cRxLock;
 80014fc:	fa4f f989 	sxtb.w	r9, r9
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8001500:	b142      	cbz	r2, 8001514 <xQueueReceiveFromISR+0x7c>
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8001502:	68e1      	ldr	r1, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8001504:	68a3      	ldr	r3, [r4, #8]
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8001506:	4411      	add	r1, r2
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8001508:	4299      	cmp	r1, r3
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 800150a:	60e1      	str	r1, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800150c:	d215      	bcs.n	800153a <xQueueReceiveFromISR+0xa2>
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 800150e:	4630      	mov	r0, r6
 8001510:	f012 fef0 	bl	80142f4 <memcpy>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8001514:	3d01      	subs	r5, #1
            if( cRxLock == queueUNLOCKED )
 8001516:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800151a:	63a5      	str	r5, [r4, #56]	; 0x38
            if( cRxLock == queueUNLOCKED )
 800151c:	d009      	beq.n	8001532 <xQueueReceiveFromISR+0x9a>
                configASSERT( cRxLock != queueINT8_MAX );
 800151e:	f1b9 0f7f 	cmp.w	r9, #127	; 0x7f
 8001522:	d019      	beq.n	8001558 <xQueueReceiveFromISR+0xc0>
                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 8001524:	f109 0301 	add.w	r3, r9, #1
            xReturn = pdPASS;
 8001528:	2001      	movs	r0, #1
                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 800152a:	b25b      	sxtb	r3, r3
 800152c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8001530:	e7c8      	b.n	80014c4 <xQueueReceiveFromISR+0x2c>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001532:	6923      	ldr	r3, [r4, #16]
 8001534:	b923      	cbnz	r3, 8001540 <xQueueReceiveFromISR+0xa8>
            xReturn = pdPASS;
 8001536:	2001      	movs	r0, #1
 8001538:	e7c4      	b.n	80014c4 <xQueueReceiveFromISR+0x2c>
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 800153a:	6821      	ldr	r1, [r4, #0]
 800153c:	60e1      	str	r1, [r4, #12]
 800153e:	e7e6      	b.n	800150e <xQueueReceiveFromISR+0x76>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001540:	f104 0010 	add.w	r0, r4, #16
 8001544:	f003 f854 	bl	80045f0 <xTaskRemoveFromEventList>
                        if( pxHigherPriorityTaskWoken != NULL )
 8001548:	2800      	cmp	r0, #0
 800154a:	d0f4      	beq.n	8001536 <xQueueReceiveFromISR+0x9e>
 800154c:	2f00      	cmp	r7, #0
 800154e:	d0f2      	beq.n	8001536 <xQueueReceiveFromISR+0x9e>
                            *pxHigherPriorityTaskWoken = pdTRUE;
 8001550:	2301      	movs	r3, #1
            xReturn = pdPASS;
 8001552:	4618      	mov	r0, r3
                            *pxHigherPriorityTaskWoken = pdTRUE;
 8001554:	603b      	str	r3, [r7, #0]
 8001556:	e7b5      	b.n	80014c4 <xQueueReceiveFromISR+0x2c>
 8001558:	f04f 0350 	mov.w	r3, #80	; 0x50
 800155c:	f383 8811 	msr	BASEPRI, r3
 8001560:	f3bf 8f6f 	isb	sy
 8001564:	f3bf 8f4f 	dsb	sy
                configASSERT( cRxLock != queueINT8_MAX );
 8001568:	e7fe      	b.n	8001568 <xQueueReceiveFromISR+0xd0>
 800156a:	bf00      	nop

0800156c <xQueueIsQueueEmptyFromISR>:
    configASSERT( pxQueue );
 800156c:	b120      	cbz	r0, 8001578 <xQueueIsQueueEmptyFromISR+0xc>
    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 800156e:	6b80      	ldr	r0, [r0, #56]	; 0x38
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 8001570:	fab0 f080 	clz	r0, r0
 8001574:	0940      	lsrs	r0, r0, #5
 8001576:	4770      	bx	lr
 8001578:	f04f 0350 	mov.w	r3, #80	; 0x50
 800157c:	f383 8811 	msr	BASEPRI, r3
 8001580:	f3bf 8f6f 	isb	sy
 8001584:	f3bf 8f4f 	dsb	sy
    configASSERT( pxQueue );
 8001588:	e7fe      	b.n	8001588 <xQueueIsQueueEmptyFromISR+0x1c>
 800158a:	bf00      	nop

0800158c <xQueueIsQueueFullFromISR>:
    configASSERT( pxQueue );
 800158c:	b130      	cbz	r0, 800159c <xQueueIsQueueFullFromISR+0x10>
    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800158e:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001590:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 8001592:	1ac0      	subs	r0, r0, r3
 8001594:	fab0 f080 	clz	r0, r0
 8001598:	0940      	lsrs	r0, r0, #5
 800159a:	4770      	bx	lr
 800159c:	f04f 0350 	mov.w	r3, #80	; 0x50
 80015a0:	f383 8811 	msr	BASEPRI, r3
 80015a4:	f3bf 8f6f 	isb	sy
 80015a8:	f3bf 8f4f 	dsb	sy
    configASSERT( pxQueue );
 80015ac:	e7fe      	b.n	80015ac <xQueueIsQueueFullFromISR+0x20>
 80015ae:	bf00      	nop

080015b0 <uxQueueMessagesWaitingFromISR>:
    configASSERT( pxQueue );
 80015b0:	b108      	cbz	r0, 80015b6 <uxQueueMessagesWaitingFromISR+0x6>
    uxReturn = pxQueue->uxMessagesWaiting;
 80015b2:	6b80      	ldr	r0, [r0, #56]	; 0x38
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 80015b4:	4770      	bx	lr
 80015b6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80015ba:	f383 8811 	msr	BASEPRI, r3
 80015be:	f3bf 8f6f 	isb	sy
 80015c2:	f3bf 8f4f 	dsb	sy
    configASSERT( pxQueue );
 80015c6:	e7fe      	b.n	80015c6 <uxQueueMessagesWaitingFromISR+0x16>

080015c8 <xQueueCreateMutex>:
    {
 80015c8:	b570      	push	{r4, r5, r6, lr}
 80015ca:	4605      	mov	r5, r0
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 80015cc:	2050      	movs	r0, #80	; 0x50
 80015ce:	f004 f9c7 	bl	8005960 <pvPortMalloc>
            if( pxNewQueue != NULL )
 80015d2:	4604      	mov	r4, r0
 80015d4:	b370      	cbz	r0, 8001634 <xQueueCreateMutex+0x6c>
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
 80015d6:	2600      	movs	r6, #0
    pxNewQueue->uxLength = uxQueueLength;
 80015d8:	2301      	movs	r3, #1
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 80015da:	6020      	str	r0, [r4, #0]
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
 80015dc:	f880 6046 	strb.w	r6, [r0, #70]	; 0x46
    pxNewQueue->uxItemSize = uxItemSize;
 80015e0:	e9c0 360f 	strd	r3, r6, [r0, #60]	; 0x3c
        taskENTER_CRITICAL();
 80015e4:	f008 fb08 	bl	8009bf8 <vPortEnterCritical>
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80015e8:	6821      	ldr	r1, [r4, #0]
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80015ea:	63a6      	str	r6, [r4, #56]	; 0x38
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80015ec:	f104 0010 	add.w	r0, r4, #16
            pxQueue->pcWriteTo = pxQueue->pcHead;
 80015f0:	6061      	str	r1, [r4, #4]
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80015f2:	e9d4 230f 	ldrd	r2, r3, [r4, #60]	; 0x3c
 80015f6:	fb03 f202 	mul.w	r2, r3, r2
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80015fa:	1ad3      	subs	r3, r2, r3
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80015fc:	440a      	add	r2, r1
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80015fe:	4419      	add	r1, r3
            pxQueue->cRxLock = queueUNLOCKED;
 8001600:	23ff      	movs	r3, #255	; 0xff
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001602:	e9c4 2102 	strd	r2, r1, [r4, #8]
            pxQueue->cRxLock = queueUNLOCKED;
 8001606:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
            pxQueue->cTxLock = queueUNLOCKED;
 800160a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800160e:	f7ff f8ab 	bl	8000768 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8001612:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8001616:	f7ff f8a7 	bl	8000768 <vListInitialise>
        taskEXIT_CRITICAL();
 800161a:	f008 fb03 	bl	8009c24 <vPortExitCritical>
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 800161e:	4633      	mov	r3, r6
 8001620:	4632      	mov	r2, r6
 8001622:	4631      	mov	r1, r6
 8001624:	4620      	mov	r0, r4
            pxNewQueue->ucQueueType = ucQueueType;
 8001626:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 800162a:	60a6      	str	r6, [r4, #8]
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 800162c:	6026      	str	r6, [r4, #0]
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 800162e:	60e6      	str	r6, [r4, #12]
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 8001630:	f7ff f928 	bl	8000884 <xQueueGenericSend>
    }
 8001634:	4620      	mov	r0, r4
 8001636:	bd70      	pop	{r4, r5, r6, pc}

08001638 <xQueueCreateMutexStatic>:
        configASSERT( pxStaticQueue );
 8001638:	b179      	cbz	r1, 800165a <xQueueCreateMutexStatic+0x22>
                    volatile size_t xSize = sizeof( StaticQueue_t );
 800163a:	2350      	movs	r3, #80	; 0x50
    {
 800163c:	b570      	push	{r4, r5, r6, lr}
 800163e:	b082      	sub	sp, #8
                    volatile size_t xSize = sizeof( StaticQueue_t );
 8001640:	9301      	str	r3, [sp, #4]
                    configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
 8001642:	9b01      	ldr	r3, [sp, #4]
 8001644:	2b50      	cmp	r3, #80	; 0x50
 8001646:	d011      	beq.n	800166c <xQueueCreateMutexStatic+0x34>
 8001648:	f04f 0350 	mov.w	r3, #80	; 0x50
 800164c:	f383 8811 	msr	BASEPRI, r3
 8001650:	f3bf 8f6f 	isb	sy
 8001654:	f3bf 8f4f 	dsb	sy
 8001658:	e7fe      	b.n	8001658 <xQueueCreateMutexStatic+0x20>
 800165a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800165e:	f383 8811 	msr	BASEPRI, r3
 8001662:	f3bf 8f6f 	isb	sy
 8001666:	f3bf 8f4f 	dsb	sy
        configASSERT( pxStaticQueue );
 800166a:	e7fe      	b.n	800166a <xQueueCreateMutexStatic+0x32>
    pxNewQueue->uxItemSize = uxItemSize;
 800166c:	2600      	movs	r6, #0
                    pxNewQueue->ucStaticallyAllocated = pdTRUE;
 800166e:	2301      	movs	r3, #1
 8001670:	460c      	mov	r4, r1
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8001672:	6009      	str	r1, [r1, #0]
                    pxNewQueue->ucStaticallyAllocated = pdTRUE;
 8001674:	f881 3046 	strb.w	r3, [r1, #70]	; 0x46
 8001678:	4605      	mov	r5, r0
                    ( void ) xSize;                             /* Keeps lint quiet when configASSERT() is not defined. */
 800167a:	9a01      	ldr	r2, [sp, #4]
    pxNewQueue->uxItemSize = uxItemSize;
 800167c:	e9c1 360f 	strd	r3, r6, [r1, #60]	; 0x3c
        taskENTER_CRITICAL();
 8001680:	f008 faba 	bl	8009bf8 <vPortEnterCritical>
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001684:	6821      	ldr	r1, [r4, #0]
            pxQueue->cRxLock = queueUNLOCKED;
 8001686:	23ff      	movs	r3, #255	; 0xff
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8001688:	63a6      	str	r6, [r4, #56]	; 0x38
            pxQueue->pcWriteTo = pxQueue->pcHead;
 800168a:	6061      	str	r1, [r4, #4]
            pxQueue->cRxLock = queueUNLOCKED;
 800168c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
            pxQueue->cTxLock = queueUNLOCKED;
 8001690:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001694:	e9d4 200f 	ldrd	r2, r0, [r4, #60]	; 0x3c
 8001698:	fb00 f202 	mul.w	r2, r0, r2
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800169c:	1a10      	subs	r0, r2, r0
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800169e:	440a      	add	r2, r1
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80016a0:	4401      	add	r1, r0
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80016a2:	f104 0010 	add.w	r0, r4, #16
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80016a6:	e9c4 2102 	strd	r2, r1, [r4, #8]
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80016aa:	f7ff f85d 	bl	8000768 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 80016ae:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80016b2:	f7ff f859 	bl	8000768 <vListInitialise>
        taskEXIT_CRITICAL();
 80016b6:	f008 fab5 	bl	8009c24 <vPortExitCritical>
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 80016ba:	4633      	mov	r3, r6
 80016bc:	4632      	mov	r2, r6
 80016be:	4631      	mov	r1, r6
 80016c0:	4620      	mov	r0, r4
            pxNewQueue->ucQueueType = ucQueueType;
 80016c2:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 80016c6:	60a6      	str	r6, [r4, #8]
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 80016c8:	6026      	str	r6, [r4, #0]
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 80016ca:	60e6      	str	r6, [r4, #12]
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 80016cc:	f7ff f8da 	bl	8000884 <xQueueGenericSend>
    }
 80016d0:	4620      	mov	r0, r4
 80016d2:	b002      	add	sp, #8
 80016d4:	bd70      	pop	{r4, r5, r6, pc}
 80016d6:	bf00      	nop

080016d8 <xQueueCreateCountingSemaphore>:
    {
 80016d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if( ( uxMaxCount != 0 ) &&
 80016da:	b118      	cbz	r0, 80016e4 <xQueueCreateCountingSemaphore+0xc>
 80016dc:	4288      	cmp	r0, r1
 80016de:	4604      	mov	r4, r0
 80016e0:	460f      	mov	r7, r1
 80016e2:	d208      	bcs.n	80016f6 <xQueueCreateCountingSemaphore+0x1e>
 80016e4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80016e8:	f383 8811 	msr	BASEPRI, r3
 80016ec:	f3bf 8f6f 	isb	sy
 80016f0:	f3bf 8f4f 	dsb	sy
            configASSERT( xHandle );
 80016f4:	e7fe      	b.n	80016f4 <xQueueCreateCountingSemaphore+0x1c>
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 80016f6:	2050      	movs	r0, #80	; 0x50
 80016f8:	f004 f932 	bl	8005960 <pvPortMalloc>
            if( pxNewQueue != NULL )
 80016fc:	4605      	mov	r5, r0
 80016fe:	b330      	cbz	r0, 800174e <xQueueCreateCountingSemaphore+0x76>
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
 8001700:	2600      	movs	r6, #0
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8001702:	6000      	str	r0, [r0, #0]
    pxNewQueue->uxLength = uxQueueLength;
 8001704:	63c4      	str	r4, [r0, #60]	; 0x3c
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
 8001706:	f880 6046 	strb.w	r6, [r0, #70]	; 0x46
    pxNewQueue->uxItemSize = uxItemSize;
 800170a:	6406      	str	r6, [r0, #64]	; 0x40
        taskENTER_CRITICAL();
 800170c:	f008 fa74 	bl	8009bf8 <vPortEnterCritical>
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001710:	682a      	ldr	r2, [r5, #0]
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8001712:	63ae      	str	r6, [r5, #56]	; 0x38
            pxQueue->pcWriteTo = pxQueue->pcHead;
 8001714:	606a      	str	r2, [r5, #4]
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001716:	e9d5 300f 	ldrd	r3, r0, [r5, #60]	; 0x3c
 800171a:	fb00 f303 	mul.w	r3, r0, r3
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800171e:	1a18      	subs	r0, r3, r0
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001720:	4413      	add	r3, r2
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001722:	4402      	add	r2, r0
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001724:	60ab      	str	r3, [r5, #8]
            pxQueue->cRxLock = queueUNLOCKED;
 8001726:	23ff      	movs	r3, #255	; 0xff
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8001728:	f105 0010 	add.w	r0, r5, #16
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800172c:	60ea      	str	r2, [r5, #12]
            pxQueue->cRxLock = queueUNLOCKED;
 800172e:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
            pxQueue->cTxLock = queueUNLOCKED;
 8001732:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8001736:	f7ff f817 	bl	8000768 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 800173a:	f105 0024 	add.w	r0, r5, #36	; 0x24
 800173e:	f7ff f813 	bl	8000768 <vListInitialise>
        taskEXIT_CRITICAL();
 8001742:	f008 fa6f 	bl	8009c24 <vPortExitCritical>
            pxNewQueue->ucQueueType = ucQueueType;
 8001746:	2302      	movs	r3, #2
                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 8001748:	63af      	str	r7, [r5, #56]	; 0x38
            pxNewQueue->ucQueueType = ucQueueType;
 800174a:	f885 304c 	strb.w	r3, [r5, #76]	; 0x4c
    }
 800174e:	4628      	mov	r0, r5
 8001750:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001752:	bf00      	nop

08001754 <xQueueCreateCountingSemaphoreStatic>:
        if( ( uxMaxCount != 0 ) &&
 8001754:	b108      	cbz	r0, 800175a <xQueueCreateCountingSemaphoreStatic+0x6>
 8001756:	4288      	cmp	r0, r1
 8001758:	d208      	bcs.n	800176c <xQueueCreateCountingSemaphoreStatic+0x18>
 800175a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800175e:	f383 8811 	msr	BASEPRI, r3
 8001762:	f3bf 8f6f 	isb	sy
 8001766:	f3bf 8f4f 	dsb	sy
            configASSERT( xHandle );
 800176a:	e7fe      	b.n	800176a <xQueueCreateCountingSemaphoreStatic+0x16>
    {
 800176c:	b530      	push	{r4, r5, lr}
 800176e:	4615      	mov	r5, r2
 8001770:	b085      	sub	sp, #20
        configASSERT( pxStaticQueue );
 8001772:	b16a      	cbz	r2, 8001790 <xQueueCreateCountingSemaphoreStatic+0x3c>
                    volatile size_t xSize = sizeof( StaticQueue_t );
 8001774:	2350      	movs	r3, #80	; 0x50
 8001776:	9303      	str	r3, [sp, #12]
                    configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
 8001778:	9b03      	ldr	r3, [sp, #12]
 800177a:	2b50      	cmp	r3, #80	; 0x50
 800177c:	d011      	beq.n	80017a2 <xQueueCreateCountingSemaphoreStatic+0x4e>
 800177e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001782:	f383 8811 	msr	BASEPRI, r3
 8001786:	f3bf 8f6f 	isb	sy
 800178a:	f3bf 8f4f 	dsb	sy
 800178e:	e7fe      	b.n	800178e <xQueueCreateCountingSemaphoreStatic+0x3a>
 8001790:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001794:	f383 8811 	msr	BASEPRI, r3
 8001798:	f3bf 8f6f 	isb	sy
 800179c:	f3bf 8f4f 	dsb	sy
        configASSERT( pxStaticQueue );
 80017a0:	e7fe      	b.n	80017a0 <xQueueCreateCountingSemaphoreStatic+0x4c>
    pxNewQueue->uxItemSize = uxItemSize;
 80017a2:	2400      	movs	r4, #0
                    pxNewQueue->ucStaticallyAllocated = pdTRUE;
 80017a4:	2301      	movs	r3, #1
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 80017a6:	602a      	str	r2, [r5, #0]
    pxNewQueue->uxLength = uxQueueLength;
 80017a8:	63d0      	str	r0, [r2, #60]	; 0x3c
                    pxNewQueue->ucStaticallyAllocated = pdTRUE;
 80017aa:	f882 3046 	strb.w	r3, [r2, #70]	; 0x46
    pxNewQueue->uxItemSize = uxItemSize;
 80017ae:	6414      	str	r4, [r2, #64]	; 0x40
 80017b0:	9101      	str	r1, [sp, #4]
                    ( void ) xSize;                             /* Keeps lint quiet when configASSERT() is not defined. */
 80017b2:	9b03      	ldr	r3, [sp, #12]
        taskENTER_CRITICAL();
 80017b4:	f008 fa20 	bl	8009bf8 <vPortEnterCritical>
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80017b8:	6828      	ldr	r0, [r5, #0]
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80017ba:	63ac      	str	r4, [r5, #56]	; 0x38
            pxQueue->pcWriteTo = pxQueue->pcHead;
 80017bc:	6068      	str	r0, [r5, #4]
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80017be:	e9d5 3c0f 	ldrd	r3, ip, [r5, #60]	; 0x3c
 80017c2:	fb03 f30c 	mul.w	r3, r3, ip
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80017c6:	eba3 0c0c 	sub.w	ip, r3, ip
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80017ca:	4403      	add	r3, r0
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80017cc:	4484      	add	ip, r0
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80017ce:	60ab      	str	r3, [r5, #8]
            pxQueue->cRxLock = queueUNLOCKED;
 80017d0:	23ff      	movs	r3, #255	; 0xff
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80017d2:	f105 0010 	add.w	r0, r5, #16
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80017d6:	f8c5 c00c 	str.w	ip, [r5, #12]
            pxQueue->cRxLock = queueUNLOCKED;
 80017da:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
            pxQueue->cTxLock = queueUNLOCKED;
 80017de:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80017e2:	f7fe ffc1 	bl	8000768 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 80017e6:	f105 0024 	add.w	r0, r5, #36	; 0x24
 80017ea:	f7fe ffbd 	bl	8000768 <vListInitialise>
        taskEXIT_CRITICAL();
 80017ee:	f008 fa19 	bl	8009c24 <vPortExitCritical>
            pxNewQueue->ucQueueType = ucQueueType;
 80017f2:	2302      	movs	r3, #2
                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 80017f4:	9901      	ldr	r1, [sp, #4]
    }
 80017f6:	4628      	mov	r0, r5
            pxNewQueue->ucQueueType = ucQueueType;
 80017f8:	f885 304c 	strb.w	r3, [r5, #76]	; 0x4c
                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 80017fc:	63a9      	str	r1, [r5, #56]	; 0x38
    }
 80017fe:	b005      	add	sp, #20
 8001800:	bd30      	pop	{r4, r5, pc}
 8001802:	bf00      	nop

08001804 <xQueueSemaphoreTake>:
{
 8001804:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001808:	b084      	sub	sp, #16
 800180a:	9101      	str	r1, [sp, #4]
    configASSERT( ( pxQueue ) );
 800180c:	2800      	cmp	r0, #0
 800180e:	d05c      	beq.n	80018ca <xQueueSemaphoreTake+0xc6>
    configASSERT( pxQueue->uxItemSize == 0 );
 8001810:	6c07      	ldr	r7, [r0, #64]	; 0x40
 8001812:	4604      	mov	r4, r0
 8001814:	b147      	cbz	r7, 8001828 <xQueueSemaphoreTake+0x24>
 8001816:	f04f 0350 	mov.w	r3, #80	; 0x50
 800181a:	f383 8811 	msr	BASEPRI, r3
 800181e:	f3bf 8f6f 	isb	sy
 8001822:	f3bf 8f4f 	dsb	sy
 8001826:	e7fe      	b.n	8001826 <xQueueSemaphoreTake+0x22>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8001828:	f003 f8b8 	bl	800499c <xTaskGetSchedulerState>
 800182c:	4605      	mov	r5, r0
 800182e:	2800      	cmp	r0, #0
 8001830:	d054      	beq.n	80018dc <xQueueSemaphoreTake+0xd8>
 8001832:	463d      	mov	r5, r7
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001834:	f104 0624 	add.w	r6, r4, #36	; 0x24
        taskENTER_CRITICAL();
 8001838:	f008 f9de 	bl	8009bf8 <vPortEnterCritical>
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 800183c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 800183e:	2b00      	cmp	r3, #0
 8001840:	f040 8149 	bne.w	8001ad6 <xQueueSemaphoreTake+0x2d2>
                if( xTicksToWait == ( TickType_t ) 0 )
 8001844:	9b01      	ldr	r3, [sp, #4]
 8001846:	2b00      	cmp	r3, #0
 8001848:	f000 813a 	beq.w	8001ac0 <xQueueSemaphoreTake+0x2bc>
                else if( xEntryTimeSet == pdFALSE )
 800184c:	2d00      	cmp	r5, #0
 800184e:	f000 809d 	beq.w	800198c <xQueueSemaphoreTake+0x188>
        taskEXIT_CRITICAL();
 8001852:	f008 f9e7 	bl	8009c24 <vPortExitCritical>
        vTaskSuspendAll();
 8001856:	f001 fe83 	bl	8003560 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 800185a:	f008 f9cd 	bl	8009bf8 <vPortEnterCritical>
 800185e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8001862:	2bff      	cmp	r3, #255	; 0xff
 8001864:	d102      	bne.n	800186c <xQueueSemaphoreTake+0x68>
 8001866:	2300      	movs	r3, #0
 8001868:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 800186c:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8001870:	2bff      	cmp	r3, #255	; 0xff
 8001872:	d102      	bne.n	800187a <xQueueSemaphoreTake+0x76>
 8001874:	2300      	movs	r3, #0
 8001876:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800187a:	f008 f9d3 	bl	8009c24 <vPortExitCritical>
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800187e:	a901      	add	r1, sp, #4
 8001880:	a802      	add	r0, sp, #8
 8001882:	f002 fa0b 	bl	8003c9c <xTaskCheckForTimeOut>
 8001886:	2800      	cmp	r0, #0
 8001888:	d135      	bne.n	80018f6 <xQueueSemaphoreTake+0xf2>
    taskENTER_CRITICAL();
 800188a:	f008 f9b5 	bl	8009bf8 <vPortEnterCritical>
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 800188e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001890:	2b00      	cmp	r3, #0
 8001892:	f000 80a4 	beq.w	80019de <xQueueSemaphoreTake+0x1da>
    taskEXIT_CRITICAL();
 8001896:	f008 f9c5 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 800189a:	f008 f9ad 	bl	8009bf8 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 800189e:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80018a2:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 80018a4:	2d00      	cmp	r5, #0
 80018a6:	dc05      	bgt.n	80018b4 <xQueueSemaphoreTake+0xb0>
 80018a8:	e074      	b.n	8001994 <xQueueSemaphoreTake+0x190>
            --cTxLock;
 80018aa:	1e6b      	subs	r3, r5, #1
 80018ac:	b2da      	uxtb	r2, r3
 80018ae:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 80018b0:	2a00      	cmp	r2, #0
 80018b2:	d06f      	beq.n	8001994 <xQueueSemaphoreTake+0x190>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80018b4:	6a63      	ldr	r3, [r4, #36]	; 0x24
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80018b6:	4630      	mov	r0, r6
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80018b8:	2b00      	cmp	r3, #0
 80018ba:	d06b      	beq.n	8001994 <xQueueSemaphoreTake+0x190>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80018bc:	f002 fe98 	bl	80045f0 <xTaskRemoveFromEventList>
 80018c0:	2800      	cmp	r0, #0
 80018c2:	d0f2      	beq.n	80018aa <xQueueSemaphoreTake+0xa6>
                            vTaskMissedYield();
 80018c4:	f003 f862 	bl	800498c <vTaskMissedYield>
 80018c8:	e7ef      	b.n	80018aa <xQueueSemaphoreTake+0xa6>
 80018ca:	f04f 0350 	mov.w	r3, #80	; 0x50
 80018ce:	f383 8811 	msr	BASEPRI, r3
 80018d2:	f3bf 8f6f 	isb	sy
 80018d6:	f3bf 8f4f 	dsb	sy
    configASSERT( ( pxQueue ) );
 80018da:	e7fe      	b.n	80018da <xQueueSemaphoreTake+0xd6>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80018dc:	9b01      	ldr	r3, [sp, #4]
 80018de:	2b00      	cmp	r3, #0
 80018e0:	f000 80d4 	beq.w	8001a8c <xQueueSemaphoreTake+0x288>
 80018e4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80018e8:	f383 8811 	msr	BASEPRI, r3
 80018ec:	f3bf 8f6f 	isb	sy
 80018f0:	f3bf 8f4f 	dsb	sy
 80018f4:	e7fe      	b.n	80018f4 <xQueueSemaphoreTake+0xf0>
    taskENTER_CRITICAL();
 80018f6:	f008 f97f 	bl	8009bf8 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 80018fa:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80018fe:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8001900:	2d00      	cmp	r5, #0
 8001902:	dc04      	bgt.n	800190e <xQueueSemaphoreTake+0x10a>
 8001904:	e011      	b.n	800192a <xQueueSemaphoreTake+0x126>
            --cTxLock;
 8001906:	1e6b      	subs	r3, r5, #1
 8001908:	b2da      	uxtb	r2, r3
 800190a:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 800190c:	b16a      	cbz	r2, 800192a <xQueueSemaphoreTake+0x126>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800190e:	6a63      	ldr	r3, [r4, #36]	; 0x24
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001910:	4630      	mov	r0, r6
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001912:	b153      	cbz	r3, 800192a <xQueueSemaphoreTake+0x126>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001914:	f002 fe6c 	bl	80045f0 <xTaskRemoveFromEventList>
 8001918:	2800      	cmp	r0, #0
 800191a:	d0f4      	beq.n	8001906 <xQueueSemaphoreTake+0x102>
                            vTaskMissedYield();
 800191c:	f003 f836 	bl	800498c <vTaskMissedYield>
            --cTxLock;
 8001920:	1e6b      	subs	r3, r5, #1
 8001922:	b2da      	uxtb	r2, r3
 8001924:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8001926:	2a00      	cmp	r2, #0
 8001928:	d1f1      	bne.n	800190e <xQueueSemaphoreTake+0x10a>
        pxQueue->cTxLock = queueUNLOCKED;
 800192a:	23ff      	movs	r3, #255	; 0xff
 800192c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    taskEXIT_CRITICAL();
 8001930:	f008 f978 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 8001934:	f008 f960 	bl	8009bf8 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8001938:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800193c:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 800193e:	2d00      	cmp	r5, #0
 8001940:	dd14      	ble.n	800196c <xQueueSemaphoreTake+0x168>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001942:	f104 0810 	add.w	r8, r4, #16
 8001946:	e003      	b.n	8001950 <xQueueSemaphoreTake+0x14c>
                --cRxLock;
 8001948:	1e6b      	subs	r3, r5, #1
 800194a:	b2da      	uxtb	r2, r3
 800194c:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 800194e:	b16a      	cbz	r2, 800196c <xQueueSemaphoreTake+0x168>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001950:	6923      	ldr	r3, [r4, #16]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001952:	4640      	mov	r0, r8
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001954:	b153      	cbz	r3, 800196c <xQueueSemaphoreTake+0x168>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001956:	f002 fe4b 	bl	80045f0 <xTaskRemoveFromEventList>
 800195a:	2800      	cmp	r0, #0
 800195c:	d0f4      	beq.n	8001948 <xQueueSemaphoreTake+0x144>
                    vTaskMissedYield();
 800195e:	f003 f815 	bl	800498c <vTaskMissedYield>
                --cRxLock;
 8001962:	1e6b      	subs	r3, r5, #1
 8001964:	b2da      	uxtb	r2, r3
 8001966:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8001968:	2a00      	cmp	r2, #0
 800196a:	d1f1      	bne.n	8001950 <xQueueSemaphoreTake+0x14c>
        pxQueue->cRxLock = queueUNLOCKED;
 800196c:	23ff      	movs	r3, #255	; 0xff
 800196e:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    taskEXIT_CRITICAL();
 8001972:	f008 f957 	bl	8009c24 <vPortExitCritical>
            ( void ) xTaskResumeAll();
 8001976:	f002 fa91 	bl	8003e9c <xTaskResumeAll>
    taskENTER_CRITICAL();
 800197a:	f008 f93d 	bl	8009bf8 <vPortEnterCritical>
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 800197e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001980:	2b00      	cmp	r3, #0
 8001982:	d07c      	beq.n	8001a7e <xQueueSemaphoreTake+0x27a>
    taskEXIT_CRITICAL();
 8001984:	f008 f94e 	bl	8009c24 <vPortExitCritical>
    return xReturn;
 8001988:	2501      	movs	r5, #1
 800198a:	e755      	b.n	8001838 <xQueueSemaphoreTake+0x34>
                    vTaskInternalSetTimeOutState( &xTimeOut );
 800198c:	a802      	add	r0, sp, #8
 800198e:	f003 f941 	bl	8004c14 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 8001992:	e75e      	b.n	8001852 <xQueueSemaphoreTake+0x4e>
        pxQueue->cTxLock = queueUNLOCKED;
 8001994:	23ff      	movs	r3, #255	; 0xff
 8001996:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    taskEXIT_CRITICAL();
 800199a:	f008 f943 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 800199e:	f008 f92b 	bl	8009bf8 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 80019a2:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80019a6:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80019a8:	2d00      	cmp	r5, #0
 80019aa:	dd10      	ble.n	80019ce <xQueueSemaphoreTake+0x1ca>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80019ac:	f104 0810 	add.w	r8, r4, #16
 80019b0:	e003      	b.n	80019ba <xQueueSemaphoreTake+0x1b6>
                --cRxLock;
 80019b2:	1e6b      	subs	r3, r5, #1
 80019b4:	b2da      	uxtb	r2, r3
 80019b6:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 80019b8:	b14a      	cbz	r2, 80019ce <xQueueSemaphoreTake+0x1ca>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80019ba:	6923      	ldr	r3, [r4, #16]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80019bc:	4640      	mov	r0, r8
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80019be:	b133      	cbz	r3, 80019ce <xQueueSemaphoreTake+0x1ca>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80019c0:	f002 fe16 	bl	80045f0 <xTaskRemoveFromEventList>
 80019c4:	2800      	cmp	r0, #0
 80019c6:	d0f4      	beq.n	80019b2 <xQueueSemaphoreTake+0x1ae>
                    vTaskMissedYield();
 80019c8:	f002 ffe0 	bl	800498c <vTaskMissedYield>
 80019cc:	e7f1      	b.n	80019b2 <xQueueSemaphoreTake+0x1ae>
        pxQueue->cRxLock = queueUNLOCKED;
 80019ce:	23ff      	movs	r3, #255	; 0xff
 80019d0:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    taskEXIT_CRITICAL();
 80019d4:	f008 f926 	bl	8009c24 <vPortExitCritical>
                ( void ) xTaskResumeAll();
 80019d8:	f002 fa60 	bl	8003e9c <xTaskResumeAll>
 80019dc:	e7d4      	b.n	8001988 <xQueueSemaphoreTake+0x184>
    taskEXIT_CRITICAL();
 80019de:	f008 f921 	bl	8009c24 <vPortExitCritical>
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80019e2:	6823      	ldr	r3, [r4, #0]
 80019e4:	2b00      	cmp	r3, #0
 80019e6:	d062      	beq.n	8001aae <xQueueSemaphoreTake+0x2aa>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80019e8:	9901      	ldr	r1, [sp, #4]
 80019ea:	4630      	mov	r0, r6
 80019ec:	f002 fd1a 	bl	8004424 <vTaskPlaceOnEventList>
    taskENTER_CRITICAL();
 80019f0:	f008 f902 	bl	8009bf8 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 80019f4:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80019f8:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 80019fa:	2d00      	cmp	r5, #0
 80019fc:	dc04      	bgt.n	8001a08 <xQueueSemaphoreTake+0x204>
 80019fe:	e00d      	b.n	8001a1c <xQueueSemaphoreTake+0x218>
            --cTxLock;
 8001a00:	1e6b      	subs	r3, r5, #1
 8001a02:	b2da      	uxtb	r2, r3
 8001a04:	b25d      	sxtb	r5, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8001a06:	b14a      	cbz	r2, 8001a1c <xQueueSemaphoreTake+0x218>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001a08:	6a63      	ldr	r3, [r4, #36]	; 0x24
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001a0a:	4630      	mov	r0, r6
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001a0c:	b133      	cbz	r3, 8001a1c <xQueueSemaphoreTake+0x218>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001a0e:	f002 fdef 	bl	80045f0 <xTaskRemoveFromEventList>
 8001a12:	2800      	cmp	r0, #0
 8001a14:	d0f4      	beq.n	8001a00 <xQueueSemaphoreTake+0x1fc>
                            vTaskMissedYield();
 8001a16:	f002 ffb9 	bl	800498c <vTaskMissedYield>
 8001a1a:	e7f1      	b.n	8001a00 <xQueueSemaphoreTake+0x1fc>
        pxQueue->cTxLock = queueUNLOCKED;
 8001a1c:	23ff      	movs	r3, #255	; 0xff
 8001a1e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    taskEXIT_CRITICAL();
 8001a22:	f008 f8ff 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 8001a26:	f008 f8e7 	bl	8009bf8 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8001a2a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8001a2e:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8001a30:	2d00      	cmp	r5, #0
 8001a32:	dd10      	ble.n	8001a56 <xQueueSemaphoreTake+0x252>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001a34:	f104 0810 	add.w	r8, r4, #16
 8001a38:	e003      	b.n	8001a42 <xQueueSemaphoreTake+0x23e>
                --cRxLock;
 8001a3a:	1e6b      	subs	r3, r5, #1
 8001a3c:	b2da      	uxtb	r2, r3
 8001a3e:	b25d      	sxtb	r5, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8001a40:	b14a      	cbz	r2, 8001a56 <xQueueSemaphoreTake+0x252>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001a42:	6923      	ldr	r3, [r4, #16]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001a44:	4640      	mov	r0, r8
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001a46:	b133      	cbz	r3, 8001a56 <xQueueSemaphoreTake+0x252>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001a48:	f002 fdd2 	bl	80045f0 <xTaskRemoveFromEventList>
 8001a4c:	2800      	cmp	r0, #0
 8001a4e:	d0f4      	beq.n	8001a3a <xQueueSemaphoreTake+0x236>
                    vTaskMissedYield();
 8001a50:	f002 ff9c 	bl	800498c <vTaskMissedYield>
 8001a54:	e7f1      	b.n	8001a3a <xQueueSemaphoreTake+0x236>
        pxQueue->cRxLock = queueUNLOCKED;
 8001a56:	23ff      	movs	r3, #255	; 0xff
 8001a58:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
    taskEXIT_CRITICAL();
 8001a5c:	f008 f8e2 	bl	8009c24 <vPortExitCritical>
                if( xTaskResumeAll() == pdFALSE )
 8001a60:	f002 fa1c 	bl	8003e9c <xTaskResumeAll>
 8001a64:	2800      	cmp	r0, #0
 8001a66:	d18f      	bne.n	8001988 <xQueueSemaphoreTake+0x184>
                    portYIELD_WITHIN_API();
 8001a68:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8001a6c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001a70:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8001a74:	f3bf 8f4f 	dsb	sy
 8001a78:	f3bf 8f6f 	isb	sy
 8001a7c:	e784      	b.n	8001988 <xQueueSemaphoreTake+0x184>
    taskEXIT_CRITICAL();
 8001a7e:	f008 f8d1 	bl	8009c24 <vPortExitCritical>
                        if( xInheritanceOccurred != pdFALSE )
 8001a82:	b92f      	cbnz	r7, 8001a90 <xQueueSemaphoreTake+0x28c>
}
 8001a84:	4638      	mov	r0, r7
 8001a86:	b004      	add	sp, #16
 8001a88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001a8c:	4607      	mov	r7, r0
 8001a8e:	e6d1      	b.n	8001834 <xQueueSemaphoreTake+0x30>
                            taskENTER_CRITICAL();
 8001a90:	f008 f8b2 	bl	8009bf8 <vPortEnterCritical>
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 8001a94:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8001a96:	b119      	cbz	r1, 8001aa0 <xQueueSemaphoreTake+0x29c>
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 8001a98:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001a9a:	6819      	ldr	r1, [r3, #0]
 8001a9c:	f1c1 0138 	rsb	r1, r1, #56	; 0x38
                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 8001aa0:	68a0      	ldr	r0, [r4, #8]
                return errQUEUE_EMPTY;
 8001aa2:	2700      	movs	r7, #0
                                vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 8001aa4:	f003 f83c 	bl	8004b20 <vTaskPriorityDisinheritAfterTimeout>
                            taskEXIT_CRITICAL();
 8001aa8:	f008 f8bc 	bl	8009c24 <vPortExitCritical>
 8001aac:	e7ea      	b.n	8001a84 <xQueueSemaphoreTake+0x280>
                            taskENTER_CRITICAL();
 8001aae:	f008 f8a3 	bl	8009bf8 <vPortEnterCritical>
                                xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 8001ab2:	68a0      	ldr	r0, [r4, #8]
 8001ab4:	f002 ff82 	bl	80049bc <xTaskPriorityInherit>
 8001ab8:	4607      	mov	r7, r0
                            taskEXIT_CRITICAL();
 8001aba:	f008 f8b3 	bl	8009c24 <vPortExitCritical>
 8001abe:	e793      	b.n	80019e8 <xQueueSemaphoreTake+0x1e4>
                            configASSERT( xInheritanceOccurred == pdFALSE );
 8001ac0:	2f00      	cmp	r7, #0
 8001ac2:	d0f1      	beq.n	8001aa8 <xQueueSemaphoreTake+0x2a4>
 8001ac4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001ac8:	f383 8811 	msr	BASEPRI, r3
 8001acc:	f3bf 8f6f 	isb	sy
 8001ad0:	f3bf 8f4f 	dsb	sy
 8001ad4:	e7fe      	b.n	8001ad4 <xQueueSemaphoreTake+0x2d0>
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 8001ad6:	3b01      	subs	r3, #1
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8001ad8:	6822      	ldr	r2, [r4, #0]
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 8001ada:	63a3      	str	r3, [r4, #56]	; 0x38
                        if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8001adc:	b12a      	cbz	r2, 8001aea <xQueueSemaphoreTake+0x2e6>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001ade:	6923      	ldr	r3, [r4, #16]
 8001ae0:	b93b      	cbnz	r3, 8001af2 <xQueueSemaphoreTake+0x2ee>
                return pdPASS;
 8001ae2:	2701      	movs	r7, #1
                taskEXIT_CRITICAL();
 8001ae4:	f008 f89e 	bl	8009c24 <vPortExitCritical>
                return pdPASS;
 8001ae8:	e7cc      	b.n	8001a84 <xQueueSemaphoreTake+0x280>
                            pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 8001aea:	f003 f885 	bl	8004bf8 <pvTaskIncrementMutexHeldCount>
 8001aee:	60a0      	str	r0, [r4, #8]
 8001af0:	e7f5      	b.n	8001ade <xQueueSemaphoreTake+0x2da>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001af2:	f104 0010 	add.w	r0, r4, #16
 8001af6:	f002 fd7b 	bl	80045f0 <xTaskRemoveFromEventList>
 8001afa:	2800      	cmp	r0, #0
 8001afc:	d0f1      	beq.n	8001ae2 <xQueueSemaphoreTake+0x2de>
                        queueYIELD_IF_USING_PREEMPTION();
 8001afe:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8001b02:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001b06:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8001b0a:	f3bf 8f4f 	dsb	sy
 8001b0e:	f3bf 8f6f 	isb	sy
 8001b12:	e7e6      	b.n	8001ae2 <xQueueSemaphoreTake+0x2de>

08001b14 <xQueueGetMutexHolder>:
        configASSERT( xSemaphore );
 8001b14:	b178      	cbz	r0, 8001b36 <xQueueGetMutexHolder+0x22>
    {
 8001b16:	b510      	push	{r4, lr}
 8001b18:	4604      	mov	r4, r0
 8001b1a:	b082      	sub	sp, #8
        taskENTER_CRITICAL();
 8001b1c:	f008 f86c 	bl	8009bf8 <vPortEnterCritical>
            if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 8001b20:	6823      	ldr	r3, [r4, #0]
 8001b22:	b933      	cbnz	r3, 8001b32 <xQueueGetMutexHolder+0x1e>
                pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 8001b24:	68a0      	ldr	r0, [r4, #8]
 8001b26:	9001      	str	r0, [sp, #4]
        taskEXIT_CRITICAL();
 8001b28:	f008 f87c 	bl	8009c24 <vPortExitCritical>
    } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 8001b2c:	9801      	ldr	r0, [sp, #4]
 8001b2e:	b002      	add	sp, #8
 8001b30:	bd10      	pop	{r4, pc}
                pxReturn = NULL;
 8001b32:	2000      	movs	r0, #0
 8001b34:	e7f7      	b.n	8001b26 <xQueueGetMutexHolder+0x12>
 8001b36:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001b3a:	f383 8811 	msr	BASEPRI, r3
 8001b3e:	f3bf 8f6f 	isb	sy
 8001b42:	f3bf 8f4f 	dsb	sy
        configASSERT( xSemaphore );
 8001b46:	e7fe      	b.n	8001b46 <xQueueGetMutexHolder+0x32>

08001b48 <xQueueGetMutexHolderFromISR>:
        configASSERT( xSemaphore );
 8001b48:	b128      	cbz	r0, 8001b56 <xQueueGetMutexHolderFromISR+0xe>
        if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 8001b4a:	6803      	ldr	r3, [r0, #0]
 8001b4c:	b90b      	cbnz	r3, 8001b52 <xQueueGetMutexHolderFromISR+0xa>
            pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 8001b4e:	6880      	ldr	r0, [r0, #8]
 8001b50:	4770      	bx	lr
            pxReturn = NULL;
 8001b52:	2000      	movs	r0, #0
    } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 8001b54:	4770      	bx	lr
 8001b56:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001b5a:	f383 8811 	msr	BASEPRI, r3
 8001b5e:	f3bf 8f6f 	isb	sy
 8001b62:	f3bf 8f4f 	dsb	sy
        configASSERT( xSemaphore );
 8001b66:	e7fe      	b.n	8001b66 <xQueueGetMutexHolderFromISR+0x1e>

08001b68 <xQueueTakeMutexRecursive>:
        configASSERT( pxMutex );
 8001b68:	b1a8      	cbz	r0, 8001b96 <xQueueTakeMutexRecursive+0x2e>
    {
 8001b6a:	b570      	push	{r4, r5, r6, lr}
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 8001b6c:	6886      	ldr	r6, [r0, #8]
 8001b6e:	4604      	mov	r4, r0
 8001b70:	460d      	mov	r5, r1
 8001b72:	f002 ff05 	bl	8004980 <xTaskGetCurrentTaskHandle>
 8001b76:	4286      	cmp	r6, r0
 8001b78:	d008      	beq.n	8001b8c <xQueueTakeMutexRecursive+0x24>
            xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 8001b7a:	4629      	mov	r1, r5
 8001b7c:	4620      	mov	r0, r4
 8001b7e:	f7ff fe41 	bl	8001804 <xQueueSemaphoreTake>
            if( xReturn != pdFAIL )
 8001b82:	b110      	cbz	r0, 8001b8a <xQueueTakeMutexRecursive+0x22>
                ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 8001b84:	68e3      	ldr	r3, [r4, #12]
 8001b86:	3301      	adds	r3, #1
 8001b88:	60e3      	str	r3, [r4, #12]
    }
 8001b8a:	bd70      	pop	{r4, r5, r6, pc}
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 8001b8c:	68e3      	ldr	r3, [r4, #12]
            xReturn = pdPASS;
 8001b8e:	2001      	movs	r0, #1
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 8001b90:	4403      	add	r3, r0
 8001b92:	60e3      	str	r3, [r4, #12]
    }
 8001b94:	bd70      	pop	{r4, r5, r6, pc}
 8001b96:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001b9a:	f383 8811 	msr	BASEPRI, r3
 8001b9e:	f3bf 8f6f 	isb	sy
 8001ba2:	f3bf 8f4f 	dsb	sy
        configASSERT( pxMutex );
 8001ba6:	e7fe      	b.n	8001ba6 <xQueueTakeMutexRecursive+0x3e>

08001ba8 <xQueueGiveMutexRecursive>:
    {
 8001ba8:	b538      	push	{r3, r4, r5, lr}
        configASSERT( pxMutex );
 8001baa:	b138      	cbz	r0, 8001bbc <xQueueGiveMutexRecursive+0x14>
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 8001bac:	6885      	ldr	r5, [r0, #8]
 8001bae:	4604      	mov	r4, r0
 8001bb0:	f002 fee6 	bl	8004980 <xTaskGetCurrentTaskHandle>
 8001bb4:	4285      	cmp	r5, r0
 8001bb6:	d00a      	beq.n	8001bce <xQueueGiveMutexRecursive+0x26>
            xReturn = pdFAIL;
 8001bb8:	2000      	movs	r0, #0
    }
 8001bba:	bd38      	pop	{r3, r4, r5, pc}
 8001bbc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001bc0:	f383 8811 	msr	BASEPRI, r3
 8001bc4:	f3bf 8f6f 	isb	sy
 8001bc8:	f3bf 8f4f 	dsb	sy
        configASSERT( pxMutex );
 8001bcc:	e7fe      	b.n	8001bcc <xQueueGiveMutexRecursive+0x24>
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 8001bce:	68e3      	ldr	r3, [r4, #12]
 8001bd0:	3b01      	subs	r3, #1
 8001bd2:	60e3      	str	r3, [r4, #12]
            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 8001bd4:	b10b      	cbz	r3, 8001bda <xQueueGiveMutexRecursive+0x32>
            xReturn = pdPASS;
 8001bd6:	2001      	movs	r0, #1
    }
 8001bd8:	bd38      	pop	{r3, r4, r5, pc}
                ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 8001bda:	461a      	mov	r2, r3
 8001bdc:	4619      	mov	r1, r3
 8001bde:	4620      	mov	r0, r4
 8001be0:	f7fe fe50 	bl	8000884 <xQueueGenericSend>
            xReturn = pdPASS;
 8001be4:	2001      	movs	r0, #1
    }
 8001be6:	bd38      	pop	{r3, r4, r5, pc}

08001be8 <vQueueAddToRegistry>:
        configASSERT( xQueue );
 8001be8:	b1a0      	cbz	r0, 8001c14 <vQueueAddToRegistry+0x2c>
        if( pcQueueName != NULL )
 8001bea:	b191      	cbz	r1, 8001c12 <vQueueAddToRegistry+0x2a>
    {
 8001bec:	b430      	push	{r4, r5}
        QueueRegistryItem_t * pxEntryToWrite = NULL;
 8001bee:	2400      	movs	r4, #0
 8001bf0:	4d47      	ldr	r5, [pc, #284]	; (8001d10 <vQueueAddToRegistry+0x128>)
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001bf2:	4623      	mov	r3, r4
                if( xQueue == xQueueRegistry[ ux ].xHandle )
 8001bf4:	eb05 02c3 	add.w	r2, r5, r3, lsl #3
 8001bf8:	ea4f 0cc3 	mov.w	ip, r3, lsl #3
 8001bfc:	6852      	ldr	r2, [r2, #4]
 8001bfe:	4282      	cmp	r2, r0
 8001c00:	d07a      	beq.n	8001cf8 <vQueueAddToRegistry+0x110>
                else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL ) )
 8001c02:	b184      	cbz	r4, 8001c26 <vQueueAddToRegistry+0x3e>
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001c04:	3301      	adds	r3, #1
 8001c06:	2b08      	cmp	r3, #8
 8001c08:	d1f4      	bne.n	8001bf4 <vQueueAddToRegistry+0xc>
            pxEntryToWrite->xHandle = xQueue;
 8001c0a:	e9c4 1000 	strd	r1, r0, [r4]
    }
 8001c0e:	bc30      	pop	{r4, r5}
 8001c10:	4770      	bx	lr
 8001c12:	4770      	bx	lr
 8001c14:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001c18:	f383 8811 	msr	BASEPRI, r3
 8001c1c:	f3bf 8f6f 	isb	sy
 8001c20:	f3bf 8f4f 	dsb	sy
        configASSERT( xQueue );
 8001c24:	e7fe      	b.n	8001c24 <vQueueAddToRegistry+0x3c>
                else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL ) )
 8001c26:	f855 2033 	ldr.w	r2, [r5, r3, lsl #3]
 8001c2a:	2a00      	cmp	r2, #0
 8001c2c:	d05f      	beq.n	8001cee <vQueueAddToRegistry+0x106>
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001c2e:	2b07      	cmp	r3, #7
 8001c30:	f103 0201 	add.w	r2, r3, #1
 8001c34:	d0eb      	beq.n	8001c0e <vQueueAddToRegistry+0x26>
                if( xQueue == xQueueRegistry[ ux ].xHandle )
 8001c36:	eb05 04c2 	add.w	r4, r5, r2, lsl #3
 8001c3a:	ea4f 0cc2 	mov.w	ip, r2, lsl #3
 8001c3e:	6864      	ldr	r4, [r4, #4]
 8001c40:	42a0      	cmp	r0, r4
 8001c42:	d059      	beq.n	8001cf8 <vQueueAddToRegistry+0x110>
                else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL ) )
 8001c44:	f855 4032 	ldr.w	r4, [r5, r2, lsl #3]
 8001c48:	2c00      	cmp	r4, #0
 8001c4a:	d058      	beq.n	8001cfe <vQueueAddToRegistry+0x116>
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001c4c:	2b06      	cmp	r3, #6
 8001c4e:	f103 0202 	add.w	r2, r3, #2
 8001c52:	d0dc      	beq.n	8001c0e <vQueueAddToRegistry+0x26>
                if( xQueue == xQueueRegistry[ ux ].xHandle )
 8001c54:	eb05 04c2 	add.w	r4, r5, r2, lsl #3
 8001c58:	ea4f 0cc2 	mov.w	ip, r2, lsl #3
 8001c5c:	6864      	ldr	r4, [r4, #4]
 8001c5e:	42a0      	cmp	r0, r4
 8001c60:	d04a      	beq.n	8001cf8 <vQueueAddToRegistry+0x110>
                else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL ) )
 8001c62:	f855 4032 	ldr.w	r4, [r5, r2, lsl #3]
 8001c66:	2c00      	cmp	r4, #0
 8001c68:	d049      	beq.n	8001cfe <vQueueAddToRegistry+0x116>
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001c6a:	2b05      	cmp	r3, #5
 8001c6c:	f103 0203 	add.w	r2, r3, #3
 8001c70:	d0cd      	beq.n	8001c0e <vQueueAddToRegistry+0x26>
                if( xQueue == xQueueRegistry[ ux ].xHandle )
 8001c72:	eb05 04c2 	add.w	r4, r5, r2, lsl #3
 8001c76:	ea4f 0cc2 	mov.w	ip, r2, lsl #3
 8001c7a:	6864      	ldr	r4, [r4, #4]
 8001c7c:	42a0      	cmp	r0, r4
 8001c7e:	d03b      	beq.n	8001cf8 <vQueueAddToRegistry+0x110>
                else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL ) )
 8001c80:	f855 4032 	ldr.w	r4, [r5, r2, lsl #3]
 8001c84:	2c00      	cmp	r4, #0
 8001c86:	d03a      	beq.n	8001cfe <vQueueAddToRegistry+0x116>
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001c88:	2b04      	cmp	r3, #4
 8001c8a:	f103 0204 	add.w	r2, r3, #4
 8001c8e:	d0be      	beq.n	8001c0e <vQueueAddToRegistry+0x26>
                if( xQueue == xQueueRegistry[ ux ].xHandle )
 8001c90:	eb05 04c2 	add.w	r4, r5, r2, lsl #3
 8001c94:	ea4f 0cc2 	mov.w	ip, r2, lsl #3
 8001c98:	6864      	ldr	r4, [r4, #4]
 8001c9a:	42a0      	cmp	r0, r4
 8001c9c:	d02c      	beq.n	8001cf8 <vQueueAddToRegistry+0x110>
                else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL ) )
 8001c9e:	f855 4032 	ldr.w	r4, [r5, r2, lsl #3]
 8001ca2:	b364      	cbz	r4, 8001cfe <vQueueAddToRegistry+0x116>
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001ca4:	2b03      	cmp	r3, #3
 8001ca6:	f103 0205 	add.w	r2, r3, #5
 8001caa:	d0b0      	beq.n	8001c0e <vQueueAddToRegistry+0x26>
                if( xQueue == xQueueRegistry[ ux ].xHandle )
 8001cac:	eb05 04c2 	add.w	r4, r5, r2, lsl #3
 8001cb0:	ea4f 0cc2 	mov.w	ip, r2, lsl #3
 8001cb4:	6864      	ldr	r4, [r4, #4]
 8001cb6:	42a0      	cmp	r0, r4
 8001cb8:	d01e      	beq.n	8001cf8 <vQueueAddToRegistry+0x110>
                else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL ) )
 8001cba:	f855 4032 	ldr.w	r4, [r5, r2, lsl #3]
 8001cbe:	b1f4      	cbz	r4, 8001cfe <vQueueAddToRegistry+0x116>
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001cc0:	2b02      	cmp	r3, #2
 8001cc2:	f103 0c06 	add.w	ip, r3, #6
 8001cc6:	d0a2      	beq.n	8001c0e <vQueueAddToRegistry+0x26>
                if( xQueue == xQueueRegistry[ ux ].xHandle )
 8001cc8:	eb05 02cc 	add.w	r2, r5, ip, lsl #3
 8001ccc:	6852      	ldr	r2, [r2, #4]
 8001cce:	4290      	cmp	r0, r2
 8001cd0:	d010      	beq.n	8001cf4 <vQueueAddToRegistry+0x10c>
                else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL ) )
 8001cd2:	f855 203c 	ldr.w	r2, [r5, ip, lsl #3]
 8001cd6:	b1a2      	cbz	r2, 8001d02 <vQueueAddToRegistry+0x11a>
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001cd8:	2b01      	cmp	r3, #1
 8001cda:	d098      	beq.n	8001c0e <vQueueAddToRegistry+0x26>
                if( xQueue == xQueueRegistry[ ux ].xHandle )
 8001cdc:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8001cde:	4298      	cmp	r0, r3
 8001ce0:	d013      	beq.n	8001d0a <vQueueAddToRegistry+0x122>
                else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL ) )
 8001ce2:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8001ce4:	2b00      	cmp	r3, #0
 8001ce6:	d192      	bne.n	8001c0e <vQueueAddToRegistry+0x26>
 8001ce8:	2307      	movs	r3, #7
 8001cea:	f04f 0c38 	mov.w	ip, #56	; 0x38
                    pxEntryToWrite = &( xQueueRegistry[ ux ] );
 8001cee:	eb05 040c 	add.w	r4, r5, ip
 8001cf2:	e787      	b.n	8001c04 <vQueueAddToRegistry+0x1c>
 8001cf4:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
                    pxEntryToWrite = &( xQueueRegistry[ ux ] );
 8001cf8:	eb05 040c 	add.w	r4, r5, ip
        if( pxEntryToWrite != NULL )
 8001cfc:	e785      	b.n	8001c0a <vQueueAddToRegistry+0x22>
                else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL ) )
 8001cfe:	4613      	mov	r3, r2
 8001d00:	e7f5      	b.n	8001cee <vQueueAddToRegistry+0x106>
 8001d02:	4663      	mov	r3, ip
 8001d04:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8001d08:	e7f1      	b.n	8001cee <vQueueAddToRegistry+0x106>
 8001d0a:	f04f 0c38 	mov.w	ip, #56	; 0x38
 8001d0e:	e7f3      	b.n	8001cf8 <vQueueAddToRegistry+0x110>
 8001d10:	24000000 	.word	0x24000000

08001d14 <vQueueUnregisterQueue>:
        configASSERT( xQueue );
 8001d14:	b1c8      	cbz	r0, 8001d4a <vQueueUnregisterQueue+0x36>
            if( xQueueRegistry[ ux ].xHandle == xQueue )
 8001d16:	4b1c      	ldr	r3, [pc, #112]	; (8001d88 <vQueueUnregisterQueue+0x74>)
 8001d18:	685a      	ldr	r2, [r3, #4]
 8001d1a:	4290      	cmp	r0, r2
 8001d1c:	d026      	beq.n	8001d6c <vQueueUnregisterQueue+0x58>
 8001d1e:	68da      	ldr	r2, [r3, #12]
 8001d20:	4290      	cmp	r0, r2
 8001d22:	d025      	beq.n	8001d70 <vQueueUnregisterQueue+0x5c>
 8001d24:	695a      	ldr	r2, [r3, #20]
 8001d26:	4290      	cmp	r0, r2
 8001d28:	d024      	beq.n	8001d74 <vQueueUnregisterQueue+0x60>
 8001d2a:	69da      	ldr	r2, [r3, #28]
 8001d2c:	4290      	cmp	r0, r2
 8001d2e:	d023      	beq.n	8001d78 <vQueueUnregisterQueue+0x64>
 8001d30:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001d32:	4290      	cmp	r0, r2
 8001d34:	d022      	beq.n	8001d7c <vQueueUnregisterQueue+0x68>
 8001d36:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001d38:	4290      	cmp	r0, r2
 8001d3a:	d00f      	beq.n	8001d5c <vQueueUnregisterQueue+0x48>
 8001d3c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001d3e:	4290      	cmp	r0, r2
 8001d40:	d01e      	beq.n	8001d80 <vQueueUnregisterQueue+0x6c>
 8001d42:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001d44:	4282      	cmp	r2, r0
 8001d46:	d01d      	beq.n	8001d84 <vQueueUnregisterQueue+0x70>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 8001d48:	4770      	bx	lr
 8001d4a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001d4e:	f383 8811 	msr	BASEPRI, r3
 8001d52:	f3bf 8f6f 	isb	sy
 8001d56:	f3bf 8f4f 	dsb	sy
        configASSERT( xQueue );
 8001d5a:	e7fe      	b.n	8001d5a <vQueueUnregisterQueue+0x46>
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001d5c:	2205      	movs	r2, #5
                xQueueRegistry[ ux ].pcQueueName = NULL;
 8001d5e:	2100      	movs	r1, #0
                xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 8001d60:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
                xQueueRegistry[ ux ].pcQueueName = NULL;
 8001d64:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
                xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 8001d68:	6041      	str	r1, [r0, #4]
    } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 8001d6a:	4770      	bx	lr
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001d6c:	2200      	movs	r2, #0
 8001d6e:	e7f6      	b.n	8001d5e <vQueueUnregisterQueue+0x4a>
 8001d70:	2201      	movs	r2, #1
 8001d72:	e7f4      	b.n	8001d5e <vQueueUnregisterQueue+0x4a>
 8001d74:	2202      	movs	r2, #2
 8001d76:	e7f2      	b.n	8001d5e <vQueueUnregisterQueue+0x4a>
 8001d78:	2203      	movs	r2, #3
 8001d7a:	e7f0      	b.n	8001d5e <vQueueUnregisterQueue+0x4a>
 8001d7c:	2204      	movs	r2, #4
 8001d7e:	e7ee      	b.n	8001d5e <vQueueUnregisterQueue+0x4a>
 8001d80:	2206      	movs	r2, #6
 8001d82:	e7ec      	b.n	8001d5e <vQueueUnregisterQueue+0x4a>
 8001d84:	2207      	movs	r2, #7
 8001d86:	e7ea      	b.n	8001d5e <vQueueUnregisterQueue+0x4a>
 8001d88:	24000000 	.word	0x24000000

08001d8c <pcQueueGetName>:
        configASSERT( xQueue );
 8001d8c:	b1d0      	cbz	r0, 8001dc4 <pcQueueGetName+0x38>
            if( xQueueRegistry[ ux ].xHandle == xQueue )
 8001d8e:	4b1b      	ldr	r3, [pc, #108]	; (8001dfc <pcQueueGetName+0x70>)
 8001d90:	685a      	ldr	r2, [r3, #4]
 8001d92:	4290      	cmp	r0, r2
 8001d94:	d023      	beq.n	8001dde <pcQueueGetName+0x52>
 8001d96:	68da      	ldr	r2, [r3, #12]
 8001d98:	4290      	cmp	r0, r2
 8001d9a:	d022      	beq.n	8001de2 <pcQueueGetName+0x56>
 8001d9c:	695a      	ldr	r2, [r3, #20]
 8001d9e:	4290      	cmp	r0, r2
 8001da0:	d021      	beq.n	8001de6 <pcQueueGetName+0x5a>
 8001da2:	69da      	ldr	r2, [r3, #28]
 8001da4:	4290      	cmp	r0, r2
 8001da6:	d020      	beq.n	8001dea <pcQueueGetName+0x5e>
 8001da8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001daa:	4290      	cmp	r0, r2
 8001dac:	d01f      	beq.n	8001dee <pcQueueGetName+0x62>
 8001dae:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001db0:	4290      	cmp	r0, r2
 8001db2:	d010      	beq.n	8001dd6 <pcQueueGetName+0x4a>
 8001db4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001db6:	4290      	cmp	r0, r2
 8001db8:	d01b      	beq.n	8001df2 <pcQueueGetName+0x66>
 8001dba:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001dbc:	4282      	cmp	r2, r0
 8001dbe:	d01a      	beq.n	8001df6 <pcQueueGetName+0x6a>
        const char * pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
 8001dc0:	2000      	movs	r0, #0
    } /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
 8001dc2:	4770      	bx	lr
 8001dc4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001dc8:	f383 8811 	msr	BASEPRI, r3
 8001dcc:	f3bf 8f6f 	isb	sy
 8001dd0:	f3bf 8f4f 	dsb	sy
        configASSERT( xQueue );
 8001dd4:	e7fe      	b.n	8001dd4 <pcQueueGetName+0x48>
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001dd6:	2205      	movs	r2, #5
                pcReturn = xQueueRegistry[ ux ].pcQueueName;
 8001dd8:	f853 0032 	ldr.w	r0, [r3, r2, lsl #3]
                break;
 8001ddc:	4770      	bx	lr
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8001dde:	2200      	movs	r2, #0
 8001de0:	e7fa      	b.n	8001dd8 <pcQueueGetName+0x4c>
 8001de2:	2201      	movs	r2, #1
 8001de4:	e7f8      	b.n	8001dd8 <pcQueueGetName+0x4c>
 8001de6:	2202      	movs	r2, #2
 8001de8:	e7f6      	b.n	8001dd8 <pcQueueGetName+0x4c>
 8001dea:	2203      	movs	r2, #3
 8001dec:	e7f4      	b.n	8001dd8 <pcQueueGetName+0x4c>
 8001dee:	2204      	movs	r2, #4
 8001df0:	e7f2      	b.n	8001dd8 <pcQueueGetName+0x4c>
 8001df2:	2206      	movs	r2, #6
 8001df4:	e7f0      	b.n	8001dd8 <pcQueueGetName+0x4c>
 8001df6:	2207      	movs	r2, #7
 8001df8:	e7ee      	b.n	8001dd8 <pcQueueGetName+0x4c>
 8001dfa:	bf00      	nop
 8001dfc:	24000000 	.word	0x24000000

08001e00 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
 8001e00:	b570      	push	{r4, r5, r6, lr}
 8001e02:	4605      	mov	r5, r0
 8001e04:	460e      	mov	r6, r1
 8001e06:	4614      	mov	r4, r2
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
 8001e08:	f007 fef6 	bl	8009bf8 <vPortEnterCritical>
 8001e0c:	f895 3044 	ldrb.w	r3, [r5, #68]	; 0x44
 8001e10:	2bff      	cmp	r3, #255	; 0xff
 8001e12:	d102      	bne.n	8001e1a <vQueueWaitForMessageRestricted+0x1a>
 8001e14:	2300      	movs	r3, #0
 8001e16:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
 8001e1a:	f895 3045 	ldrb.w	r3, [r5, #69]	; 0x45
 8001e1e:	2bff      	cmp	r3, #255	; 0xff
 8001e20:	d102      	bne.n	8001e28 <vQueueWaitForMessageRestricted+0x28>
 8001e22:	2300      	movs	r3, #0
 8001e24:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
 8001e28:	f007 fefc 	bl	8009c24 <vPortExitCritical>

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 8001e2c:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8001e2e:	2b00      	cmp	r3, #0
 8001e30:	d043      	beq.n	8001eba <vQueueWaitForMessageRestricted+0xba>
    taskENTER_CRITICAL();
 8001e32:	f007 fee1 	bl	8009bf8 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 8001e36:	f895 3045 	ldrb.w	r3, [r5, #69]	; 0x45
 8001e3a:	b25c      	sxtb	r4, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8001e3c:	2c00      	cmp	r4, #0
 8001e3e:	dd14      	ble.n	8001e6a <vQueueWaitForMessageRestricted+0x6a>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001e40:	f105 0624 	add.w	r6, r5, #36	; 0x24
 8001e44:	e003      	b.n	8001e4e <vQueueWaitForMessageRestricted+0x4e>
            --cTxLock;
 8001e46:	1e63      	subs	r3, r4, #1
 8001e48:	b2da      	uxtb	r2, r3
 8001e4a:	b25c      	sxtb	r4, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8001e4c:	b16a      	cbz	r2, 8001e6a <vQueueWaitForMessageRestricted+0x6a>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001e4e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001e50:	4630      	mov	r0, r6
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001e52:	b153      	cbz	r3, 8001e6a <vQueueWaitForMessageRestricted+0x6a>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001e54:	f002 fbcc 	bl	80045f0 <xTaskRemoveFromEventList>
 8001e58:	2800      	cmp	r0, #0
 8001e5a:	d0f4      	beq.n	8001e46 <vQueueWaitForMessageRestricted+0x46>
                            vTaskMissedYield();
 8001e5c:	f002 fd96 	bl	800498c <vTaskMissedYield>
            --cTxLock;
 8001e60:	1e63      	subs	r3, r4, #1
 8001e62:	b2da      	uxtb	r2, r3
 8001e64:	b25c      	sxtb	r4, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8001e66:	2a00      	cmp	r2, #0
 8001e68:	d1f1      	bne.n	8001e4e <vQueueWaitForMessageRestricted+0x4e>
        pxQueue->cTxLock = queueUNLOCKED;
 8001e6a:	23ff      	movs	r3, #255	; 0xff
 8001e6c:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
    taskEXIT_CRITICAL();
 8001e70:	f007 fed8 	bl	8009c24 <vPortExitCritical>
    taskENTER_CRITICAL();
 8001e74:	f007 fec0 	bl	8009bf8 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8001e78:	f895 3044 	ldrb.w	r3, [r5, #68]	; 0x44
 8001e7c:	b25c      	sxtb	r4, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8001e7e:	2c00      	cmp	r4, #0
 8001e80:	dd14      	ble.n	8001eac <vQueueWaitForMessageRestricted+0xac>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001e82:	f105 0610 	add.w	r6, r5, #16
 8001e86:	e003      	b.n	8001e90 <vQueueWaitForMessageRestricted+0x90>
                --cRxLock;
 8001e88:	1e63      	subs	r3, r4, #1
 8001e8a:	b2da      	uxtb	r2, r3
 8001e8c:	b25c      	sxtb	r4, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8001e8e:	b16a      	cbz	r2, 8001eac <vQueueWaitForMessageRestricted+0xac>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001e90:	692b      	ldr	r3, [r5, #16]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001e92:	4630      	mov	r0, r6
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001e94:	b153      	cbz	r3, 8001eac <vQueueWaitForMessageRestricted+0xac>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001e96:	f002 fbab 	bl	80045f0 <xTaskRemoveFromEventList>
 8001e9a:	2800      	cmp	r0, #0
 8001e9c:	d0f4      	beq.n	8001e88 <vQueueWaitForMessageRestricted+0x88>
                    vTaskMissedYield();
 8001e9e:	f002 fd75 	bl	800498c <vTaskMissedYield>
                --cRxLock;
 8001ea2:	1e63      	subs	r3, r4, #1
 8001ea4:	b2da      	uxtb	r2, r3
 8001ea6:	b25c      	sxtb	r4, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 8001ea8:	2a00      	cmp	r2, #0
 8001eaa:	d1f1      	bne.n	8001e90 <vQueueWaitForMessageRestricted+0x90>
        pxQueue->cRxLock = queueUNLOCKED;
 8001eac:	23ff      	movs	r3, #255	; 0xff
 8001eae:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    }
 8001eb2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    taskEXIT_CRITICAL();
 8001eb6:	f007 beb5 	b.w	8009c24 <vPortExitCritical>
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 8001eba:	4622      	mov	r2, r4
 8001ebc:	4631      	mov	r1, r6
 8001ebe:	f105 0024 	add.w	r0, r5, #36	; 0x24
 8001ec2:	f002 fb33 	bl	800452c <vTaskPlaceOnEventListRestricted>
 8001ec6:	e7b4      	b.n	8001e32 <vQueueWaitForMessageRestricted+0x32>

08001ec8 <xQueueGenericReset>:
    configASSERT( pxQueue );
 8001ec8:	b358      	cbz	r0, 8001f22 <xQueueGenericReset+0x5a>
        ( pxQueue->uxLength >= 1U ) &&
 8001eca:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
{
 8001ecc:	b570      	push	{r4, r5, r6, lr}
 8001ece:	4604      	mov	r4, r0
    if( ( pxQueue != NULL ) &&
 8001ed0:	b1f3      	cbz	r3, 8001f10 <xQueueGenericReset+0x48>
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
 8001ed2:	6c05      	ldr	r5, [r0, #64]	; 0x40
 8001ed4:	fba5 3503 	umull	r3, r5, r5, r3
 8001ed8:	b9d5      	cbnz	r5, 8001f10 <xQueueGenericReset+0x48>
        taskENTER_CRITICAL();
 8001eda:	460e      	mov	r6, r1
 8001edc:	f007 fe8c 	bl	8009bf8 <vPortEnterCritical>
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001ee0:	6822      	ldr	r2, [r4, #0]
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8001ee2:	63a5      	str	r5, [r4, #56]	; 0x38
            pxQueue->pcWriteTo = pxQueue->pcHead;
 8001ee4:	6062      	str	r2, [r4, #4]
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001ee6:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	; 0x3c
 8001eea:	fb01 f303 	mul.w	r3, r1, r3
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001eee:	1a59      	subs	r1, r3, r1
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001ef0:	4413      	add	r3, r2
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001ef2:	440a      	add	r2, r1
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001ef4:	60a3      	str	r3, [r4, #8]
            pxQueue->cRxLock = queueUNLOCKED;
 8001ef6:	23ff      	movs	r3, #255	; 0xff
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001ef8:	60e2      	str	r2, [r4, #12]
            pxQueue->cRxLock = queueUNLOCKED;
 8001efa:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
            pxQueue->cTxLock = queueUNLOCKED;
 8001efe:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
            if( xNewQueue == pdFALSE )
 8001f02:	bb46      	cbnz	r6, 8001f56 <xQueueGenericReset+0x8e>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001f04:	6923      	ldr	r3, [r4, #16]
 8001f06:	b9ab      	cbnz	r3, 8001f34 <xQueueGenericReset+0x6c>
        taskEXIT_CRITICAL();
 8001f08:	f007 fe8c 	bl	8009c24 <vPortExitCritical>
}
 8001f0c:	2001      	movs	r0, #1
 8001f0e:	bd70      	pop	{r4, r5, r6, pc}
 8001f10:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001f14:	f383 8811 	msr	BASEPRI, r3
 8001f18:	f3bf 8f6f 	isb	sy
 8001f1c:	f3bf 8f4f 	dsb	sy
    configASSERT( xReturn != pdFAIL );
 8001f20:	e7fe      	b.n	8001f20 <xQueueGenericReset+0x58>
 8001f22:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001f26:	f383 8811 	msr	BASEPRI, r3
 8001f2a:	f3bf 8f6f 	isb	sy
 8001f2e:	f3bf 8f4f 	dsb	sy
    configASSERT( pxQueue );
 8001f32:	e7fe      	b.n	8001f32 <xQueueGenericReset+0x6a>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001f34:	f104 0010 	add.w	r0, r4, #16
 8001f38:	f002 fb5a 	bl	80045f0 <xTaskRemoveFromEventList>
 8001f3c:	2800      	cmp	r0, #0
 8001f3e:	d0e3      	beq.n	8001f08 <xQueueGenericReset+0x40>
                        queueYIELD_IF_USING_PREEMPTION();
 8001f40:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8001f44:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001f48:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8001f4c:	f3bf 8f4f 	dsb	sy
 8001f50:	f3bf 8f6f 	isb	sy
 8001f54:	e7d8      	b.n	8001f08 <xQueueGenericReset+0x40>
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8001f56:	f104 0010 	add.w	r0, r4, #16
 8001f5a:	f7fe fc05 	bl	8000768 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8001f5e:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8001f62:	f7fe fc01 	bl	8000768 <vListInitialise>
 8001f66:	e7cf      	b.n	8001f08 <xQueueGenericReset+0x40>

08001f68 <xQueueGenericCreate>:
    {
 8001f68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 8001f6c:	b148      	cbz	r0, 8001f82 <xQueueGenericCreate+0x1a>
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 8001f6e:	fba0 3701 	umull	r3, r7, r0, r1
 8001f72:	460d      	mov	r5, r1
 8001f74:	4604      	mov	r4, r0
 8001f76:	b927      	cbnz	r7, 8001f82 <xQueueGenericCreate+0x1a>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
 8001f78:	fb01 f000 	mul.w	r0, r1, r0
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 8001f7c:	f110 0f51 	cmn.w	r0, #81	; 0x51
 8001f80:	d908      	bls.n	8001f94 <xQueueGenericCreate+0x2c>
 8001f82:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001f86:	f383 8811 	msr	BASEPRI, r3
 8001f8a:	f3bf 8f6f 	isb	sy
 8001f8e:	f3bf 8f4f 	dsb	sy
            configASSERT( pxNewQueue );
 8001f92:	e7fe      	b.n	8001f92 <xQueueGenericCreate+0x2a>
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 8001f94:	3050      	adds	r0, #80	; 0x50
 8001f96:	4690      	mov	r8, r2
 8001f98:	f003 fce2 	bl	8005960 <pvPortMalloc>
            if( pxNewQueue != NULL )
 8001f9c:	4606      	mov	r6, r0
 8001f9e:	b168      	cbz	r0, 8001fbc <xQueueGenericCreate+0x54>
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
 8001fa0:	f880 7046 	strb.w	r7, [r0, #70]	; 0x46
    if( uxItemSize == ( UBaseType_t ) 0 )
 8001fa4:	b16d      	cbz	r5, 8001fc2 <xQueueGenericCreate+0x5a>
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8001fa6:	f100 0350 	add.w	r3, r0, #80	; 0x50
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8001faa:	2101      	movs	r1, #1
 8001fac:	4630      	mov	r0, r6
 8001fae:	6033      	str	r3, [r6, #0]
    pxNewQueue->uxItemSize = uxItemSize;
 8001fb0:	e9c6 450f 	strd	r4, r5, [r6, #60]	; 0x3c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8001fb4:	f7ff ff88 	bl	8001ec8 <xQueueGenericReset>
            pxNewQueue->ucQueueType = ucQueueType;
 8001fb8:	f886 804c 	strb.w	r8, [r6, #76]	; 0x4c
    }
 8001fbc:	4630      	mov	r0, r6
 8001fbe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001fc2:	4603      	mov	r3, r0
 8001fc4:	e7f1      	b.n	8001faa <xQueueGenericCreate+0x42>
 8001fc6:	bf00      	nop

08001fc8 <xQueueGenericCreateStatic>:
    {
 8001fc8:	b530      	push	{r4, r5, lr}
 8001fca:	b085      	sub	sp, #20
 8001fcc:	f89d 4020 	ldrb.w	r4, [sp, #32]
        configASSERT( pxStaticQueue );
 8001fd0:	b15b      	cbz	r3, 8001fea <xQueueGenericCreateStatic+0x22>
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 8001fd2:	b108      	cbz	r0, 8001fd8 <xQueueGenericCreateStatic+0x10>
            ( pxStaticQueue != NULL ) &&
 8001fd4:	b30a      	cbz	r2, 800201a <xQueueGenericCreateStatic+0x52>
 8001fd6:	b989      	cbnz	r1, 8001ffc <xQueueGenericCreateStatic+0x34>
 8001fd8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001fdc:	f383 8811 	msr	BASEPRI, r3
 8001fe0:	f3bf 8f6f 	isb	sy
 8001fe4:	f3bf 8f4f 	dsb	sy
            configASSERT( pxNewQueue );
 8001fe8:	e7fe      	b.n	8001fe8 <xQueueGenericCreateStatic+0x20>
 8001fea:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001fee:	f383 8811 	msr	BASEPRI, r3
 8001ff2:	f3bf 8f6f 	isb	sy
 8001ff6:	f3bf 8f4f 	dsb	sy
        configASSERT( pxStaticQueue );
 8001ffa:	e7fe      	b.n	8001ffa <xQueueGenericCreateStatic+0x32>
            ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) ) &&
 8001ffc:	b16a      	cbz	r2, 800201a <xQueueGenericCreateStatic+0x52>
                    volatile size_t xSize = sizeof( StaticQueue_t );
 8001ffe:	2550      	movs	r5, #80	; 0x50
 8002000:	9503      	str	r5, [sp, #12]
                    configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
 8002002:	9d03      	ldr	r5, [sp, #12]
 8002004:	2d50      	cmp	r5, #80	; 0x50
 8002006:	d00b      	beq.n	8002020 <xQueueGenericCreateStatic+0x58>
 8002008:	f04f 0350 	mov.w	r3, #80	; 0x50
 800200c:	f383 8811 	msr	BASEPRI, r3
 8002010:	f3bf 8f6f 	isb	sy
 8002014:	f3bf 8f4f 	dsb	sy
 8002018:	e7fe      	b.n	8002018 <xQueueGenericCreateStatic+0x50>
            ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) ) &&
 800201a:	2900      	cmp	r1, #0
 800201c:	d1dc      	bne.n	8001fd8 <xQueueGenericCreateStatic+0x10>
 800201e:	e7ee      	b.n	8001ffe <xQueueGenericCreateStatic+0x36>
                    ( void ) xSize;                             /* Keeps lint quiet when configASSERT() is not defined. */
 8002020:	2900      	cmp	r1, #0
 8002022:	bf08      	it	eq
 8002024:	461a      	moveq	r2, r3
    pxNewQueue->uxItemSize = uxItemSize;
 8002026:	6419      	str	r1, [r3, #64]	; 0x40
                    pxNewQueue->ucStaticallyAllocated = pdTRUE;
 8002028:	2101      	movs	r1, #1
    pxNewQueue->uxLength = uxQueueLength;
 800202a:	63d8      	str	r0, [r3, #60]	; 0x3c
 800202c:	601a      	str	r2, [r3, #0]
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800202e:	4618      	mov	r0, r3
                    pxNewQueue->ucStaticallyAllocated = pdTRUE;
 8002030:	f883 1046 	strb.w	r1, [r3, #70]	; 0x46
 8002034:	9301      	str	r3, [sp, #4]
                    ( void ) xSize;                             /* Keeps lint quiet when configASSERT() is not defined. */
 8002036:	9a03      	ldr	r2, [sp, #12]
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8002038:	f7ff ff46 	bl	8001ec8 <xQueueGenericReset>
            pxNewQueue->ucQueueType = ucQueueType;
 800203c:	9b01      	ldr	r3, [sp, #4]
    }
 800203e:	4618      	mov	r0, r3
            pxNewQueue->ucQueueType = ucQueueType;
 8002040:	f883 404c 	strb.w	r4, [r3, #76]	; 0x4c
    }
 8002044:	b005      	add	sp, #20
 8002046:	bd30      	pop	{r4, r5, pc}

08002048 <vQueueSetQueueNumber>:
        ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 8002048:	6481      	str	r1, [r0, #72]	; 0x48
    }
 800204a:	4770      	bx	lr

0800204c <uxQueueGetQueueNumber>:
    }
 800204c:	6c80      	ldr	r0, [r0, #72]	; 0x48
 800204e:	4770      	bx	lr

08002050 <ucQueueGetQueueType>:
    }
 8002050:	f890 004c 	ldrb.w	r0, [r0, #76]	; 0x4c
 8002054:	4770      	bx	lr
 8002056:	bf00      	nop

08002058 <prvWriteBytesToBuffer>:
                                     size_t xCount,
                                     size_t xHead )
{
    size_t xFirstLength;

    configASSERT( xCount > ( size_t ) 0 );
 8002058:	b942      	cbnz	r2, 800206c <prvWriteBytesToBuffer+0x14>
 800205a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800205e:	f383 8811 	msr	BASEPRI, r3
 8002062:	f3bf 8f6f 	isb	sy
 8002066:	f3bf 8f4f 	dsb	sy
 800206a:	e7fe      	b.n	800206a <prvWriteBytesToBuffer+0x12>
{
 800206c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002070:	4614      	mov	r4, r2

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
 8002072:	6882      	ldr	r2, [r0, #8]
 8002074:	4606      	mov	r6, r0
 8002076:	4698      	mov	r8, r3
 8002078:	1ad5      	subs	r5, r2, r3
 800207a:	42a5      	cmp	r5, r4
 800207c:	bf28      	it	cs
 800207e:	4625      	movcs	r5, r4

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
 8002080:	1958      	adds	r0, r3, r5
 8002082:	4282      	cmp	r2, r0
 8002084:	d208      	bcs.n	8002098 <prvWriteBytesToBuffer+0x40>
 8002086:	f04f 0350 	mov.w	r3, #80	; 0x50
 800208a:	f383 8811 	msr	BASEPRI, r3
 800208e:	f3bf 8f6f 	isb	sy
 8002092:	f3bf 8f4f 	dsb	sy
 8002096:	e7fe      	b.n	8002096 <prvWriteBytesToBuffer+0x3e>
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 8002098:	69b0      	ldr	r0, [r6, #24]
 800209a:	462a      	mov	r2, r5
 800209c:	460f      	mov	r7, r1
 800209e:	4418      	add	r0, r3
 80020a0:	f012 f928 	bl	80142f4 <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
 80020a4:	42ac      	cmp	r4, r5
 80020a6:	d910      	bls.n	80020ca <prvWriteBytesToBuffer+0x72>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
 80020a8:	1b62      	subs	r2, r4, r5
 80020aa:	68b1      	ldr	r1, [r6, #8]
 80020ac:	428a      	cmp	r2, r1
 80020ae:	d908      	bls.n	80020c2 <prvWriteBytesToBuffer+0x6a>
 80020b0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80020b4:	f383 8811 	msr	BASEPRI, r3
 80020b8:	f3bf 8f6f 	isb	sy
 80020bc:	f3bf 8f4f 	dsb	sy
 80020c0:	e7fe      	b.n	80020c0 <prvWriteBytesToBuffer+0x68>
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 80020c2:	1979      	adds	r1, r7, r5
 80020c4:	69b0      	ldr	r0, [r6, #24]
 80020c6:	f012 f915 	bl	80142f4 <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
 80020ca:	eb04 0008 	add.w	r0, r4, r8

    if( xHead >= pxStreamBuffer->xLength )
 80020ce:	68b3      	ldr	r3, [r6, #8]
 80020d0:	4283      	cmp	r3, r0
    {
        xHead -= pxStreamBuffer->xLength;
 80020d2:	bf98      	it	ls
 80020d4:	1ac0      	subls	r0, r0, r3
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
}
 80020d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80020da:	bf00      	nop

080020dc <prvReadBytesFromBuffer>:
                                      size_t xCount,
                                      size_t xTail )
{
    size_t xFirstLength;

    configASSERT( xCount != ( size_t ) 0 );
 80020dc:	b942      	cbnz	r2, 80020f0 <prvReadBytesFromBuffer+0x14>
 80020de:	f04f 0350 	mov.w	r3, #80	; 0x50
 80020e2:	f383 8811 	msr	BASEPRI, r3
 80020e6:	f3bf 8f6f 	isb	sy
 80020ea:	f3bf 8f4f 	dsb	sy
 80020ee:	e7fe      	b.n	80020ee <prvReadBytesFromBuffer+0x12>
{
 80020f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80020f2:	460e      	mov	r6, r1

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
 80020f4:	6881      	ldr	r1, [r0, #8]
 80020f6:	4614      	mov	r4, r2
{
 80020f8:	b083      	sub	sp, #12
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
 80020fa:	1aca      	subs	r2, r1, r3
 80020fc:	4605      	mov	r5, r0
 80020fe:	461f      	mov	r7, r3
 8002100:	42a2      	cmp	r2, r4
 8002102:	bf28      	it	cs
 8002104:	4622      	movcs	r2, r4

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
 8002106:	4294      	cmp	r4, r2
 8002108:	d208      	bcs.n	800211c <prvReadBytesFromBuffer+0x40>
 800210a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800210e:	f383 8811 	msr	BASEPRI, r3
 8002112:	f3bf 8f6f 	isb	sy
 8002116:	f3bf 8f4f 	dsb	sy
 800211a:	e7fe      	b.n	800211a <prvReadBytesFromBuffer+0x3e>
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
 800211c:	1898      	adds	r0, r3, r2
 800211e:	4281      	cmp	r1, r0
 8002120:	d208      	bcs.n	8002134 <prvReadBytesFromBuffer+0x58>
 8002122:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002126:	f383 8811 	msr	BASEPRI, r3
 800212a:	f3bf 8f6f 	isb	sy
 800212e:	f3bf 8f4f 	dsb	sy
 8002132:	e7fe      	b.n	8002132 <prvReadBytesFromBuffer+0x56>
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 8002134:	69a9      	ldr	r1, [r5, #24]
 8002136:	4630      	mov	r0, r6
 8002138:	9201      	str	r2, [sp, #4]
 800213a:	4419      	add	r1, r3
 800213c:	f012 f8da 	bl	80142f4 <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
 8002140:	9a01      	ldr	r2, [sp, #4]
 8002142:	4294      	cmp	r4, r2
 8002144:	d806      	bhi.n	8002154 <prvReadBytesFromBuffer+0x78>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
 8002146:	19e0      	adds	r0, r4, r7

    if( xTail >= pxStreamBuffer->xLength )
 8002148:	68ab      	ldr	r3, [r5, #8]
 800214a:	4283      	cmp	r3, r0
    {
        xTail -= pxStreamBuffer->xLength;
 800214c:	bf98      	it	ls
 800214e:	1ac0      	subls	r0, r0, r3
    }

    return xTail;
}
 8002150:	b003      	add	sp, #12
 8002152:	bdf0      	pop	{r4, r5, r6, r7, pc}
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 8002154:	18b0      	adds	r0, r6, r2
 8002156:	69a9      	ldr	r1, [r5, #24]
 8002158:	1aa2      	subs	r2, r4, r2
 800215a:	f012 f8cb 	bl	80142f4 <memcpy>
 800215e:	e7f2      	b.n	8002146 <prvReadBytesFromBuffer+0x6a>

08002160 <xStreamBufferSend>:
{
 8002160:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002164:	b089      	sub	sp, #36	; 0x24
 8002166:	9303      	str	r3, [sp, #12]
    configASSERT( pvTxData );
 8002168:	2900      	cmp	r1, #0
 800216a:	d034      	beq.n	80021d6 <xStreamBufferSend+0x76>
    configASSERT( pxStreamBuffer );
 800216c:	4604      	mov	r4, r0
 800216e:	b348      	cbz	r0, 80021c4 <xStreamBufferSend+0x64>
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
 8002170:	7f03      	ldrb	r3, [r0, #28]
 8002172:	460e      	mov	r6, r1
 8002174:	f8d0 e008 	ldr.w	lr, [r0, #8]
 8002178:	4617      	mov	r7, r2
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 800217a:	f013 0101 	ands.w	r1, r3, #1
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
 800217e:	f10e 3cff 	add.w	ip, lr, #4294967295	; 0xffffffff
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 8002182:	d031      	beq.n	80021e8 <xStreamBufferSend+0x88>
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 8002184:	f102 0804 	add.w	r8, r2, #4
        configASSERT( xRequiredSpace > xDataLengthBytes );
 8002188:	4542      	cmp	r2, r8
 800218a:	d26c      	bcs.n	8002266 <xStreamBufferSend+0x106>
        if( xRequiredSpace > xMaxReportedSpace )
 800218c:	45c4      	cmp	ip, r8
 800218e:	d22f      	bcs.n	80021f0 <xStreamBufferSend+0x90>
            xTicksToWait = ( TickType_t ) 0;
 8002190:	2300      	movs	r3, #0
 8002192:	9303      	str	r3, [sp, #12]
        xOriginalTail = pxStreamBuffer->xTail;
 8002194:	6822      	ldr	r2, [r4, #0]
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 8002196:	6825      	ldr	r5, [r4, #0]
        xSpace -= pxStreamBuffer->xHead;
 8002198:	6860      	ldr	r0, [r4, #4]
    } while( xOriginalTail != pxStreamBuffer->xTail );
 800219a:	6823      	ldr	r3, [r4, #0]
 800219c:	429a      	cmp	r2, r3
 800219e:	d1f9      	bne.n	8002194 <xStreamBufferSend+0x34>
    xSpace -= ( size_t ) 1;
 80021a0:	4465      	add	r5, ip
 80021a2:	1a2d      	subs	r5, r5, r0
    if( xSpace >= pxStreamBuffer->xLength )
 80021a4:	45ae      	cmp	lr, r5
        xSpace -= pxStreamBuffer->xLength;
 80021a6:	bf98      	it	ls
 80021a8:	eba5 050e 	subls.w	r5, r5, lr
    size_t xNextHead = pxStreamBuffer->xHead;
 80021ac:	6863      	ldr	r3, [r4, #4]
 80021ae:	9705      	str	r7, [sp, #20]
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 80021b0:	2900      	cmp	r1, #0
 80021b2:	d061      	beq.n	8002278 <xStreamBufferSend+0x118>
        if( xSpace >= xRequiredSpace )
 80021b4:	4545      	cmp	r5, r8
 80021b6:	f080 8089 	bcs.w	80022cc <xStreamBufferSend+0x16c>
    return xDataLengthBytes;
 80021ba:	2500      	movs	r5, #0
}
 80021bc:	4628      	mov	r0, r5
 80021be:	b009      	add	sp, #36	; 0x24
 80021c0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80021c4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80021c8:	f383 8811 	msr	BASEPRI, r3
 80021cc:	f3bf 8f6f 	isb	sy
 80021d0:	f3bf 8f4f 	dsb	sy
    configASSERT( pxStreamBuffer );
 80021d4:	e7fe      	b.n	80021d4 <xStreamBufferSend+0x74>
 80021d6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80021da:	f383 8811 	msr	BASEPRI, r3
 80021de:	f3bf 8f6f 	isb	sy
 80021e2:	f3bf 8f4f 	dsb	sy
    configASSERT( pvTxData );
 80021e6:	e7fe      	b.n	80021e6 <xStreamBufferSend+0x86>
        if( xRequiredSpace > xMaxReportedSpace )
 80021e8:	4562      	cmp	r2, ip
 80021ea:	4690      	mov	r8, r2
 80021ec:	bf28      	it	cs
 80021ee:	46e0      	movcs	r8, ip
    if( xTicksToWait != ( TickType_t ) 0 )
 80021f0:	9b03      	ldr	r3, [sp, #12]
 80021f2:	2b00      	cmp	r3, #0
 80021f4:	d0ce      	beq.n	8002194 <xStreamBufferSend+0x34>
        vTaskSetTimeOutState( &xTimeOut );
 80021f6:	a806      	add	r0, sp, #24
 80021f8:	f001 fd36 	bl	8003c68 <vTaskSetTimeOutState>
            taskENTER_CRITICAL();
 80021fc:	f007 fcfc 	bl	8009bf8 <vPortEnterCritical>
        xOriginalTail = pxStreamBuffer->xTail;
 8002200:	6820      	ldr	r0, [r4, #0]
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 8002202:	6821      	ldr	r1, [r4, #0]
        xSpace -= pxStreamBuffer->xHead;
 8002204:	6862      	ldr	r2, [r4, #4]
    } while( xOriginalTail != pxStreamBuffer->xTail );
 8002206:	6823      	ldr	r3, [r4, #0]
 8002208:	4298      	cmp	r0, r3
 800220a:	d1f9      	bne.n	8002200 <xStreamBufferSend+0xa0>
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 800220c:	68a3      	ldr	r3, [r4, #8]
    xSpace -= ( size_t ) 1;
 800220e:	1e5d      	subs	r5, r3, #1
 8002210:	4429      	add	r1, r5
 8002212:	1a8d      	subs	r5, r1, r2
    if( xSpace >= pxStreamBuffer->xLength )
 8002214:	42ab      	cmp	r3, r5
        xSpace -= pxStreamBuffer->xLength;
 8002216:	bf98      	it	ls
 8002218:	1aed      	subls	r5, r5, r3
                if( xSpace < xRequiredSpace )
 800221a:	45a8      	cmp	r8, r5
 800221c:	d96a      	bls.n	80022f4 <xStreamBufferSend+0x194>
                    ( void ) xTaskNotifyStateClear( NULL );
 800221e:	2100      	movs	r1, #0
 8002220:	4608      	mov	r0, r1
 8002222:	f001 fcd3 	bl	8003bcc <xTaskGenericNotifyStateClear>
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
 8002226:	f8d4 9014 	ldr.w	r9, [r4, #20]
 800222a:	f1b9 0f00 	cmp.w	r9, #0
 800222e:	d158      	bne.n	80022e2 <xStreamBufferSend+0x182>
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
 8002230:	f002 fba6 	bl	8004980 <xTaskGetCurrentTaskHandle>
 8002234:	6160      	str	r0, [r4, #20]
            taskEXIT_CRITICAL();
 8002236:	f007 fcf5 	bl	8009c24 <vPortExitCritical>
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 800223a:	9b03      	ldr	r3, [sp, #12]
 800223c:	4649      	mov	r1, r9
 800223e:	464a      	mov	r2, r9
 8002240:	9300      	str	r3, [sp, #0]
 8002242:	4648      	mov	r0, r9
 8002244:	464b      	mov	r3, r9
 8002246:	f001 fb5d 	bl	8003904 <xTaskGenericNotifyWait>
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
 800224a:	a903      	add	r1, sp, #12
 800224c:	a806      	add	r0, sp, #24
            pxStreamBuffer->xTaskWaitingToSend = NULL;
 800224e:	f8c4 9014 	str.w	r9, [r4, #20]
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
 8002252:	f001 fd23 	bl	8003c9c <xTaskCheckForTimeOut>
 8002256:	2800      	cmp	r0, #0
 8002258:	d0d0      	beq.n	80021fc <xStreamBufferSend+0x9c>
    if( xSpace == ( size_t ) 0 )
 800225a:	2d00      	cmp	r5, #0
 800225c:	d04d      	beq.n	80022fa <xStreamBufferSend+0x19a>
 800225e:	7f23      	ldrb	r3, [r4, #28]
 8002260:	f003 0101 	and.w	r1, r3, #1
 8002264:	e7a2      	b.n	80021ac <xStreamBufferSend+0x4c>
 8002266:	f04f 0350 	mov.w	r3, #80	; 0x50
 800226a:	f383 8811 	msr	BASEPRI, r3
 800226e:	f3bf 8f6f 	isb	sy
 8002272:	f3bf 8f4f 	dsb	sy
        configASSERT( xRequiredSpace > xDataLengthBytes );
 8002276:	e7fe      	b.n	8002276 <xStreamBufferSend+0x116>
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
 8002278:	42bd      	cmp	r5, r7
 800227a:	462a      	mov	r2, r5
 800227c:	bf28      	it	cs
 800227e:	463a      	movcs	r2, r7
 8002280:	9205      	str	r2, [sp, #20]
    if( xDataLengthBytes != ( size_t ) 0 )
 8002282:	2a00      	cmp	r2, #0
 8002284:	d099      	beq.n	80021ba <xStreamBufferSend+0x5a>
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
 8002286:	4631      	mov	r1, r6
 8002288:	4620      	mov	r0, r4
 800228a:	f7ff fee5 	bl	8002058 <prvWriteBytesToBuffer>
    return xDataLengthBytes;
 800228e:	9d05      	ldr	r5, [sp, #20]
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
 8002290:	6060      	str	r0, [r4, #4]
    if( xReturn > ( size_t ) 0 )
 8002292:	2d00      	cmp	r5, #0
 8002294:	d092      	beq.n	80021bc <xStreamBufferSend+0x5c>
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 8002296:	68a2      	ldr	r2, [r4, #8]
 8002298:	6863      	ldr	r3, [r4, #4]
    xCount -= pxStreamBuffer->xTail;
 800229a:	6821      	ldr	r1, [r4, #0]
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 800229c:	4413      	add	r3, r2
    xCount -= pxStreamBuffer->xTail;
 800229e:	1a5b      	subs	r3, r3, r1

    if( xCount >= pxStreamBuffer->xLength )
 80022a0:	429a      	cmp	r2, r3
    {
        xCount -= pxStreamBuffer->xLength;
 80022a2:	bf98      	it	ls
 80022a4:	1a9b      	subls	r3, r3, r2
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 80022a6:	68e2      	ldr	r2, [r4, #12]
 80022a8:	429a      	cmp	r2, r3
 80022aa:	d887      	bhi.n	80021bc <xStreamBufferSend+0x5c>
            sbSEND_COMPLETED( pxStreamBuffer );
 80022ac:	f001 f958 	bl	8003560 <vTaskSuspendAll>
 80022b0:	6923      	ldr	r3, [r4, #16]
 80022b2:	b143      	cbz	r3, 80022c6 <xStreamBufferSend+0x166>
 80022b4:	2600      	movs	r6, #0
 80022b6:	6920      	ldr	r0, [r4, #16]
 80022b8:	4633      	mov	r3, r6
 80022ba:	4632      	mov	r2, r6
 80022bc:	4631      	mov	r1, r6
 80022be:	9600      	str	r6, [sp, #0]
 80022c0:	f001 f99a 	bl	80035f8 <xTaskGenericNotify>
 80022c4:	6126      	str	r6, [r4, #16]
 80022c6:	f001 fde9 	bl	8003e9c <xTaskResumeAll>
    return xReturn;
 80022ca:	e777      	b.n	80021bc <xStreamBufferSend+0x5c>
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
 80022cc:	2204      	movs	r2, #4
 80022ce:	a905      	add	r1, sp, #20
 80022d0:	4620      	mov	r0, r4
 80022d2:	f7ff fec1 	bl	8002058 <prvWriteBytesToBuffer>
    if( xDataLengthBytes != ( size_t ) 0 )
 80022d6:	9a05      	ldr	r2, [sp, #20]
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
 80022d8:	4603      	mov	r3, r0
    if( xDataLengthBytes != ( size_t ) 0 )
 80022da:	2a00      	cmp	r2, #0
 80022dc:	f43f af6d 	beq.w	80021ba <xStreamBufferSend+0x5a>
 80022e0:	e7d1      	b.n	8002286 <xStreamBufferSend+0x126>
 80022e2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80022e6:	f383 8811 	msr	BASEPRI, r3
 80022ea:	f3bf 8f6f 	isb	sy
 80022ee:	f3bf 8f4f 	dsb	sy
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
 80022f2:	e7fe      	b.n	80022f2 <xStreamBufferSend+0x192>
                    taskEXIT_CRITICAL();
 80022f4:	f007 fc96 	bl	8009c24 <vPortExitCritical>
                    break;
 80022f8:	e7af      	b.n	800225a <xStreamBufferSend+0xfa>
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 80022fa:	f8d4 e008 	ldr.w	lr, [r4, #8]
 80022fe:	7f23      	ldrb	r3, [r4, #28]
 8002300:	f10e 3cff 	add.w	ip, lr, #4294967295	; 0xffffffff
    configASSERT( pxStreamBuffer );
 8002304:	f003 0101 	and.w	r1, r3, #1
 8002308:	e744      	b.n	8002194 <xStreamBufferSend+0x34>
 800230a:	bf00      	nop

0800230c <xStreamBufferSendFromISR>:
    configASSERT( pvTxData );
 800230c:	b369      	cbz	r1, 800236a <xStreamBufferSendFromISR+0x5e>
{
 800230e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002312:	4604      	mov	r4, r0
 8002314:	b085      	sub	sp, #20
    configASSERT( pxStreamBuffer );
 8002316:	b1f8      	cbz	r0, 8002358 <xStreamBufferSendFromISR+0x4c>
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 8002318:	4699      	mov	r9, r3
 800231a:	7f03      	ldrb	r3, [r0, #28]
 800231c:	4688      	mov	r8, r1
 800231e:	f013 0301 	ands.w	r3, r3, #1
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 8002322:	bf14      	ite	ne
 8002324:	f102 0c04 	addne.w	ip, r2, #4
    size_t xRequiredSpace = xDataLengthBytes;
 8002328:	4694      	moveq	ip, r2
        xOriginalTail = pxStreamBuffer->xTail;
 800232a:	6825      	ldr	r5, [r4, #0]
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 800232c:	6827      	ldr	r7, [r4, #0]
        xSpace -= pxStreamBuffer->xHead;
 800232e:	6866      	ldr	r6, [r4, #4]
    } while( xOriginalTail != pxStreamBuffer->xTail );
 8002330:	6820      	ldr	r0, [r4, #0]
 8002332:	4285      	cmp	r5, r0
 8002334:	d1f9      	bne.n	800232a <xStreamBufferSendFromISR+0x1e>
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 8002336:	68a0      	ldr	r0, [r4, #8]
    xSpace -= ( size_t ) 1;
 8002338:	9203      	str	r2, [sp, #12]
 800233a:	1e41      	subs	r1, r0, #1
 800233c:	4439      	add	r1, r7
 800233e:	1b89      	subs	r1, r1, r6
    if( xSpace >= pxStreamBuffer->xLength )
 8002340:	4288      	cmp	r0, r1
        xSpace -= pxStreamBuffer->xLength;
 8002342:	bf98      	it	ls
 8002344:	1a09      	subls	r1, r1, r0
    size_t xNextHead = pxStreamBuffer->xHead;
 8002346:	6860      	ldr	r0, [r4, #4]
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 8002348:	b1c3      	cbz	r3, 800237c <xStreamBufferSendFromISR+0x70>
        if( xSpace >= xRequiredSpace )
 800234a:	458c      	cmp	ip, r1
 800234c:	d94a      	bls.n	80023e4 <xStreamBufferSendFromISR+0xd8>
    return xDataLengthBytes;
 800234e:	2500      	movs	r5, #0
}
 8002350:	4628      	mov	r0, r5
 8002352:	b005      	add	sp, #20
 8002354:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8002358:	f04f 0350 	mov.w	r3, #80	; 0x50
 800235c:	f383 8811 	msr	BASEPRI, r3
 8002360:	f3bf 8f6f 	isb	sy
 8002364:	f3bf 8f4f 	dsb	sy
    configASSERT( pxStreamBuffer );
 8002368:	e7fe      	b.n	8002368 <xStreamBufferSendFromISR+0x5c>
 800236a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800236e:	f383 8811 	msr	BASEPRI, r3
 8002372:	f3bf 8f6f 	isb	sy
 8002376:	f3bf 8f4f 	dsb	sy
    configASSERT( pvTxData );
 800237a:	e7fe      	b.n	800237a <xStreamBufferSendFromISR+0x6e>
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
 800237c:	428a      	cmp	r2, r1
 800237e:	bf28      	it	cs
 8002380:	460a      	movcs	r2, r1
 8002382:	9203      	str	r2, [sp, #12]
    if( xDataLengthBytes != ( size_t ) 0 )
 8002384:	2a00      	cmp	r2, #0
 8002386:	d0e2      	beq.n	800234e <xStreamBufferSendFromISR+0x42>
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
 8002388:	4603      	mov	r3, r0
 800238a:	4641      	mov	r1, r8
 800238c:	4620      	mov	r0, r4
 800238e:	f7ff fe63 	bl	8002058 <prvWriteBytesToBuffer>
    return xDataLengthBytes;
 8002392:	9d03      	ldr	r5, [sp, #12]
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
 8002394:	6060      	str	r0, [r4, #4]
    if( xReturn > ( size_t ) 0 )
 8002396:	2d00      	cmp	r5, #0
 8002398:	d0da      	beq.n	8002350 <xStreamBufferSendFromISR+0x44>
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 800239a:	68a2      	ldr	r2, [r4, #8]
 800239c:	6863      	ldr	r3, [r4, #4]
    xCount -= pxStreamBuffer->xTail;
 800239e:	6821      	ldr	r1, [r4, #0]
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 80023a0:	4413      	add	r3, r2
    xCount -= pxStreamBuffer->xTail;
 80023a2:	1a5b      	subs	r3, r3, r1
    if( xCount >= pxStreamBuffer->xLength )
 80023a4:	429a      	cmp	r2, r3
        xCount -= pxStreamBuffer->xLength;
 80023a6:	bf98      	it	ls
 80023a8:	1a9b      	subls	r3, r3, r2
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 80023aa:	68e2      	ldr	r2, [r4, #12]
 80023ac:	429a      	cmp	r2, r3
 80023ae:	d8cf      	bhi.n	8002350 <xStreamBufferSendFromISR+0x44>
    __asm volatile
 80023b0:	f3ef 8711 	mrs	r7, BASEPRI
 80023b4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80023b8:	f383 8811 	msr	BASEPRI, r3
 80023bc:	f3bf 8f6f 	isb	sy
 80023c0:	f3bf 8f4f 	dsb	sy
            sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 80023c4:	6923      	ldr	r3, [r4, #16]
 80023c6:	b153      	cbz	r3, 80023de <xStreamBufferSendFromISR+0xd2>
 80023c8:	2600      	movs	r6, #0
 80023ca:	6920      	ldr	r0, [r4, #16]
 80023cc:	f8cd 9004 	str.w	r9, [sp, #4]
 80023d0:	4633      	mov	r3, r6
 80023d2:	4632      	mov	r2, r6
 80023d4:	4631      	mov	r1, r6
 80023d6:	9600      	str	r6, [sp, #0]
 80023d8:	f001 f9be 	bl	8003758 <xTaskGenericNotifyFromISR>
 80023dc:	6126      	str	r6, [r4, #16]
    __asm volatile
 80023de:	f387 8811 	msr	BASEPRI, r7
    return xReturn;
 80023e2:	e7b5      	b.n	8002350 <xStreamBufferSendFromISR+0x44>
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
 80023e4:	4603      	mov	r3, r0
 80023e6:	2204      	movs	r2, #4
 80023e8:	a903      	add	r1, sp, #12
 80023ea:	4620      	mov	r0, r4
 80023ec:	f7ff fe34 	bl	8002058 <prvWriteBytesToBuffer>
    if( xDataLengthBytes != ( size_t ) 0 )
 80023f0:	9a03      	ldr	r2, [sp, #12]
 80023f2:	e7c7      	b.n	8002384 <xStreamBufferSendFromISR+0x78>

080023f4 <xStreamBufferReceive>:
    configASSERT( pvRxData );
 80023f4:	b341      	cbz	r1, 8002448 <xStreamBufferReceive+0x54>
{
 80023f6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80023fa:	4604      	mov	r4, r0
 80023fc:	b085      	sub	sp, #20
    configASSERT( pxStreamBuffer );
 80023fe:	b1d0      	cbz	r0, 8002436 <xStreamBufferReceive+0x42>
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 8002400:	4617      	mov	r7, r2
 8002402:	7f02      	ldrb	r2, [r0, #28]
 8002404:	460e      	mov	r6, r1
 8002406:	4699      	mov	r9, r3
        xBytesToStoreMessageLength = 0;
 8002408:	f012 0f01 	tst.w	r2, #1
 800240c:	bf14      	ite	ne
 800240e:	f04f 0804 	movne.w	r8, #4
 8002412:	f04f 0800 	moveq.w	r8, #0
    if( xTicksToWait != ( TickType_t ) 0 )
 8002416:	bb03      	cbnz	r3, 800245a <xStreamBufferReceive+0x66>
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 8002418:	68a3      	ldr	r3, [r4, #8]
 800241a:	6865      	ldr	r5, [r4, #4]
    xCount -= pxStreamBuffer->xTail;
 800241c:	6822      	ldr	r2, [r4, #0]
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 800241e:	441d      	add	r5, r3
    xCount -= pxStreamBuffer->xTail;
 8002420:	1aad      	subs	r5, r5, r2
    if( xCount >= pxStreamBuffer->xLength )
 8002422:	42ab      	cmp	r3, r5
        xCount -= pxStreamBuffer->xLength;
 8002424:	bf98      	it	ls
 8002426:	1aed      	subls	r5, r5, r3
    if( xBytesAvailable > xBytesToStoreMessageLength )
 8002428:	4545      	cmp	r5, r8
 800242a:	d824      	bhi.n	8002476 <xStreamBufferReceive+0x82>
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 800242c:	2500      	movs	r5, #0
}
 800242e:	4628      	mov	r0, r5
 8002430:	b005      	add	sp, #20
 8002432:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __asm volatile
 8002436:	f04f 0350 	mov.w	r3, #80	; 0x50
 800243a:	f383 8811 	msr	BASEPRI, r3
 800243e:	f3bf 8f6f 	isb	sy
 8002442:	f3bf 8f4f 	dsb	sy
    configASSERT( pxStreamBuffer );
 8002446:	e7fe      	b.n	8002446 <xStreamBufferReceive+0x52>
 8002448:	f04f 0350 	mov.w	r3, #80	; 0x50
 800244c:	f383 8811 	msr	BASEPRI, r3
 8002450:	f3bf 8f6f 	isb	sy
 8002454:	f3bf 8f4f 	dsb	sy
    configASSERT( pvRxData );
 8002458:	e7fe      	b.n	8002458 <xStreamBufferReceive+0x64>
        taskENTER_CRITICAL();
 800245a:	f007 fbcd 	bl	8009bf8 <vPortEnterCritical>
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 800245e:	68a3      	ldr	r3, [r4, #8]
 8002460:	6865      	ldr	r5, [r4, #4]
    xCount -= pxStreamBuffer->xTail;
 8002462:	6822      	ldr	r2, [r4, #0]
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 8002464:	441d      	add	r5, r3
    xCount -= pxStreamBuffer->xTail;
 8002466:	1aad      	subs	r5, r5, r2
    if( xCount >= pxStreamBuffer->xLength )
 8002468:	42ab      	cmp	r3, r5
        xCount -= pxStreamBuffer->xLength;
 800246a:	bf98      	it	ls
 800246c:	1aed      	subls	r5, r5, r3
            if( xBytesAvailable <= xBytesToStoreMessageLength )
 800246e:	45a8      	cmp	r8, r5
 8002470:	d220      	bcs.n	80024b4 <xStreamBufferReceive+0xc0>
        taskEXIT_CRITICAL();
 8002472:	f007 fbd7 	bl	8009c24 <vPortExitCritical>
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 8002476:	7f22      	ldrb	r2, [r4, #28]
    size_t xNextTail = pxStreamBuffer->xTail;
 8002478:	6823      	ldr	r3, [r4, #0]
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 800247a:	07d2      	lsls	r2, r2, #31
 800247c:	d429      	bmi.n	80024d2 <xStreamBufferReceive+0xde>
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
 800247e:	42bd      	cmp	r5, r7
 8002480:	bf28      	it	cs
 8002482:	463d      	movcs	r5, r7
    if( xCount != ( size_t ) 0 )
 8002484:	2d00      	cmp	r5, #0
 8002486:	d0d1      	beq.n	800242c <xStreamBufferReceive+0x38>
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
 8002488:	462a      	mov	r2, r5
 800248a:	4631      	mov	r1, r6
 800248c:	4620      	mov	r0, r4
 800248e:	f7ff fe25 	bl	80020dc <prvReadBytesFromBuffer>
 8002492:	6020      	str	r0, [r4, #0]
            sbRECEIVE_COMPLETED( pxStreamBuffer );
 8002494:	f001 f864 	bl	8003560 <vTaskSuspendAll>
 8002498:	6963      	ldr	r3, [r4, #20]
 800249a:	b143      	cbz	r3, 80024ae <xStreamBufferReceive+0xba>
 800249c:	2600      	movs	r6, #0
 800249e:	6960      	ldr	r0, [r4, #20]
 80024a0:	4633      	mov	r3, r6
 80024a2:	4632      	mov	r2, r6
 80024a4:	4631      	mov	r1, r6
 80024a6:	9600      	str	r6, [sp, #0]
 80024a8:	f001 f8a6 	bl	80035f8 <xTaskGenericNotify>
 80024ac:	6166      	str	r6, [r4, #20]
 80024ae:	f001 fcf5 	bl	8003e9c <xTaskResumeAll>
 80024b2:	e7bc      	b.n	800242e <xStreamBufferReceive+0x3a>
                ( void ) xTaskNotifyStateClear( NULL );
 80024b4:	2100      	movs	r1, #0
 80024b6:	4608      	mov	r0, r1
 80024b8:	f001 fb88 	bl	8003bcc <xTaskGenericNotifyStateClear>
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
 80024bc:	6925      	ldr	r5, [r4, #16]
 80024be:	b1a5      	cbz	r5, 80024ea <xStreamBufferReceive+0xf6>
 80024c0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80024c4:	f383 8811 	msr	BASEPRI, r3
 80024c8:	f3bf 8f6f 	isb	sy
 80024cc:	f3bf 8f4f 	dsb	sy
 80024d0:	e7fe      	b.n	80024d0 <xStreamBufferReceive+0xdc>
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
 80024d2:	2204      	movs	r2, #4
 80024d4:	a903      	add	r1, sp, #12
 80024d6:	4620      	mov	r0, r4
 80024d8:	f7ff fe00 	bl	80020dc <prvReadBytesFromBuffer>
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
 80024dc:	9a03      	ldr	r2, [sp, #12]
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
 80024de:	4603      	mov	r3, r0
        if( xNextMessageLength > xBufferLengthBytes )
 80024e0:	4297      	cmp	r7, r2
 80024e2:	d3a3      	bcc.n	800242c <xStreamBufferReceive+0x38>
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
 80024e4:	3d04      	subs	r5, #4
 80024e6:	4617      	mov	r7, r2
 80024e8:	e7c9      	b.n	800247e <xStreamBufferReceive+0x8a>
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
 80024ea:	f002 fa49 	bl	8004980 <xTaskGetCurrentTaskHandle>
 80024ee:	6120      	str	r0, [r4, #16]
        taskEXIT_CRITICAL();
 80024f0:	f007 fb98 	bl	8009c24 <vPortExitCritical>
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 80024f4:	462b      	mov	r3, r5
 80024f6:	462a      	mov	r2, r5
 80024f8:	4629      	mov	r1, r5
 80024fa:	4628      	mov	r0, r5
 80024fc:	f8cd 9000 	str.w	r9, [sp]
 8002500:	f001 fa00 	bl	8003904 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
 8002504:	6125      	str	r5, [r4, #16]
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 8002506:	e787      	b.n	8002418 <xStreamBufferReceive+0x24>

08002508 <xStreamBufferReceiveFromISR>:
    configASSERT( pvRxData );
 8002508:	b331      	cbz	r1, 8002558 <xStreamBufferReceiveFromISR+0x50>
{
 800250a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800250e:	4604      	mov	r4, r0
 8002510:	b084      	sub	sp, #16
    configASSERT( pxStreamBuffer );
 8002512:	b1c0      	cbz	r0, 8002546 <xStreamBufferReceiveFromISR+0x3e>
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 8002514:	7f05      	ldrb	r5, [r0, #28]
 8002516:	4698      	mov	r8, r3
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 8002518:	68a3      	ldr	r3, [r4, #8]
 800251a:	4617      	mov	r7, r2
        xBytesToStoreMessageLength = 0;
 800251c:	f015 0001 	ands.w	r0, r5, #1
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 8002520:	6865      	ldr	r5, [r4, #4]
    xCount -= pxStreamBuffer->xTail;
 8002522:	6822      	ldr	r2, [r4, #0]
 8002524:	460e      	mov	r6, r1
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 8002526:	441d      	add	r5, r3
    xCount -= pxStreamBuffer->xTail;
 8002528:	eba5 0502 	sub.w	r5, r5, r2
        xBytesToStoreMessageLength = 0;
 800252c:	bf14      	ite	ne
 800252e:	2204      	movne	r2, #4
 8002530:	2200      	moveq	r2, #0
    if( xCount >= pxStreamBuffer->xLength )
 8002532:	42ab      	cmp	r3, r5
        xCount -= pxStreamBuffer->xLength;
 8002534:	bf98      	it	ls
 8002536:	1aed      	subls	r5, r5, r3
    if( xBytesAvailable > xBytesToStoreMessageLength )
 8002538:	42aa      	cmp	r2, r5
 800253a:	d316      	bcc.n	800256a <xStreamBufferReceiveFromISR+0x62>
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 800253c:	2500      	movs	r5, #0
}
 800253e:	4628      	mov	r0, r5
 8002540:	b004      	add	sp, #16
 8002542:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002546:	f04f 0350 	mov.w	r3, #80	; 0x50
 800254a:	f383 8811 	msr	BASEPRI, r3
 800254e:	f3bf 8f6f 	isb	sy
 8002552:	f3bf 8f4f 	dsb	sy
    configASSERT( pxStreamBuffer );
 8002556:	e7fe      	b.n	8002556 <xStreamBufferReceiveFromISR+0x4e>
 8002558:	f04f 0350 	mov.w	r3, #80	; 0x50
 800255c:	f383 8811 	msr	BASEPRI, r3
 8002560:	f3bf 8f6f 	isb	sy
 8002564:	f3bf 8f4f 	dsb	sy
    configASSERT( pvRxData );
 8002568:	e7fe      	b.n	8002568 <xStreamBufferReceiveFromISR+0x60>
    size_t xNextTail = pxStreamBuffer->xTail;
 800256a:	6823      	ldr	r3, [r4, #0]
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 800256c:	bb20      	cbnz	r0, 80025b8 <xStreamBufferReceiveFromISR+0xb0>
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
 800256e:	42bd      	cmp	r5, r7
 8002570:	bf28      	it	cs
 8002572:	463d      	movcs	r5, r7
    if( xCount != ( size_t ) 0 )
 8002574:	2d00      	cmp	r5, #0
 8002576:	d0e1      	beq.n	800253c <xStreamBufferReceiveFromISR+0x34>
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
 8002578:	4631      	mov	r1, r6
 800257a:	462a      	mov	r2, r5
 800257c:	4620      	mov	r0, r4
 800257e:	f7ff fdad 	bl	80020dc <prvReadBytesFromBuffer>
 8002582:	6020      	str	r0, [r4, #0]
    __asm volatile
 8002584:	f3ef 8711 	mrs	r7, BASEPRI
 8002588:	f04f 0350 	mov.w	r3, #80	; 0x50
 800258c:	f383 8811 	msr	BASEPRI, r3
 8002590:	f3bf 8f6f 	isb	sy
 8002594:	f3bf 8f4f 	dsb	sy
            sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 8002598:	6963      	ldr	r3, [r4, #20]
 800259a:	b153      	cbz	r3, 80025b2 <xStreamBufferReceiveFromISR+0xaa>
 800259c:	2600      	movs	r6, #0
 800259e:	6960      	ldr	r0, [r4, #20]
 80025a0:	f8cd 8004 	str.w	r8, [sp, #4]
 80025a4:	4633      	mov	r3, r6
 80025a6:	4632      	mov	r2, r6
 80025a8:	4631      	mov	r1, r6
 80025aa:	9600      	str	r6, [sp, #0]
 80025ac:	f001 f8d4 	bl	8003758 <xTaskGenericNotifyFromISR>
 80025b0:	6166      	str	r6, [r4, #20]
    __asm volatile
 80025b2:	f387 8811 	msr	BASEPRI, r7
    (
        "	msr basepri, %0	"::"r" ( ulNewMaskValue ) : "memory"
    );
}
 80025b6:	e7c2      	b.n	800253e <xStreamBufferReceiveFromISR+0x36>
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
 80025b8:	2204      	movs	r2, #4
 80025ba:	a903      	add	r1, sp, #12
 80025bc:	4620      	mov	r0, r4
 80025be:	f7ff fd8d 	bl	80020dc <prvReadBytesFromBuffer>
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
 80025c2:	9a03      	ldr	r2, [sp, #12]
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
 80025c4:	4603      	mov	r3, r0
        if( xNextMessageLength > xBufferLengthBytes )
 80025c6:	4297      	cmp	r7, r2
 80025c8:	d3b8      	bcc.n	800253c <xStreamBufferReceiveFromISR+0x34>
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
 80025ca:	3d04      	subs	r5, #4
 80025cc:	4617      	mov	r7, r2
 80025ce:	e7ce      	b.n	800256e <xStreamBufferReceiveFromISR+0x66>

080025d0 <vStreamBufferDelete>:
    configASSERT( pxStreamBuffer );
 80025d0:	b140      	cbz	r0, 80025e4 <vStreamBufferDelete+0x14>
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
 80025d2:	7f03      	ldrb	r3, [r0, #28]
 80025d4:	079b      	lsls	r3, r3, #30
 80025d6:	d401      	bmi.n	80025dc <vStreamBufferDelete+0xc>
                vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
 80025d8:	f003 ba72 	b.w	8005ac0 <vPortFree>
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 80025dc:	2224      	movs	r2, #36	; 0x24
 80025de:	2100      	movs	r1, #0
 80025e0:	f011 be96 	b.w	8014310 <memset>
    __asm volatile
 80025e4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80025e8:	f383 8811 	msr	BASEPRI, r3
 80025ec:	f3bf 8f6f 	isb	sy
 80025f0:	f3bf 8f4f 	dsb	sy
    configASSERT( pxStreamBuffer );
 80025f4:	e7fe      	b.n	80025f4 <vStreamBufferDelete+0x24>
 80025f6:	bf00      	nop

080025f8 <xStreamBufferIsFull>:
    configASSERT( pxStreamBuffer );
 80025f8:	b1e0      	cbz	r0, 8002634 <xStreamBufferIsFull+0x3c>
{
 80025fa:	b410      	push	{r4}
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 80025fc:	7f03      	ldrb	r3, [r0, #28]
        xBytesToStoreMessageLength = 0;
 80025fe:	f013 0f01 	tst.w	r3, #1
 8002602:	bf14      	ite	ne
 8002604:	f04f 0c04 	movne.w	ip, #4
 8002608:	f04f 0c00 	moveq.w	ip, #0
        xOriginalTail = pxStreamBuffer->xTail;
 800260c:	6802      	ldr	r2, [r0, #0]
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 800260e:	6804      	ldr	r4, [r0, #0]
        xSpace -= pxStreamBuffer->xHead;
 8002610:	6841      	ldr	r1, [r0, #4]
    } while( xOriginalTail != pxStreamBuffer->xTail );
 8002612:	6803      	ldr	r3, [r0, #0]
 8002614:	429a      	cmp	r2, r3
 8002616:	d1f9      	bne.n	800260c <xStreamBufferIsFull+0x14>
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 8002618:	6882      	ldr	r2, [r0, #8]
    xSpace -= ( size_t ) 1;
 800261a:	1e53      	subs	r3, r2, #1
 800261c:	441c      	add	r4, r3
 800261e:	1a61      	subs	r1, r4, r1
}
 8002620:	f85d 4b04 	ldr.w	r4, [sp], #4
    if( xSpace >= pxStreamBuffer->xLength )
 8002624:	428a      	cmp	r2, r1
        xSpace -= pxStreamBuffer->xLength;
 8002626:	bf98      	it	ls
 8002628:	1a89      	subls	r1, r1, r2
}
 800262a:	458c      	cmp	ip, r1
 800262c:	bf34      	ite	cc
 800262e:	2000      	movcc	r0, #0
 8002630:	2001      	movcs	r0, #1
 8002632:	4770      	bx	lr
 8002634:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002638:	f383 8811 	msr	BASEPRI, r3
 800263c:	f3bf 8f6f 	isb	sy
 8002640:	f3bf 8f4f 	dsb	sy
    configASSERT( pxStreamBuffer );
 8002644:	e7fe      	b.n	8002644 <xStreamBufferIsFull+0x4c>
 8002646:	bf00      	nop

08002648 <xStreamBufferIsEmpty>:
    configASSERT( pxStreamBuffer );
 8002648:	b130      	cbz	r0, 8002658 <xStreamBufferIsEmpty+0x10>
    xTail = pxStreamBuffer->xTail;
 800264a:	6803      	ldr	r3, [r0, #0]
    if( pxStreamBuffer->xHead == xTail )
 800264c:	6840      	ldr	r0, [r0, #4]
}
 800264e:	1ac0      	subs	r0, r0, r3
 8002650:	fab0 f080 	clz	r0, r0
 8002654:	0940      	lsrs	r0, r0, #5
 8002656:	4770      	bx	lr
 8002658:	f04f 0350 	mov.w	r3, #80	; 0x50
 800265c:	f383 8811 	msr	BASEPRI, r3
 8002660:	f3bf 8f6f 	isb	sy
 8002664:	f3bf 8f4f 	dsb	sy
    configASSERT( pxStreamBuffer );
 8002668:	e7fe      	b.n	8002668 <xStreamBufferIsEmpty+0x20>
 800266a:	bf00      	nop

0800266c <xStreamBufferReset>:
    configASSERT( pxStreamBuffer );
 800266c:	b168      	cbz	r0, 800268a <xStreamBufferReset+0x1e>
{
 800266e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002672:	4604      	mov	r4, r0
            uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
 8002674:	6a06      	ldr	r6, [r0, #32]
    taskENTER_CRITICAL();
 8002676:	f007 fabf 	bl	8009bf8 <vPortEnterCritical>
        if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
 800267a:	6920      	ldr	r0, [r4, #16]
 800267c:	b170      	cbz	r0, 800269c <xStreamBufferReset+0x30>
    BaseType_t xReturn = pdFAIL;
 800267e:	2500      	movs	r5, #0
    taskEXIT_CRITICAL();
 8002680:	f007 fad0 	bl	8009c24 <vPortExitCritical>
}
 8002684:	4628      	mov	r0, r5
 8002686:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800268a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800268e:	f383 8811 	msr	BASEPRI, r3
 8002692:	f3bf 8f6f 	isb	sy
 8002696:	f3bf 8f4f 	dsb	sy
    configASSERT( pxStreamBuffer );
 800269a:	e7fe      	b.n	800269a <xStreamBufferReset+0x2e>
            if( pxStreamBuffer->xTaskWaitingToSend == NULL )
 800269c:	6965      	ldr	r5, [r4, #20]
 800269e:	b12d      	cbz	r5, 80026ac <xStreamBufferReset+0x40>
    BaseType_t xReturn = pdFAIL;
 80026a0:	4605      	mov	r5, r0
    taskEXIT_CRITICAL();
 80026a2:	f007 fabf 	bl	8009c24 <vPortExitCritical>
}
 80026a6:	4628      	mov	r0, r5
 80026a8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                prvInitialiseNewStreamBuffer( pxStreamBuffer,
 80026ac:	69a7      	ldr	r7, [r4, #24]
        {
            /* The value written just has to be identifiable when looking at the
             * memory.  Don't use 0xA5 as that is the stack fill value and could
             * result in confusion as to what is actually being observed. */
            const BaseType_t xWriteValue = 0x55;
            configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
 80026ae:	2155      	movs	r1, #85	; 0x55
                prvInitialiseNewStreamBuffer( pxStreamBuffer,
 80026b0:	f8d4 8008 	ldr.w	r8, [r4, #8]
            configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
 80026b4:	4638      	mov	r0, r7
                prvInitialiseNewStreamBuffer( pxStreamBuffer,
 80026b6:	f8d4 a00c 	ldr.w	sl, [r4, #12]
            configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
 80026ba:	4642      	mov	r2, r8
                prvInitialiseNewStreamBuffer( pxStreamBuffer,
 80026bc:	f894 901c 	ldrb.w	r9, [r4, #28]
            configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
 80026c0:	f011 fe26 	bl	8014310 <memset>
 80026c4:	4287      	cmp	r7, r0
 80026c6:	d008      	beq.n	80026da <xStreamBufferReset+0x6e>
 80026c8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80026cc:	f383 8811 	msr	BASEPRI, r3
 80026d0:	f3bf 8f6f 	isb	sy
 80026d4:	f3bf 8f4f 	dsb	sy
 80026d8:	e7fe      	b.n	80026d8 <xStreamBufferReset+0x6c>
        } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
 80026da:	4629      	mov	r1, r5
 80026dc:	2224      	movs	r2, #36	; 0x24
 80026de:	4620      	mov	r0, r4
                xReturn = pdPASS;
 80026e0:	2501      	movs	r5, #1
    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
 80026e2:	f011 fe15 	bl	8014310 <memset>
    pxStreamBuffer->pucBuffer = pucBuffer;
 80026e6:	61a7      	str	r7, [r4, #24]
    pxStreamBuffer->xLength = xBufferSizeBytes;
 80026e8:	f8c4 8008 	str.w	r8, [r4, #8]
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 80026ec:	f8c4 a00c 	str.w	sl, [r4, #12]
    pxStreamBuffer->ucFlags = ucFlags;
 80026f0:	f884 901c 	strb.w	r9, [r4, #28]
                        pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
 80026f4:	6226      	str	r6, [r4, #32]
 80026f6:	e7c3      	b.n	8002680 <xStreamBufferReset+0x14>

080026f8 <xStreamBufferSpacesAvailable>:
    configASSERT( pxStreamBuffer );
 80026f8:	b178      	cbz	r0, 800271a <xStreamBufferSpacesAvailable+0x22>
{
 80026fa:	b430      	push	{r4, r5}
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 80026fc:	6885      	ldr	r5, [r0, #8]
        xOriginalTail = pxStreamBuffer->xTail;
 80026fe:	6803      	ldr	r3, [r0, #0]
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 8002700:	6804      	ldr	r4, [r0, #0]
        xSpace -= pxStreamBuffer->xHead;
 8002702:	6841      	ldr	r1, [r0, #4]
    } while( xOriginalTail != pxStreamBuffer->xTail );
 8002704:	6802      	ldr	r2, [r0, #0]
 8002706:	429a      	cmp	r2, r3
 8002708:	d1f9      	bne.n	80026fe <xStreamBufferSpacesAvailable+0x6>
    xSpace -= ( size_t ) 1;
 800270a:	1e68      	subs	r0, r5, #1
 800270c:	4420      	add	r0, r4
 800270e:	1a40      	subs	r0, r0, r1
    if( xSpace >= pxStreamBuffer->xLength )
 8002710:	4285      	cmp	r5, r0
        xSpace -= pxStreamBuffer->xLength;
 8002712:	bf98      	it	ls
 8002714:	1b40      	subls	r0, r0, r5
}
 8002716:	bc30      	pop	{r4, r5}
 8002718:	4770      	bx	lr
 800271a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800271e:	f383 8811 	msr	BASEPRI, r3
 8002722:	f3bf 8f6f 	isb	sy
 8002726:	f3bf 8f4f 	dsb	sy
    configASSERT( pxStreamBuffer );
 800272a:	e7fe      	b.n	800272a <xStreamBufferSpacesAvailable+0x32>

0800272c <xStreamBufferBytesAvailable>:
    configASSERT( pxStreamBuffer );
 800272c:	b140      	cbz	r0, 8002740 <xStreamBufferBytesAvailable+0x14>
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 800272e:	6882      	ldr	r2, [r0, #8]
 8002730:	6843      	ldr	r3, [r0, #4]
    xCount -= pxStreamBuffer->xTail;
 8002732:	6801      	ldr	r1, [r0, #0]
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 8002734:	18d0      	adds	r0, r2, r3
    xCount -= pxStreamBuffer->xTail;
 8002736:	1a40      	subs	r0, r0, r1
    if( xCount >= pxStreamBuffer->xLength )
 8002738:	4282      	cmp	r2, r0
        xCount -= pxStreamBuffer->xLength;
 800273a:	bf98      	it	ls
 800273c:	1a80      	subls	r0, r0, r2
}
 800273e:	4770      	bx	lr
 8002740:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002744:	f383 8811 	msr	BASEPRI, r3
 8002748:	f3bf 8f6f 	isb	sy
 800274c:	f3bf 8f4f 	dsb	sy
    configASSERT( pxStreamBuffer );
 8002750:	e7fe      	b.n	8002750 <xStreamBufferBytesAvailable+0x24>
 8002752:	bf00      	nop

08002754 <xStreamBufferSetTriggerLevel>:
    configASSERT( pxStreamBuffer );
 8002754:	4603      	mov	r3, r0
 8002756:	b150      	cbz	r0, 800276e <xStreamBufferSetTriggerLevel+0x1a>
    if( xTriggerLevel == ( size_t ) 0 )
 8002758:	2901      	cmp	r1, #1
    if( xTriggerLevel < pxStreamBuffer->xLength )
 800275a:	6882      	ldr	r2, [r0, #8]
 800275c:	bf38      	it	cc
 800275e:	2101      	movcc	r1, #1
 8002760:	428a      	cmp	r2, r1
 8002762:	d902      	bls.n	800276a <xStreamBufferSetTriggerLevel+0x16>
        xReturn = pdPASS;
 8002764:	2001      	movs	r0, #1
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
 8002766:	60d9      	str	r1, [r3, #12]
        xReturn = pdPASS;
 8002768:	4770      	bx	lr
        xReturn = pdFALSE;
 800276a:	2000      	movs	r0, #0
}
 800276c:	4770      	bx	lr
 800276e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002772:	f383 8811 	msr	BASEPRI, r3
 8002776:	f3bf 8f6f 	isb	sy
 800277a:	f3bf 8f4f 	dsb	sy
    configASSERT( pxStreamBuffer );
 800277e:	e7fe      	b.n	800277e <xStreamBufferSetTriggerLevel+0x2a>

08002780 <xStreamBufferSendCompletedFromISR>:
    configASSERT( pxStreamBuffer );
 8002780:	b1e8      	cbz	r0, 80027be <xStreamBufferSendCompletedFromISR+0x3e>
{
 8002782:	b5d0      	push	{r4, r6, r7, lr}
 8002784:	4604      	mov	r4, r0
 8002786:	b082      	sub	sp, #8
    __asm volatile
 8002788:	f3ef 8711 	mrs	r7, BASEPRI
 800278c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002790:	f383 8811 	msr	BASEPRI, r3
 8002794:	f3bf 8f6f 	isb	sy
 8002798:	f3bf 8f4f 	dsb	sy
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
 800279c:	6900      	ldr	r0, [r0, #16]
 800279e:	b150      	cbz	r0, 80027b6 <xStreamBufferSendCompletedFromISR+0x36>
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
 80027a0:	2600      	movs	r6, #0
 80027a2:	6920      	ldr	r0, [r4, #16]
 80027a4:	9101      	str	r1, [sp, #4]
 80027a6:	4633      	mov	r3, r6
 80027a8:	4632      	mov	r2, r6
 80027aa:	4631      	mov	r1, r6
 80027ac:	9600      	str	r6, [sp, #0]
 80027ae:	f000 ffd3 	bl	8003758 <xTaskGenericNotifyFromISR>
            xReturn = pdTRUE;
 80027b2:	2001      	movs	r0, #1
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
 80027b4:	6126      	str	r6, [r4, #16]
    __asm volatile
 80027b6:	f387 8811 	msr	BASEPRI, r7
}
 80027ba:	b002      	add	sp, #8
 80027bc:	bdd0      	pop	{r4, r6, r7, pc}
    __asm volatile
 80027be:	f04f 0350 	mov.w	r3, #80	; 0x50
 80027c2:	f383 8811 	msr	BASEPRI, r3
 80027c6:	f3bf 8f6f 	isb	sy
 80027ca:	f3bf 8f4f 	dsb	sy
    configASSERT( pxStreamBuffer );
 80027ce:	e7fe      	b.n	80027ce <xStreamBufferSendCompletedFromISR+0x4e>

080027d0 <xStreamBufferReceiveCompletedFromISR>:
    configASSERT( pxStreamBuffer );
 80027d0:	b1e8      	cbz	r0, 800280e <xStreamBufferReceiveCompletedFromISR+0x3e>
{
 80027d2:	b5d0      	push	{r4, r6, r7, lr}
 80027d4:	4604      	mov	r4, r0
 80027d6:	b082      	sub	sp, #8
    __asm volatile
 80027d8:	f3ef 8711 	mrs	r7, BASEPRI
 80027dc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80027e0:	f383 8811 	msr	BASEPRI, r3
 80027e4:	f3bf 8f6f 	isb	sy
 80027e8:	f3bf 8f4f 	dsb	sy
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
 80027ec:	6940      	ldr	r0, [r0, #20]
 80027ee:	b150      	cbz	r0, 8002806 <xStreamBufferReceiveCompletedFromISR+0x36>
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
 80027f0:	2600      	movs	r6, #0
 80027f2:	6960      	ldr	r0, [r4, #20]
 80027f4:	9101      	str	r1, [sp, #4]
 80027f6:	4633      	mov	r3, r6
 80027f8:	4632      	mov	r2, r6
 80027fa:	4631      	mov	r1, r6
 80027fc:	9600      	str	r6, [sp, #0]
 80027fe:	f000 ffab 	bl	8003758 <xTaskGenericNotifyFromISR>
            xReturn = pdTRUE;
 8002802:	2001      	movs	r0, #1
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
 8002804:	6166      	str	r6, [r4, #20]
    __asm volatile
 8002806:	f387 8811 	msr	BASEPRI, r7
}
 800280a:	b002      	add	sp, #8
 800280c:	bdd0      	pop	{r4, r6, r7, pc}
    __asm volatile
 800280e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002812:	f383 8811 	msr	BASEPRI, r3
 8002816:	f3bf 8f6f 	isb	sy
 800281a:	f3bf 8f4f 	dsb	sy
    configASSERT( pxStreamBuffer );
 800281e:	e7fe      	b.n	800281e <xStreamBufferReceiveCompletedFromISR+0x4e>

08002820 <xStreamBufferGenericCreate>:
        if( xIsMessageBuffer == pdTRUE )
 8002820:	2a01      	cmp	r2, #1
    {
 8002822:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002826:	4604      	mov	r4, r0
 8002828:	460e      	mov	r6, r1
        if( xIsMessageBuffer == pdTRUE )
 800282a:	d015      	beq.n	8002858 <xStreamBufferGenericCreate+0x38>
            configASSERT( xBufferSizeBytes > 0 );
 800282c:	b158      	cbz	r0, 8002846 <xStreamBufferGenericCreate+0x26>
            ucFlags = 0;
 800282e:	2500      	movs	r5, #0
        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
 8002830:	42b4      	cmp	r4, r6
 8002832:	d21c      	bcs.n	800286e <xStreamBufferGenericCreate+0x4e>
 8002834:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002838:	f383 8811 	msr	BASEPRI, r3
 800283c:	f3bf 8f6f 	isb	sy
 8002840:	f3bf 8f4f 	dsb	sy
 8002844:	e7fe      	b.n	8002844 <xStreamBufferGenericCreate+0x24>
 8002846:	f04f 0350 	mov.w	r3, #80	; 0x50
 800284a:	f383 8811 	msr	BASEPRI, r3
 800284e:	f3bf 8f6f 	isb	sy
 8002852:	f3bf 8f4f 	dsb	sy
            configASSERT( xBufferSizeBytes > 0 );
 8002856:	e7fe      	b.n	8002856 <xStreamBufferGenericCreate+0x36>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
 8002858:	2804      	cmp	r0, #4
 800285a:	d824      	bhi.n	80028a6 <xStreamBufferGenericCreate+0x86>
 800285c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002860:	f383 8811 	msr	BASEPRI, r3
 8002864:	f3bf 8f6f 	isb	sy
 8002868:	f3bf 8f4f 	dsb	sy
 800286c:	e7fe      	b.n	800286c <xStreamBufferGenericCreate+0x4c>
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
 800286e:	f114 0f26 	cmn.w	r4, #38	; 0x26
 8002872:	d81a      	bhi.n	80028aa <xStreamBufferGenericCreate+0x8a>
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
 8002874:	f104 0025 	add.w	r0, r4, #37	; 0x25
 8002878:	f003 f872 	bl	8005960 <pvPortMalloc>
        if( pucAllocatedMemory != NULL )
 800287c:	4607      	mov	r7, r0
 800287e:	b1a0      	cbz	r0, 80028aa <xStreamBufferGenericCreate+0x8a>
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
 8002880:	f100 0824 	add.w	r8, r0, #36	; 0x24
            xBufferSizeBytes++;
 8002884:	3401      	adds	r4, #1
            configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
 8002886:	2155      	movs	r1, #85	; 0x55
 8002888:	4622      	mov	r2, r4
 800288a:	4640      	mov	r0, r8
 800288c:	f011 fd40 	bl	8014310 <memset>
 8002890:	4580      	cmp	r8, r0
 8002892:	d00e      	beq.n	80028b2 <xStreamBufferGenericCreate+0x92>
 8002894:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002898:	f383 8811 	msr	BASEPRI, r3
 800289c:	f3bf 8f6f 	isb	sy
 80028a0:	f3bf 8f4f 	dsb	sy
 80028a4:	e7fe      	b.n	80028a4 <xStreamBufferGenericCreate+0x84>
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
 80028a6:	4615      	mov	r5, r2
 80028a8:	e7c2      	b.n	8002830 <xStreamBufferGenericCreate+0x10>
            pucAllocatedMemory = NULL;
 80028aa:	2700      	movs	r7, #0
    }
 80028ac:	4638      	mov	r0, r7
 80028ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
 80028b2:	2224      	movs	r2, #36	; 0x24
 80028b4:	2100      	movs	r1, #0
 80028b6:	4638      	mov	r0, r7
 80028b8:	f011 fd2a 	bl	8014310 <memset>
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 80028bc:	2e01      	cmp	r6, #1
    pxStreamBuffer->pucBuffer = pucBuffer;
 80028be:	f8c7 8018 	str.w	r8, [r7, #24]
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 80028c2:	bf38      	it	cc
 80028c4:	2601      	movcc	r6, #1
    pxStreamBuffer->ucFlags = ucFlags;
 80028c6:	773d      	strb	r5, [r7, #28]
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 80028c8:	e9c7 4602 	strd	r4, r6, [r7, #8]
        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
 80028cc:	e7ee      	b.n	80028ac <xStreamBufferGenericCreate+0x8c>
 80028ce:	bf00      	nop

080028d0 <xStreamBufferGenericCreateStatic>:
        configASSERT( pucStreamBufferStorageArea );
 80028d0:	b1cb      	cbz	r3, 8002906 <xStreamBufferGenericCreateStatic+0x36>
    {
 80028d2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80028d4:	b085      	sub	sp, #20
 80028d6:	460c      	mov	r4, r1
        configASSERT( pxStaticStreamBuffer );
 80028d8:	990a      	ldr	r1, [sp, #40]	; 0x28
 80028da:	b159      	cbz	r1, 80028f4 <xStreamBufferGenericCreateStatic+0x24>
        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
 80028dc:	4284      	cmp	r4, r0
 80028de:	4605      	mov	r5, r0
 80028e0:	d91a      	bls.n	8002918 <xStreamBufferGenericCreateStatic+0x48>
 80028e2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80028e6:	f383 8811 	msr	BASEPRI, r3
 80028ea:	f3bf 8f6f 	isb	sy
 80028ee:	f3bf 8f4f 	dsb	sy
 80028f2:	e7fe      	b.n	80028f2 <xStreamBufferGenericCreateStatic+0x22>
 80028f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80028f8:	f383 8811 	msr	BASEPRI, r3
 80028fc:	f3bf 8f6f 	isb	sy
 8002900:	f3bf 8f4f 	dsb	sy
        configASSERT( pxStaticStreamBuffer );
 8002904:	e7fe      	b.n	8002904 <xStreamBufferGenericCreateStatic+0x34>
 8002906:	f04f 0350 	mov.w	r3, #80	; 0x50
 800290a:	f383 8811 	msr	BASEPRI, r3
 800290e:	f3bf 8f6f 	isb	sy
 8002912:	f3bf 8f4f 	dsb	sy
        configASSERT( pucStreamBufferStorageArea );
 8002916:	e7fe      	b.n	8002916 <xStreamBufferGenericCreateStatic+0x46>
            ucFlags = sbFLAGS_IS_STATICALLY_ALLOCATED;
 8002918:	2a00      	cmp	r2, #0
 800291a:	bf14      	ite	ne
 800291c:	2603      	movne	r6, #3
 800291e:	2602      	moveq	r6, #2
        configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
 8002920:	2804      	cmp	r0, #4
 8002922:	d90d      	bls.n	8002940 <xStreamBufferGenericCreateStatic+0x70>
                volatile size_t xSize = sizeof( StaticStreamBuffer_t );
 8002924:	2224      	movs	r2, #36	; 0x24
 8002926:	9203      	str	r2, [sp, #12]
                configASSERT( xSize == sizeof( StreamBuffer_t ) );
 8002928:	9f03      	ldr	r7, [sp, #12]
 800292a:	4297      	cmp	r7, r2
 800292c:	d011      	beq.n	8002952 <xStreamBufferGenericCreateStatic+0x82>
 800292e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002932:	f383 8811 	msr	BASEPRI, r3
 8002936:	f3bf 8f6f 	isb	sy
 800293a:	f3bf 8f4f 	dsb	sy
 800293e:	e7fe      	b.n	800293e <xStreamBufferGenericCreateStatic+0x6e>
 8002940:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002944:	f383 8811 	msr	BASEPRI, r3
 8002948:	f3bf 8f6f 	isb	sy
 800294c:	f3bf 8f4f 	dsb	sy
        configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
 8002950:	e7fe      	b.n	8002950 <xStreamBufferGenericCreateStatic+0x80>
            configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
 8002952:	4602      	mov	r2, r0
 8002954:	2155      	movs	r1, #85	; 0x55
 8002956:	4618      	mov	r0, r3
 8002958:	f011 fcda 	bl	8014310 <memset>
 800295c:	4280      	cmp	r0, r0
 800295e:	d008      	beq.n	8002972 <xStreamBufferGenericCreateStatic+0xa2>
 8002960:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002964:	f383 8811 	msr	BASEPRI, r3
 8002968:	f3bf 8f6f 	isb	sy
 800296c:	f3bf 8f4f 	dsb	sy
 8002970:	e7fe      	b.n	8002970 <xStreamBufferGenericCreateStatic+0xa0>
    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
 8002972:	463a      	mov	r2, r7
 8002974:	9001      	str	r0, [sp, #4]
 8002976:	2100      	movs	r1, #0
 8002978:	980a      	ldr	r0, [sp, #40]	; 0x28
 800297a:	f011 fcc9 	bl	8014310 <memset>
    pxStreamBuffer->pucBuffer = pucBuffer;
 800297e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 8002980:	2c01      	cmp	r4, #1
    pxStreamBuffer->pucBuffer = pucBuffer;
 8002982:	9b01      	ldr	r3, [sp, #4]
    }
 8002984:	4610      	mov	r0, r2
    pxStreamBuffer->ucFlags = ucFlags;
 8002986:	7716      	strb	r6, [r2, #28]
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 8002988:	bf38      	it	cc
 800298a:	2401      	movcc	r4, #1
    pxStreamBuffer->pucBuffer = pucBuffer;
 800298c:	6193      	str	r3, [r2, #24]
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 800298e:	e9c2 5402 	strd	r5, r4, [r2, #8]
    }
 8002992:	b005      	add	sp, #20
 8002994:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002996:	bf00      	nop

08002998 <xStreamBufferNextMessageLengthBytes>:
    configASSERT( pxStreamBuffer );
 8002998:	b1c8      	cbz	r0, 80029ce <xStreamBufferNextMessageLengthBytes+0x36>
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 800299a:	7f03      	ldrb	r3, [r0, #28]
 800299c:	f013 0301 	ands.w	r3, r3, #1
 80029a0:	d013      	beq.n	80029ca <xStreamBufferNextMessageLengthBytes+0x32>
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 80029a2:	6882      	ldr	r2, [r0, #8]
 80029a4:	6843      	ldr	r3, [r0, #4]
    xCount -= pxStreamBuffer->xTail;
 80029a6:	6801      	ldr	r1, [r0, #0]
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 80029a8:	4413      	add	r3, r2
    xCount -= pxStreamBuffer->xTail;
 80029aa:	1a5b      	subs	r3, r3, r1
    if( xCount >= pxStreamBuffer->xLength )
 80029ac:	429a      	cmp	r2, r3
        xCount -= pxStreamBuffer->xLength;
 80029ae:	bf98      	it	ls
 80029b0:	1a9b      	subls	r3, r3, r2
        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
 80029b2:	2b04      	cmp	r3, #4
 80029b4:	d814      	bhi.n	80029e0 <xStreamBufferNextMessageLengthBytes+0x48>
            configASSERT( xBytesAvailable == 0 );
 80029b6:	b143      	cbz	r3, 80029ca <xStreamBufferNextMessageLengthBytes+0x32>
 80029b8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80029bc:	f383 8811 	msr	BASEPRI, r3
 80029c0:	f3bf 8f6f 	isb	sy
 80029c4:	f3bf 8f4f 	dsb	sy
 80029c8:	e7fe      	b.n	80029c8 <xStreamBufferNextMessageLengthBytes+0x30>
}
 80029ca:	4618      	mov	r0, r3
 80029cc:	4770      	bx	lr
 80029ce:	f04f 0350 	mov.w	r3, #80	; 0x50
 80029d2:	f383 8811 	msr	BASEPRI, r3
 80029d6:	f3bf 8f6f 	isb	sy
 80029da:	f3bf 8f4f 	dsb	sy
    configASSERT( pxStreamBuffer );
 80029de:	e7fe      	b.n	80029de <xStreamBufferNextMessageLengthBytes+0x46>
{
 80029e0:	b500      	push	{lr}
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
 80029e2:	2204      	movs	r2, #4
{
 80029e4:	b083      	sub	sp, #12
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
 80029e6:	6803      	ldr	r3, [r0, #0]
 80029e8:	eb0d 0102 	add.w	r1, sp, r2
 80029ec:	f7ff fb76 	bl	80020dc <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
 80029f0:	9b01      	ldr	r3, [sp, #4]
}
 80029f2:	4618      	mov	r0, r3
 80029f4:	b003      	add	sp, #12
 80029f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80029fa:	bf00      	nop

080029fc <vStreamBufferSetStreamBufferNumber>:
#if ( configUSE_TRACE_FACILITY == 1 )

    void vStreamBufferSetStreamBufferNumber( StreamBufferHandle_t xStreamBuffer,
                                             UBaseType_t uxStreamBufferNumber )
    {
        xStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
 80029fc:	6201      	str	r1, [r0, #32]
    }
 80029fe:	4770      	bx	lr

08002a00 <uxStreamBufferGetStreamBufferNumber>:
    }
 8002a00:	6a00      	ldr	r0, [r0, #32]
 8002a02:	4770      	bx	lr

08002a04 <ucStreamBufferGetStreamBufferType>:

#if ( configUSE_TRACE_FACILITY == 1 )

    uint8_t ucStreamBufferGetStreamBufferType( StreamBufferHandle_t xStreamBuffer )
    {
        return( xStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER );
 8002a04:	7f00      	ldrb	r0, [r0, #28]
    }
 8002a06:	f000 0001 	and.w	r0, r0, #1
 8002a0a:	4770      	bx	lr

08002a0c <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
 8002a0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
 8002a0e:	4c1d      	ldr	r4, [pc, #116]	; (8002a84 <prvAddCurrentTaskToDelayedList+0x78>)
{
 8002a10:	4605      	mov	r5, r0
 8002a12:	460f      	mov	r7, r1
    const TickType_t xConstTickCount = xTickCount;
 8002a14:	6826      	ldr	r6, [r4, #0]
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8002a16:	6863      	ldr	r3, [r4, #4]
 8002a18:	f103 0084 	add.w	r0, r3, #132	; 0x84
 8002a1c:	f7fd fedc 	bl	80007d8 <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8002a20:	1c6b      	adds	r3, r5, #1
 8002a22:	d118      	bne.n	8002a56 <prvAddCurrentTaskToDelayedList+0x4a>
 8002a24:	b1bf      	cbz	r7, 8002a56 <prvAddCurrentTaskToDelayedList+0x4a>
            {
                /* Add the task to the suspended task list instead of a delayed task
                 * list to ensure it is not woken by a timing event.  It will block
                 * indefinitely. */
                listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8002a26:	68e3      	ldr	r3, [r4, #12]
 8002a28:	6860      	ldr	r0, [r4, #4]
 8002a2a:	6899      	ldr	r1, [r3, #8]
 8002a2c:	6862      	ldr	r2, [r4, #4]
 8002a2e:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
 8002a32:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
 8002a36:	6861      	ldr	r1, [r4, #4]
 8002a38:	689d      	ldr	r5, [r3, #8]
 8002a3a:	3184      	adds	r1, #132	; 0x84
 8002a3c:	6862      	ldr	r2, [r4, #4]
 8002a3e:	6860      	ldr	r0, [r4, #4]
 8002a40:	6069      	str	r1, [r5, #4]
 8002a42:	3284      	adds	r2, #132	; 0x84
 8002a44:	68a1      	ldr	r1, [r4, #8]
 8002a46:	f104 0508 	add.w	r5, r4, #8
 8002a4a:	609a      	str	r2, [r3, #8]
 8002a4c:	3101      	adds	r1, #1
 8002a4e:	f8c0 5094 	str.w	r5, [r0, #148]	; 0x94
 8002a52:	60a1      	str	r1, [r4, #8]

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
 8002a54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                xTimeToWake = xConstTickCount + xTicksToWait;
 8002a56:	1975      	adds	r5, r6, r5
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8002a58:	6863      	ldr	r3, [r4, #4]
 8002a5a:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
                if( xTimeToWake < xConstTickCount )
 8002a5e:	d306      	bcc.n	8002a6e <prvAddCurrentTaskToDelayedList+0x62>
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8002a60:	69e0      	ldr	r0, [r4, #28]
 8002a62:	6861      	ldr	r1, [r4, #4]
}
 8002a64:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8002a68:	3184      	adds	r1, #132	; 0x84
 8002a6a:	f7fd be8d 	b.w	8000788 <vListInsert>
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8002a6e:	6a20      	ldr	r0, [r4, #32]
 8002a70:	6861      	ldr	r1, [r4, #4]
 8002a72:	3184      	adds	r1, #132	; 0x84
 8002a74:	f7fd fe88 	bl	8000788 <vListInsert>
                    if( xTimeToWake < xNextTaskUnblockTime )
 8002a78:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002a7a:	42ab      	cmp	r3, r5
 8002a7c:	d9ea      	bls.n	8002a54 <prvAddCurrentTaskToDelayedList+0x48>
                        xNextTaskUnblockTime = xTimeToWake;
 8002a7e:	6265      	str	r5, [r4, #36]	; 0x24
}
 8002a80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002a82:	bf00      	nop
 8002a84:	24000040 	.word	0x24000040

08002a88 <prvInitialiseNewTask>:
{
 8002a88:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002a8c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8002a8e:	ea4f 0882 	mov.w	r8, r2, lsl #2
{
 8002a92:	4689      	mov	r9, r1
 8002a94:	461f      	mov	r7, r3
        uxPriority &= ~portPRIVILEGE_BIT;
 8002a96:	9b0a      	ldr	r3, [sp, #40]	; 0x28
{
 8002a98:	4615      	mov	r5, r2
 8002a9a:	4606      	mov	r6, r0
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8002a9c:	21a5      	movs	r1, #165	; 0xa5
 8002a9e:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
 8002aa2:	4642      	mov	r2, r8
        uxPriority &= ~portPRIVILEGE_BIT;
 8002aa4:	f023 4b00 	bic.w	fp, r3, #2147483648	; 0x80000000
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8002aa8:	f011 fc32 	bl	8014310 <memset>
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8002aac:	f8d4 a0b0 	ldr.w	sl, [r4, #176]	; 0xb0
    if( pcName != NULL )
 8002ab0:	f1b9 0f00 	cmp.w	r9, #0
 8002ab4:	f000 80cb 	beq.w	8002c4e <prvInitialiseNewTask+0x1c6>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002ab8:	f899 3000 	ldrb.w	r3, [r9]
 8002abc:	f884 30b4 	strb.w	r3, [r4, #180]	; 0xb4
            if( pcName[ x ] == ( char ) 0x00 )
 8002ac0:	f899 3000 	ldrb.w	r3, [r9]
 8002ac4:	2b00      	cmp	r3, #0
 8002ac6:	d06a      	beq.n	8002b9e <prvInitialiseNewTask+0x116>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002ac8:	f899 3001 	ldrb.w	r3, [r9, #1]
 8002acc:	f884 30b5 	strb.w	r3, [r4, #181]	; 0xb5
            if( pcName[ x ] == ( char ) 0x00 )
 8002ad0:	f899 3001 	ldrb.w	r3, [r9, #1]
 8002ad4:	2b00      	cmp	r3, #0
 8002ad6:	d062      	beq.n	8002b9e <prvInitialiseNewTask+0x116>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002ad8:	f899 3002 	ldrb.w	r3, [r9, #2]
 8002adc:	f884 30b6 	strb.w	r3, [r4, #182]	; 0xb6
            if( pcName[ x ] == ( char ) 0x00 )
 8002ae0:	f899 3002 	ldrb.w	r3, [r9, #2]
 8002ae4:	2b00      	cmp	r3, #0
 8002ae6:	d05a      	beq.n	8002b9e <prvInitialiseNewTask+0x116>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002ae8:	f899 3003 	ldrb.w	r3, [r9, #3]
 8002aec:	f884 30b7 	strb.w	r3, [r4, #183]	; 0xb7
            if( pcName[ x ] == ( char ) 0x00 )
 8002af0:	f899 3003 	ldrb.w	r3, [r9, #3]
 8002af4:	2b00      	cmp	r3, #0
 8002af6:	d052      	beq.n	8002b9e <prvInitialiseNewTask+0x116>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002af8:	f899 3004 	ldrb.w	r3, [r9, #4]
 8002afc:	f884 30b8 	strb.w	r3, [r4, #184]	; 0xb8
            if( pcName[ x ] == ( char ) 0x00 )
 8002b00:	f899 3004 	ldrb.w	r3, [r9, #4]
 8002b04:	2b00      	cmp	r3, #0
 8002b06:	d04a      	beq.n	8002b9e <prvInitialiseNewTask+0x116>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002b08:	f899 3005 	ldrb.w	r3, [r9, #5]
 8002b0c:	f884 30b9 	strb.w	r3, [r4, #185]	; 0xb9
            if( pcName[ x ] == ( char ) 0x00 )
 8002b10:	f899 3005 	ldrb.w	r3, [r9, #5]
 8002b14:	2b00      	cmp	r3, #0
 8002b16:	d042      	beq.n	8002b9e <prvInitialiseNewTask+0x116>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002b18:	f899 3006 	ldrb.w	r3, [r9, #6]
 8002b1c:	f884 30ba 	strb.w	r3, [r4, #186]	; 0xba
            if( pcName[ x ] == ( char ) 0x00 )
 8002b20:	f899 3006 	ldrb.w	r3, [r9, #6]
 8002b24:	b3db      	cbz	r3, 8002b9e <prvInitialiseNewTask+0x116>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002b26:	f899 3007 	ldrb.w	r3, [r9, #7]
 8002b2a:	f884 30bb 	strb.w	r3, [r4, #187]	; 0xbb
            if( pcName[ x ] == ( char ) 0x00 )
 8002b2e:	f899 3007 	ldrb.w	r3, [r9, #7]
 8002b32:	b3a3      	cbz	r3, 8002b9e <prvInitialiseNewTask+0x116>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002b34:	f899 3008 	ldrb.w	r3, [r9, #8]
 8002b38:	f884 30bc 	strb.w	r3, [r4, #188]	; 0xbc
            if( pcName[ x ] == ( char ) 0x00 )
 8002b3c:	f899 3008 	ldrb.w	r3, [r9, #8]
 8002b40:	b36b      	cbz	r3, 8002b9e <prvInitialiseNewTask+0x116>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002b42:	f899 3009 	ldrb.w	r3, [r9, #9]
 8002b46:	f884 30bd 	strb.w	r3, [r4, #189]	; 0xbd
            if( pcName[ x ] == ( char ) 0x00 )
 8002b4a:	f899 3009 	ldrb.w	r3, [r9, #9]
 8002b4e:	b333      	cbz	r3, 8002b9e <prvInitialiseNewTask+0x116>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002b50:	f899 300a 	ldrb.w	r3, [r9, #10]
 8002b54:	f884 30be 	strb.w	r3, [r4, #190]	; 0xbe
            if( pcName[ x ] == ( char ) 0x00 )
 8002b58:	f899 300a 	ldrb.w	r3, [r9, #10]
 8002b5c:	b1fb      	cbz	r3, 8002b9e <prvInitialiseNewTask+0x116>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002b5e:	f899 300b 	ldrb.w	r3, [r9, #11]
 8002b62:	f884 30bf 	strb.w	r3, [r4, #191]	; 0xbf
            if( pcName[ x ] == ( char ) 0x00 )
 8002b66:	f899 300b 	ldrb.w	r3, [r9, #11]
 8002b6a:	b1c3      	cbz	r3, 8002b9e <prvInitialiseNewTask+0x116>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002b6c:	f899 300c 	ldrb.w	r3, [r9, #12]
 8002b70:	f884 30c0 	strb.w	r3, [r4, #192]	; 0xc0
            if( pcName[ x ] == ( char ) 0x00 )
 8002b74:	f899 300c 	ldrb.w	r3, [r9, #12]
 8002b78:	b18b      	cbz	r3, 8002b9e <prvInitialiseNewTask+0x116>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002b7a:	f899 300d 	ldrb.w	r3, [r9, #13]
 8002b7e:	f884 30c1 	strb.w	r3, [r4, #193]	; 0xc1
            if( pcName[ x ] == ( char ) 0x00 )
 8002b82:	f899 300d 	ldrb.w	r3, [r9, #13]
 8002b86:	b153      	cbz	r3, 8002b9e <prvInitialiseNewTask+0x116>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002b88:	f899 300e 	ldrb.w	r3, [r9, #14]
 8002b8c:	f884 30c2 	strb.w	r3, [r4, #194]	; 0xc2
            if( pcName[ x ] == ( char ) 0x00 )
 8002b90:	f899 300e 	ldrb.w	r3, [r9, #14]
 8002b94:	b11b      	cbz	r3, 8002b9e <prvInitialiseNewTask+0x116>
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002b96:	f899 300f 	ldrb.w	r3, [r9, #15]
 8002b9a:	f884 30c3 	strb.w	r3, [r4, #195]	; 0xc3
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8002b9e:	2300      	movs	r3, #0
 8002ba0:	f884 30c3 	strb.w	r3, [r4, #195]	; 0xc3
    configASSERT( uxPriority < configMAX_PRIORITIES );
 8002ba4:	f1bb 0f37 	cmp.w	fp, #55	; 0x37
 8002ba8:	d908      	bls.n	8002bbc <prvInitialiseNewTask+0x134>
 8002baa:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002bae:	f383 8811 	msr	BASEPRI, r3
 8002bb2:	f3bf 8f6f 	isb	sy
 8002bb6:	f3bf 8f4f 	dsb	sy
 8002bba:	e7fe      	b.n	8002bba <prvInitialiseNewTask+0x132>
            pxNewTCB->uxMutexesHeld = 0;
 8002bbc:	f04f 0900 	mov.w	r9, #0
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8002bc0:	f104 0084 	add.w	r0, r4, #132	; 0x84
    pxNewTCB->uxPriority = uxPriority;
 8002bc4:	f8c4 b0ac 	str.w	fp, [r4, #172]	; 0xac
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8002bc8:	f1a8 0804 	sub.w	r8, r8, #4
            pxNewTCB->uxBasePriority = uxPriority;
 8002bcc:	f8c4 b0cc 	str.w	fp, [r4, #204]	; 0xcc
            pxNewTCB->uxMutexesHeld = 0;
 8002bd0:	f8c4 90d0 	str.w	r9, [r4, #208]	; 0xd0
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8002bd4:	44d0      	add	r8, sl
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8002bd6:	f7fd fdd3 	bl	8000780 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8002bda:	f104 0098 	add.w	r0, r4, #152	; 0x98
 8002bde:	f7fd fdcf 	bl	8000780 <vListInitialiseItem>
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002be2:	f1cb 0338 	rsb	r3, fp, #56	; 0x38
            vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
 8002be6:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
 8002bea:	1d20      	adds	r0, r4, #4
 8002bec:	990d      	ldr	r1, [sp, #52]	; 0x34
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002bee:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
            vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
 8002bf2:	462b      	mov	r3, r5
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8002bf4:	f8c4 4090 	str.w	r4, [r4, #144]	; 0x90
            _REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 8002bf8:	4d16      	ldr	r5, [pc, #88]	; (8002c54 <prvInitialiseNewTask+0x1cc>)
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8002bfa:	f8c4 40a4 	str.w	r4, [r4, #164]	; 0xa4
            vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
 8002bfe:	f002 fc7b 	bl	80054f8 <vPortStoreTaskMPUSettings>
            _REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 8002c02:	4649      	mov	r1, r9
 8002c04:	2260      	movs	r2, #96	; 0x60
 8002c06:	f104 00d4 	add.w	r0, r4, #212	; 0xd4
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
 8002c0a:	f8c4 9134 	str.w	r9, [r4, #308]	; 0x134
 8002c0e:	f8c4 9138 	str.w	r9, [r4, #312]	; 0x138
 8002c12:	f8c4 913c 	str.w	r9, [r4, #316]	; 0x13c
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
 8002c16:	f8a4 9140 	strh.w	r9, [r4, #320]	; 0x140
 8002c1a:	f884 9142 	strb.w	r9, [r4, #322]	; 0x142
            _REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 8002c1e:	f011 fb77 	bl	8014310 <memset>
 8002c22:	f8c4 50d8 	str.w	r5, [r4, #216]	; 0xd8
 8002c26:	4d0c      	ldr	r5, [pc, #48]	; (8002c58 <prvInitialiseNewTask+0x1d0>)
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
 8002c28:	463a      	mov	r2, r7
 8002c2a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002c2c:	4631      	mov	r1, r6
            _REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 8002c2e:	f8c4 50dc 	str.w	r5, [r4, #220]	; 0xdc
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
 8002c32:	f028 0007 	bic.w	r0, r8, #7
            _REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 8002c36:	4d09      	ldr	r5, [pc, #36]	; (8002c5c <prvInitialiseNewTask+0x1d4>)
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
 8002c38:	0fdb      	lsrs	r3, r3, #31
            _REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 8002c3a:	f8c4 50e0 	str.w	r5, [r4, #224]	; 0xe0
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
 8002c3e:	f002 fc2f 	bl	80054a0 <pxPortInitialiseStack>
    if( pxCreatedTask != NULL )
 8002c42:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
 8002c44:	6020      	str	r0, [r4, #0]
    if( pxCreatedTask != NULL )
 8002c46:	b103      	cbz	r3, 8002c4a <prvInitialiseNewTask+0x1c2>
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8002c48:	601c      	str	r4, [r3, #0]
}
 8002c4a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
 8002c4e:	f884 90b4 	strb.w	r9, [r4, #180]	; 0xb4
 8002c52:	e7a7      	b.n	8002ba4 <prvInitialiseNewTask+0x11c>
 8002c54:	2400853c 	.word	0x2400853c
 8002c58:	2400855c 	.word	0x2400855c
 8002c5c:	2400851c 	.word	0x2400851c

08002c60 <prvAddNewTaskToReadyList>:
{
 8002c60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        uxCurrentNumberOfTasks++;
 8002c64:	4d3f      	ldr	r5, [pc, #252]	; (8002d64 <prvAddNewTaskToReadyList+0x104>)
{
 8002c66:	4606      	mov	r6, r0
    taskENTER_CRITICAL();
 8002c68:	f006 ffc6 	bl	8009bf8 <vPortEnterCritical>
        uxCurrentNumberOfTasks++;
 8002c6c:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002c6e:	3301      	adds	r3, #1
 8002c70:	62ab      	str	r3, [r5, #40]	; 0x28
        if( pxCurrentTCB == NULL )
 8002c72:	686b      	ldr	r3, [r5, #4]
 8002c74:	2b00      	cmp	r3, #0
 8002c76:	d04d      	beq.n	8002d14 <prvAddNewTaskToReadyList+0xb4>
            if( xSchedulerRunning == pdFALSE )
 8002c78:	f8d5 34dc 	ldr.w	r3, [r5, #1244]	; 0x4dc
 8002c7c:	2b00      	cmp	r3, #0
 8002c7e:	d03e      	beq.n	8002cfe <prvAddNewTaskToReadyList+0x9e>
        prvAddTaskToReadyList( pxNewTCB );
 8002c80:	f8d6 30ac 	ldr.w	r3, [r6, #172]	; 0xac
 8002c84:	f105 072c 	add.w	r7, r5, #44	; 0x2c
        uxTaskNumber++;
 8002c88:	f8d5 24e0 	ldr.w	r2, [r5, #1248]	; 0x4e0
 8002c8c:	3201      	adds	r2, #1
 8002c8e:	f8c5 24e0 	str.w	r2, [r5, #1248]	; 0x4e0
                pxNewTCB->uxTCBNumber = uxTaskNumber;
 8002c92:	f8c6 20c4 	str.w	r2, [r6, #196]	; 0xc4
        prvAddTaskToReadyList( pxNewTCB );
 8002c96:	f8d5 24e4 	ldr.w	r2, [r5, #1252]	; 0x4e4
 8002c9a:	429a      	cmp	r2, r3
 8002c9c:	d201      	bcs.n	8002ca2 <prvAddNewTaskToReadyList+0x42>
 8002c9e:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
 8002ca2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8002ca6:	eb05 0083 	add.w	r0, r5, r3, lsl #2
 8002caa:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 8002cae:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8002cb0:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
 8002cb2:	6891      	ldr	r1, [r2, #8]
 8002cb4:	3701      	adds	r7, #1
 8002cb6:	f8c6 2088 	str.w	r2, [r6, #136]	; 0x88
 8002cba:	f8c6 108c 	str.w	r1, [r6, #140]	; 0x8c
 8002cbe:	f106 0184 	add.w	r1, r6, #132	; 0x84
 8002cc2:	6894      	ldr	r4, [r2, #8]
 8002cc4:	6061      	str	r1, [r4, #4]
 8002cc6:	6091      	str	r1, [r2, #8]
 8002cc8:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
 8002ccc:	62c7      	str	r7, [r0, #44]	; 0x2c
    taskEXIT_CRITICAL();
 8002cce:	f006 ffa9 	bl	8009c24 <vPortExitCritical>
    if( xSchedulerRunning != pdFALSE )
 8002cd2:	f8d5 34dc 	ldr.w	r3, [r5, #1244]	; 0x4dc
 8002cd6:	b183      	cbz	r3, 8002cfa <prvAddNewTaskToReadyList+0x9a>
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8002cd8:	686a      	ldr	r2, [r5, #4]
 8002cda:	f8d6 30ac 	ldr.w	r3, [r6, #172]	; 0xac
 8002cde:	f8d2 20ac 	ldr.w	r2, [r2, #172]	; 0xac
 8002ce2:	429a      	cmp	r2, r3
 8002ce4:	d209      	bcs.n	8002cfa <prvAddNewTaskToReadyList+0x9a>
            taskYIELD_IF_USING_PREEMPTION();
 8002ce6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8002cea:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002cee:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8002cf2:	f3bf 8f4f 	dsb	sy
 8002cf6:	f3bf 8f6f 	isb	sy
}
 8002cfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8002cfe:	686a      	ldr	r2, [r5, #4]
 8002d00:	f105 072c 	add.w	r7, r5, #44	; 0x2c
 8002d04:	f8d6 30ac 	ldr.w	r3, [r6, #172]	; 0xac
 8002d08:	f8d2 20ac 	ldr.w	r2, [r2, #172]	; 0xac
 8002d0c:	429a      	cmp	r2, r3
 8002d0e:	d8bb      	bhi.n	8002c88 <prvAddNewTaskToReadyList+0x28>
                    pxCurrentTCB = pxNewTCB;
 8002d10:	606e      	str	r6, [r5, #4]
 8002d12:	e7b9      	b.n	8002c88 <prvAddNewTaskToReadyList+0x28>
            pxCurrentTCB = pxNewTCB;
 8002d14:	606e      	str	r6, [r5, #4]
            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8002d16:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002d18:	2b01      	cmp	r3, #1
 8002d1a:	d1b1      	bne.n	8002c80 <prvAddNewTaskToReadyList+0x20>
 8002d1c:	f105 072c 	add.w	r7, r5, #44	; 0x2c
 8002d20:	f205 488c 	addw	r8, r5, #1164	; 0x48c
 8002d24:	463c      	mov	r4, r7
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8002d26:	4620      	mov	r0, r4
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8002d28:	3414      	adds	r4, #20
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8002d2a:	f7fd fd1d 	bl	8000768 <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8002d2e:	45a0      	cmp	r8, r4
 8002d30:	d1f9      	bne.n	8002d26 <prvAddNewTaskToReadyList+0xc6>
    vListInitialise( &xDelayedTaskList2 );
 8002d32:	4c0d      	ldr	r4, [pc, #52]	; (8002d68 <prvAddNewTaskToReadyList+0x108>)
    vListInitialise( &xDelayedTaskList1 );
 8002d34:	480d      	ldr	r0, [pc, #52]	; (8002d6c <prvAddNewTaskToReadyList+0x10c>)
 8002d36:	f7fd fd17 	bl	8000768 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
 8002d3a:	4620      	mov	r0, r4
 8002d3c:	f7fd fd14 	bl	8000768 <vListInitialise>
    vListInitialise( &xPendingReadyList );
 8002d40:	f104 0014 	add.w	r0, r4, #20
 8002d44:	f7fd fd10 	bl	8000768 <vListInitialise>
            vListInitialise( &xTasksWaitingTermination );
 8002d48:	f104 0028 	add.w	r0, r4, #40	; 0x28
 8002d4c:	f7fd fd0c 	bl	8000768 <vListInitialise>
            vListInitialise( &xSuspendedTaskList );
 8002d50:	f5a4 6093 	sub.w	r0, r4, #1176	; 0x498
 8002d54:	f7fd fd08 	bl	8000768 <vListInitialise>
    pxDelayedTaskList = &xDelayedTaskList1;
 8002d58:	f8c5 8020 	str.w	r8, [r5, #32]
        prvAddTaskToReadyList( pxNewTCB );
 8002d5c:	f8d6 30ac 	ldr.w	r3, [r6, #172]	; 0xac
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8002d60:	61ec      	str	r4, [r5, #28]
}
 8002d62:	e791      	b.n	8002c88 <prvAddNewTaskToReadyList+0x28>
 8002d64:	24000040 	.word	0x24000040
 8002d68:	240004e0 	.word	0x240004e0
 8002d6c:	240004cc 	.word	0x240004cc

08002d70 <prvIdleTask>:
{
 8002d70:	4c1f      	ldr	r4, [pc, #124]	; (8002df0 <prvIdleTask+0x80>)
 8002d72:	b508      	push	{r3, lr}
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8002d74:	f8d4 34e8 	ldr.w	r3, [r4, #1256]	; 0x4e8
 8002d78:	b38b      	cbz	r3, 8002dde <prvIdleTask+0x6e>
                taskENTER_CRITICAL();
 8002d7a:	f006 ff3d 	bl	8009bf8 <vPortEnterCritical>
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8002d7e:	f8d4 34d4 	ldr.w	r3, [r4, #1236]	; 0x4d4
 8002d82:	68dd      	ldr	r5, [r3, #12]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8002d84:	f105 0084 	add.w	r0, r5, #132	; 0x84
 8002d88:	f7fd fd26 	bl	80007d8 <uxListRemove>
                    --uxCurrentNumberOfTasks;
 8002d8c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002d8e:	3b01      	subs	r3, #1
 8002d90:	62a3      	str	r3, [r4, #40]	; 0x28
                    --uxDeletedTasksWaitingCleanUp;
 8002d92:	f8d4 34e8 	ldr.w	r3, [r4, #1256]	; 0x4e8
 8002d96:	3b01      	subs	r3, #1
 8002d98:	f8c4 34e8 	str.w	r3, [r4, #1256]	; 0x4e8
                taskEXIT_CRITICAL();
 8002d9c:	f006 ff42 	bl	8009c24 <vPortExitCritical>
                _reclaim_reent( &( pxTCB->xNewLib_reent ) );
 8002da0:	f105 00d4 	add.w	r0, r5, #212	; 0xd4
 8002da4:	f011 fc38 	bl	8014618 <_reclaim_reent>
                if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 8002da8:	f895 3143 	ldrb.w	r3, [r5, #323]	; 0x143
 8002dac:	b163      	cbz	r3, 8002dc8 <prvIdleTask+0x58>
                else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 8002dae:	2b01      	cmp	r3, #1
 8002db0:	d01a      	beq.n	8002de8 <prvIdleTask+0x78>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
 8002db2:	2b02      	cmp	r3, #2
 8002db4:	d0de      	beq.n	8002d74 <prvIdleTask+0x4>
 8002db6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002dba:	f383 8811 	msr	BASEPRI, r3
 8002dbe:	f3bf 8f6f 	isb	sy
 8002dc2:	f3bf 8f4f 	dsb	sy
 8002dc6:	e7fe      	b.n	8002dc6 <prvIdleTask+0x56>
                    vPortFreeStack( pxTCB->pxStack );
 8002dc8:	f8d5 00b0 	ldr.w	r0, [r5, #176]	; 0xb0
 8002dcc:	f002 fe78 	bl	8005ac0 <vPortFree>
                    vPortFree( pxTCB );
 8002dd0:	4628      	mov	r0, r5
 8002dd2:	f002 fe75 	bl	8005ac0 <vPortFree>
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8002dd6:	f8d4 34e8 	ldr.w	r3, [r4, #1256]	; 0x4e8
 8002dda:	2b00      	cmp	r3, #0
 8002ddc:	d1cd      	bne.n	8002d7a <prvIdleTask+0xa>
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8002dde:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002de0:	2b01      	cmp	r3, #1
 8002de2:	d9c7      	bls.n	8002d74 <prvIdleTask+0x4>
                    taskYIELD();
 8002de4:	df01      	svc	1
 8002de6:	e7c5      	b.n	8002d74 <prvIdleTask+0x4>
                    vPortFree( pxTCB );
 8002de8:	4628      	mov	r0, r5
 8002dea:	f002 fe69 	bl	8005ac0 <vPortFree>
 8002dee:	e7c1      	b.n	8002d74 <prvIdleTask+0x4>
 8002df0:	24000040 	.word	0x24000040

08002df4 <xTaskCreate>:
    {
 8002df4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002df8:	4607      	mov	r7, r0
 8002dfa:	b085      	sub	sp, #20
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8002dfc:	0090      	lsls	r0, r2, #2
    {
 8002dfe:	4615      	mov	r5, r2
 8002e00:	4688      	mov	r8, r1
 8002e02:	4699      	mov	r9, r3
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8002e04:	f002 fdac 	bl	8005960 <pvPortMalloc>
                if( pxStack != NULL )
 8002e08:	b1f0      	cbz	r0, 8002e48 <xTaskCreate+0x54>
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 8002e0a:	4604      	mov	r4, r0
 8002e0c:	f44f 70a2 	mov.w	r0, #324	; 0x144
 8002e10:	f002 fda6 	bl	8005960 <pvPortMalloc>
                    if( pxNewTCB != NULL )
 8002e14:	4606      	mov	r6, r0
 8002e16:	b1e0      	cbz	r0, 8002e52 <xTaskCreate+0x5e>
                        pxNewTCB->pxStack = pxStack;
 8002e18:	f8c0 40b0 	str.w	r4, [r0, #176]	; 0xb0
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8002e1c:	2400      	movs	r4, #0
            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8002e1e:	464b      	mov	r3, r9
 8002e20:	462a      	mov	r2, r5
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8002e22:	f886 4143 	strb.w	r4, [r6, #323]	; 0x143
            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8002e26:	4641      	mov	r1, r8
 8002e28:	4638      	mov	r0, r7
 8002e2a:	e9cd 6402 	strd	r6, r4, [sp, #8]
 8002e2e:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8002e30:	9401      	str	r4, [sp, #4]
 8002e32:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8002e34:	9400      	str	r4, [sp, #0]
 8002e36:	f7ff fe27 	bl	8002a88 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
 8002e3a:	4630      	mov	r0, r6
 8002e3c:	f7ff ff10 	bl	8002c60 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
 8002e40:	2001      	movs	r0, #1
    }
 8002e42:	b005      	add	sp, #20
 8002e44:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8002e48:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    }
 8002e4c:	b005      	add	sp, #20
 8002e4e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                        vPortFreeStack( pxStack );
 8002e52:	4620      	mov	r0, r4
 8002e54:	f002 fe34 	bl	8005ac0 <vPortFree>
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8002e58:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8002e5c:	e7f1      	b.n	8002e42 <xTaskCreate+0x4e>
 8002e5e:	bf00      	nop

08002e60 <xTaskCreateStatic>:
    {
 8002e60:	b530      	push	{r4, r5, lr}
 8002e62:	b087      	sub	sp, #28
 8002e64:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
        configASSERT( puxStackBuffer != NULL );
 8002e66:	b1d4      	cbz	r4, 8002e9e <xTaskCreateStatic+0x3e>
        configASSERT( pxTaskBuffer != NULL );
 8002e68:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8002e6a:	b17d      	cbz	r5, 8002e8c <xTaskCreateStatic+0x2c>
                volatile size_t xSize = sizeof( StaticTask_t );
 8002e6c:	f44f 75a2 	mov.w	r5, #324	; 0x144
 8002e70:	9505      	str	r5, [sp, #20]
                configASSERT( xSize == sizeof( TCB_t ) );
 8002e72:	9d05      	ldr	r5, [sp, #20]
 8002e74:	f5b5 7fa2 	cmp.w	r5, #324	; 0x144
 8002e78:	d01a      	beq.n	8002eb0 <xTaskCreateStatic+0x50>
 8002e7a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002e7e:	f383 8811 	msr	BASEPRI, r3
 8002e82:	f3bf 8f6f 	isb	sy
 8002e86:	f3bf 8f4f 	dsb	sy
 8002e8a:	e7fe      	b.n	8002e8a <xTaskCreateStatic+0x2a>
 8002e8c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002e90:	f383 8811 	msr	BASEPRI, r3
 8002e94:	f3bf 8f6f 	isb	sy
 8002e98:	f3bf 8f4f 	dsb	sy
        configASSERT( pxTaskBuffer != NULL );
 8002e9c:	e7fe      	b.n	8002e9c <xTaskCreateStatic+0x3c>
 8002e9e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002ea2:	f383 8811 	msr	BASEPRI, r3
 8002ea6:	f3bf 8f6f 	isb	sy
 8002eaa:	f3bf 8f4f 	dsb	sy
        configASSERT( puxStackBuffer != NULL );
 8002eae:	e7fe      	b.n	8002eae <xTaskCreateStatic+0x4e>
            pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 8002eb0:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8002eb2:	f8c5 40b0 	str.w	r4, [r5, #176]	; 0xb0
                    pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8002eb6:	2402      	movs	r4, #2
            prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 8002eb8:	9502      	str	r5, [sp, #8]
 8002eba:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8002ebc:	9500      	str	r5, [sp, #0]
                    pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8002ebe:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8002ec0:	f885 4143 	strb.w	r4, [r5, #323]	; 0x143
            prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 8002ec4:	2400      	movs	r4, #0
                ( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 8002ec6:	9d05      	ldr	r5, [sp, #20]
            prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 8002ec8:	9403      	str	r4, [sp, #12]
 8002eca:	ac04      	add	r4, sp, #16
 8002ecc:	9401      	str	r4, [sp, #4]
 8002ece:	f7ff fddb 	bl	8002a88 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
 8002ed2:	980c      	ldr	r0, [sp, #48]	; 0x30
 8002ed4:	f7ff fec4 	bl	8002c60 <prvAddNewTaskToReadyList>
    }
 8002ed8:	9804      	ldr	r0, [sp, #16]
 8002eda:	b007      	add	sp, #28
 8002edc:	bd30      	pop	{r4, r5, pc}
 8002ede:	bf00      	nop

08002ee0 <xTaskCreateRestricted>:
        configASSERT( pxTaskDefinition->puxStackBuffer );
 8002ee0:	6943      	ldr	r3, [r0, #20]
 8002ee2:	b333      	cbz	r3, 8002f32 <xTaskCreateRestricted+0x52>
    {
 8002ee4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002ee6:	4604      	mov	r4, r0
 8002ee8:	b085      	sub	sp, #20
            pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 8002eea:	f44f 70a2 	mov.w	r0, #324	; 0x144
 8002eee:	460d      	mov	r5, r1
 8002ef0:	f002 fd36 	bl	8005960 <pvPortMalloc>
            if( pxNewTCB != NULL )
 8002ef4:	4606      	mov	r6, r0
 8002ef6:	b1c0      	cbz	r0, 8002f2a <xTaskCreateRestricted+0x4a>
                pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 8002ef8:	6963      	ldr	r3, [r4, #20]
                        pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 8002efa:	2701      	movs	r7, #1
                prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 8002efc:	4622      	mov	r2, r4
                        pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 8002efe:	f880 7143 	strb.w	r7, [r0, #323]	; 0x143
                pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 8002f02:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
                prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 8002f06:	9501      	str	r5, [sp, #4]
 8002f08:	6923      	ldr	r3, [r4, #16]
 8002f0a:	9002      	str	r0, [sp, #8]
 8002f0c:	9300      	str	r3, [sp, #0]
 8002f0e:	f852 0b18 	ldr.w	r0, [r2], #24
 8002f12:	68e3      	ldr	r3, [r4, #12]
 8002f14:	9203      	str	r2, [sp, #12]
 8002f16:	8922      	ldrh	r2, [r4, #8]
 8002f18:	6861      	ldr	r1, [r4, #4]
 8002f1a:	f7ff fdb5 	bl	8002a88 <prvInitialiseNewTask>
                prvAddNewTaskToReadyList( pxNewTCB );
 8002f1e:	4630      	mov	r0, r6
 8002f20:	f7ff fe9e 	bl	8002c60 <prvAddNewTaskToReadyList>
                xReturn = pdPASS;
 8002f24:	4638      	mov	r0, r7
    }
 8002f26:	b005      	add	sp, #20
 8002f28:	bdf0      	pop	{r4, r5, r6, r7, pc}
        BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8002f2a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    }
 8002f2e:	b005      	add	sp, #20
 8002f30:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002f32:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002f36:	f383 8811 	msr	BASEPRI, r3
 8002f3a:	f3bf 8f6f 	isb	sy
 8002f3e:	f3bf 8f4f 	dsb	sy
        configASSERT( pxTaskDefinition->puxStackBuffer );
 8002f42:	e7fe      	b.n	8002f42 <xTaskCreateRestricted+0x62>

08002f44 <xTaskCreateRestrictedStatic>:
        configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 8002f44:	6943      	ldr	r3, [r0, #20]
 8002f46:	b343      	cbz	r3, 8002f9a <xTaskCreateRestrictedStatic+0x56>
        configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 8002f48:	4684      	mov	ip, r0
    {
 8002f4a:	b510      	push	{r4, lr}
        configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 8002f4c:	f8d0 409c 	ldr.w	r4, [r0, #156]	; 0x9c
    {
 8002f50:	b084      	sub	sp, #16
        configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 8002f52:	b1cc      	cbz	r4, 8002f88 <xTaskCreateRestrictedStatic+0x44>
            prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 8002f54:	4602      	mov	r2, r0
                    pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8002f56:	2002      	movs	r0, #2
            pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 8002f58:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
                    pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8002f5c:	f884 0143 	strb.w	r0, [r4, #323]	; 0x143
            prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 8002f60:	9101      	str	r1, [sp, #4]
 8002f62:	e9dc 3103 	ldrd	r3, r1, [ip, #12]
 8002f66:	9402      	str	r4, [sp, #8]
 8002f68:	9100      	str	r1, [sp, #0]
 8002f6a:	f852 0b18 	ldr.w	r0, [r2], #24
 8002f6e:	9203      	str	r2, [sp, #12]
 8002f70:	f8bc 2008 	ldrh.w	r2, [ip, #8]
 8002f74:	f8dc 1004 	ldr.w	r1, [ip, #4]
 8002f78:	f7ff fd86 	bl	8002a88 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
 8002f7c:	4620      	mov	r0, r4
 8002f7e:	f7ff fe6f 	bl	8002c60 <prvAddNewTaskToReadyList>
    }
 8002f82:	2001      	movs	r0, #1
 8002f84:	b004      	add	sp, #16
 8002f86:	bd10      	pop	{r4, pc}
 8002f88:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002f8c:	f383 8811 	msr	BASEPRI, r3
 8002f90:	f3bf 8f6f 	isb	sy
 8002f94:	f3bf 8f4f 	dsb	sy
        configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 8002f98:	e7fe      	b.n	8002f98 <xTaskCreateRestrictedStatic+0x54>
 8002f9a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002f9e:	f383 8811 	msr	BASEPRI, r3
 8002fa2:	f3bf 8f6f 	isb	sy
 8002fa6:	f3bf 8f4f 	dsb	sy
        configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 8002faa:	e7fe      	b.n	8002faa <xTaskCreateRestrictedStatic+0x66>

08002fac <vTaskAllocateMPURegions>:
        pxTCB = prvGetTCBFromHandle( xTaskToModify );
 8002fac:	b120      	cbz	r0, 8002fb8 <vTaskAllocateMPURegions+0xc>
        vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
 8002fae:	2300      	movs	r3, #0
 8002fb0:	3004      	adds	r0, #4
 8002fb2:	461a      	mov	r2, r3
 8002fb4:	f002 baa0 	b.w	80054f8 <vPortStoreTaskMPUSettings>
        pxTCB = prvGetTCBFromHandle( xTaskToModify );
 8002fb8:	4b03      	ldr	r3, [pc, #12]	; (8002fc8 <vTaskAllocateMPURegions+0x1c>)
 8002fba:	6858      	ldr	r0, [r3, #4]
        vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
 8002fbc:	2300      	movs	r3, #0
 8002fbe:	3004      	adds	r0, #4
 8002fc0:	461a      	mov	r2, r3
 8002fc2:	f002 ba99 	b.w	80054f8 <vPortStoreTaskMPUSettings>
 8002fc6:	bf00      	nop
 8002fc8:	24000040 	.word	0x24000040

08002fcc <vTaskDelete>:
    {
 8002fcc:	b570      	push	{r4, r5, r6, lr}
 8002fce:	4604      	mov	r4, r0
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8002fd0:	4d3c      	ldr	r5, [pc, #240]	; (80030c4 <vTaskDelete+0xf8>)
        taskENTER_CRITICAL();
 8002fd2:	f006 fe11 	bl	8009bf8 <vPortEnterCritical>
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8002fd6:	2c00      	cmp	r4, #0
 8002fd8:	d045      	beq.n	8003066 <vTaskDelete+0x9a>
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8002fda:	f104 0684 	add.w	r6, r4, #132	; 0x84
 8002fde:	4630      	mov	r0, r6
 8002fe0:	f7fd fbfa 	bl	80007d8 <uxListRemove>
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8002fe4:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 8002fe8:	b11b      	cbz	r3, 8002ff2 <vTaskDelete+0x26>
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8002fea:	f104 0098 	add.w	r0, r4, #152	; 0x98
 8002fee:	f7fd fbf3 	bl	80007d8 <uxListRemove>
            uxTaskNumber++;
 8002ff2:	f8d5 34e0 	ldr.w	r3, [r5, #1248]	; 0x4e0
            if( pxTCB == pxCurrentTCB )
 8002ff6:	686a      	ldr	r2, [r5, #4]
            uxTaskNumber++;
 8002ff8:	3301      	adds	r3, #1
            if( pxTCB == pxCurrentTCB )
 8002ffa:	42a2      	cmp	r2, r4
            uxTaskNumber++;
 8002ffc:	f8c5 34e0 	str.w	r3, [r5, #1248]	; 0x4e0
            if( pxTCB == pxCurrentTCB )
 8003000:	d047      	beq.n	8003092 <vTaskDelete+0xc6>
                --uxCurrentNumberOfTasks;
 8003002:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8003004:	3b01      	subs	r3, #1
 8003006:	62ab      	str	r3, [r5, #40]	; 0x28
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003008:	6a2b      	ldr	r3, [r5, #32]
 800300a:	681b      	ldr	r3, [r3, #0]
 800300c:	b1e3      	cbz	r3, 8003048 <vTaskDelete+0x7c>
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 800300e:	6a2b      	ldr	r3, [r5, #32]
 8003010:	68db      	ldr	r3, [r3, #12]
 8003012:	681b      	ldr	r3, [r3, #0]
 8003014:	626b      	str	r3, [r5, #36]	; 0x24
        taskEXIT_CRITICAL();
 8003016:	f006 fe05 	bl	8009c24 <vPortExitCritical>
        if( pxTCB != pxCurrentTCB )
 800301a:	686b      	ldr	r3, [r5, #4]
 800301c:	42a3      	cmp	r3, r4
 800301e:	d01b      	beq.n	8003058 <vTaskDelete+0x8c>
                _reclaim_reent( &( pxTCB->xNewLib_reent ) );
 8003020:	f104 00d4 	add.w	r0, r4, #212	; 0xd4
 8003024:	f011 faf8 	bl	8014618 <_reclaim_reent>
                if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 8003028:	f894 3143 	ldrb.w	r3, [r4, #323]	; 0x143
 800302c:	b34b      	cbz	r3, 8003082 <vTaskDelete+0xb6>
                else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 800302e:	2b01      	cmp	r3, #1
 8003030:	d039      	beq.n	80030a6 <vTaskDelete+0xda>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
 8003032:	2b02      	cmp	r3, #2
 8003034:	d010      	beq.n	8003058 <vTaskDelete+0x8c>
 8003036:	f04f 0350 	mov.w	r3, #80	; 0x50
 800303a:	f383 8811 	msr	BASEPRI, r3
 800303e:	f3bf 8f6f 	isb	sy
 8003042:	f3bf 8f4f 	dsb	sy
 8003046:	e7fe      	b.n	8003046 <vTaskDelete+0x7a>
        xNextTaskUnblockTime = portMAX_DELAY;
 8003048:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800304c:	626b      	str	r3, [r5, #36]	; 0x24
        taskEXIT_CRITICAL();
 800304e:	f006 fde9 	bl	8009c24 <vPortExitCritical>
        if( pxTCB != pxCurrentTCB )
 8003052:	686b      	ldr	r3, [r5, #4]
 8003054:	42a3      	cmp	r3, r4
 8003056:	d1e3      	bne.n	8003020 <vTaskDelete+0x54>
        if( xSchedulerRunning != pdFALSE )
 8003058:	f8d5 34dc 	ldr.w	r3, [r5, #1244]	; 0x4dc
 800305c:	b113      	cbz	r3, 8003064 <vTaskDelete+0x98>
            if( pxTCB == pxCurrentTCB )
 800305e:	686b      	ldr	r3, [r5, #4]
 8003060:	42a3      	cmp	r3, r4
 8003062:	d002      	beq.n	800306a <vTaskDelete+0x9e>
    }
 8003064:	bd70      	pop	{r4, r5, r6, pc}
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8003066:	686c      	ldr	r4, [r5, #4]
 8003068:	e7b7      	b.n	8002fda <vTaskDelete+0xe>
                configASSERT( uxSchedulerSuspended == 0 );
 800306a:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
 800306e:	b1f3      	cbz	r3, 80030ae <vTaskDelete+0xe2>
 8003070:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003074:	f383 8811 	msr	BASEPRI, r3
 8003078:	f3bf 8f6f 	isb	sy
 800307c:	f3bf 8f4f 	dsb	sy
 8003080:	e7fe      	b.n	8003080 <vTaskDelete+0xb4>
                    vPortFreeStack( pxTCB->pxStack );
 8003082:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
 8003086:	f002 fd1b 	bl	8005ac0 <vPortFree>
                    vPortFree( pxTCB );
 800308a:	4620      	mov	r0, r4
 800308c:	f002 fd18 	bl	8005ac0 <vPortFree>
 8003090:	e7e2      	b.n	8003058 <vTaskDelete+0x8c>
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 8003092:	4631      	mov	r1, r6
 8003094:	480c      	ldr	r0, [pc, #48]	; (80030c8 <vTaskDelete+0xfc>)
 8003096:	f7fd fb8f 	bl	80007b8 <vListInsertEnd>
                ++uxDeletedTasksWaitingCleanUp;
 800309a:	f8d5 34e8 	ldr.w	r3, [r5, #1256]	; 0x4e8
 800309e:	3301      	adds	r3, #1
 80030a0:	f8c5 34e8 	str.w	r3, [r5, #1256]	; 0x4e8
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
 80030a4:	e7b7      	b.n	8003016 <vTaskDelete+0x4a>
                    vPortFree( pxTCB );
 80030a6:	4620      	mov	r0, r4
 80030a8:	f002 fd0a 	bl	8005ac0 <vPortFree>
 80030ac:	e7d4      	b.n	8003058 <vTaskDelete+0x8c>
                portYIELD_WITHIN_API();
 80030ae:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80030b2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80030b6:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80030ba:	f3bf 8f4f 	dsb	sy
 80030be:	f3bf 8f6f 	isb	sy
    }
 80030c2:	bd70      	pop	{r4, r5, r6, pc}
 80030c4:	24000040 	.word	0x24000040
 80030c8:	24000508 	.word	0x24000508

080030cc <uxTaskPriorityGet>:
    {
 80030cc:	b510      	push	{r4, lr}
 80030ce:	4604      	mov	r4, r0
 80030d0:	b082      	sub	sp, #8
        taskENTER_CRITICAL();
 80030d2:	f006 fd91 	bl	8009bf8 <vPortEnterCritical>
            pxTCB = prvGetTCBFromHandle( xTask );
 80030d6:	b13c      	cbz	r4, 80030e8 <uxTaskPriorityGet+0x1c>
            uxReturn = pxTCB->uxPriority;
 80030d8:	f8d4 00ac 	ldr.w	r0, [r4, #172]	; 0xac
 80030dc:	9001      	str	r0, [sp, #4]
        taskEXIT_CRITICAL();
 80030de:	f006 fda1 	bl	8009c24 <vPortExitCritical>
    }
 80030e2:	9801      	ldr	r0, [sp, #4]
 80030e4:	b002      	add	sp, #8
 80030e6:	bd10      	pop	{r4, pc}
            pxTCB = prvGetTCBFromHandle( xTask );
 80030e8:	4b01      	ldr	r3, [pc, #4]	; (80030f0 <uxTaskPriorityGet+0x24>)
 80030ea:	685c      	ldr	r4, [r3, #4]
 80030ec:	e7f4      	b.n	80030d8 <uxTaskPriorityGet+0xc>
 80030ee:	bf00      	nop
 80030f0:	24000040 	.word	0x24000040

080030f4 <uxTaskPriorityGetFromISR>:
    {
 80030f4:	b510      	push	{r4, lr}
 80030f6:	4604      	mov	r4, r0
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80030f8:	f006 fdd2 	bl	8009ca0 <vPortValidateInterruptPriority>
    __asm volatile
 80030fc:	f3ef 8311 	mrs	r3, BASEPRI
 8003100:	f04f 0250 	mov.w	r2, #80	; 0x50
 8003104:	f382 8811 	msr	BASEPRI, r2
 8003108:	f3bf 8f6f 	isb	sy
 800310c:	f3bf 8f4f 	dsb	sy
            pxTCB = prvGetTCBFromHandle( xTask );
 8003110:	b124      	cbz	r4, 800311c <uxTaskPriorityGetFromISR+0x28>
            uxReturn = pxTCB->uxPriority;
 8003112:	f8d4 00ac 	ldr.w	r0, [r4, #172]	; 0xac
    __asm volatile
 8003116:	f383 8811 	msr	BASEPRI, r3
    }
 800311a:	bd10      	pop	{r4, pc}
            pxTCB = prvGetTCBFromHandle( xTask );
 800311c:	4a03      	ldr	r2, [pc, #12]	; (800312c <uxTaskPriorityGetFromISR+0x38>)
 800311e:	6854      	ldr	r4, [r2, #4]
            uxReturn = pxTCB->uxPriority;
 8003120:	f8d4 00ac 	ldr.w	r0, [r4, #172]	; 0xac
 8003124:	f383 8811 	msr	BASEPRI, r3
    }
 8003128:	bd10      	pop	{r4, pc}
 800312a:	bf00      	nop
 800312c:	24000040 	.word	0x24000040

08003130 <eTaskGetState>:
        configASSERT( pxTCB );
 8003130:	b310      	cbz	r0, 8003178 <eTaskGetState+0x48>
    {
 8003132:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        if( pxTCB == pxCurrentTCB )
 8003136:	4d20      	ldr	r5, [pc, #128]	; (80031b8 <eTaskGetState+0x88>)
 8003138:	4604      	mov	r4, r0
 800313a:	686b      	ldr	r3, [r5, #4]
 800313c:	4283      	cmp	r3, r0
 800313e:	d018      	beq.n	8003172 <eTaskGetState+0x42>
            taskENTER_CRITICAL();
 8003140:	f006 fd5a 	bl	8009bf8 <vPortEnterCritical>
                pxDelayedList = pxDelayedTaskList;
 8003144:	6a2f      	ldr	r7, [r5, #32]
                pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 8003146:	f8d4 6094 	ldr.w	r6, [r4, #148]	; 0x94
                pxOverflowedDelayedList = pxOverflowDelayedTaskList;
 800314a:	f8d5 801c 	ldr.w	r8, [r5, #28]
            taskEXIT_CRITICAL();
 800314e:	f006 fd69 	bl	8009c24 <vPortExitCritical>
            if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
 8003152:	42be      	cmp	r6, r7
 8003154:	d01c      	beq.n	8003190 <eTaskGetState+0x60>
 8003156:	4546      	cmp	r6, r8
 8003158:	d01a      	beq.n	8003190 <eTaskGetState+0x60>
                else if( pxStateList == &xSuspendedTaskList )
 800315a:	f105 0308 	add.w	r3, r5, #8
 800315e:	429e      	cmp	r6, r3
 8003160:	d013      	beq.n	800318a <eTaskGetState+0x5a>
                else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 8003162:	f505 6599 	add.w	r5, r5, #1224	; 0x4c8
 8003166:	42ae      	cmp	r6, r5
 8003168:	d015      	beq.n	8003196 <eTaskGetState+0x66>
 800316a:	b1a6      	cbz	r6, 8003196 <eTaskGetState+0x66>
                eReturn = eReady;
 800316c:	2001      	movs	r0, #1
    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 800316e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            eReturn = eRunning;
 8003172:	2000      	movs	r0, #0
    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 8003174:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __asm volatile
 8003178:	f04f 0350 	mov.w	r3, #80	; 0x50
 800317c:	f383 8811 	msr	BASEPRI, r3
 8003180:	f3bf 8f6f 	isb	sy
 8003184:	f3bf 8f4f 	dsb	sy
        configASSERT( pxTCB );
 8003188:	e7fe      	b.n	8003188 <eTaskGetState+0x58>
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 800318a:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 800318e:	b123      	cbz	r3, 800319a <eTaskGetState+0x6a>
                eReturn = eBlocked;
 8003190:	2002      	movs	r0, #2
    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 8003192:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                    eReturn = eDeleted;
 8003196:	2004      	movs	r0, #4
 8003198:	e7ec      	b.n	8003174 <eTaskGetState+0x44>
                                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 800319a:	f894 3140 	ldrb.w	r3, [r4, #320]	; 0x140
 800319e:	2b01      	cmp	r3, #1
 80031a0:	d0f6      	beq.n	8003190 <eTaskGetState+0x60>
 80031a2:	f894 3141 	ldrb.w	r3, [r4, #321]	; 0x141
 80031a6:	2b01      	cmp	r3, #1
 80031a8:	d0f2      	beq.n	8003190 <eTaskGetState+0x60>
 80031aa:	f894 3142 	ldrb.w	r3, [r4, #322]	; 0x142
                                eReturn = eSuspended;
 80031ae:	2b01      	cmp	r3, #1
 80031b0:	bf0c      	ite	eq
 80031b2:	2002      	moveq	r0, #2
 80031b4:	2003      	movne	r0, #3
 80031b6:	e7dd      	b.n	8003174 <eTaskGetState+0x44>
 80031b8:	24000040 	.word	0x24000040

080031bc <vTaskPrioritySet>:
        configASSERT( uxNewPriority < configMAX_PRIORITIES );
 80031bc:	2937      	cmp	r1, #55	; 0x37
 80031be:	d908      	bls.n	80031d2 <vTaskPrioritySet+0x16>
 80031c0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80031c4:	f383 8811 	msr	BASEPRI, r3
 80031c8:	f3bf 8f6f 	isb	sy
 80031cc:	f3bf 8f4f 	dsb	sy
 80031d0:	e7fe      	b.n	80031d0 <vTaskPrioritySet+0x14>
    {
 80031d2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80031d6:	4604      	mov	r4, r0
 80031d8:	460d      	mov	r5, r1
        taskENTER_CRITICAL();
 80031da:	f006 fd0d 	bl	8009bf8 <vPortEnterCritical>
            pxTCB = prvGetTCBFromHandle( xTask );
 80031de:	2c00      	cmp	r4, #0
 80031e0:	d03d      	beq.n	800325e <vTaskPrioritySet+0xa2>
                    uxCurrentBasePriority = pxTCB->uxBasePriority;
 80031e2:	f8d4 20cc 	ldr.w	r2, [r4, #204]	; 0xcc
            if( uxCurrentBasePriority != uxNewPriority )
 80031e6:	4295      	cmp	r5, r2
 80031e8:	d02a      	beq.n	8003240 <vTaskPrioritySet+0x84>
                    if( pxTCB != pxCurrentTCB )
 80031ea:	4e31      	ldr	r6, [pc, #196]	; (80032b0 <vTaskPrioritySet+0xf4>)
                if( uxNewPriority > uxCurrentBasePriority )
 80031ec:	d82c      	bhi.n	8003248 <vTaskPrioritySet+0x8c>
                else if( pxTCB == pxCurrentTCB )
 80031ee:	6877      	ldr	r7, [r6, #4]
 80031f0:	1b3f      	subs	r7, r7, r4
 80031f2:	fab7 f787 	clz	r7, r7
 80031f6:	097f      	lsrs	r7, r7, #5
                uxPriorityUsedOnEntry = pxTCB->uxPriority;
 80031f8:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
                        pxTCB->uxBasePriority = uxNewPriority;
 80031fc:	f8c4 50cc 	str.w	r5, [r4, #204]	; 0xcc
                        if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 8003200:	429a      	cmp	r2, r3
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8003202:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
                            pxTCB->uxPriority = uxNewPriority;
 8003206:	bf08      	it	eq
 8003208:	f8c4 50ac 	streq.w	r5, [r4, #172]	; 0xac
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800320c:	2a00      	cmp	r2, #0
 800320e:	db03      	blt.n	8003218 <vTaskPrioritySet+0x5c>
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003210:	f1c5 0538 	rsb	r5, r5, #56	; 0x38
 8003214:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8003218:	4d26      	ldr	r5, [pc, #152]	; (80032b4 <vTaskPrioritySet+0xf8>)
 800321a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800321e:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
 8003222:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8003226:	429a      	cmp	r2, r3
 8003228:	d01c      	beq.n	8003264 <vTaskPrioritySet+0xa8>
                if( xYieldRequired != pdFALSE )
 800322a:	b14f      	cbz	r7, 8003240 <vTaskPrioritySet+0x84>
                    taskYIELD_IF_USING_PREEMPTION();
 800322c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003230:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003234:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8003238:	f3bf 8f4f 	dsb	sy
 800323c:	f3bf 8f6f 	isb	sy
    }
 8003240:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        taskEXIT_CRITICAL();
 8003244:	f006 bcee 	b.w	8009c24 <vPortExitCritical>
                    if( pxTCB != pxCurrentTCB )
 8003248:	6873      	ldr	r3, [r6, #4]
 800324a:	42a3      	cmp	r3, r4
 800324c:	d02e      	beq.n	80032ac <vTaskPrioritySet+0xf0>
                        if( uxNewPriority >= pxCurrentTCB->uxPriority )
 800324e:	6873      	ldr	r3, [r6, #4]
 8003250:	f8d3 70ac 	ldr.w	r7, [r3, #172]	; 0xac
 8003254:	42af      	cmp	r7, r5
 8003256:	bf8c      	ite	hi
 8003258:	2700      	movhi	r7, #0
 800325a:	2701      	movls	r7, #1
 800325c:	e7cc      	b.n	80031f8 <vTaskPrioritySet+0x3c>
            pxTCB = prvGetTCBFromHandle( xTask );
 800325e:	4b14      	ldr	r3, [pc, #80]	; (80032b0 <vTaskPrioritySet+0xf4>)
 8003260:	685c      	ldr	r4, [r3, #4]
 8003262:	e7be      	b.n	80031e2 <vTaskPrioritySet+0x26>
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003264:	f104 0884 	add.w	r8, r4, #132	; 0x84
 8003268:	4640      	mov	r0, r8
 800326a:	f7fd fab5 	bl	80007d8 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 800326e:	f8d6 24e4 	ldr.w	r2, [r6, #1252]	; 0x4e4
 8003272:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8003276:	4293      	cmp	r3, r2
 8003278:	d901      	bls.n	800327e <vTaskPrioritySet+0xc2>
 800327a:	f8c6 34e4 	str.w	r3, [r6, #1252]	; 0x4e4
 800327e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8003282:	eb06 0683 	add.w	r6, r6, r3, lsl #2
 8003286:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 800328a:	6b33      	ldr	r3, [r6, #48]	; 0x30
 800328c:	689a      	ldr	r2, [r3, #8]
 800328e:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
 8003292:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
 8003296:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8003298:	6898      	ldr	r0, [r3, #8]
 800329a:	3201      	adds	r2, #1
 800329c:	f8c0 8004 	str.w	r8, [r0, #4]
 80032a0:	f8c3 8008 	str.w	r8, [r3, #8]
 80032a4:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
 80032a8:	62f2      	str	r2, [r6, #44]	; 0x2c
 80032aa:	e7be      	b.n	800322a <vTaskPrioritySet+0x6e>
        BaseType_t xYieldRequired = pdFALSE;
 80032ac:	2700      	movs	r7, #0
 80032ae:	e7a3      	b.n	80031f8 <vTaskPrioritySet+0x3c>
 80032b0:	24000040 	.word	0x24000040
 80032b4:	2400006c 	.word	0x2400006c

080032b8 <vTaskResume>:
    {
 80032b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        configASSERT( xTaskToResume );
 80032ba:	b188      	cbz	r0, 80032e0 <vTaskResume+0x28>
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 80032bc:	4d2b      	ldr	r5, [pc, #172]	; (800336c <vTaskResume+0xb4>)
 80032be:	4604      	mov	r4, r0
 80032c0:	686b      	ldr	r3, [r5, #4]
 80032c2:	4283      	cmp	r3, r0
 80032c4:	d00b      	beq.n	80032de <vTaskResume+0x26>
            taskENTER_CRITICAL();
 80032c6:	f006 fc97 	bl	8009bf8 <vPortEnterCritical>
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 80032ca:	f105 0308 	add.w	r3, r5, #8
 80032ce:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
 80032d2:	429a      	cmp	r2, r3
 80032d4:	d00d      	beq.n	80032f2 <vTaskResume+0x3a>
    }
 80032d6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
            taskEXIT_CRITICAL();
 80032da:	f006 bca3 	b.w	8009c24 <vPortExitCritical>
    }
 80032de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80032e0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80032e4:	f383 8811 	msr	BASEPRI, r3
 80032e8:	f3bf 8f6f 	isb	sy
 80032ec:	f3bf 8f4f 	dsb	sy
        configASSERT( xTaskToResume );
 80032f0:	e7fe      	b.n	80032f0 <vTaskResume+0x38>
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 80032f2:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 80032f6:	f205 42b4 	addw	r2, r5, #1204	; 0x4b4
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 80032fa:	4293      	cmp	r3, r2
 80032fc:	d0eb      	beq.n	80032d6 <vTaskResume+0x1e>
 80032fe:	2b00      	cmp	r3, #0
 8003300:	d1e9      	bne.n	80032d6 <vTaskResume+0x1e>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8003302:	f104 0684 	add.w	r6, r4, #132	; 0x84
 8003306:	4630      	mov	r0, r6
 8003308:	f7fd fa66 	bl	80007d8 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 800330c:	f8d5 34e4 	ldr.w	r3, [r5, #1252]	; 0x4e4
 8003310:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
 8003314:	429a      	cmp	r2, r3
 8003316:	d901      	bls.n	800331c <vTaskResume+0x64>
 8003318:	f8c5 24e4 	str.w	r2, [r5, #1252]	; 0x4e4
 800331c:	eb02 0382 	add.w	r3, r2, r2, lsl #2
 8003320:	4f13      	ldr	r7, [pc, #76]	; (8003370 <vTaskResume+0xb8>)
 8003322:	eb07 0783 	add.w	r7, r7, r3, lsl #2
 8003326:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800332a:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800332c:	6888      	ldr	r0, [r1, #8]
 800332e:	f8c4 1088 	str.w	r1, [r4, #136]	; 0x88
 8003332:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
 8003336:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8003338:	f100 0c01 	add.w	ip, r0, #1
 800333c:	6888      	ldr	r0, [r1, #8]
 800333e:	6046      	str	r6, [r0, #4]
 8003340:	608e      	str	r6, [r1, #8]
 8003342:	f8c4 7094 	str.w	r7, [r4, #148]	; 0x94
 8003346:	f8c3 c02c 	str.w	ip, [r3, #44]	; 0x2c
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800334a:	686b      	ldr	r3, [r5, #4]
 800334c:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8003350:	429a      	cmp	r2, r3
 8003352:	d3c0      	bcc.n	80032d6 <vTaskResume+0x1e>
                        taskYIELD_IF_USING_PREEMPTION();
 8003354:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003358:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800335c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8003360:	f3bf 8f4f 	dsb	sy
 8003364:	f3bf 8f6f 	isb	sy
 8003368:	e7b5      	b.n	80032d6 <vTaskResume+0x1e>
 800336a:	bf00      	nop
 800336c:	24000040 	.word	0x24000040
 8003370:	2400006c 	.word	0x2400006c

08003374 <xTaskResumeFromISR>:
        configASSERT( xTaskToResume );
 8003374:	b1d8      	cbz	r0, 80033ae <xTaskResumeFromISR+0x3a>
    {
 8003376:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800337a:	4604      	mov	r4, r0
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800337c:	f006 fc90 	bl	8009ca0 <vPortValidateInterruptPriority>
    __asm volatile
 8003380:	f3ef 8711 	mrs	r7, BASEPRI
 8003384:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003388:	f383 8811 	msr	BASEPRI, r3
 800338c:	f3bf 8f6f 	isb	sy
 8003390:	f3bf 8f4f 	dsb	sy
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 8003394:	4d2b      	ldr	r5, [pc, #172]	; (8003444 <xTaskResumeFromISR+0xd0>)
 8003396:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
 800339a:	f105 0308 	add.w	r3, r5, #8
 800339e:	429a      	cmp	r2, r3
 80033a0:	d00e      	beq.n	80033c0 <xTaskResumeFromISR+0x4c>
        BaseType_t xYieldRequired = pdFALSE;
 80033a2:	2600      	movs	r6, #0
    __asm volatile
 80033a4:	f387 8811 	msr	BASEPRI, r7
    }
 80033a8:	4630      	mov	r0, r6
 80033aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __asm volatile
 80033ae:	f04f 0350 	mov.w	r3, #80	; 0x50
 80033b2:	f383 8811 	msr	BASEPRI, r3
 80033b6:	f3bf 8f6f 	isb	sy
 80033ba:	f3bf 8f4f 	dsb	sy
        configASSERT( xTaskToResume );
 80033be:	e7fe      	b.n	80033be <xTaskResumeFromISR+0x4a>
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 80033c0:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 80033c4:	f205 40b4 	addw	r0, r5, #1204	; 0x4b4
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 80033c8:	4283      	cmp	r3, r0
 80033ca:	d0ea      	beq.n	80033a2 <xTaskResumeFromISR+0x2e>
 80033cc:	2b00      	cmp	r3, #0
 80033ce:	d1e8      	bne.n	80033a2 <xTaskResumeFromISR+0x2e>
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80033d0:	f8d5 64ec 	ldr.w	r6, [r5, #1260]	; 0x4ec
 80033d4:	bb7e      	cbnz	r6, 8003436 <xTaskResumeFromISR+0xc2>
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80033d6:	686b      	ldr	r3, [r5, #4]
 80033d8:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
 80033dc:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 80033e0:	429a      	cmp	r2, r3
 80033e2:	d303      	bcc.n	80033ec <xTaskResumeFromISR+0x78>
                        xYieldPending = pdTRUE;
 80033e4:	2301      	movs	r3, #1
                        xYieldRequired = pdTRUE;
 80033e6:	461e      	mov	r6, r3
                        xYieldPending = pdTRUE;
 80033e8:	f8c5 34f0 	str.w	r3, [r5, #1264]	; 0x4f0
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80033ec:	f104 0884 	add.w	r8, r4, #132	; 0x84
 80033f0:	4640      	mov	r0, r8
 80033f2:	f7fd f9f1 	bl	80007d8 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
 80033f6:	f8d5 24e4 	ldr.w	r2, [r5, #1252]	; 0x4e4
 80033fa:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 80033fe:	4293      	cmp	r3, r2
 8003400:	d901      	bls.n	8003406 <xTaskResumeFromISR+0x92>
 8003402:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
 8003406:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800340a:	480f      	ldr	r0, [pc, #60]	; (8003448 <xTaskResumeFromISR+0xd4>)
 800340c:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 8003410:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8003414:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8003416:	689a      	ldr	r2, [r3, #8]
 8003418:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
 800341c:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
 8003420:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8003422:	6899      	ldr	r1, [r3, #8]
 8003424:	3201      	adds	r2, #1
 8003426:	f8c1 8004 	str.w	r8, [r1, #4]
 800342a:	f8c3 8008 	str.w	r8, [r3, #8]
 800342e:	f8c4 0094 	str.w	r0, [r4, #148]	; 0x94
 8003432:	62ea      	str	r2, [r5, #44]	; 0x2c
 8003434:	e7b6      	b.n	80033a4 <xTaskResumeFromISR+0x30>
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8003436:	f104 0198 	add.w	r1, r4, #152	; 0x98
        BaseType_t xYieldRequired = pdFALSE;
 800343a:	2600      	movs	r6, #0
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 800343c:	f7fd f9bc 	bl	80007b8 <vListInsertEnd>
 8003440:	e7b0      	b.n	80033a4 <xTaskResumeFromISR+0x30>
 8003442:	bf00      	nop
 8003444:	24000040 	.word	0x24000040
 8003448:	2400006c 	.word	0x2400006c

0800344c <vTaskStartScheduler>:
{
 800344c:	b530      	push	{r4, r5, lr}
 800344e:	b08b      	sub	sp, #44	; 0x2c
            StaticTask_t * pxIdleTaskTCBBuffer = NULL;
 8003450:	2400      	movs	r4, #0
            vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 8003452:	aa07      	add	r2, sp, #28
 8003454:	a906      	add	r1, sp, #24
 8003456:	a805      	add	r0, sp, #20
            StackType_t * pxIdleTaskStackBuffer = NULL;
 8003458:	e9cd 4405 	strd	r4, r4, [sp, #20]
            vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 800345c:	f006 fc86 	bl	8009d6c <vApplicationGetIdleTaskMemory>
            xIdleTaskHandle = xTaskCreateStatic( prvIdleTask,
 8003460:	9b06      	ldr	r3, [sp, #24]
        configASSERT( puxStackBuffer != NULL );
 8003462:	b1db      	cbz	r3, 800349c <vTaskStartScheduler+0x50>
            xIdleTaskHandle = xTaskCreateStatic( prvIdleTask,
 8003464:	9d05      	ldr	r5, [sp, #20]
        configASSERT( pxTaskBuffer != NULL );
 8003466:	b185      	cbz	r5, 800348a <vTaskStartScheduler+0x3e>
                volatile size_t xSize = sizeof( StaticTask_t );
 8003468:	f44f 71a2 	mov.w	r1, #324	; 0x144
            xIdleTaskHandle = xTaskCreateStatic( prvIdleTask,
 800346c:	9a07      	ldr	r2, [sp, #28]
                volatile size_t xSize = sizeof( StaticTask_t );
 800346e:	9109      	str	r1, [sp, #36]	; 0x24
                configASSERT( xSize == sizeof( TCB_t ) );
 8003470:	9909      	ldr	r1, [sp, #36]	; 0x24
 8003472:	f5b1 7fa2 	cmp.w	r1, #324	; 0x144
 8003476:	d01a      	beq.n	80034ae <vTaskStartScheduler+0x62>
 8003478:	f04f 0350 	mov.w	r3, #80	; 0x50
 800347c:	f383 8811 	msr	BASEPRI, r3
 8003480:	f3bf 8f6f 	isb	sy
 8003484:	f3bf 8f4f 	dsb	sy
 8003488:	e7fe      	b.n	8003488 <vTaskStartScheduler+0x3c>
 800348a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800348e:	f383 8811 	msr	BASEPRI, r3
 8003492:	f3bf 8f6f 	isb	sy
 8003496:	f3bf 8f4f 	dsb	sy
        configASSERT( pxTaskBuffer != NULL );
 800349a:	e7fe      	b.n	800349a <vTaskStartScheduler+0x4e>
 800349c:	f04f 0350 	mov.w	r3, #80	; 0x50
 80034a0:	f383 8811 	msr	BASEPRI, r3
 80034a4:	f3bf 8f6f 	isb	sy
 80034a8:	f3bf 8f4f 	dsb	sy
        configASSERT( puxStackBuffer != NULL );
 80034ac:	e7fe      	b.n	80034ac <vTaskStartScheduler+0x60>
                    pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 80034ae:	2102      	movs	r1, #2
            pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 80034b0:	f8c5 30b0 	str.w	r3, [r5, #176]	; 0xb0
                ( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 80034b4:	9b09      	ldr	r3, [sp, #36]	; 0x24
            prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 80034b6:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
                    pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 80034ba:	f885 1143 	strb.w	r1, [r5, #323]	; 0x143
            prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 80034be:	a908      	add	r1, sp, #32
 80034c0:	481a      	ldr	r0, [pc, #104]	; (800352c <vTaskStartScheduler+0xe0>)
 80034c2:	e9cd 3100 	strd	r3, r1, [sp]
 80034c6:	e9cd 5402 	strd	r5, r4, [sp, #8]
 80034ca:	4623      	mov	r3, r4
 80034cc:	4918      	ldr	r1, [pc, #96]	; (8003530 <vTaskStartScheduler+0xe4>)
 80034ce:	f7ff fadb 	bl	8002a88 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
 80034d2:	4628      	mov	r0, r5
 80034d4:	f7ff fbc4 	bl	8002c60 <prvAddNewTaskToReadyList>
        return xReturn;
 80034d8:	9b08      	ldr	r3, [sp, #32]
            if( xIdleTaskHandle != NULL )
 80034da:	b1c3      	cbz	r3, 800350e <vTaskStartScheduler+0xc2>
                xReturn = xTimerCreateTimerTask();
 80034dc:	f001 fee8 	bl	80052b0 <xTimerCreateTimerTask>
    if( xReturn == pdPASS )
 80034e0:	2801      	cmp	r0, #1
 80034e2:	d118      	bne.n	8003516 <vTaskStartScheduler+0xca>
 80034e4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80034e8:	f383 8811 	msr	BASEPRI, r3
 80034ec:	f3bf 8f6f 	isb	sy
 80034f0:	f3bf 8f4f 	dsb	sy
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
 80034f4:	4b0f      	ldr	r3, [pc, #60]	; (8003534 <vTaskStartScheduler+0xe8>)
 80034f6:	4910      	ldr	r1, [pc, #64]	; (8003538 <vTaskStartScheduler+0xec>)
 80034f8:	685a      	ldr	r2, [r3, #4]
 80034fa:	32d4      	adds	r2, #212	; 0xd4
 80034fc:	600a      	str	r2, [r1, #0]
        xNextTaskUnblockTime = portMAX_DELAY;
 80034fe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003502:	625a      	str	r2, [r3, #36]	; 0x24
        xSchedulerRunning = pdTRUE;
 8003504:	f8c3 04dc 	str.w	r0, [r3, #1244]	; 0x4dc
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8003508:	601c      	str	r4, [r3, #0]
        if( xPortStartScheduler() != pdFALSE )
 800350a:	f002 f90b 	bl	8005724 <xPortStartScheduler>
    ( void ) uxTopUsedPriority;
 800350e:	4b0b      	ldr	r3, [pc, #44]	; (800353c <vTaskStartScheduler+0xf0>)
 8003510:	681b      	ldr	r3, [r3, #0]
}
 8003512:	b00b      	add	sp, #44	; 0x2c
 8003514:	bd30      	pop	{r4, r5, pc}
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8003516:	3001      	adds	r0, #1
 8003518:	d1f9      	bne.n	800350e <vTaskStartScheduler+0xc2>
 800351a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800351e:	f383 8811 	msr	BASEPRI, r3
 8003522:	f3bf 8f6f 	isb	sy
 8003526:	f3bf 8f4f 	dsb	sy
 800352a:	e7fe      	b.n	800352a <vTaskStartScheduler+0xde>
 800352c:	08002d71 	.word	0x08002d71
 8003530:	24008250 	.word	0x24008250
 8003534:	24000040 	.word	0x24000040
 8003538:	24008184 	.word	0x24008184
 800353c:	24008010 	.word	0x24008010

08003540 <vTaskEndScheduler>:
 8003540:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003544:	f383 8811 	msr	BASEPRI, r3
 8003548:	f3bf 8f6f 	isb	sy
 800354c:	f3bf 8f4f 	dsb	sy
    xSchedulerRunning = pdFALSE;
 8003550:	4b02      	ldr	r3, [pc, #8]	; (800355c <vTaskEndScheduler+0x1c>)
 8003552:	2200      	movs	r2, #0
 8003554:	f8c3 24dc 	str.w	r2, [r3, #1244]	; 0x4dc
    vPortEndScheduler();
 8003558:	f001 bfbc 	b.w	80054d4 <vPortEndScheduler>
 800355c:	24000040 	.word	0x24000040

08003560 <vTaskSuspendAll>:
    ++uxSchedulerSuspended;
 8003560:	4a03      	ldr	r2, [pc, #12]	; (8003570 <vTaskSuspendAll+0x10>)
 8003562:	f8d2 34ec 	ldr.w	r3, [r2, #1260]	; 0x4ec
 8003566:	3301      	adds	r3, #1
 8003568:	f8c2 34ec 	str.w	r3, [r2, #1260]	; 0x4ec
}
 800356c:	4770      	bx	lr
 800356e:	bf00      	nop
 8003570:	24000040 	.word	0x24000040

08003574 <xTaskGetTickCount>:
        xTicks = xTickCount;
 8003574:	4b01      	ldr	r3, [pc, #4]	; (800357c <xTaskGetTickCount+0x8>)
 8003576:	6818      	ldr	r0, [r3, #0]
}
 8003578:	4770      	bx	lr
 800357a:	bf00      	nop
 800357c:	24000040 	.word	0x24000040

08003580 <xTaskGetTickCountFromISR>:
{
 8003580:	b508      	push	{r3, lr}
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8003582:	f006 fb8d 	bl	8009ca0 <vPortValidateInterruptPriority>
        xReturn = xTickCount;
 8003586:	4b01      	ldr	r3, [pc, #4]	; (800358c <xTaskGetTickCountFromISR+0xc>)
 8003588:	6818      	ldr	r0, [r3, #0]
}
 800358a:	bd08      	pop	{r3, pc}
 800358c:	24000040 	.word	0x24000040

08003590 <uxTaskGetNumberOfTasks>:
    return uxCurrentNumberOfTasks;
 8003590:	4b01      	ldr	r3, [pc, #4]	; (8003598 <uxTaskGetNumberOfTasks+0x8>)
 8003592:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
 8003594:	4770      	bx	lr
 8003596:	bf00      	nop
 8003598:	24000040 	.word	0x24000040

0800359c <pcTaskGetName>:
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 800359c:	b108      	cbz	r0, 80035a2 <pcTaskGetName+0x6>
}
 800359e:	30b4      	adds	r0, #180	; 0xb4
 80035a0:	4770      	bx	lr
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 80035a2:	4b06      	ldr	r3, [pc, #24]	; (80035bc <pcTaskGetName+0x20>)
 80035a4:	6858      	ldr	r0, [r3, #4]
    configASSERT( pxTCB );
 80035a6:	2800      	cmp	r0, #0
 80035a8:	d1f9      	bne.n	800359e <pcTaskGetName+0x2>
 80035aa:	f04f 0350 	mov.w	r3, #80	; 0x50
 80035ae:	f383 8811 	msr	BASEPRI, r3
 80035b2:	f3bf 8f6f 	isb	sy
 80035b6:	f3bf 8f4f 	dsb	sy
 80035ba:	e7fe      	b.n	80035ba <pcTaskGetName+0x1e>
 80035bc:	24000040 	.word	0x24000040

080035c0 <uxTaskGetStackHighWaterMark>:
        pxTCB = prvGetTCBFromHandle( xTask );
 80035c0:	b170      	cbz	r0, 80035e0 <uxTaskGetStackHighWaterMark+0x20>
                pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 80035c2:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 80035c6:	781a      	ldrb	r2, [r3, #0]
 80035c8:	2aa5      	cmp	r2, #165	; 0xa5
 80035ca:	d110      	bne.n	80035ee <uxTaskGetStackHighWaterMark+0x2e>
 80035cc:	f1c3 0101 	rsb	r1, r3, #1
            ulCount++;
 80035d0:	18c8      	adds	r0, r1, r3
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 80035d2:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 80035d6:	2aa5      	cmp	r2, #165	; 0xa5
 80035d8:	d0fa      	beq.n	80035d0 <uxTaskGetStackHighWaterMark+0x10>
 80035da:	f3c0 008f 	ubfx	r0, r0, #2, #16
 80035de:	4770      	bx	lr
        pxTCB = prvGetTCBFromHandle( xTask );
 80035e0:	4b04      	ldr	r3, [pc, #16]	; (80035f4 <uxTaskGetStackHighWaterMark+0x34>)
 80035e2:	6858      	ldr	r0, [r3, #4]
                pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 80035e4:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 80035e8:	781a      	ldrb	r2, [r3, #0]
 80035ea:	2aa5      	cmp	r2, #165	; 0xa5
 80035ec:	d0ee      	beq.n	80035cc <uxTaskGetStackHighWaterMark+0xc>
 80035ee:	2000      	movs	r0, #0
    }
 80035f0:	4770      	bx	lr
 80035f2:	bf00      	nop
 80035f4:	24000040 	.word	0x24000040

080035f8 <xTaskGenericNotify>:
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 80035f8:	2902      	cmp	r1, #2
    {
 80035fa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 80035fc:	d908      	bls.n	8003610 <xTaskGenericNotify+0x18>
 80035fe:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003602:	f383 8811 	msr	BASEPRI, r3
 8003606:	f3bf 8f6f 	isb	sy
 800360a:	f3bf 8f4f 	dsb	sy
 800360e:	e7fe      	b.n	800360e <xTaskGenericNotify+0x16>
        configASSERT( xTaskToNotify );
 8003610:	4607      	mov	r7, r0
 8003612:	b1d8      	cbz	r0, 800364c <xTaskGenericNotify+0x54>
        taskENTER_CRITICAL();
 8003614:	461d      	mov	r5, r3
 8003616:	460c      	mov	r4, r1
 8003618:	4616      	mov	r6, r2
 800361a:	f006 faed 	bl	8009bf8 <vPortEnterCritical>
            if( pulPreviousNotificationValue != NULL )
 800361e:	9b06      	ldr	r3, [sp, #24]
 8003620:	b133      	cbz	r3, 8003630 <xTaskGenericNotify+0x38>
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 8003622:	461a      	mov	r2, r3
 8003624:	f104 034c 	add.w	r3, r4, #76	; 0x4c
 8003628:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 800362c:	685b      	ldr	r3, [r3, #4]
 800362e:	6013      	str	r3, [r2, #0]
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 8003630:	193b      	adds	r3, r7, r4
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 8003632:	2102      	movs	r1, #2
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 8003634:	f893 2140 	ldrb.w	r2, [r3, #320]	; 0x140
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 8003638:	f883 1140 	strb.w	r1, [r3, #320]	; 0x140
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 800363c:	b2d2      	uxtb	r2, r2
            switch( eAction )
 800363e:	2d04      	cmp	r5, #4
 8003640:	d879      	bhi.n	8003736 <xTaskGenericNotify+0x13e>
 8003642:	e8df f005 	tbb	[pc, r5]
 8003646:	6811      	.short	0x6811
 8003648:	0c70      	.short	0x0c70
 800364a:	64          	.byte	0x64
 800364b:	00          	.byte	0x00
 800364c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003650:	f383 8811 	msr	BASEPRI, r3
 8003654:	f3bf 8f6f 	isb	sy
 8003658:	f3bf 8f4f 	dsb	sy
        configASSERT( xTaskToNotify );
 800365c:	e7fe      	b.n	800365c <xTaskGenericNotify+0x64>
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 800365e:	f104 034c 	add.w	r3, r4, #76	; 0x4c
 8003662:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 8003666:	605e      	str	r6, [r3, #4]
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8003668:	2a01      	cmp	r2, #1
 800366a:	d14b      	bne.n	8003704 <xTaskGenericNotify+0x10c>
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 800366c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8003670:	f107 0c84 	add.w	ip, r7, #132	; 0x84
                prvAddTaskToReadyList( pxTCB );
 8003674:	4836      	ldr	r0, [pc, #216]	; (8003750 <xTaskGenericNotify+0x158>)
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8003676:	e9d7 1222 	ldrd	r1, r2, [r7, #136]	; 0x88
 800367a:	608a      	str	r2, [r1, #8]
 800367c:	6051      	str	r1, [r2, #4]
 800367e:	6859      	ldr	r1, [r3, #4]
 8003680:	4561      	cmp	r1, ip
                prvAddTaskToReadyList( pxTCB );
 8003682:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8003686:	bf08      	it	eq
 8003688:	605a      	streq	r2, [r3, #4]
 800368a:	681a      	ldr	r2, [r3, #0]
 800368c:	3a01      	subs	r2, #1
 800368e:	601a      	str	r2, [r3, #0]
                prvAddTaskToReadyList( pxTCB );
 8003690:	f8d0 34e4 	ldr.w	r3, [r0, #1252]	; 0x4e4
 8003694:	4299      	cmp	r1, r3
 8003696:	d901      	bls.n	800369c <xTaskGenericNotify+0xa4>
 8003698:	f8c0 14e4 	str.w	r1, [r0, #1252]	; 0x4e4
 800369c:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 80036a0:	4d2c      	ldr	r5, [pc, #176]	; (8003754 <xTaskGenericNotify+0x15c>)
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 80036a2:	f8d7 60a8 	ldr.w	r6, [r7, #168]	; 0xa8
                prvAddTaskToReadyList( pxTCB );
 80036a6:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 80036aa:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80036ae:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80036b0:	6894      	ldr	r4, [r2, #8]
 80036b2:	f8c7 2088 	str.w	r2, [r7, #136]	; 0x88
 80036b6:	f8c7 408c 	str.w	r4, [r7, #140]	; 0x8c
 80036ba:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 80036bc:	f104 0e01 	add.w	lr, r4, #1
 80036c0:	6894      	ldr	r4, [r2, #8]
 80036c2:	f8c4 c004 	str.w	ip, [r4, #4]
 80036c6:	f8c2 c008 	str.w	ip, [r2, #8]
 80036ca:	f8c7 5094 	str.w	r5, [r7, #148]	; 0x94
 80036ce:	f8c3 e02c 	str.w	lr, [r3, #44]	; 0x2c
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 80036d2:	b146      	cbz	r6, 80036e6 <xTaskGenericNotify+0xee>
 80036d4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80036d8:	f383 8811 	msr	BASEPRI, r3
 80036dc:	f3bf 8f6f 	isb	sy
 80036e0:	f3bf 8f4f 	dsb	sy
 80036e4:	e7fe      	b.n	80036e4 <xTaskGenericNotify+0xec>
                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 80036e6:	6843      	ldr	r3, [r0, #4]
 80036e8:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 80036ec:	4299      	cmp	r1, r3
 80036ee:	d909      	bls.n	8003704 <xTaskGenericNotify+0x10c>
                    taskYIELD_IF_USING_PREEMPTION();
 80036f0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80036f4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80036f8:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80036fc:	f3bf 8f4f 	dsb	sy
 8003700:	f3bf 8f6f 	isb	sy
 8003704:	2401      	movs	r4, #1
        taskEXIT_CRITICAL();
 8003706:	f006 fa8d 	bl	8009c24 <vPortExitCritical>
    }
 800370a:	4620      	mov	r0, r4
 800370c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 800370e:	2a02      	cmp	r2, #2
 8003710:	d1a5      	bne.n	800365e <xTaskGenericNotify+0x66>
                        xReturn = pdFAIL;
 8003712:	2400      	movs	r4, #0
 8003714:	e7f7      	b.n	8003706 <xTaskGenericNotify+0x10e>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 8003716:	eb07 0484 	add.w	r4, r7, r4, lsl #2
 800371a:	f8d4 3134 	ldr.w	r3, [r4, #308]	; 0x134
 800371e:	431e      	orrs	r6, r3
 8003720:	f8c4 6134 	str.w	r6, [r4, #308]	; 0x134
                    break;
 8003724:	e7a0      	b.n	8003668 <xTaskGenericNotify+0x70>
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 8003726:	eb07 0484 	add.w	r4, r7, r4, lsl #2
 800372a:	f8d4 3134 	ldr.w	r3, [r4, #308]	; 0x134
 800372e:	3301      	adds	r3, #1
 8003730:	f8c4 3134 	str.w	r3, [r4, #308]	; 0x134
                    break;
 8003734:	e798      	b.n	8003668 <xTaskGenericNotify+0x70>
                    configASSERT( xTickCount == ( TickType_t ) 0 );
 8003736:	4b06      	ldr	r3, [pc, #24]	; (8003750 <xTaskGenericNotify+0x158>)
 8003738:	681b      	ldr	r3, [r3, #0]
 800373a:	2b00      	cmp	r3, #0
 800373c:	d094      	beq.n	8003668 <xTaskGenericNotify+0x70>
 800373e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003742:	f383 8811 	msr	BASEPRI, r3
 8003746:	f3bf 8f6f 	isb	sy
 800374a:	f3bf 8f4f 	dsb	sy
 800374e:	e7fe      	b.n	800374e <xTaskGenericNotify+0x156>
 8003750:	24000040 	.word	0x24000040
 8003754:	2400006c 	.word	0x2400006c

08003758 <xTaskGenericNotifyFromISR>:
    {
 8003758:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        configASSERT( xTaskToNotify );
 800375a:	2800      	cmp	r0, #0
 800375c:	d033      	beq.n	80037c6 <xTaskGenericNotifyFromISR+0x6e>
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 800375e:	2902      	cmp	r1, #2
 8003760:	460e      	mov	r6, r1
 8003762:	d908      	bls.n	8003776 <xTaskGenericNotifyFromISR+0x1e>
 8003764:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003768:	f383 8811 	msr	BASEPRI, r3
 800376c:	f3bf 8f6f 	isb	sy
 8003770:	f3bf 8f4f 	dsb	sy
 8003774:	e7fe      	b.n	8003774 <xTaskGenericNotifyFromISR+0x1c>
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8003776:	4615      	mov	r5, r2
 8003778:	461c      	mov	r4, r3
 800377a:	4607      	mov	r7, r0
 800377c:	f006 fa90 	bl	8009ca0 <vPortValidateInterruptPriority>
    __asm volatile
 8003780:	f3ef 8c11 	mrs	ip, BASEPRI
 8003784:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003788:	f383 8811 	msr	BASEPRI, r3
 800378c:	f3bf 8f6f 	isb	sy
 8003790:	f3bf 8f4f 	dsb	sy
            if( pulPreviousNotificationValue != NULL )
 8003794:	9b06      	ldr	r3, [sp, #24]
 8003796:	b133      	cbz	r3, 80037a6 <xTaskGenericNotifyFromISR+0x4e>
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 8003798:	461a      	mov	r2, r3
 800379a:	f106 034c 	add.w	r3, r6, #76	; 0x4c
 800379e:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 80037a2:	685b      	ldr	r3, [r3, #4]
 80037a4:	6013      	str	r3, [r2, #0]
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 80037a6:	19bb      	adds	r3, r7, r6
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 80037a8:	f04f 0e02 	mov.w	lr, #2
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 80037ac:	f893 2140 	ldrb.w	r2, [r3, #320]	; 0x140
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 80037b0:	f883 e140 	strb.w	lr, [r3, #320]	; 0x140
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 80037b4:	b2d2      	uxtb	r2, r2
            switch( eAction )
 80037b6:	2c04      	cmp	r4, #4
 80037b8:	f200 8091 	bhi.w	80038de <xTaskGenericNotifyFromISR+0x186>
 80037bc:	e8df f004 	tbb	[pc, r4]
 80037c0:	0c232f11 	.word	0x0c232f11
 80037c4:	2b          	.byte	0x2b
 80037c5:	00          	.byte	0x00
    __asm volatile
 80037c6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80037ca:	f383 8811 	msr	BASEPRI, r3
 80037ce:	f3bf 8f6f 	isb	sy
 80037d2:	f3bf 8f4f 	dsb	sy
        configASSERT( xTaskToNotify );
 80037d6:	e7fe      	b.n	80037d6 <xTaskGenericNotifyFromISR+0x7e>
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 80037d8:	f106 034c 	add.w	r3, r6, #76	; 0x4c
 80037dc:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 80037e0:	605d      	str	r5, [r3, #4]
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 80037e2:	2a01      	cmp	r2, #1
 80037e4:	d003      	beq.n	80037ee <xTaskGenericNotifyFromISR+0x96>
    {
 80037e6:	2001      	movs	r0, #1
    __asm volatile
 80037e8:	f38c 8811 	msr	BASEPRI, ip
    }
 80037ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 80037ee:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80037f2:	b1e3      	cbz	r3, 800382e <xTaskGenericNotifyFromISR+0xd6>
    __asm volatile
 80037f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80037f8:	f383 8811 	msr	BASEPRI, r3
 80037fc:	f3bf 8f6f 	isb	sy
 8003800:	f3bf 8f4f 	dsb	sy
 8003804:	e7fe      	b.n	8003804 <xTaskGenericNotifyFromISR+0xac>
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 8003806:	eb07 0186 	add.w	r1, r7, r6, lsl #2
 800380a:	f8d1 3134 	ldr.w	r3, [r1, #308]	; 0x134
 800380e:	3301      	adds	r3, #1
 8003810:	f8c1 3134 	str.w	r3, [r1, #308]	; 0x134
                    break;
 8003814:	e7e5      	b.n	80037e2 <xTaskGenericNotifyFromISR+0x8a>
                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 8003816:	2a02      	cmp	r2, #2
 8003818:	d1de      	bne.n	80037d8 <xTaskGenericNotifyFromISR+0x80>
                        xReturn = pdFAIL;
 800381a:	2000      	movs	r0, #0
 800381c:	e7e4      	b.n	80037e8 <xTaskGenericNotifyFromISR+0x90>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 800381e:	eb07 0186 	add.w	r1, r7, r6, lsl #2
 8003822:	f8d1 3134 	ldr.w	r3, [r1, #308]	; 0x134
 8003826:	431d      	orrs	r5, r3
 8003828:	f8c1 5134 	str.w	r5, [r1, #308]	; 0x134
                    break;
 800382c:	e7d9      	b.n	80037e2 <xTaskGenericNotifyFromISR+0x8a>
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800382e:	4a33      	ldr	r2, [pc, #204]	; (80038fc <xTaskGenericNotifyFromISR+0x1a4>)
 8003830:	f8d2 34ec 	ldr.w	r3, [r2, #1260]	; 0x4ec
 8003834:	2b00      	cmp	r3, #0
 8003836:	d13c      	bne.n	80038b2 <xTaskGenericNotifyFromISR+0x15a>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8003838:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800383c:	f107 0084 	add.w	r0, r7, #132	; 0x84
 8003840:	e9d7 4122 	ldrd	r4, r1, [r7, #136]	; 0x88
 8003844:	60a1      	str	r1, [r4, #8]
 8003846:	604c      	str	r4, [r1, #4]
 8003848:	685c      	ldr	r4, [r3, #4]
 800384a:	4284      	cmp	r4, r0
 800384c:	bf08      	it	eq
 800384e:	6059      	streq	r1, [r3, #4]
 8003850:	6819      	ldr	r1, [r3, #0]
 8003852:	3901      	subs	r1, #1
 8003854:	6019      	str	r1, [r3, #0]
                    prvAddTaskToReadyList( pxTCB );
 8003856:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 800385a:	f8d2 34e4 	ldr.w	r3, [r2, #1252]	; 0x4e4
 800385e:	4299      	cmp	r1, r3
 8003860:	d901      	bls.n	8003866 <xTaskGenericNotifyFromISR+0x10e>
 8003862:	f8c2 14e4 	str.w	r1, [r2, #1252]	; 0x4e4
 8003866:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 800386a:	4e25      	ldr	r6, [pc, #148]	; (8003900 <xTaskGenericNotifyFromISR+0x1a8>)
 800386c:	eb06 0683 	add.w	r6, r6, r3, lsl #2
 8003870:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8003874:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 8003876:	68a5      	ldr	r5, [r4, #8]
 8003878:	f8c7 4088 	str.w	r4, [r7, #136]	; 0x88
 800387c:	f8c7 508c 	str.w	r5, [r7, #140]	; 0x8c
 8003880:	6add      	ldr	r5, [r3, #44]	; 0x2c
 8003882:	f105 0e01 	add.w	lr, r5, #1
 8003886:	68a5      	ldr	r5, [r4, #8]
 8003888:	6068      	str	r0, [r5, #4]
 800388a:	60a0      	str	r0, [r4, #8]
 800388c:	f8c7 6094 	str.w	r6, [r7, #148]	; 0x94
 8003890:	f8c3 e02c 	str.w	lr, [r3, #44]	; 0x2c
                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8003894:	6853      	ldr	r3, [r2, #4]
 8003896:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 800389a:	428b      	cmp	r3, r1
 800389c:	d2a3      	bcs.n	80037e6 <xTaskGenericNotifyFromISR+0x8e>
                    if( pxHigherPriorityTaskWoken != NULL )
 800389e:	9b07      	ldr	r3, [sp, #28]
 80038a0:	b113      	cbz	r3, 80038a8 <xTaskGenericNotifyFromISR+0x150>
 80038a2:	4619      	mov	r1, r3
                        *pxHigherPriorityTaskWoken = pdTRUE;
 80038a4:	2301      	movs	r3, #1
 80038a6:	600b      	str	r3, [r1, #0]
                    xYieldPending = pdTRUE;
 80038a8:	2301      	movs	r3, #1
 80038aa:	4618      	mov	r0, r3
 80038ac:	f8c2 34f0 	str.w	r3, [r2, #1264]	; 0x4f0
 80038b0:	e79a      	b.n	80037e8 <xTaskGenericNotifyFromISR+0x90>
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 80038b2:	f8d2 34b8 	ldr.w	r3, [r2, #1208]	; 0x4b8
 80038b6:	f107 0498 	add.w	r4, r7, #152	; 0x98
 80038ba:	6899      	ldr	r1, [r3, #8]
 80038bc:	e9c7 3127 	strd	r3, r1, [r7, #156]	; 0x9c
 80038c0:	f8d2 14b4 	ldr.w	r1, [r2, #1204]	; 0x4b4
 80038c4:	3101      	adds	r1, #1
 80038c6:	f8c2 14b4 	str.w	r1, [r2, #1204]	; 0x4b4
 80038ca:	6899      	ldr	r1, [r3, #8]
 80038cc:	604c      	str	r4, [r1, #4]
 80038ce:	609c      	str	r4, [r3, #8]
 80038d0:	f202 43b4 	addw	r3, r2, #1204	; 0x4b4
                    prvAddTaskToReadyList( pxTCB );
 80038d4:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 80038d8:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 80038dc:	e7da      	b.n	8003894 <xTaskGenericNotifyFromISR+0x13c>
                    configASSERT( xTickCount == ( TickType_t ) 0 );
 80038de:	4b07      	ldr	r3, [pc, #28]	; (80038fc <xTaskGenericNotifyFromISR+0x1a4>)
 80038e0:	681b      	ldr	r3, [r3, #0]
 80038e2:	2b00      	cmp	r3, #0
 80038e4:	f43f af7d 	beq.w	80037e2 <xTaskGenericNotifyFromISR+0x8a>
 80038e8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80038ec:	f383 8811 	msr	BASEPRI, r3
 80038f0:	f3bf 8f6f 	isb	sy
 80038f4:	f3bf 8f4f 	dsb	sy
 80038f8:	e7fe      	b.n	80038f8 <xTaskGenericNotifyFromISR+0x1a0>
 80038fa:	bf00      	nop
 80038fc:	24000040 	.word	0x24000040
 8003900:	2400006c 	.word	0x2400006c

08003904 <xTaskGenericNotifyWait>:
        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 8003904:	2802      	cmp	r0, #2
 8003906:	d908      	bls.n	800391a <xTaskGenericNotifyWait+0x16>
 8003908:	f04f 0350 	mov.w	r3, #80	; 0x50
 800390c:	f383 8811 	msr	BASEPRI, r3
 8003910:	f3bf 8f6f 	isb	sy
 8003914:	f3bf 8f4f 	dsb	sy
 8003918:	e7fe      	b.n	8003918 <xTaskGenericNotifyWait+0x14>
    {
 800391a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 800391e:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 80039dc <xTaskGenericNotifyWait+0xd8>
    {
 8003922:	b082      	sub	sp, #8
 8003924:	4604      	mov	r4, r0
 8003926:	461d      	mov	r5, r3
 8003928:	460e      	mov	r6, r1
 800392a:	4617      	mov	r7, r2
        taskENTER_CRITICAL();
 800392c:	f006 f964 	bl	8009bf8 <vPortEnterCritical>
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 8003930:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8003934:	4423      	add	r3, r4
 8003936:	f893 3140 	ldrb.w	r3, [r3, #320]	; 0x140
 800393a:	2b02      	cmp	r3, #2
 800393c:	d011      	beq.n	8003962 <xTaskGenericNotifyWait+0x5e>
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
 800393e:	f8d8 3004 	ldr.w	r3, [r8, #4]
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 8003942:	2101      	movs	r1, #1
 8003944:	eb03 0384 	add.w	r3, r3, r4, lsl #2
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
 8003948:	f8d3 2134 	ldr.w	r2, [r3, #308]	; 0x134
 800394c:	ea22 0606 	bic.w	r6, r2, r6
 8003950:	f8c3 6134 	str.w	r6, [r3, #308]	; 0x134
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 8003954:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8003958:	4423      	add	r3, r4
 800395a:	f883 1140 	strb.w	r1, [r3, #320]	; 0x140
                if( xTicksToWait > ( TickType_t ) 0 )
 800395e:	9b08      	ldr	r3, [sp, #32]
 8003960:	bb0b      	cbnz	r3, 80039a6 <xTaskGenericNotifyWait+0xa2>
        taskEXIT_CRITICAL();
 8003962:	f006 f95f 	bl	8009c24 <vPortExitCritical>
        taskENTER_CRITICAL();
 8003966:	f006 f947 	bl	8009bf8 <vPortEnterCritical>
            if( pulNotificationValue != NULL )
 800396a:	b13d      	cbz	r5, 800397c <xTaskGenericNotifyWait+0x78>
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 800396c:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8003970:	f104 024c 	add.w	r2, r4, #76	; 0x4c
 8003974:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8003978:	685b      	ldr	r3, [r3, #4]
 800397a:	602b      	str	r3, [r5, #0]
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 800397c:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8003980:	4423      	add	r3, r4
 8003982:	f893 3140 	ldrb.w	r3, [r3, #320]	; 0x140
 8003986:	2b02      	cmp	r3, #2
 8003988:	d01b      	beq.n	80039c2 <xTaskGenericNotifyWait+0xbe>
                xReturn = pdFALSE;
 800398a:	2000      	movs	r0, #0
            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 800398c:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8003990:	2200      	movs	r2, #0
 8003992:	9001      	str	r0, [sp, #4]
 8003994:	441c      	add	r4, r3
 8003996:	f884 2140 	strb.w	r2, [r4, #320]	; 0x140
        taskEXIT_CRITICAL();
 800399a:	f006 f943 	bl	8009c24 <vPortExitCritical>
    }
 800399e:	9801      	ldr	r0, [sp, #4]
 80039a0:	b002      	add	sp, #8
 80039a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80039a6:	4618      	mov	r0, r3
 80039a8:	f7ff f830 	bl	8002a0c <prvAddCurrentTaskToDelayedList>
                    portYIELD_WITHIN_API();
 80039ac:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80039b0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80039b4:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80039b8:	f3bf 8f4f 	dsb	sy
 80039bc:	f3bf 8f6f 	isb	sy
 80039c0:	e7cf      	b.n	8003962 <xTaskGenericNotifyWait+0x5e>
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
 80039c2:	f8d8 3004 	ldr.w	r3, [r8, #4]
                xReturn = pdTRUE;
 80039c6:	2001      	movs	r0, #1
 80039c8:	eb03 0384 	add.w	r3, r3, r4, lsl #2
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
 80039cc:	f8d3 2134 	ldr.w	r2, [r3, #308]	; 0x134
 80039d0:	ea22 0207 	bic.w	r2, r2, r7
 80039d4:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134
                xReturn = pdTRUE;
 80039d8:	e7d8      	b.n	800398c <xTaskGenericNotifyWait+0x88>
 80039da:	bf00      	nop
 80039dc:	24000040 	.word	0x24000040

080039e0 <vTaskGenericNotifyGiveFromISR>:
        configASSERT( xTaskToNotify );
 80039e0:	b388      	cbz	r0, 8003a46 <vTaskGenericNotifyGiveFromISR+0x66>
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 80039e2:	2902      	cmp	r1, #2
    {
 80039e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80039e8:	460d      	mov	r5, r1
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 80039ea:	d908      	bls.n	80039fe <vTaskGenericNotifyGiveFromISR+0x1e>
 80039ec:	f04f 0350 	mov.w	r3, #80	; 0x50
 80039f0:	f383 8811 	msr	BASEPRI, r3
 80039f4:	f3bf 8f6f 	isb	sy
 80039f8:	f3bf 8f4f 	dsb	sy
 80039fc:	e7fe      	b.n	80039fc <vTaskGenericNotifyGiveFromISR+0x1c>
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80039fe:	4680      	mov	r8, r0
 8003a00:	4614      	mov	r4, r2
 8003a02:	f006 f94d 	bl	8009ca0 <vPortValidateInterruptPriority>
    __asm volatile
 8003a06:	f3ef 8e11 	mrs	lr, BASEPRI
 8003a0a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003a0e:	f383 8811 	msr	BASEPRI, r3
 8003a12:	f3bf 8f6f 	isb	sy
 8003a16:	f3bf 8f4f 	dsb	sy
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 8003a1a:	f04f 0c02 	mov.w	ip, #2
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 8003a1e:	eb08 0305 	add.w	r3, r8, r5
 8003a22:	eb08 0185 	add.w	r1, r8, r5, lsl #2
 8003a26:	f893 2140 	ldrb.w	r2, [r3, #320]	; 0x140
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 8003a2a:	f883 c140 	strb.w	ip, [r3, #320]	; 0x140
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 8003a2e:	f8d1 3134 	ldr.w	r3, [r1, #308]	; 0x134
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8003a32:	2a01      	cmp	r2, #1
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 8003a34:	f103 0301 	add.w	r3, r3, #1
 8003a38:	f8c1 3134 	str.w	r3, [r1, #308]	; 0x134
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8003a3c:	d00c      	beq.n	8003a58 <vTaskGenericNotifyGiveFromISR+0x78>
    __asm volatile
 8003a3e:	f38e 8811 	msr	BASEPRI, lr
    }
 8003a42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __asm volatile
 8003a46:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003a4a:	f383 8811 	msr	BASEPRI, r3
 8003a4e:	f3bf 8f6f 	isb	sy
 8003a52:	f3bf 8f4f 	dsb	sy
        configASSERT( xTaskToNotify );
 8003a56:	e7fe      	b.n	8003a56 <vTaskGenericNotifyGiveFromISR+0x76>
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 8003a58:	f8d8 30a8 	ldr.w	r3, [r8, #168]	; 0xa8
 8003a5c:	b143      	cbz	r3, 8003a70 <vTaskGenericNotifyGiveFromISR+0x90>
 8003a5e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003a62:	f383 8811 	msr	BASEPRI, r3
 8003a66:	f3bf 8f6f 	isb	sy
 8003a6a:	f3bf 8f4f 	dsb	sy
 8003a6e:	e7fe      	b.n	8003a6e <vTaskGenericNotifyGiveFromISR+0x8e>
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8003a70:	4b2b      	ldr	r3, [pc, #172]	; (8003b20 <vTaskGenericNotifyGiveFromISR+0x140>)
 8003a72:	f8d3 24ec 	ldr.w	r2, [r3, #1260]	; 0x4ec
 8003a76:	2a00      	cmp	r2, #0
 8003a78:	d139      	bne.n	8003aee <vTaskGenericNotifyGiveFromISR+0x10e>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8003a7a:	f8d8 2094 	ldr.w	r2, [r8, #148]	; 0x94
 8003a7e:	f108 0684 	add.w	r6, r8, #132	; 0x84
 8003a82:	e9d8 5122 	ldrd	r5, r1, [r8, #136]	; 0x88
 8003a86:	60a9      	str	r1, [r5, #8]
 8003a88:	604d      	str	r5, [r1, #4]
 8003a8a:	6855      	ldr	r5, [r2, #4]
 8003a8c:	42b5      	cmp	r5, r6
 8003a8e:	bf08      	it	eq
 8003a90:	6051      	streq	r1, [r2, #4]
 8003a92:	6811      	ldr	r1, [r2, #0]
 8003a94:	3901      	subs	r1, #1
 8003a96:	6011      	str	r1, [r2, #0]
                    prvAddTaskToReadyList( pxTCB );
 8003a98:	f8d8 10ac 	ldr.w	r1, [r8, #172]	; 0xac
 8003a9c:	f8d3 24e4 	ldr.w	r2, [r3, #1252]	; 0x4e4
 8003aa0:	4291      	cmp	r1, r2
 8003aa2:	d901      	bls.n	8003aa8 <vTaskGenericNotifyGiveFromISR+0xc8>
 8003aa4:	f8c3 14e4 	str.w	r1, [r3, #1252]	; 0x4e4
 8003aa8:	eb01 0281 	add.w	r2, r1, r1, lsl #2
 8003aac:	4f1d      	ldr	r7, [pc, #116]	; (8003b24 <vTaskGenericNotifyGiveFromISR+0x144>)
 8003aae:	eb07 0782 	add.w	r7, r7, r2, lsl #2
 8003ab2:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8003ab6:	6b10      	ldr	r0, [r2, #48]	; 0x30
 8003ab8:	6885      	ldr	r5, [r0, #8]
 8003aba:	f8c8 0088 	str.w	r0, [r8, #136]	; 0x88
 8003abe:	f8c8 508c 	str.w	r5, [r8, #140]	; 0x8c
 8003ac2:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
 8003ac4:	f105 0c01 	add.w	ip, r5, #1
 8003ac8:	6885      	ldr	r5, [r0, #8]
 8003aca:	606e      	str	r6, [r5, #4]
 8003acc:	6086      	str	r6, [r0, #8]
 8003ace:	f8c8 7094 	str.w	r7, [r8, #148]	; 0x94
 8003ad2:	f8c2 c02c 	str.w	ip, [r2, #44]	; 0x2c
                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8003ad6:	685a      	ldr	r2, [r3, #4]
 8003ad8:	f8d2 20ac 	ldr.w	r2, [r2, #172]	; 0xac
 8003adc:	428a      	cmp	r2, r1
 8003ade:	d2ae      	bcs.n	8003a3e <vTaskGenericNotifyGiveFromISR+0x5e>
                    if( pxHigherPriorityTaskWoken != NULL )
 8003ae0:	b10c      	cbz	r4, 8003ae6 <vTaskGenericNotifyGiveFromISR+0x106>
                        *pxHigherPriorityTaskWoken = pdTRUE;
 8003ae2:	2201      	movs	r2, #1
 8003ae4:	6022      	str	r2, [r4, #0]
                    xYieldPending = pdTRUE;
 8003ae6:	2201      	movs	r2, #1
 8003ae8:	f8c3 24f0 	str.w	r2, [r3, #1264]	; 0x4f0
 8003aec:	e7a7      	b.n	8003a3e <vTaskGenericNotifyGiveFromISR+0x5e>
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8003aee:	f8d3 24b8 	ldr.w	r2, [r3, #1208]	; 0x4b8
 8003af2:	6891      	ldr	r1, [r2, #8]
 8003af4:	f8c8 209c 	str.w	r2, [r8, #156]	; 0x9c
 8003af8:	f8c8 10a0 	str.w	r1, [r8, #160]	; 0xa0
 8003afc:	f8d3 14b4 	ldr.w	r1, [r3, #1204]	; 0x4b4
 8003b00:	6895      	ldr	r5, [r2, #8]
 8003b02:	3101      	adds	r1, #1
 8003b04:	f8c3 14b4 	str.w	r1, [r3, #1204]	; 0x4b4
 8003b08:	f108 0198 	add.w	r1, r8, #152	; 0x98
 8003b0c:	6069      	str	r1, [r5, #4]
 8003b0e:	6091      	str	r1, [r2, #8]
 8003b10:	f203 42b4 	addw	r2, r3, #1204	; 0x4b4
                    prvAddTaskToReadyList( pxTCB );
 8003b14:	f8d8 10ac 	ldr.w	r1, [r8, #172]	; 0xac
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8003b18:	f8c8 20a8 	str.w	r2, [r8, #168]	; 0xa8
 8003b1c:	e7db      	b.n	8003ad6 <vTaskGenericNotifyGiveFromISR+0xf6>
 8003b1e:	bf00      	nop
 8003b20:	24000040 	.word	0x24000040
 8003b24:	2400006c 	.word	0x2400006c

08003b28 <ulTaskGenericNotifyTake>:
        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 8003b28:	2802      	cmp	r0, #2
 8003b2a:	d908      	bls.n	8003b3e <ulTaskGenericNotifyTake+0x16>
 8003b2c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003b30:	f383 8811 	msr	BASEPRI, r3
 8003b34:	f3bf 8f6f 	isb	sy
 8003b38:	f3bf 8f4f 	dsb	sy
 8003b3c:	e7fe      	b.n	8003b3c <ulTaskGenericNotifyTake+0x14>
    {
 8003b3e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003b42:	4604      	mov	r4, r0
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
 8003b44:	f8df 8080 	ldr.w	r8, [pc, #128]	; 8003bc8 <ulTaskGenericNotifyTake+0xa0>
 8003b48:	460e      	mov	r6, r1
 8003b4a:	4615      	mov	r5, r2
 8003b4c:	f104 074c 	add.w	r7, r4, #76	; 0x4c
        taskENTER_CRITICAL();
 8003b50:	f006 f852 	bl	8009bf8 <vPortEnterCritical>
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
 8003b54:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8003b58:	eb03 0387 	add.w	r3, r3, r7, lsl #2
 8003b5c:	685b      	ldr	r3, [r3, #4]
 8003b5e:	b99b      	cbnz	r3, 8003b88 <ulTaskGenericNotifyTake+0x60>
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 8003b60:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8003b64:	2101      	movs	r1, #1
 8003b66:	4423      	add	r3, r4
 8003b68:	f883 1140 	strb.w	r1, [r3, #320]	; 0x140
                if( xTicksToWait > ( TickType_t ) 0 )
 8003b6c:	b165      	cbz	r5, 8003b88 <ulTaskGenericNotifyTake+0x60>
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8003b6e:	4628      	mov	r0, r5
 8003b70:	f7fe ff4c 	bl	8002a0c <prvAddCurrentTaskToDelayedList>
                    portYIELD_WITHIN_API();
 8003b74:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003b78:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003b7c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8003b80:	f3bf 8f4f 	dsb	sy
 8003b84:	f3bf 8f6f 	isb	sy
        taskEXIT_CRITICAL();
 8003b88:	f006 f84c 	bl	8009c24 <vPortExitCritical>
        taskENTER_CRITICAL();
 8003b8c:	f006 f834 	bl	8009bf8 <vPortEnterCritical>
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 8003b90:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8003b94:	eb03 0387 	add.w	r3, r3, r7, lsl #2
 8003b98:	00bf      	lsls	r7, r7, #2
 8003b9a:	685d      	ldr	r5, [r3, #4]
            if( ulReturn != 0UL )
 8003b9c:	b12d      	cbz	r5, 8003baa <ulTaskGenericNotifyTake+0x82>
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
 8003b9e:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8003ba2:	441f      	add	r7, r3
                if( xClearCountOnExit != pdFALSE )
 8003ba4:	b166      	cbz	r6, 8003bc0 <ulTaskGenericNotifyTake+0x98>
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
 8003ba6:	2300      	movs	r3, #0
 8003ba8:	607b      	str	r3, [r7, #4]
            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 8003baa:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8003bae:	2200      	movs	r2, #0
 8003bb0:	441c      	add	r4, r3
 8003bb2:	f884 2140 	strb.w	r2, [r4, #320]	; 0x140
        taskEXIT_CRITICAL();
 8003bb6:	f006 f835 	bl	8009c24 <vPortExitCritical>
    }
 8003bba:	4628      	mov	r0, r5
 8003bbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
 8003bc0:	1e6b      	subs	r3, r5, #1
 8003bc2:	607b      	str	r3, [r7, #4]
 8003bc4:	e7f1      	b.n	8003baa <ulTaskGenericNotifyTake+0x82>
 8003bc6:	bf00      	nop
 8003bc8:	24000040 	.word	0x24000040

08003bcc <xTaskGenericNotifyStateClear>:
        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 8003bcc:	2902      	cmp	r1, #2
 8003bce:	d908      	bls.n	8003be2 <xTaskGenericNotifyStateClear+0x16>
 8003bd0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003bd4:	f383 8811 	msr	BASEPRI, r3
 8003bd8:	f3bf 8f6f 	isb	sy
 8003bdc:	f3bf 8f4f 	dsb	sy
 8003be0:	e7fe      	b.n	8003be0 <xTaskGenericNotifyStateClear+0x14>
    {
 8003be2:	b530      	push	{r4, r5, lr}
 8003be4:	460d      	mov	r5, r1
 8003be6:	b083      	sub	sp, #12
 8003be8:	4604      	mov	r4, r0
        pxTCB = prvGetTCBFromHandle( xTask );
 8003bea:	b190      	cbz	r0, 8003c12 <xTaskGenericNotifyStateClear+0x46>
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
 8003bec:	442c      	add	r4, r5
        taskENTER_CRITICAL();
 8003bee:	f006 f803 	bl	8009bf8 <vPortEnterCritical>
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
 8003bf2:	f894 3140 	ldrb.w	r3, [r4, #320]	; 0x140
 8003bf6:	2b02      	cmp	r3, #2
 8003bf8:	d006      	beq.n	8003c08 <xTaskGenericNotifyStateClear+0x3c>
                xReturn = pdFAIL;
 8003bfa:	2000      	movs	r0, #0
 8003bfc:	9001      	str	r0, [sp, #4]
        taskEXIT_CRITICAL();
 8003bfe:	f006 f811 	bl	8009c24 <vPortExitCritical>
    }
 8003c02:	9801      	ldr	r0, [sp, #4]
 8003c04:	b003      	add	sp, #12
 8003c06:	bd30      	pop	{r4, r5, pc}
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
 8003c08:	2300      	movs	r3, #0
                xReturn = pdPASS;
 8003c0a:	2001      	movs	r0, #1
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
 8003c0c:	f884 3140 	strb.w	r3, [r4, #320]	; 0x140
                xReturn = pdPASS;
 8003c10:	e7f4      	b.n	8003bfc <xTaskGenericNotifyStateClear+0x30>
        pxTCB = prvGetTCBFromHandle( xTask );
 8003c12:	4b05      	ldr	r3, [pc, #20]	; (8003c28 <xTaskGenericNotifyStateClear+0x5c>)
 8003c14:	685c      	ldr	r4, [r3, #4]
        taskENTER_CRITICAL();
 8003c16:	f005 ffef 	bl	8009bf8 <vPortEnterCritical>
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
 8003c1a:	442c      	add	r4, r5
 8003c1c:	f894 3140 	ldrb.w	r3, [r4, #320]	; 0x140
 8003c20:	2b02      	cmp	r3, #2
 8003c22:	d1ea      	bne.n	8003bfa <xTaskGenericNotifyStateClear+0x2e>
 8003c24:	e7f0      	b.n	8003c08 <xTaskGenericNotifyStateClear+0x3c>
 8003c26:	bf00      	nop
 8003c28:	24000040 	.word	0x24000040

08003c2c <ulTaskGenericNotifyValueClear>:
    {
 8003c2c:	b570      	push	{r4, r5, r6, lr}
 8003c2e:	460e      	mov	r6, r1
 8003c30:	b082      	sub	sp, #8
 8003c32:	4615      	mov	r5, r2
        pxTCB = prvGetTCBFromHandle( xTask );
 8003c34:	b190      	cbz	r0, 8003c5c <ulTaskGenericNotifyValueClear+0x30>
 8003c36:	4604      	mov	r4, r0
        taskENTER_CRITICAL();
 8003c38:	f005 ffde 	bl	8009bf8 <vPortEnterCritical>
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
 8003c3c:	eb04 0186 	add.w	r1, r4, r6, lsl #2
 8003c40:	f8d1 0134 	ldr.w	r0, [r1, #308]	; 0x134
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
 8003c44:	f8d1 3134 	ldr.w	r3, [r1, #308]	; 0x134
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
 8003c48:	9001      	str	r0, [sp, #4]
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
 8003c4a:	ea23 0305 	bic.w	r3, r3, r5
 8003c4e:	f8c1 3134 	str.w	r3, [r1, #308]	; 0x134
        taskEXIT_CRITICAL();
 8003c52:	f005 ffe7 	bl	8009c24 <vPortExitCritical>
    }
 8003c56:	9801      	ldr	r0, [sp, #4]
 8003c58:	b002      	add	sp, #8
 8003c5a:	bd70      	pop	{r4, r5, r6, pc}
        pxTCB = prvGetTCBFromHandle( xTask );
 8003c5c:	4b01      	ldr	r3, [pc, #4]	; (8003c64 <ulTaskGenericNotifyValueClear+0x38>)
 8003c5e:	685c      	ldr	r4, [r3, #4]
 8003c60:	e7ea      	b.n	8003c38 <ulTaskGenericNotifyValueClear+0xc>
 8003c62:	bf00      	nop
 8003c64:	24000040 	.word	0x24000040

08003c68 <vTaskSetTimeOutState>:
    configASSERT( pxTimeOut );
 8003c68:	b168      	cbz	r0, 8003c86 <vTaskSetTimeOutState+0x1e>
{
 8003c6a:	b510      	push	{r4, lr}
 8003c6c:	4604      	mov	r4, r0
    taskENTER_CRITICAL();
 8003c6e:	f005 ffc3 	bl	8009bf8 <vPortEnterCritical>
        pxTimeOut->xOverflowCount = xNumOfOverflows;
 8003c72:	4b09      	ldr	r3, [pc, #36]	; (8003c98 <vTaskSetTimeOutState+0x30>)
 8003c74:	f8d3 24f4 	ldr.w	r2, [r3, #1268]	; 0x4f4
        pxTimeOut->xTimeOnEntering = xTickCount;
 8003c78:	681b      	ldr	r3, [r3, #0]
 8003c7a:	e9c4 2300 	strd	r2, r3, [r4]
}
 8003c7e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    taskEXIT_CRITICAL();
 8003c82:	f005 bfcf 	b.w	8009c24 <vPortExitCritical>
 8003c86:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003c8a:	f383 8811 	msr	BASEPRI, r3
 8003c8e:	f3bf 8f6f 	isb	sy
 8003c92:	f3bf 8f4f 	dsb	sy
    configASSERT( pxTimeOut );
 8003c96:	e7fe      	b.n	8003c96 <vTaskSetTimeOutState+0x2e>
 8003c98:	24000040 	.word	0x24000040

08003c9c <xTaskCheckForTimeOut>:
    configASSERT( pxTimeOut );
 8003c9c:	b328      	cbz	r0, 8003cea <xTaskCheckForTimeOut+0x4e>
{
 8003c9e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003ca0:	460d      	mov	r5, r1
 8003ca2:	b083      	sub	sp, #12
    configASSERT( pxTicksToWait );
 8003ca4:	b1c1      	cbz	r1, 8003cd8 <xTaskCheckForTimeOut+0x3c>
 8003ca6:	4604      	mov	r4, r0
    taskENTER_CRITICAL();
 8003ca8:	f005 ffa6 	bl	8009bf8 <vPortEnterCritical>
            if( *pxTicksToWait == portMAX_DELAY )
 8003cac:	682b      	ldr	r3, [r5, #0]
        const TickType_t xConstTickCount = xTickCount;
 8003cae:	4a1b      	ldr	r2, [pc, #108]	; (8003d1c <xTaskCheckForTimeOut+0x80>)
            if( *pxTicksToWait == portMAX_DELAY )
 8003cb0:	1c58      	adds	r0, r3, #1
        const TickType_t xConstTickCount = xTickCount;
 8003cb2:	6811      	ldr	r1, [r2, #0]
            if( *pxTicksToWait == portMAX_DELAY )
 8003cb4:	d030      	beq.n	8003d18 <xTaskCheckForTimeOut+0x7c>
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8003cb6:	f8d2 64f4 	ldr.w	r6, [r2, #1268]	; 0x4f4
 8003cba:	e9d4 7000 	ldrd	r7, r0, [r4]
 8003cbe:	42b7      	cmp	r7, r6
 8003cc0:	d01c      	beq.n	8003cfc <xTaskCheckForTimeOut+0x60>
 8003cc2:	4288      	cmp	r0, r1
 8003cc4:	d81a      	bhi.n	8003cfc <xTaskCheckForTimeOut+0x60>
            *pxTicksToWait = ( TickType_t ) 0;
 8003cc6:	2300      	movs	r3, #0
            xReturn = pdTRUE;
 8003cc8:	2001      	movs	r0, #1
            *pxTicksToWait = ( TickType_t ) 0;
 8003cca:	602b      	str	r3, [r5, #0]
 8003ccc:	9001      	str	r0, [sp, #4]
    taskEXIT_CRITICAL();
 8003cce:	f005 ffa9 	bl	8009c24 <vPortExitCritical>
}
 8003cd2:	9801      	ldr	r0, [sp, #4]
 8003cd4:	b003      	add	sp, #12
 8003cd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003cd8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003cdc:	f383 8811 	msr	BASEPRI, r3
 8003ce0:	f3bf 8f6f 	isb	sy
 8003ce4:	f3bf 8f4f 	dsb	sy
    configASSERT( pxTicksToWait );
 8003ce8:	e7fe      	b.n	8003ce8 <xTaskCheckForTimeOut+0x4c>
 8003cea:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003cee:	f383 8811 	msr	BASEPRI, r3
 8003cf2:	f3bf 8f6f 	isb	sy
 8003cf6:	f3bf 8f4f 	dsb	sy
    configASSERT( pxTimeOut );
 8003cfa:	e7fe      	b.n	8003cfa <xTaskCheckForTimeOut+0x5e>
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8003cfc:	eba1 0c00 	sub.w	ip, r1, r0
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8003d00:	4563      	cmp	r3, ip
 8003d02:	d9e0      	bls.n	8003cc6 <xTaskCheckForTimeOut+0x2a>
            *pxTicksToWait -= xElapsedTime;
 8003d04:	1a5b      	subs	r3, r3, r1
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 8003d06:	f8d2 14f4 	ldr.w	r1, [r2, #1268]	; 0x4f4
    pxTimeOut->xTimeOnEntering = xTickCount;
 8003d0a:	6812      	ldr	r2, [r2, #0]
            *pxTicksToWait -= xElapsedTime;
 8003d0c:	4403      	add	r3, r0
            xReturn = pdFALSE;
 8003d0e:	2000      	movs	r0, #0
            *pxTicksToWait -= xElapsedTime;
 8003d10:	602b      	str	r3, [r5, #0]
    pxTimeOut->xTimeOnEntering = xTickCount;
 8003d12:	e9c4 1200 	strd	r1, r2, [r4]
            xReturn = pdFALSE;
 8003d16:	e7d9      	b.n	8003ccc <xTaskCheckForTimeOut+0x30>
                xReturn = pdFALSE;
 8003d18:	2000      	movs	r0, #0
 8003d1a:	e7d7      	b.n	8003ccc <xTaskCheckForTimeOut+0x30>
 8003d1c:	24000040 	.word	0x24000040

08003d20 <xTaskIncrementTick>:
    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8003d20:	4a5c      	ldr	r2, [pc, #368]	; (8003e94 <xTaskIncrementTick+0x174>)
 8003d22:	f8d2 34ec 	ldr.w	r3, [r2, #1260]	; 0x4ec
 8003d26:	2b00      	cmp	r3, #0
 8003d28:	f040 8087 	bne.w	8003e3a <xTaskIncrementTick+0x11a>
{
 8003d2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8003d30:	6817      	ldr	r7, [r2, #0]
 8003d32:	3701      	adds	r7, #1
        xTickCount = xConstTickCount;
 8003d34:	6017      	str	r7, [r2, #0]
        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8003d36:	b9af      	cbnz	r7, 8003d64 <xTaskIncrementTick+0x44>
            taskSWITCH_DELAYED_LISTS();
 8003d38:	6a13      	ldr	r3, [r2, #32]
 8003d3a:	681b      	ldr	r3, [r3, #0]
 8003d3c:	2b00      	cmp	r3, #0
 8003d3e:	f040 8096 	bne.w	8003e6e <xTaskIncrementTick+0x14e>
 8003d42:	6a13      	ldr	r3, [r2, #32]
 8003d44:	69d1      	ldr	r1, [r2, #28]
 8003d46:	6211      	str	r1, [r2, #32]
 8003d48:	61d3      	str	r3, [r2, #28]
 8003d4a:	f8d2 34f4 	ldr.w	r3, [r2, #1268]	; 0x4f4
 8003d4e:	3301      	adds	r3, #1
 8003d50:	f8c2 34f4 	str.w	r3, [r2, #1268]	; 0x4f4
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003d54:	6a13      	ldr	r3, [r2, #32]
 8003d56:	681b      	ldr	r3, [r3, #0]
 8003d58:	2b00      	cmp	r3, #0
 8003d5a:	f040 8095 	bne.w	8003e88 <xTaskIncrementTick+0x168>
        xNextTaskUnblockTime = portMAX_DELAY;
 8003d5e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003d62:	6253      	str	r3, [r2, #36]	; 0x24
        if( xConstTickCount >= xNextTaskUnblockTime )
 8003d64:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8003d66:	42bb      	cmp	r3, r7
 8003d68:	d86e      	bhi.n	8003e48 <xTaskIncrementTick+0x128>
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003d6a:	6a13      	ldr	r3, [r2, #32]
 8003d6c:	6818      	ldr	r0, [r3, #0]
 8003d6e:	2800      	cmp	r0, #0
 8003d70:	f000 8086 	beq.w	8003e80 <xTaskIncrementTick+0x160>
    BaseType_t xSwitchRequired = pdFALSE;
 8003d74:	2000      	movs	r0, #0
                    prvAddTaskToReadyList( pxTCB );
 8003d76:	f8df e120 	ldr.w	lr, [pc, #288]	; 8003e98 <xTaskIncrementTick+0x178>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8003d7a:	4684      	mov	ip, r0
 8003d7c:	e050      	b.n	8003e20 <xTaskIncrementTick+0x100>
 8003d7e:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 8003d82:	e9d3 4822 	ldrd	r4, r8, [r3, #136]	; 0x88
 8003d86:	f8c4 8008 	str.w	r8, [r4, #8]
 8003d8a:	f8c8 4004 	str.w	r4, [r8, #4]
 8003d8e:	684c      	ldr	r4, [r1, #4]
 8003d90:	42b4      	cmp	r4, r6
 8003d92:	680c      	ldr	r4, [r1, #0]
 8003d94:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
 8003d98:	bf08      	it	eq
 8003d9a:	f8c1 8004 	streq.w	r8, [r1, #4]
 8003d9e:	f8c3 c094 	str.w	ip, [r3, #148]	; 0x94
 8003da2:	600c      	str	r4, [r1, #0]
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8003da4:	f8d3 40a8 	ldr.w	r4, [r3, #168]	; 0xa8
 8003da8:	b18c      	cbz	r4, 8003dce <xTaskIncrementTick+0xae>
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 8003daa:	f8d4 9004 	ldr.w	r9, [r4, #4]
 8003dae:	e9d3 8127 	ldrd	r8, r1, [r3, #156]	; 0x9c
 8003db2:	45a9      	cmp	r9, r5
 8003db4:	f8c8 1008 	str.w	r1, [r8, #8]
 8003db8:	f8d3 10a0 	ldr.w	r1, [r3, #160]	; 0xa0
 8003dbc:	f8c1 8004 	str.w	r8, [r1, #4]
 8003dc0:	bf08      	it	eq
 8003dc2:	6061      	streq	r1, [r4, #4]
 8003dc4:	6821      	ldr	r1, [r4, #0]
 8003dc6:	f8c3 c0a8 	str.w	ip, [r3, #168]	; 0xa8
 8003dca:	3901      	subs	r1, #1
 8003dcc:	6021      	str	r1, [r4, #0]
                    prvAddTaskToReadyList( pxTCB );
 8003dce:	f8d3 10ac 	ldr.w	r1, [r3, #172]	; 0xac
 8003dd2:	f8d2 44e4 	ldr.w	r4, [r2, #1252]	; 0x4e4
 8003dd6:	42a1      	cmp	r1, r4
 8003dd8:	eb01 0481 	add.w	r4, r1, r1, lsl #2
 8003ddc:	d901      	bls.n	8003de2 <xTaskIncrementTick+0xc2>
 8003dde:	f8c2 14e4 	str.w	r1, [r2, #1252]	; 0x4e4
 8003de2:	eb02 0884 	add.w	r8, r2, r4, lsl #2
 8003de6:	eb0e 0a84 	add.w	sl, lr, r4, lsl #2
 8003dea:	f8d8 5030 	ldr.w	r5, [r8, #48]	; 0x30
 8003dee:	f8d8 902c 	ldr.w	r9, [r8, #44]	; 0x2c
 8003df2:	68ac      	ldr	r4, [r5, #8]
 8003df4:	f109 0901 	add.w	r9, r9, #1
 8003df8:	f8c3 5088 	str.w	r5, [r3, #136]	; 0x88
 8003dfc:	f8c3 408c 	str.w	r4, [r3, #140]	; 0x8c
 8003e00:	68ac      	ldr	r4, [r5, #8]
 8003e02:	6066      	str	r6, [r4, #4]
 8003e04:	60ae      	str	r6, [r5, #8]
 8003e06:	f8c3 a094 	str.w	sl, [r3, #148]	; 0x94
 8003e0a:	f8c8 902c 	str.w	r9, [r8, #44]	; 0x2c
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8003e0e:	6854      	ldr	r4, [r2, #4]
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003e10:	6a13      	ldr	r3, [r2, #32]
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8003e12:	f8d4 40ac 	ldr.w	r4, [r4, #172]	; 0xac
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003e16:	681b      	ldr	r3, [r3, #0]
                                xSwitchRequired = pdTRUE;
 8003e18:	42a1      	cmp	r1, r4
 8003e1a:	bf28      	it	cs
 8003e1c:	2001      	movcs	r0, #1
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003e1e:	b37b      	cbz	r3, 8003e80 <xTaskIncrementTick+0x160>
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003e20:	6a13      	ldr	r3, [r2, #32]
 8003e22:	68db      	ldr	r3, [r3, #12]
 8003e24:	68db      	ldr	r3, [r3, #12]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8003e26:	f8d3 1084 	ldr.w	r1, [r3, #132]	; 0x84
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8003e2a:	f103 0684 	add.w	r6, r3, #132	; 0x84
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 8003e2e:	f103 0598 	add.w	r5, r3, #152	; 0x98
                    if( xConstTickCount < xItemValue )
 8003e32:	428f      	cmp	r7, r1
 8003e34:	d2a3      	bcs.n	8003d7e <xTaskIncrementTick+0x5e>
                        xNextTaskUnblockTime = xItemValue;
 8003e36:	6251      	str	r1, [r2, #36]	; 0x24
                        break; /*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */
 8003e38:	e007      	b.n	8003e4a <xTaskIncrementTick+0x12a>
        ++xPendedTicks;
 8003e3a:	f8d2 34f8 	ldr.w	r3, [r2, #1272]	; 0x4f8
    BaseType_t xSwitchRequired = pdFALSE;
 8003e3e:	2000      	movs	r0, #0
        ++xPendedTicks;
 8003e40:	3301      	adds	r3, #1
 8003e42:	f8c2 34f8 	str.w	r3, [r2, #1272]	; 0x4f8
}
 8003e46:	4770      	bx	lr
    BaseType_t xSwitchRequired = pdFALSE;
 8003e48:	2000      	movs	r0, #0
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8003e4a:	6853      	ldr	r3, [r2, #4]
 8003e4c:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8003e50:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8003e54:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8003e58:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
                if( xYieldPending != pdFALSE )
 8003e5a:	f8d2 34f0 	ldr.w	r3, [r2, #1264]	; 0x4f0
                    xSwitchRequired = pdTRUE;
 8003e5e:	2902      	cmp	r1, #2
 8003e60:	bf28      	it	cs
 8003e62:	2001      	movcs	r0, #1
                    xSwitchRequired = pdTRUE;
 8003e64:	2b00      	cmp	r3, #0
 8003e66:	bf18      	it	ne
 8003e68:	2001      	movne	r0, #1
}
 8003e6a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8003e6e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003e72:	f383 8811 	msr	BASEPRI, r3
 8003e76:	f3bf 8f6f 	isb	sy
 8003e7a:	f3bf 8f4f 	dsb	sy
            taskSWITCH_DELAYED_LISTS();
 8003e7e:	e7fe      	b.n	8003e7e <xTaskIncrementTick+0x15e>
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003e80:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003e84:	6253      	str	r3, [r2, #36]	; 0x24
                    break;
 8003e86:	e7e0      	b.n	8003e4a <xTaskIncrementTick+0x12a>
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 8003e88:	6a13      	ldr	r3, [r2, #32]
 8003e8a:	68db      	ldr	r3, [r3, #12]
 8003e8c:	681b      	ldr	r3, [r3, #0]
 8003e8e:	6253      	str	r3, [r2, #36]	; 0x24
 8003e90:	e768      	b.n	8003d64 <xTaskIncrementTick+0x44>
 8003e92:	bf00      	nop
 8003e94:	24000040 	.word	0x24000040
 8003e98:	2400006c 	.word	0x2400006c

08003e9c <xTaskResumeAll>:
{
 8003e9c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    configASSERT( uxSchedulerSuspended );
 8003ea0:	4c51      	ldr	r4, [pc, #324]	; (8003fe8 <xTaskResumeAll+0x14c>)
 8003ea2:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
 8003ea6:	b943      	cbnz	r3, 8003eba <xTaskResumeAll+0x1e>
 8003ea8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003eac:	f383 8811 	msr	BASEPRI, r3
 8003eb0:	f3bf 8f6f 	isb	sy
 8003eb4:	f3bf 8f4f 	dsb	sy
 8003eb8:	e7fe      	b.n	8003eb8 <xTaskResumeAll+0x1c>
    taskENTER_CRITICAL();
 8003eba:	f005 fe9d 	bl	8009bf8 <vPortEnterCritical>
        --uxSchedulerSuspended;
 8003ebe:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
 8003ec2:	3b01      	subs	r3, #1
 8003ec4:	f8c4 34ec 	str.w	r3, [r4, #1260]	; 0x4ec
        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8003ec8:	f8d4 54ec 	ldr.w	r5, [r4, #1260]	; 0x4ec
 8003ecc:	2d00      	cmp	r5, #0
 8003ece:	d16f      	bne.n	8003fb0 <xTaskResumeAll+0x114>
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8003ed0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003ed2:	2b00      	cmp	r3, #0
 8003ed4:	d06c      	beq.n	8003fb0 <xTaskResumeAll+0x114>
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8003ed6:	f8d4 34b4 	ldr.w	r3, [r4, #1204]	; 0x4b4
 8003eda:	2b00      	cmp	r3, #0
 8003edc:	d058      	beq.n	8003f90 <xTaskResumeAll+0xf4>
 8003ede:	f104 0e2c 	add.w	lr, r4, #44	; 0x2c
                        xYieldPending = pdTRUE;
 8003ee2:	f04f 0901 	mov.w	r9, #1
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003ee6:	f8d4 34c0 	ldr.w	r3, [r4, #1216]	; 0x4c0
 8003eea:	68db      	ldr	r3, [r3, #12]
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 8003eec:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
 8003ef0:	f103 0798 	add.w	r7, r3, #152	; 0x98
 8003ef4:	e9d3 0127 	ldrd	r0, r1, [r3, #156]	; 0x9c
 8003ef8:	6081      	str	r1, [r0, #8]
 8003efa:	6048      	str	r0, [r1, #4]
 8003efc:	6850      	ldr	r0, [r2, #4]
 8003efe:	42b8      	cmp	r0, r7
 8003f00:	bf08      	it	eq
 8003f02:	6051      	streq	r1, [r2, #4]
 8003f04:	6811      	ldr	r1, [r2, #0]
 8003f06:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
 8003f0a:	3901      	subs	r1, #1
 8003f0c:	6011      	str	r1, [r2, #0]
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8003f0e:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8003f12:	f103 0784 	add.w	r7, r3, #132	; 0x84
 8003f16:	e9d3 1022 	ldrd	r1, r0, [r3, #136]	; 0x88
 8003f1a:	6088      	str	r0, [r1, #8]
 8003f1c:	6041      	str	r1, [r0, #4]
 8003f1e:	6851      	ldr	r1, [r2, #4]
 8003f20:	42b9      	cmp	r1, r7
 8003f22:	6811      	ldr	r1, [r2, #0]
 8003f24:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
 8003f28:	bf08      	it	eq
 8003f2a:	6050      	streq	r0, [r2, #4]
 8003f2c:	6011      	str	r1, [r2, #0]
                    prvAddTaskToReadyList( pxTCB );
 8003f2e:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
 8003f32:	f8d4 14e4 	ldr.w	r1, [r4, #1252]	; 0x4e4
 8003f36:	428a      	cmp	r2, r1
 8003f38:	d901      	bls.n	8003f3e <xTaskResumeAll+0xa2>
 8003f3a:	f8c4 24e4 	str.w	r2, [r4, #1252]	; 0x4e4
 8003f3e:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 8003f42:	eb04 0c81 	add.w	ip, r4, r1, lsl #2
 8003f46:	eb0e 0181 	add.w	r1, lr, r1, lsl #2
 8003f4a:	f8dc 0030 	ldr.w	r0, [ip, #48]	; 0x30
 8003f4e:	f8dc 802c 	ldr.w	r8, [ip, #44]	; 0x2c
 8003f52:	6886      	ldr	r6, [r0, #8]
 8003f54:	f108 0801 	add.w	r8, r8, #1
 8003f58:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
 8003f5c:	f8c3 608c 	str.w	r6, [r3, #140]	; 0x8c
 8003f60:	6886      	ldr	r6, [r0, #8]
 8003f62:	6077      	str	r7, [r6, #4]
 8003f64:	6087      	str	r7, [r0, #8]
 8003f66:	f8c3 1094 	str.w	r1, [r3, #148]	; 0x94
 8003f6a:	f8cc 802c 	str.w	r8, [ip, #44]	; 0x2c
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8003f6e:	6863      	ldr	r3, [r4, #4]
 8003f70:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8003f74:	429a      	cmp	r2, r3
 8003f76:	d321      	bcc.n	8003fbc <xTaskResumeAll+0x120>
                        xYieldPending = pdTRUE;
 8003f78:	f8c4 94f0 	str.w	r9, [r4, #1264]	; 0x4f0
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8003f7c:	f8d4 34b4 	ldr.w	r3, [r4, #1204]	; 0x4b4
 8003f80:	2b00      	cmp	r3, #0
 8003f82:	d1b0      	bne.n	8003ee6 <xTaskResumeAll+0x4a>
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003f84:	6a23      	ldr	r3, [r4, #32]
 8003f86:	681b      	ldr	r3, [r3, #0]
 8003f88:	bb4b      	cbnz	r3, 8003fde <xTaskResumeAll+0x142>
        xNextTaskUnblockTime = portMAX_DELAY;
 8003f8a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003f8e:	6263      	str	r3, [r4, #36]	; 0x24
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 8003f90:	f8d4 54f8 	ldr.w	r5, [r4, #1272]	; 0x4f8
                    if( xPendedCounts > ( TickType_t ) 0U )
 8003f94:	b14d      	cbz	r5, 8003faa <xTaskResumeAll+0x10e>
                                xYieldPending = pdTRUE;
 8003f96:	2601      	movs	r6, #1
                            if( xTaskIncrementTick() != pdFALSE )
 8003f98:	f7ff fec2 	bl	8003d20 <xTaskIncrementTick>
 8003f9c:	b108      	cbz	r0, 8003fa2 <xTaskResumeAll+0x106>
                                xYieldPending = pdTRUE;
 8003f9e:	f8c4 64f0 	str.w	r6, [r4, #1264]	; 0x4f0
                        } while( xPendedCounts > ( TickType_t ) 0U );
 8003fa2:	3d01      	subs	r5, #1
 8003fa4:	d1f8      	bne.n	8003f98 <xTaskResumeAll+0xfc>
                        xPendedTicks = 0;
 8003fa6:	f8c4 54f8 	str.w	r5, [r4, #1272]	; 0x4f8
                if( xYieldPending != pdFALSE )
 8003faa:	f8d4 34f0 	ldr.w	r3, [r4, #1264]	; 0x4f0
 8003fae:	b953      	cbnz	r3, 8003fc6 <xTaskResumeAll+0x12a>
    BaseType_t xAlreadyYielded = pdFALSE;
 8003fb0:	2400      	movs	r4, #0
    taskEXIT_CRITICAL();
 8003fb2:	f005 fe37 	bl	8009c24 <vPortExitCritical>
}
 8003fb6:	4620      	mov	r0, r4
 8003fb8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8003fbc:	f8d4 34b4 	ldr.w	r3, [r4, #1204]	; 0x4b4
 8003fc0:	2b00      	cmp	r3, #0
 8003fc2:	d190      	bne.n	8003ee6 <xTaskResumeAll+0x4a>
 8003fc4:	e7de      	b.n	8003f84 <xTaskResumeAll+0xe8>
                    taskYIELD_IF_USING_PREEMPTION();
 8003fc6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8003fca:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003fce:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8003fd2:	f3bf 8f4f 	dsb	sy
 8003fd6:	f3bf 8f6f 	isb	sy
                            xAlreadyYielded = pdTRUE;
 8003fda:	2401      	movs	r4, #1
 8003fdc:	e7e9      	b.n	8003fb2 <xTaskResumeAll+0x116>
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 8003fde:	6a23      	ldr	r3, [r4, #32]
 8003fe0:	68db      	ldr	r3, [r3, #12]
 8003fe2:	681b      	ldr	r3, [r3, #0]
 8003fe4:	6263      	str	r3, [r4, #36]	; 0x24
 8003fe6:	e7d3      	b.n	8003f90 <xTaskResumeAll+0xf4>
 8003fe8:	24000040 	.word	0x24000040

08003fec <vTaskDelay>:
    {
 8003fec:	b508      	push	{r3, lr}
        if( xTicksToDelay > ( TickType_t ) 0U )
 8003fee:	b1b0      	cbz	r0, 800401e <vTaskDelay+0x32>
            configASSERT( uxSchedulerSuspended == 0 );
 8003ff0:	4b10      	ldr	r3, [pc, #64]	; (8004034 <vTaskDelay+0x48>)
 8003ff2:	f8d3 14ec 	ldr.w	r1, [r3, #1260]	; 0x4ec
 8003ff6:	b141      	cbz	r1, 800400a <vTaskDelay+0x1e>
 8003ff8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003ffc:	f383 8811 	msr	BASEPRI, r3
 8004000:	f3bf 8f6f 	isb	sy
 8004004:	f3bf 8f4f 	dsb	sy
 8004008:	e7fe      	b.n	8004008 <vTaskDelay+0x1c>
    ++uxSchedulerSuspended;
 800400a:	f8d3 24ec 	ldr.w	r2, [r3, #1260]	; 0x4ec
 800400e:	3201      	adds	r2, #1
 8004010:	f8c3 24ec 	str.w	r2, [r3, #1260]	; 0x4ec
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8004014:	f7fe fcfa 	bl	8002a0c <prvAddCurrentTaskToDelayedList>
            xAlreadyYielded = xTaskResumeAll();
 8004018:	f7ff ff40 	bl	8003e9c <xTaskResumeAll>
        if( xAlreadyYielded == pdFALSE )
 800401c:	b948      	cbnz	r0, 8004032 <vTaskDelay+0x46>
            portYIELD_WITHIN_API();
 800401e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8004022:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004026:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800402a:	f3bf 8f4f 	dsb	sy
 800402e:	f3bf 8f6f 	isb	sy
    }
 8004032:	bd08      	pop	{r3, pc}
 8004034:	24000040 	.word	0x24000040

08004038 <xTaskDelayUntil>:
    {
 8004038:	b538      	push	{r3, r4, r5, lr}
        configASSERT( pxPreviousWakeTime );
 800403a:	b300      	cbz	r0, 800407e <xTaskDelayUntil+0x46>
        configASSERT( ( xTimeIncrement > 0U ) );
 800403c:	b941      	cbnz	r1, 8004050 <xTaskDelayUntil+0x18>
 800403e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004042:	f383 8811 	msr	BASEPRI, r3
 8004046:	f3bf 8f6f 	isb	sy
 800404a:	f3bf 8f4f 	dsb	sy
 800404e:	e7fe      	b.n	800404e <xTaskDelayUntil+0x16>
        configASSERT( uxSchedulerSuspended == 0 );
 8004050:	4b24      	ldr	r3, [pc, #144]	; (80040e4 <xTaskDelayUntil+0xac>)
 8004052:	f8d3 24ec 	ldr.w	r2, [r3, #1260]	; 0x4ec
 8004056:	b9da      	cbnz	r2, 8004090 <xTaskDelayUntil+0x58>
    ++uxSchedulerSuspended;
 8004058:	f8d3 44ec 	ldr.w	r4, [r3, #1260]	; 0x4ec
 800405c:	3401      	adds	r4, #1
 800405e:	f8c3 44ec 	str.w	r4, [r3, #1260]	; 0x4ec
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8004062:	6804      	ldr	r4, [r0, #0]
            const TickType_t xConstTickCount = xTickCount;
 8004064:	681d      	ldr	r5, [r3, #0]
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8004066:	1863      	adds	r3, r4, r1
 8004068:	bf2c      	ite	cs
 800406a:	2101      	movcs	r1, #1
 800406c:	2100      	movcc	r1, #0
            if( xConstTickCount < *pxPreviousWakeTime )
 800406e:	42ac      	cmp	r4, r5
 8004070:	d917      	bls.n	80040a2 <xTaskDelayUntil+0x6a>
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 8004072:	b389      	cbz	r1, 80040d8 <xTaskDelayUntil+0xa0>
 8004074:	429d      	cmp	r5, r3
 8004076:	d332      	bcc.n	80040de <xTaskDelayUntil+0xa6>
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 8004078:	4614      	mov	r4, r2
            *pxPreviousWakeTime = xTimeToWake;
 800407a:	6003      	str	r3, [r0, #0]
            if( xShouldDelay != pdFALSE )
 800407c:	e01d      	b.n	80040ba <xTaskDelayUntil+0x82>
 800407e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004082:	f383 8811 	msr	BASEPRI, r3
 8004086:	f3bf 8f6f 	isb	sy
 800408a:	f3bf 8f4f 	dsb	sy
        configASSERT( pxPreviousWakeTime );
 800408e:	e7fe      	b.n	800408e <xTaskDelayUntil+0x56>
 8004090:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004094:	f383 8811 	msr	BASEPRI, r3
 8004098:	f3bf 8f6f 	isb	sy
 800409c:	f3bf 8f4f 	dsb	sy
        configASSERT( uxSchedulerSuspended == 0 );
 80040a0:	e7fe      	b.n	80040a0 <xTaskDelayUntil+0x68>
            *pxPreviousWakeTime = xTimeToWake;
 80040a2:	6003      	str	r3, [r0, #0]
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 80040a4:	b921      	cbnz	r1, 80040b0 <xTaskDelayUntil+0x78>
 80040a6:	429d      	cmp	r5, r3
 80040a8:	bf2c      	ite	cs
 80040aa:	2400      	movcs	r4, #0
 80040ac:	2401      	movcc	r4, #1
 80040ae:	b124      	cbz	r4, 80040ba <xTaskDelayUntil+0x82>
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 80040b0:	2100      	movs	r1, #0
 80040b2:	1b58      	subs	r0, r3, r5
 80040b4:	2401      	movs	r4, #1
 80040b6:	f7fe fca9 	bl	8002a0c <prvAddCurrentTaskToDelayedList>
        xAlreadyYielded = xTaskResumeAll();
 80040ba:	f7ff feef 	bl	8003e9c <xTaskResumeAll>
        if( xAlreadyYielded == pdFALSE )
 80040be:	b948      	cbnz	r0, 80040d4 <xTaskDelayUntil+0x9c>
            portYIELD_WITHIN_API();
 80040c0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80040c4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80040c8:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80040cc:	f3bf 8f4f 	dsb	sy
 80040d0:	f3bf 8f6f 	isb	sy
    }
 80040d4:	4620      	mov	r0, r4
 80040d6:	bd38      	pop	{r3, r4, r5, pc}
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 80040d8:	460c      	mov	r4, r1
            *pxPreviousWakeTime = xTimeToWake;
 80040da:	6003      	str	r3, [r0, #0]
            if( xShouldDelay != pdFALSE )
 80040dc:	e7ed      	b.n	80040ba <xTaskDelayUntil+0x82>
            *pxPreviousWakeTime = xTimeToWake;
 80040de:	6003      	str	r3, [r0, #0]
            if( xShouldDelay != pdFALSE )
 80040e0:	e7e6      	b.n	80040b0 <xTaskDelayUntil+0x78>
 80040e2:	bf00      	nop
 80040e4:	24000040 	.word	0x24000040

080040e8 <vTaskGetInfo>:
    {
 80040e8:	b570      	push	{r4, r5, r6, lr}
 80040ea:	460c      	mov	r4, r1
 80040ec:	4616      	mov	r6, r2
        pxTCB = prvGetTCBFromHandle( xTask );
 80040ee:	b378      	cbz	r0, 8004150 <vTaskGetInfo+0x68>
 80040f0:	4605      	mov	r5, r0
        pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
 80040f2:	f105 02b4 	add.w	r2, r5, #180	; 0xb4
        if( eState != eInvalid )
 80040f6:	2b05      	cmp	r3, #5
        pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
 80040f8:	e9c4 5200 	strd	r5, r2, [r4]
        pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 80040fc:	f8d5 20ac 	ldr.w	r2, [r5, #172]	; 0xac
 8004100:	6122      	str	r2, [r4, #16]
        pxTaskStatus->pxStackBase = pxTCB->pxStack;
 8004102:	f8d5 20b0 	ldr.w	r2, [r5, #176]	; 0xb0
 8004106:	61e2      	str	r2, [r4, #28]
        pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 8004108:	f8d5 20c4 	ldr.w	r2, [r5, #196]	; 0xc4
 800410c:	60a2      	str	r2, [r4, #8]
                pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 800410e:	f8d5 20cc 	ldr.w	r2, [r5, #204]	; 0xcc
 8004112:	6162      	str	r2, [r4, #20]
                pxTaskStatus->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
 8004114:	f04f 0200 	mov.w	r2, #0
 8004118:	61a2      	str	r2, [r4, #24]
        if( eState != eInvalid )
 800411a:	d01e      	beq.n	800415a <vTaskGetInfo+0x72>
            if( pxTCB == pxCurrentTCB )
 800411c:	4919      	ldr	r1, [pc, #100]	; (8004184 <vTaskGetInfo+0x9c>)
 800411e:	6848      	ldr	r0, [r1, #4]
 8004120:	42a8      	cmp	r0, r5
 8004122:	d018      	beq.n	8004156 <vTaskGetInfo+0x6e>
                        if( eState == eSuspended )
 8004124:	2b03      	cmp	r3, #3
                pxTaskStatus->eCurrentState = eState;
 8004126:	7323      	strb	r3, [r4, #12]
                        if( eState == eSuspended )
 8004128:	d01c      	beq.n	8004164 <vTaskGetInfo+0x7c>
        if( xGetFreeStackSpace != pdFALSE )
 800412a:	b17e      	cbz	r6, 800414c <vTaskGetInfo+0x64>
                    pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 800412c:	f8d5 30b0 	ldr.w	r3, [r5, #176]	; 0xb0
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 8004130:	781a      	ldrb	r2, [r3, #0]
 8004132:	2aa5      	cmp	r2, #165	; 0xa5
 8004134:	d123      	bne.n	800417e <vTaskGetInfo+0x96>
 8004136:	f1c3 0001 	rsb	r0, r3, #1
            ulCount++;
 800413a:	18c1      	adds	r1, r0, r3
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 800413c:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 8004140:	2aa5      	cmp	r2, #165	; 0xa5
 8004142:	d0fa      	beq.n	800413a <vTaskGetInfo+0x52>
        return ( configSTACK_DEPTH_TYPE ) ulCount;
 8004144:	f3c1 018f 	ubfx	r1, r1, #2, #16
                    pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 8004148:	8421      	strh	r1, [r4, #32]
    }
 800414a:	bd70      	pop	{r4, r5, r6, pc}
            pxTaskStatus->usStackHighWaterMark = 0;
 800414c:	8426      	strh	r6, [r4, #32]
    }
 800414e:	bd70      	pop	{r4, r5, r6, pc}
        pxTCB = prvGetTCBFromHandle( xTask );
 8004150:	4a0c      	ldr	r2, [pc, #48]	; (8004184 <vTaskGetInfo+0x9c>)
 8004152:	6855      	ldr	r5, [r2, #4]
 8004154:	e7cd      	b.n	80040f2 <vTaskGetInfo+0xa>
                pxTaskStatus->eCurrentState = eRunning;
 8004156:	7322      	strb	r2, [r4, #12]
 8004158:	e7e7      	b.n	800412a <vTaskGetInfo+0x42>
            pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
 800415a:	4628      	mov	r0, r5
 800415c:	f7fe ffe8 	bl	8003130 <eTaskGetState>
 8004160:	7320      	strb	r0, [r4, #12]
 8004162:	e7e2      	b.n	800412a <vTaskGetInfo+0x42>
    ++uxSchedulerSuspended;
 8004164:	f8d1 34ec 	ldr.w	r3, [r1, #1260]	; 0x4ec
 8004168:	3301      	adds	r3, #1
 800416a:	f8c1 34ec 	str.w	r3, [r1, #1260]	; 0x4ec
                                if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800416e:	f8d5 30a8 	ldr.w	r3, [r5, #168]	; 0xa8
 8004172:	b10b      	cbz	r3, 8004178 <vTaskGetInfo+0x90>
                                    pxTaskStatus->eCurrentState = eBlocked;
 8004174:	2302      	movs	r3, #2
 8004176:	7323      	strb	r3, [r4, #12]
                            ( void ) xTaskResumeAll();
 8004178:	f7ff fe90 	bl	8003e9c <xTaskResumeAll>
 800417c:	e7d5      	b.n	800412a <vTaskGetInfo+0x42>
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 800417e:	2100      	movs	r1, #0
 8004180:	e7e2      	b.n	8004148 <vTaskGetInfo+0x60>
 8004182:	bf00      	nop
 8004184:	24000040 	.word	0x24000040

08004188 <xTaskCatchUpTicks>:
    configASSERT( uxSchedulerSuspended == 0 );
 8004188:	4b0c      	ldr	r3, [pc, #48]	; (80041bc <xTaskCatchUpTicks+0x34>)
 800418a:	f8d3 24ec 	ldr.w	r2, [r3, #1260]	; 0x4ec
 800418e:	b142      	cbz	r2, 80041a2 <xTaskCatchUpTicks+0x1a>
 8004190:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004194:	f383 8811 	msr	BASEPRI, r3
 8004198:	f3bf 8f6f 	isb	sy
 800419c:	f3bf 8f4f 	dsb	sy
 80041a0:	e7fe      	b.n	80041a0 <xTaskCatchUpTicks+0x18>
    ++uxSchedulerSuspended;
 80041a2:	f8d3 24ec 	ldr.w	r2, [r3, #1260]	; 0x4ec
 80041a6:	3201      	adds	r2, #1
 80041a8:	f8c3 24ec 	str.w	r2, [r3, #1260]	; 0x4ec
    xPendedTicks += xTicksToCatchUp;
 80041ac:	f8d3 24f8 	ldr.w	r2, [r3, #1272]	; 0x4f8
 80041b0:	4410      	add	r0, r2
 80041b2:	f8c3 04f8 	str.w	r0, [r3, #1272]	; 0x4f8
    xYieldOccurred = xTaskResumeAll();
 80041b6:	f7ff be71 	b.w	8003e9c <xTaskResumeAll>
 80041ba:	bf00      	nop
 80041bc:	24000040 	.word	0x24000040

080041c0 <prvListTasksWithinSingleList>:
    {
 80041c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 80041c4:	680f      	ldr	r7, [r1, #0]
    {
 80041c6:	b083      	sub	sp, #12
        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 80041c8:	2f00      	cmp	r7, #0
 80041ca:	d063      	beq.n	8004294 <prvListTasksWithinSingleList+0xd4>
            listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80041cc:	684b      	ldr	r3, [r1, #4]
 80041ce:	f101 0b08 	add.w	fp, r1, #8
 80041d2:	460e      	mov	r6, r1
        UBaseType_t uxTask = 0;
 80041d4:	2700      	movs	r7, #0
            listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80041d6:	685b      	ldr	r3, [r3, #4]
 80041d8:	4690      	mov	r8, r2
 80041da:	4604      	mov	r4, r0
 80041dc:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 80042c4 <prvListTasksWithinSingleList+0x104>
 80041e0:	455b      	cmp	r3, fp
                pxTaskStatus->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
 80041e2:	463a      	mov	r2, r7
            listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80041e4:	bf08      	it	eq
 80041e6:	68cb      	ldreq	r3, [r1, #12]
 80041e8:	f8d3 a00c 	ldr.w	sl, [r3, #12]
                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80041ec:	685b      	ldr	r3, [r3, #4]
 80041ee:	459b      	cmp	fp, r3
 80041f0:	6073      	str	r3, [r6, #4]
 80041f2:	d038      	beq.n	8004266 <prvListTasksWithinSingleList+0xa6>
 80041f4:	68dd      	ldr	r5, [r3, #12]
        pxTCB = prvGetTCBFromHandle( xTask );
 80041f6:	2d00      	cmp	r5, #0
 80041f8:	d03b      	beq.n	8004272 <prvListTasksWithinSingleList+0xb2>
 80041fa:	462b      	mov	r3, r5
        pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 80041fc:	f8d3 00ac 	ldr.w	r0, [r3, #172]	; 0xac
        pxTaskStatus->pxStackBase = pxTCB->pxStack;
 8004200:	f8d3 10b0 	ldr.w	r1, [r3, #176]	; 0xb0
        pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 8004204:	6120      	str	r0, [r4, #16]
        pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 8004206:	f8d3 00c4 	ldr.w	r0, [r3, #196]	; 0xc4
        pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
 800420a:	6023      	str	r3, [r4, #0]
        pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 800420c:	60a0      	str	r0, [r4, #8]
                pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 800420e:	f8d3 00cc 	ldr.w	r0, [r3, #204]	; 0xcc
        pxTaskStatus->pxStackBase = pxTCB->pxStack;
 8004212:	61e1      	str	r1, [r4, #28]
                pxTaskStatus->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
 8004214:	e9c4 0205 	strd	r0, r2, [r4, #20]
        pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
 8004218:	f103 00b4 	add.w	r0, r3, #180	; 0xb4
 800421c:	6060      	str	r0, [r4, #4]
            if( pxTCB == pxCurrentTCB )
 800421e:	f8d9 0004 	ldr.w	r0, [r9, #4]
 8004222:	4298      	cmp	r0, r3
 8004224:	d028      	beq.n	8004278 <prvListTasksWithinSingleList+0xb8>
                        if( eState == eSuspended )
 8004226:	f1b8 0f03 	cmp.w	r8, #3
                pxTaskStatus->eCurrentState = eState;
 800422a:	f884 800c 	strb.w	r8, [r4, #12]
                        if( eState == eSuspended )
 800422e:	d035      	beq.n	800429c <prvListTasksWithinSingleList+0xdc>
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 8004230:	780b      	ldrb	r3, [r1, #0]
 8004232:	2ba5      	cmp	r3, #165	; 0xa5
 8004234:	d124      	bne.n	8004280 <prvListTasksWithinSingleList+0xc0>
 8004236:	460b      	mov	r3, r1
 8004238:	f1c1 0e01 	rsb	lr, r1, #1
            ulCount++;
 800423c:	eb0e 0c03 	add.w	ip, lr, r3
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 8004240:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8004244:	28a5      	cmp	r0, #165	; 0xa5
 8004246:	d0f9      	beq.n	800423c <prvListTasksWithinSingleList+0x7c>
        return ( configSTACK_DEPTH_TYPE ) ulCount;
 8004248:	f3cc 0c8f 	ubfx	ip, ip, #2, #16
            } while( pxNextTCB != pxFirstTCB );
 800424c:	45aa      	cmp	sl, r5
                uxTask++;
 800424e:	f107 0701 	add.w	r7, r7, #1
            } while( pxNextTCB != pxFirstTCB );
 8004252:	f104 0424 	add.w	r4, r4, #36	; 0x24
                    pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 8004256:	f824 cc04 	strh.w	ip, [r4, #-4]
            } while( pxNextTCB != pxFirstTCB );
 800425a:	d01b      	beq.n	8004294 <prvListTasksWithinSingleList+0xd4>
                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800425c:	6873      	ldr	r3, [r6, #4]
 800425e:	685b      	ldr	r3, [r3, #4]
 8004260:	459b      	cmp	fp, r3
 8004262:	6073      	str	r3, [r6, #4]
 8004264:	d1c6      	bne.n	80041f4 <prvListTasksWithinSingleList+0x34>
 8004266:	f8db 3004 	ldr.w	r3, [fp, #4]
 800426a:	68dd      	ldr	r5, [r3, #12]
 800426c:	6073      	str	r3, [r6, #4]
        pxTCB = prvGetTCBFromHandle( xTask );
 800426e:	2d00      	cmp	r5, #0
 8004270:	d1c3      	bne.n	80041fa <prvListTasksWithinSingleList+0x3a>
 8004272:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8004276:	e7c1      	b.n	80041fc <prvListTasksWithinSingleList+0x3c>
                pxTaskStatus->eCurrentState = eRunning;
 8004278:	7322      	strb	r2, [r4, #12]
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 800427a:	780b      	ldrb	r3, [r1, #0]
 800427c:	2ba5      	cmp	r3, #165	; 0xa5
 800427e:	d0da      	beq.n	8004236 <prvListTasksWithinSingleList+0x76>
 8004280:	f04f 0c00 	mov.w	ip, #0
            } while( pxNextTCB != pxFirstTCB );
 8004284:	45aa      	cmp	sl, r5
                uxTask++;
 8004286:	f107 0701 	add.w	r7, r7, #1
            } while( pxNextTCB != pxFirstTCB );
 800428a:	f104 0424 	add.w	r4, r4, #36	; 0x24
                    pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 800428e:	f824 cc04 	strh.w	ip, [r4, #-4]
            } while( pxNextTCB != pxFirstTCB );
 8004292:	d1e3      	bne.n	800425c <prvListTasksWithinSingleList+0x9c>
    }
 8004294:	4638      	mov	r0, r7
 8004296:	b003      	add	sp, #12
 8004298:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ++uxSchedulerSuspended;
 800429c:	f8d9 04ec 	ldr.w	r0, [r9, #1260]	; 0x4ec
 80042a0:	3001      	adds	r0, #1
 80042a2:	f8c9 04ec 	str.w	r0, [r9, #1260]	; 0x4ec
                                if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80042a6:	f8d3 00a8 	ldr.w	r0, [r3, #168]	; 0xa8
 80042aa:	b110      	cbz	r0, 80042b2 <prvListTasksWithinSingleList+0xf2>
                                    pxTaskStatus->eCurrentState = eBlocked;
 80042ac:	f04f 0102 	mov.w	r1, #2
 80042b0:	7321      	strb	r1, [r4, #12]
 80042b2:	9301      	str	r3, [sp, #4]
                            ( void ) xTaskResumeAll();
 80042b4:	f7ff fdf2 	bl	8003e9c <xTaskResumeAll>
                    pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 80042b8:	9b01      	ldr	r3, [sp, #4]
 80042ba:	2200      	movs	r2, #0
 80042bc:	f8d3 10b0 	ldr.w	r1, [r3, #176]	; 0xb0
 80042c0:	e7b6      	b.n	8004230 <prvListTasksWithinSingleList+0x70>
 80042c2:	bf00      	nop
 80042c4:	24000040 	.word	0x24000040

080042c8 <uxTaskGetSystemState>:
    {
 80042c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ++uxSchedulerSuspended;
 80042cc:	4d52      	ldr	r5, [pc, #328]	; (8004418 <uxTaskGetSystemState+0x150>)
    {
 80042ce:	b083      	sub	sp, #12
    ++uxSchedulerSuspended;
 80042d0:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
 80042d4:	3301      	adds	r3, #1
    {
 80042d6:	e9cd 0200 	strd	r0, r2, [sp]
    ++uxSchedulerSuspended;
 80042da:	f8c5 34ec 	str.w	r3, [r5, #1260]	; 0x4ec
            if( uxArraySize >= uxCurrentNumberOfTasks )
 80042de:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80042e0:	428b      	cmp	r3, r1
 80042e2:	f200 8091 	bhi.w	8004408 <uxTaskGetSystemState+0x140>
        UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 80042e6:	2700      	movs	r7, #0
 80042e8:	2638      	movs	r6, #56	; 0x38
 80042ea:	f505 6890 	add.w	r8, r5, #1152	; 0x480
                pxTaskStatus->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
 80042ee:	46bb      	mov	fp, r7
 80042f0:	46ba      	mov	sl, r7
 80042f2:	46b1      	mov	r9, r6
                    uxQueue--;
 80042f4:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 80042f8:	eb09 0389 	add.w	r3, r9, r9, lsl #2
 80042fc:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8004300:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004302:	2b00      	cmp	r3, #0
 8004304:	d042      	beq.n	800438c <uxTaskGetSystemState+0xc4>
            listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004306:	f858 3c04 	ldr.w	r3, [r8, #-4]
 800430a:	eb0a 01ca 	add.w	r1, sl, sl, lsl #3
        UBaseType_t uxTask = 0;
 800430e:	f04f 0c00 	mov.w	ip, #0
            listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004312:	685e      	ldr	r6, [r3, #4]
 8004314:	9b00      	ldr	r3, [sp, #0]
 8004316:	4546      	cmp	r6, r8
 8004318:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 800431c:	bf08      	it	eq
 800431e:	f8d8 6004 	ldreq.w	r6, [r8, #4]
 8004322:	f8d6 e00c 	ldr.w	lr, [r6, #12]
                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004326:	6876      	ldr	r6, [r6, #4]
 8004328:	4546      	cmp	r6, r8
 800432a:	f848 6c04 	str.w	r6, [r8, #-4]
 800432e:	d065      	beq.n	80043fc <uxTaskGetSystemState+0x134>
 8004330:	68f0      	ldr	r0, [r6, #12]
        pxTCB = prvGetTCBFromHandle( xTask );
 8004332:	2800      	cmp	r0, #0
 8004334:	d060      	beq.n	80043f8 <uxTaskGetSystemState+0x130>
 8004336:	4602      	mov	r2, r0
        pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 8004338:	f8d2 30ac 	ldr.w	r3, [r2, #172]	; 0xac
        pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
 800433c:	600a      	str	r2, [r1, #0]
            if( pxTCB == pxCurrentTCB )
 800433e:	686f      	ldr	r7, [r5, #4]
        pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 8004340:	610b      	str	r3, [r1, #16]
            if( pxTCB == pxCurrentTCB )
 8004342:	1bd7      	subs	r7, r2, r7
        pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 8004344:	f8d2 40c4 	ldr.w	r4, [r2, #196]	; 0xc4
        pxTaskStatus->pxStackBase = pxTCB->pxStack;
 8004348:	f8d2 30b0 	ldr.w	r3, [r2, #176]	; 0xb0
        pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
 800434c:	f102 02b4 	add.w	r2, r2, #180	; 0xb4
            if( pxTCB == pxCurrentTCB )
 8004350:	bf18      	it	ne
 8004352:	2701      	movne	r7, #1
        pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 8004354:	608c      	str	r4, [r1, #8]
                pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 8004356:	6994      	ldr	r4, [r2, #24]
        pxTaskStatus->pxStackBase = pxTCB->pxStack;
 8004358:	61cb      	str	r3, [r1, #28]
            if( pxTCB == pxCurrentTCB )
 800435a:	730f      	strb	r7, [r1, #12]
                pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 800435c:	614c      	str	r4, [r1, #20]
        pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
 800435e:	604a      	str	r2, [r1, #4]
                pxTaskStatus->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
 8004360:	f8c1 b018 	str.w	fp, [r1, #24]
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 8004364:	781a      	ldrb	r2, [r3, #0]
 8004366:	2aa5      	cmp	r2, #165	; 0xa5
 8004368:	d14c      	bne.n	8004404 <uxTaskGetSystemState+0x13c>
 800436a:	f1c3 0701 	rsb	r7, r3, #1
            ulCount++;
 800436e:	18fc      	adds	r4, r7, r3
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 8004370:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 8004374:	2aa5      	cmp	r2, #165	; 0xa5
 8004376:	d0fa      	beq.n	800436e <uxTaskGetSystemState+0xa6>
        return ( configSTACK_DEPTH_TYPE ) ulCount;
 8004378:	f3c4 048f 	ubfx	r4, r4, #2, #16
            } while( pxNextTCB != pxFirstTCB );
 800437c:	4586      	cmp	lr, r0
                    pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 800437e:	840c      	strh	r4, [r1, #32]
                uxTask++;
 8004380:	f10c 0c01 	add.w	ip, ip, #1
            } while( pxNextTCB != pxFirstTCB );
 8004384:	f101 0124 	add.w	r1, r1, #36	; 0x24
 8004388:	d1cd      	bne.n	8004326 <uxTaskGetSystemState+0x5e>
                    uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 800438a:	44e2      	add	sl, ip
                } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800438c:	f1a8 0814 	sub.w	r8, r8, #20
 8004390:	f1b9 0f00 	cmp.w	r9, #0
 8004394:	d1ae      	bne.n	80042f4 <uxTaskGetSystemState+0x2c>
                uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 8004396:	9c00      	ldr	r4, [sp, #0]
 8004398:	eb0a 00ca 	add.w	r0, sl, sl, lsl #3
 800439c:	4657      	mov	r7, sl
 800439e:	6a29      	ldr	r1, [r5, #32]
 80043a0:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 80043a4:	2202      	movs	r2, #2
 80043a6:	f7ff ff0b 	bl	80041c0 <prvListTasksWithinSingleList>
 80043aa:	4407      	add	r7, r0
                uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 80043ac:	69e9      	ldr	r1, [r5, #28]
 80043ae:	2202      	movs	r2, #2
 80043b0:	eb07 00c7 	add.w	r0, r7, r7, lsl #3
                        uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
 80043b4:	4625      	mov	r5, r4
                uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 80043b6:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 80043ba:	f7ff ff01 	bl	80041c0 <prvListTasksWithinSingleList>
 80043be:	4407      	add	r7, r0
                        uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
 80043c0:	2204      	movs	r2, #4
 80043c2:	4916      	ldr	r1, [pc, #88]	; (800441c <uxTaskGetSystemState+0x154>)
 80043c4:	eb07 00c7 	add.w	r0, r7, r7, lsl #3
 80043c8:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 80043cc:	f7ff fef8 	bl	80041c0 <prvListTasksWithinSingleList>
 80043d0:	183c      	adds	r4, r7, r0
                        uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
 80043d2:	2203      	movs	r2, #3
 80043d4:	4912      	ldr	r1, [pc, #72]	; (8004420 <uxTaskGetSystemState+0x158>)
 80043d6:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 80043da:	eb05 0080 	add.w	r0, r5, r0, lsl #2
 80043de:	f7ff feef 	bl	80041c0 <prvListTasksWithinSingleList>
                        if( pulTotalRunTime != NULL )
 80043e2:	9b01      	ldr	r3, [sp, #4]
                        uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
 80043e4:	4404      	add	r4, r0
                        if( pulTotalRunTime != NULL )
 80043e6:	b183      	cbz	r3, 800440a <uxTaskGetSystemState+0x142>
                            *pulTotalRunTime = 0;
 80043e8:	f8c3 9000 	str.w	r9, [r3]
        ( void ) xTaskResumeAll();
 80043ec:	f7ff fd56 	bl	8003e9c <xTaskResumeAll>
    }
 80043f0:	4620      	mov	r0, r4
 80043f2:	b003      	add	sp, #12
 80043f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        pxTCB = prvGetTCBFromHandle( xTask );
 80043f8:	686a      	ldr	r2, [r5, #4]
 80043fa:	e79d      	b.n	8004338 <uxTaskGetSystemState+0x70>
                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80043fc:	6876      	ldr	r6, [r6, #4]
 80043fe:	f848 6c04 	str.w	r6, [r8, #-4]
 8004402:	e795      	b.n	8004330 <uxTaskGetSystemState+0x68>
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 8004404:	2400      	movs	r4, #0
 8004406:	e7b9      	b.n	800437c <uxTaskGetSystemState+0xb4>
        UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 8004408:	2400      	movs	r4, #0
        ( void ) xTaskResumeAll();
 800440a:	f7ff fd47 	bl	8003e9c <xTaskResumeAll>
    }
 800440e:	4620      	mov	r0, r4
 8004410:	b003      	add	sp, #12
 8004412:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004416:	bf00      	nop
 8004418:	24000040 	.word	0x24000040
 800441c:	24000508 	.word	0x24000508
 8004420:	24000048 	.word	0x24000048

08004424 <vTaskPlaceOnEventList>:
    configASSERT( pxEventList );
 8004424:	2800      	cmp	r0, #0
 8004426:	d034      	beq.n	8004492 <vTaskPlaceOnEventList+0x6e>
{
 8004428:	b570      	push	{r4, r5, r6, lr}
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800442a:	4c22      	ldr	r4, [pc, #136]	; (80044b4 <vTaskPlaceOnEventList+0x90>)
 800442c:	460d      	mov	r5, r1
 800442e:	6861      	ldr	r1, [r4, #4]
 8004430:	3198      	adds	r1, #152	; 0x98
 8004432:	f7fc f9a9 	bl	8000788 <vListInsert>
    const TickType_t xConstTickCount = xTickCount;
 8004436:	6826      	ldr	r6, [r4, #0]
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8004438:	6860      	ldr	r0, [r4, #4]
 800443a:	3084      	adds	r0, #132	; 0x84
 800443c:	f7fc f9cc 	bl	80007d8 <uxListRemove>
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8004440:	1c6b      	adds	r3, r5, #1
 8004442:	d117      	bne.n	8004474 <vTaskPlaceOnEventList+0x50>
                listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004444:	68e3      	ldr	r3, [r4, #12]
 8004446:	6860      	ldr	r0, [r4, #4]
 8004448:	6899      	ldr	r1, [r3, #8]
 800444a:	6862      	ldr	r2, [r4, #4]
 800444c:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
 8004450:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
 8004454:	6861      	ldr	r1, [r4, #4]
 8004456:	689d      	ldr	r5, [r3, #8]
 8004458:	3184      	adds	r1, #132	; 0x84
 800445a:	6862      	ldr	r2, [r4, #4]
 800445c:	6860      	ldr	r0, [r4, #4]
 800445e:	6069      	str	r1, [r5, #4]
 8004460:	3284      	adds	r2, #132	; 0x84
 8004462:	68a1      	ldr	r1, [r4, #8]
 8004464:	f104 0508 	add.w	r5, r4, #8
 8004468:	609a      	str	r2, [r3, #8]
 800446a:	3101      	adds	r1, #1
 800446c:	f8c0 5094 	str.w	r5, [r0, #148]	; 0x94
 8004470:	60a1      	str	r1, [r4, #8]
}
 8004472:	bd70      	pop	{r4, r5, r6, pc}
                xTimeToWake = xConstTickCount + xTicksToWait;
 8004474:	19ad      	adds	r5, r5, r6
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8004476:	6863      	ldr	r3, [r4, #4]
 8004478:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
                if( xTimeToWake < xConstTickCount )
 800447c:	d212      	bcs.n	80044a4 <vTaskPlaceOnEventList+0x80>
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800447e:	6a20      	ldr	r0, [r4, #32]
 8004480:	6861      	ldr	r1, [r4, #4]
 8004482:	3184      	adds	r1, #132	; 0x84
 8004484:	f7fc f980 	bl	8000788 <vListInsert>
                    if( xTimeToWake < xNextTaskUnblockTime )
 8004488:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800448a:	429d      	cmp	r5, r3
 800448c:	d2f1      	bcs.n	8004472 <vTaskPlaceOnEventList+0x4e>
                        xNextTaskUnblockTime = xTimeToWake;
 800448e:	6265      	str	r5, [r4, #36]	; 0x24
}
 8004490:	bd70      	pop	{r4, r5, r6, pc}
 8004492:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004496:	f383 8811 	msr	BASEPRI, r3
 800449a:	f3bf 8f6f 	isb	sy
 800449e:	f3bf 8f4f 	dsb	sy
    configASSERT( pxEventList );
 80044a2:	e7fe      	b.n	80044a2 <vTaskPlaceOnEventList+0x7e>
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80044a4:	69e0      	ldr	r0, [r4, #28]
 80044a6:	6861      	ldr	r1, [r4, #4]
}
 80044a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80044ac:	3184      	adds	r1, #132	; 0x84
 80044ae:	f7fc b96b 	b.w	8000788 <vListInsert>
 80044b2:	bf00      	nop
 80044b4:	24000040 	.word	0x24000040

080044b8 <vTaskPlaceOnUnorderedEventList>:
    configASSERT( pxEventList );
 80044b8:	b368      	cbz	r0, 8004516 <vTaskPlaceOnUnorderedEventList+0x5e>
    configASSERT( uxSchedulerSuspended != 0 );
 80044ba:	4603      	mov	r3, r0
{
 80044bc:	b4f0      	push	{r4, r5, r6, r7}
    configASSERT( uxSchedulerSuspended != 0 );
 80044be:	4c1a      	ldr	r4, [pc, #104]	; (8004528 <vTaskPlaceOnUnorderedEventList+0x70>)
 80044c0:	f8d4 04ec 	ldr.w	r0, [r4, #1260]	; 0x4ec
 80044c4:	b940      	cbnz	r0, 80044d8 <vTaskPlaceOnUnorderedEventList+0x20>
 80044c6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80044ca:	f383 8811 	msr	BASEPRI, r3
 80044ce:	f3bf 8f6f 	isb	sy
 80044d2:	f3bf 8f4f 	dsb	sy
 80044d6:	e7fe      	b.n	80044d6 <vTaskPlaceOnUnorderedEventList+0x1e>
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 80044d8:	6865      	ldr	r5, [r4, #4]
 80044da:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80044de:	4610      	mov	r0, r2
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80044e0:	685a      	ldr	r2, [r3, #4]
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 80044e2:	f8c5 1098 	str.w	r1, [r5, #152]	; 0x98
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80044e6:	6861      	ldr	r1, [r4, #4]
 80044e8:	6895      	ldr	r5, [r2, #8]
 80044ea:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
 80044ee:	6861      	ldr	r1, [r4, #4]
 80044f0:	6866      	ldr	r6, [r4, #4]
 80044f2:	f8c1 50a0 	str.w	r5, [r1, #160]	; 0xa0
 80044f6:	6861      	ldr	r1, [r4, #4]
 80044f8:	3698      	adds	r6, #152	; 0x98
 80044fa:	6865      	ldr	r5, [r4, #4]
 80044fc:	681c      	ldr	r4, [r3, #0]
 80044fe:	3198      	adds	r1, #152	; 0x98
 8004500:	6897      	ldr	r7, [r2, #8]
 8004502:	3401      	adds	r4, #1
 8004504:	607e      	str	r6, [r7, #4]
 8004506:	6091      	str	r1, [r2, #8]
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8004508:	2101      	movs	r1, #1
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800450a:	f8c5 30a8 	str.w	r3, [r5, #168]	; 0xa8
 800450e:	601c      	str	r4, [r3, #0]
}
 8004510:	bcf0      	pop	{r4, r5, r6, r7}
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8004512:	f7fe ba7b 	b.w	8002a0c <prvAddCurrentTaskToDelayedList>
 8004516:	f04f 0350 	mov.w	r3, #80	; 0x50
 800451a:	f383 8811 	msr	BASEPRI, r3
 800451e:	f3bf 8f6f 	isb	sy
 8004522:	f3bf 8f4f 	dsb	sy
    configASSERT( pxEventList );
 8004526:	e7fe      	b.n	8004526 <vTaskPlaceOnUnorderedEventList+0x6e>
 8004528:	24000040 	.word	0x24000040

0800452c <vTaskPlaceOnEventListRestricted>:
        configASSERT( pxEventList );
 800452c:	2800      	cmp	r0, #0
 800452e:	d04d      	beq.n	80045cc <vTaskPlaceOnEventListRestricted+0xa0>
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8004530:	6843      	ldr	r3, [r0, #4]
    {
 8004532:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8004536:	4c2d      	ldr	r4, [pc, #180]	; (80045ec <vTaskPlaceOnEventListRestricted+0xc0>)
 8004538:	4688      	mov	r8, r1
 800453a:	689e      	ldr	r6, [r3, #8]
 800453c:	6861      	ldr	r1, [r4, #4]
 800453e:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
 8004542:	6861      	ldr	r1, [r4, #4]
 8004544:	6867      	ldr	r7, [r4, #4]
 8004546:	f8c1 60a0 	str.w	r6, [r1, #160]	; 0xa0
 800454a:	6866      	ldr	r6, [r4, #4]
 800454c:	3798      	adds	r7, #152	; 0x98
 800454e:	f8d4 c004 	ldr.w	ip, [r4, #4]
 8004552:	6801      	ldr	r1, [r0, #0]
 8004554:	3698      	adds	r6, #152	; 0x98
 8004556:	689d      	ldr	r5, [r3, #8]
 8004558:	3101      	adds	r1, #1
 800455a:	606f      	str	r7, [r5, #4]
 800455c:	609e      	str	r6, [r3, #8]
 800455e:	f8cc 00a8 	str.w	r0, [ip, #168]	; 0xa8
 8004562:	6001      	str	r1, [r0, #0]
        if( xWaitIndefinitely != pdFALSE )
 8004564:	b1ea      	cbz	r2, 80045a2 <vTaskPlaceOnEventListRestricted+0x76>
    const TickType_t xConstTickCount = xTickCount;
 8004566:	6823      	ldr	r3, [r4, #0]
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8004568:	6860      	ldr	r0, [r4, #4]
 800456a:	3084      	adds	r0, #132	; 0x84
 800456c:	f7fc f934 	bl	80007d8 <uxListRemove>
                listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8004570:	68e3      	ldr	r3, [r4, #12]
 8004572:	6860      	ldr	r0, [r4, #4]
 8004574:	6899      	ldr	r1, [r3, #8]
 8004576:	6862      	ldr	r2, [r4, #4]
 8004578:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
 800457c:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
 8004580:	6861      	ldr	r1, [r4, #4]
 8004582:	689d      	ldr	r5, [r3, #8]
 8004584:	3184      	adds	r1, #132	; 0x84
 8004586:	6862      	ldr	r2, [r4, #4]
 8004588:	6860      	ldr	r0, [r4, #4]
 800458a:	6069      	str	r1, [r5, #4]
 800458c:	3284      	adds	r2, #132	; 0x84
 800458e:	68a1      	ldr	r1, [r4, #8]
 8004590:	f104 0508 	add.w	r5, r4, #8
 8004594:	609a      	str	r2, [r3, #8]
 8004596:	3101      	adds	r1, #1
 8004598:	f8c0 5094 	str.w	r5, [r0, #148]	; 0x94
 800459c:	60a1      	str	r1, [r4, #8]
    }
 800459e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    const TickType_t xConstTickCount = xTickCount;
 80045a2:	6826      	ldr	r6, [r4, #0]
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80045a4:	6860      	ldr	r0, [r4, #4]
 80045a6:	3084      	adds	r0, #132	; 0x84
 80045a8:	f7fc f916 	bl	80007d8 <uxListRemove>
                xTimeToWake = xConstTickCount + xTicksToWait;
 80045ac:	eb18 0506 	adds.w	r5, r8, r6
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80045b0:	6863      	ldr	r3, [r4, #4]
 80045b2:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
                if( xTimeToWake < xConstTickCount )
 80045b6:	d212      	bcs.n	80045de <vTaskPlaceOnEventListRestricted+0xb2>
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80045b8:	6a20      	ldr	r0, [r4, #32]
 80045ba:	6861      	ldr	r1, [r4, #4]
 80045bc:	3184      	adds	r1, #132	; 0x84
 80045be:	f7fc f8e3 	bl	8000788 <vListInsert>
                    if( xTimeToWake < xNextTaskUnblockTime )
 80045c2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80045c4:	429d      	cmp	r5, r3
 80045c6:	d2ea      	bcs.n	800459e <vTaskPlaceOnEventListRestricted+0x72>
                        xNextTaskUnblockTime = xTimeToWake;
 80045c8:	6265      	str	r5, [r4, #36]	; 0x24
    }
 80045ca:	e7e8      	b.n	800459e <vTaskPlaceOnEventListRestricted+0x72>
 80045cc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80045d0:	f383 8811 	msr	BASEPRI, r3
 80045d4:	f3bf 8f6f 	isb	sy
 80045d8:	f3bf 8f4f 	dsb	sy
        configASSERT( pxEventList );
 80045dc:	e7fe      	b.n	80045dc <vTaskPlaceOnEventListRestricted+0xb0>
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80045de:	69e0      	ldr	r0, [r4, #28]
 80045e0:	6861      	ldr	r1, [r4, #4]
    }
 80045e2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80045e6:	3184      	adds	r1, #132	; 0x84
 80045e8:	f7fc b8ce 	b.w	8000788 <vListInsert>
 80045ec:	24000040 	.word	0x24000040

080045f0 <xTaskRemoveFromEventList>:
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80045f0:	68c3      	ldr	r3, [r0, #12]
 80045f2:	68db      	ldr	r3, [r3, #12]
    configASSERT( pxUnblockedTCB );
 80045f4:	2b00      	cmp	r3, #0
 80045f6:	d06e      	beq.n	80046d6 <xTaskRemoveFromEventList+0xe6>
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
 80045f8:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
 80045fc:	e9d3 0127 	ldrd	r0, r1, [r3, #156]	; 0x9c
{
 8004600:	b4f0      	push	{r4, r5, r6, r7}
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
 8004602:	6081      	str	r1, [r0, #8]
 8004604:	f103 0498 	add.w	r4, r3, #152	; 0x98
 8004608:	6048      	str	r0, [r1, #4]
 800460a:	6850      	ldr	r0, [r2, #4]
 800460c:	42a0      	cmp	r0, r4
 800460e:	f04f 0000 	mov.w	r0, #0
 8004612:	bf08      	it	eq
 8004614:	6051      	streq	r1, [r2, #4]
 8004616:	6811      	ldr	r1, [r2, #0]
 8004618:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
 800461c:	3901      	subs	r1, #1
 800461e:	6011      	str	r1, [r2, #0]
    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8004620:	4a31      	ldr	r2, [pc, #196]	; (80046e8 <xTaskRemoveFromEventList+0xf8>)
 8004622:	f8d2 14ec 	ldr.w	r1, [r2, #1260]	; 0x4ec
 8004626:	b1e9      	cbz	r1, 8004664 <xTaskRemoveFromEventList+0x74>
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8004628:	f8d2 14b8 	ldr.w	r1, [r2, #1208]	; 0x4b8
 800462c:	f202 45b4 	addw	r5, r2, #1204	; 0x4b4
 8004630:	6888      	ldr	r0, [r1, #8]
 8004632:	e9c3 1027 	strd	r1, r0, [r3, #156]	; 0x9c
 8004636:	6888      	ldr	r0, [r1, #8]
 8004638:	6044      	str	r4, [r0, #4]
 800463a:	f8d2 04b4 	ldr.w	r0, [r2, #1204]	; 0x4b4
 800463e:	608c      	str	r4, [r1, #8]
 8004640:	1c41      	adds	r1, r0, #1
 8004642:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
        prvAddTaskToReadyList( pxUnblockedTCB );
 8004646:	f8d3 00ac 	ldr.w	r0, [r3, #172]	; 0xac
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800464a:	f8c2 14b4 	str.w	r1, [r2, #1204]	; 0x4b4
    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800464e:	6853      	ldr	r3, [r2, #4]
 8004650:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8004654:	4283      	cmp	r3, r0
 8004656:	d23b      	bcs.n	80046d0 <xTaskRemoveFromEventList+0xe0>
        xYieldPending = pdTRUE;
 8004658:	2301      	movs	r3, #1
}
 800465a:	bcf0      	pop	{r4, r5, r6, r7}
        xReturn = pdTRUE;
 800465c:	4618      	mov	r0, r3
        xYieldPending = pdTRUE;
 800465e:	f8c2 34f0 	str.w	r3, [r2, #1264]	; 0x4f0
}
 8004662:	4770      	bx	lr
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 8004664:	e9d3 0422 	ldrd	r0, r4, [r3, #136]	; 0x88
 8004668:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 800466c:	f103 0784 	add.w	r7, r3, #132	; 0x84
 8004670:	6084      	str	r4, [r0, #8]
 8004672:	f8d3 408c 	ldr.w	r4, [r3, #140]	; 0x8c
 8004676:	6060      	str	r0, [r4, #4]
 8004678:	6848      	ldr	r0, [r1, #4]
 800467a:	42b8      	cmp	r0, r7
 800467c:	6808      	ldr	r0, [r1, #0]
 800467e:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
 8004682:	bf08      	it	eq
 8004684:	604c      	streq	r4, [r1, #4]
 8004686:	6008      	str	r0, [r1, #0]
        prvAddTaskToReadyList( pxUnblockedTCB );
 8004688:	f8d3 00ac 	ldr.w	r0, [r3, #172]	; 0xac
 800468c:	f8d2 14e4 	ldr.w	r1, [r2, #1252]	; 0x4e4
 8004690:	4288      	cmp	r0, r1
 8004692:	d901      	bls.n	8004698 <xTaskRemoveFromEventList+0xa8>
 8004694:	f8c2 04e4 	str.w	r0, [r2, #1252]	; 0x4e4
 8004698:	eb00 0180 	add.w	r1, r0, r0, lsl #2
 800469c:	4e13      	ldr	r6, [pc, #76]	; (80046ec <xTaskRemoveFromEventList+0xfc>)
 800469e:	eb06 0681 	add.w	r6, r6, r1, lsl #2
 80046a2:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 80046a6:	6b0c      	ldr	r4, [r1, #48]	; 0x30
 80046a8:	68a5      	ldr	r5, [r4, #8]
 80046aa:	f8c3 4088 	str.w	r4, [r3, #136]	; 0x88
 80046ae:	f8c3 508c 	str.w	r5, [r3, #140]	; 0x8c
 80046b2:	6acd      	ldr	r5, [r1, #44]	; 0x2c
 80046b4:	f105 0c01 	add.w	ip, r5, #1
 80046b8:	68a5      	ldr	r5, [r4, #8]
 80046ba:	606f      	str	r7, [r5, #4]
 80046bc:	60a7      	str	r7, [r4, #8]
 80046be:	f8c3 6094 	str.w	r6, [r3, #148]	; 0x94
 80046c2:	f8c1 c02c 	str.w	ip, [r1, #44]	; 0x2c
    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 80046c6:	6853      	ldr	r3, [r2, #4]
 80046c8:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 80046cc:	4283      	cmp	r3, r0
 80046ce:	d3c3      	bcc.n	8004658 <xTaskRemoveFromEventList+0x68>
        xReturn = pdFALSE;
 80046d0:	2000      	movs	r0, #0
}
 80046d2:	bcf0      	pop	{r4, r5, r6, r7}
 80046d4:	4770      	bx	lr
 80046d6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80046da:	f383 8811 	msr	BASEPRI, r3
 80046de:	f3bf 8f6f 	isb	sy
 80046e2:	f3bf 8f4f 	dsb	sy
    configASSERT( pxUnblockedTCB );
 80046e6:	e7fe      	b.n	80046e6 <xTaskRemoveFromEventList+0xf6>
 80046e8:	24000040 	.word	0x24000040
 80046ec:	2400006c 	.word	0x2400006c

080046f0 <vTaskRemoveFromUnorderedEventList>:
    configASSERT( uxSchedulerSuspended != pdFALSE );
 80046f0:	4a33      	ldr	r2, [pc, #204]	; (80047c0 <vTaskRemoveFromUnorderedEventList+0xd0>)
 80046f2:	f8d2 34ec 	ldr.w	r3, [r2, #1260]	; 0x4ec
 80046f6:	b943      	cbnz	r3, 800470a <vTaskRemoveFromUnorderedEventList+0x1a>
 80046f8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80046fc:	f383 8811 	msr	BASEPRI, r3
 8004700:	f3bf 8f6f 	isb	sy
 8004704:	f3bf 8f4f 	dsb	sy
 8004708:	e7fe      	b.n	8004708 <vTaskRemoveFromUnorderedEventList+0x18>
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 800470a:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800470e:	68c3      	ldr	r3, [r0, #12]
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 8004710:	6001      	str	r1, [r0, #0]
    configASSERT( pxUnblockedTCB );
 8004712:	2b00      	cmp	r3, #0
 8004714:	d04b      	beq.n	80047ae <vTaskRemoveFromUnorderedEventList+0xbe>
{
 8004716:	b4f0      	push	{r4, r5, r6, r7}
    listREMOVE_ITEM( pxEventListItem );
 8004718:	6904      	ldr	r4, [r0, #16]
 800471a:	e9d0 1501 	ldrd	r1, r5, [r0, #4]
 800471e:	6866      	ldr	r6, [r4, #4]
 8004720:	608d      	str	r5, [r1, #8]
 8004722:	6885      	ldr	r5, [r0, #8]
 8004724:	4286      	cmp	r6, r0
 8004726:	6069      	str	r1, [r5, #4]
 8004728:	f04f 0100 	mov.w	r1, #0
 800472c:	bf08      	it	eq
 800472e:	6065      	streq	r5, [r4, #4]
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 8004730:	f103 0584 	add.w	r5, r3, #132	; 0x84
    listREMOVE_ITEM( pxEventListItem );
 8004734:	6101      	str	r1, [r0, #16]
 8004736:	6820      	ldr	r0, [r4, #0]
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 8004738:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
    listREMOVE_ITEM( pxEventListItem );
 800473c:	3801      	subs	r0, #1
 800473e:	6020      	str	r0, [r4, #0]
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 8004740:	e9d3 0422 	ldrd	r0, r4, [r3, #136]	; 0x88
 8004744:	6084      	str	r4, [r0, #8]
 8004746:	f8d3 408c 	ldr.w	r4, [r3, #140]	; 0x8c
 800474a:	6060      	str	r0, [r4, #4]
 800474c:	6848      	ldr	r0, [r1, #4]
 800474e:	42a8      	cmp	r0, r5
 8004750:	6808      	ldr	r0, [r1, #0]
 8004752:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
 8004756:	bf08      	it	eq
 8004758:	604c      	streq	r4, [r1, #4]
 800475a:	6008      	str	r0, [r1, #0]
    prvAddTaskToReadyList( pxUnblockedTCB );
 800475c:	f8d3 00ac 	ldr.w	r0, [r3, #172]	; 0xac
 8004760:	f8d2 14e4 	ldr.w	r1, [r2, #1252]	; 0x4e4
 8004764:	4288      	cmp	r0, r1
 8004766:	d901      	bls.n	800476c <vTaskRemoveFromUnorderedEventList+0x7c>
 8004768:	f8c2 04e4 	str.w	r0, [r2, #1252]	; 0x4e4
 800476c:	eb00 0180 	add.w	r1, r0, r0, lsl #2
 8004770:	4f14      	ldr	r7, [pc, #80]	; (80047c4 <vTaskRemoveFromUnorderedEventList+0xd4>)
 8004772:	eb07 0781 	add.w	r7, r7, r1, lsl #2
 8004776:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 800477a:	6b0c      	ldr	r4, [r1, #48]	; 0x30
 800477c:	68a6      	ldr	r6, [r4, #8]
 800477e:	f8c3 4088 	str.w	r4, [r3, #136]	; 0x88
 8004782:	f8c3 608c 	str.w	r6, [r3, #140]	; 0x8c
 8004786:	6ace      	ldr	r6, [r1, #44]	; 0x2c
 8004788:	f106 0c01 	add.w	ip, r6, #1
 800478c:	68a6      	ldr	r6, [r4, #8]
 800478e:	6075      	str	r5, [r6, #4]
 8004790:	60a5      	str	r5, [r4, #8]
 8004792:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
 8004796:	f8c1 c02c 	str.w	ip, [r1, #44]	; 0x2c
    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800479a:	6853      	ldr	r3, [r2, #4]
 800479c:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 80047a0:	4298      	cmp	r0, r3
 80047a2:	d902      	bls.n	80047aa <vTaskRemoveFromUnorderedEventList+0xba>
        xYieldPending = pdTRUE;
 80047a4:	2301      	movs	r3, #1
 80047a6:	f8c2 34f0 	str.w	r3, [r2, #1264]	; 0x4f0
}
 80047aa:	bcf0      	pop	{r4, r5, r6, r7}
 80047ac:	4770      	bx	lr
 80047ae:	f04f 0350 	mov.w	r3, #80	; 0x50
 80047b2:	f383 8811 	msr	BASEPRI, r3
 80047b6:	f3bf 8f6f 	isb	sy
 80047ba:	f3bf 8f4f 	dsb	sy
    configASSERT( pxUnblockedTCB );
 80047be:	e7fe      	b.n	80047be <vTaskRemoveFromUnorderedEventList+0xce>
 80047c0:	24000040 	.word	0x24000040
 80047c4:	2400006c 	.word	0x2400006c

080047c8 <vTaskSwitchContext>:
{
 80047c8:	b510      	push	{r4, lr}
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80047ca:	4c2a      	ldr	r4, [pc, #168]	; (8004874 <vTaskSwitchContext+0xac>)
 80047cc:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
 80047d0:	b11b      	cbz	r3, 80047da <vTaskSwitchContext+0x12>
        xYieldPending = pdTRUE;
 80047d2:	2301      	movs	r3, #1
 80047d4:	f8c4 34f0 	str.w	r3, [r4, #1264]	; 0x4f0
}
 80047d8:	bd10      	pop	{r4, pc}
        xYieldPending = pdFALSE;
 80047da:	f8c4 34f0 	str.w	r3, [r4, #1264]	; 0x4f0
        taskCHECK_FOR_STACK_OVERFLOW();
 80047de:	6863      	ldr	r3, [r4, #4]
 80047e0:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 80047e4:	681a      	ldr	r2, [r3, #0]
 80047e6:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 80047ea:	d103      	bne.n	80047f4 <vTaskSwitchContext+0x2c>
 80047ec:	685a      	ldr	r2, [r3, #4]
 80047ee:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 80047f2:	d032      	beq.n	800485a <vTaskSwitchContext+0x92>
 80047f4:	6860      	ldr	r0, [r4, #4]
 80047f6:	6861      	ldr	r1, [r4, #4]
 80047f8:	31b4      	adds	r1, #180	; 0xb4
 80047fa:	f005 fab3 	bl	8009d64 <vApplicationStackOverflowHook>
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80047fe:	f8d4 34e4 	ldr.w	r3, [r4, #1252]	; 0x4e4
 8004802:	e001      	b.n	8004808 <vTaskSwitchContext+0x40>
 8004804:	b303      	cbz	r3, 8004848 <vTaskSwitchContext+0x80>
 8004806:	3b01      	subs	r3, #1
 8004808:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 800480c:	0099      	lsls	r1, r3, #2
 800480e:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8004812:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8004814:	2a00      	cmp	r2, #0
 8004816:	d0f5      	beq.n	8004804 <vTaskSwitchContext+0x3c>
 8004818:	4419      	add	r1, r3
 800481a:	eb04 0c81 	add.w	ip, r4, r1, lsl #2
 800481e:	f8dc 2030 	ldr.w	r2, [ip, #48]	; 0x30
 8004822:	6850      	ldr	r0, [r2, #4]
 8004824:	4a14      	ldr	r2, [pc, #80]	; (8004878 <vTaskSwitchContext+0xb0>)
 8004826:	f8cc 0030 	str.w	r0, [ip, #48]	; 0x30
 800482a:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 800482e:	f101 0208 	add.w	r2, r1, #8
 8004832:	4290      	cmp	r0, r2
 8004834:	d01a      	beq.n	800486c <vTaskSwitchContext+0xa4>
 8004836:	68c1      	ldr	r1, [r0, #12]
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
 8004838:	4a10      	ldr	r2, [pc, #64]	; (800487c <vTaskSwitchContext+0xb4>)
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800483a:	6061      	str	r1, [r4, #4]
 800483c:	f8c4 34e4 	str.w	r3, [r4, #1252]	; 0x4e4
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
 8004840:	6863      	ldr	r3, [r4, #4]
 8004842:	33d4      	adds	r3, #212	; 0xd4
 8004844:	6013      	str	r3, [r2, #0]
}
 8004846:	bd10      	pop	{r4, pc}
 8004848:	f04f 0350 	mov.w	r3, #80	; 0x50
 800484c:	f383 8811 	msr	BASEPRI, r3
 8004850:	f3bf 8f6f 	isb	sy
 8004854:	f3bf 8f4f 	dsb	sy
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004858:	e7fe      	b.n	8004858 <vTaskSwitchContext+0x90>
        taskCHECK_FOR_STACK_OVERFLOW();
 800485a:	689a      	ldr	r2, [r3, #8]
 800485c:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 8004860:	d1c8      	bne.n	80047f4 <vTaskSwitchContext+0x2c>
 8004862:	68db      	ldr	r3, [r3, #12]
 8004864:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
 8004868:	d1c4      	bne.n	80047f4 <vTaskSwitchContext+0x2c>
 800486a:	e7c8      	b.n	80047fe <vTaskSwitchContext+0x36>
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800486c:	6840      	ldr	r0, [r0, #4]
 800486e:	f8cc 0030 	str.w	r0, [ip, #48]	; 0x30
 8004872:	e7e0      	b.n	8004836 <vTaskSwitchContext+0x6e>
 8004874:	24000040 	.word	0x24000040
 8004878:	2400006c 	.word	0x2400006c
 800487c:	24008184 	.word	0x24008184

08004880 <vTaskSuspend>:
    {
 8004880:	b570      	push	{r4, r5, r6, lr}
 8004882:	4604      	mov	r4, r0
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 8004884:	4d34      	ldr	r5, [pc, #208]	; (8004958 <vTaskSuspend+0xd8>)
        taskENTER_CRITICAL();
 8004886:	f005 f9b7 	bl	8009bf8 <vPortEnterCritical>
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 800488a:	2c00      	cmp	r4, #0
 800488c:	d048      	beq.n	8004920 <vTaskSuspend+0xa0>
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800488e:	f104 0684 	add.w	r6, r4, #132	; 0x84
 8004892:	4630      	mov	r0, r6
 8004894:	f7fb ffa0 	bl	80007d8 <uxListRemove>
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8004898:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 800489c:	b11b      	cbz	r3, 80048a6 <vTaskSuspend+0x26>
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800489e:	f104 0098 	add.w	r0, r4, #152	; 0x98
 80048a2:	f7fb ff99 	bl	80007d8 <uxListRemove>
            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 80048a6:	4631      	mov	r1, r6
 80048a8:	482c      	ldr	r0, [pc, #176]	; (800495c <vTaskSuspend+0xdc>)
 80048aa:	f7fb ff85 	bl	80007b8 <vListInsertEnd>
                        if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 80048ae:	f894 3140 	ldrb.w	r3, [r4, #320]	; 0x140
 80048b2:	2b01      	cmp	r3, #1
 80048b4:	d102      	bne.n	80048bc <vTaskSuspend+0x3c>
                            pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
 80048b6:	2300      	movs	r3, #0
 80048b8:	f884 3140 	strb.w	r3, [r4, #320]	; 0x140
                        if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 80048bc:	f894 3141 	ldrb.w	r3, [r4, #321]	; 0x141
 80048c0:	2b01      	cmp	r3, #1
 80048c2:	d102      	bne.n	80048ca <vTaskSuspend+0x4a>
                            pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
 80048c4:	2300      	movs	r3, #0
 80048c6:	f884 3141 	strb.w	r3, [r4, #321]	; 0x141
                        if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 80048ca:	f894 3142 	ldrb.w	r3, [r4, #322]	; 0x142
 80048ce:	2b01      	cmp	r3, #1
 80048d0:	d102      	bne.n	80048d8 <vTaskSuspend+0x58>
                            pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
 80048d2:	2300      	movs	r3, #0
 80048d4:	f884 3142 	strb.w	r3, [r4, #322]	; 0x142
        taskEXIT_CRITICAL();
 80048d8:	f005 f9a4 	bl	8009c24 <vPortExitCritical>
        if( xSchedulerRunning != pdFALSE )
 80048dc:	f8d5 34dc 	ldr.w	r3, [r5, #1244]	; 0x4dc
 80048e0:	b993      	cbnz	r3, 8004908 <vTaskSuspend+0x88>
        if( pxTCB == pxCurrentTCB )
 80048e2:	686b      	ldr	r3, [r5, #4]
 80048e4:	42a3      	cmp	r3, r4
 80048e6:	d000      	beq.n	80048ea <vTaskSuspend+0x6a>
    }
 80048e8:	bd70      	pop	{r4, r5, r6, pc}
            if( xSchedulerRunning != pdFALSE )
 80048ea:	f8d5 34dc 	ldr.w	r3, [r5, #1244]	; 0x4dc
 80048ee:	b1eb      	cbz	r3, 800492c <vTaskSuspend+0xac>
                configASSERT( uxSchedulerSuspended == 0 );
 80048f0:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
 80048f4:	b303      	cbz	r3, 8004938 <vTaskSuspend+0xb8>
 80048f6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80048fa:	f383 8811 	msr	BASEPRI, r3
 80048fe:	f3bf 8f6f 	isb	sy
 8004902:	f3bf 8f4f 	dsb	sy
 8004906:	e7fe      	b.n	8004906 <vTaskSuspend+0x86>
            taskENTER_CRITICAL();
 8004908:	f005 f976 	bl	8009bf8 <vPortEnterCritical>
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800490c:	6a2b      	ldr	r3, [r5, #32]
 800490e:	681b      	ldr	r3, [r3, #0]
 8004910:	b143      	cbz	r3, 8004924 <vTaskSuspend+0xa4>
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 8004912:	6a2b      	ldr	r3, [r5, #32]
 8004914:	68db      	ldr	r3, [r3, #12]
 8004916:	681b      	ldr	r3, [r3, #0]
 8004918:	626b      	str	r3, [r5, #36]	; 0x24
            taskEXIT_CRITICAL();
 800491a:	f005 f983 	bl	8009c24 <vPortExitCritical>
 800491e:	e7e0      	b.n	80048e2 <vTaskSuspend+0x62>
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 8004920:	686c      	ldr	r4, [r5, #4]
 8004922:	e7b4      	b.n	800488e <vTaskSuspend+0xe>
        xNextTaskUnblockTime = portMAX_DELAY;
 8004924:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004928:	626b      	str	r3, [r5, #36]	; 0x24
 800492a:	e7f6      	b.n	800491a <vTaskSuspend+0x9a>
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 800492c:	68a9      	ldr	r1, [r5, #8]
 800492e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8004930:	4291      	cmp	r1, r2
 8004932:	d10c      	bne.n	800494e <vTaskSuspend+0xce>
                    pxCurrentTCB = NULL;
 8004934:	606b      	str	r3, [r5, #4]
    }
 8004936:	bd70      	pop	{r4, r5, r6, pc}
                portYIELD_WITHIN_API();
 8004938:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800493c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004940:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8004944:	f3bf 8f4f 	dsb	sy
 8004948:	f3bf 8f6f 	isb	sy
    }
 800494c:	bd70      	pop	{r4, r5, r6, pc}
 800494e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                    vTaskSwitchContext();
 8004952:	f7ff bf39 	b.w	80047c8 <vTaskSwitchContext>
 8004956:	bf00      	nop
 8004958:	24000040 	.word	0x24000040
 800495c:	24000048 	.word	0x24000048

08004960 <uxTaskResetEventItemValue>:
    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 8004960:	4b06      	ldr	r3, [pc, #24]	; (800497c <uxTaskResetEventItemValue+0x1c>)
 8004962:	6859      	ldr	r1, [r3, #4]
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004964:	6858      	ldr	r0, [r3, #4]
 8004966:	685a      	ldr	r2, [r3, #4]
 8004968:	f8d0 30ac 	ldr.w	r3, [r0, #172]	; 0xac
    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 800496c:	f8d1 0098 	ldr.w	r0, [r1, #152]	; 0x98
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004970:	f1c3 0338 	rsb	r3, r3, #56	; 0x38
 8004974:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
}
 8004978:	4770      	bx	lr
 800497a:	bf00      	nop
 800497c:	24000040 	.word	0x24000040

08004980 <xTaskGetCurrentTaskHandle>:
        xReturn = pxCurrentTCB;
 8004980:	4b01      	ldr	r3, [pc, #4]	; (8004988 <xTaskGetCurrentTaskHandle+0x8>)
 8004982:	6858      	ldr	r0, [r3, #4]
    }
 8004984:	4770      	bx	lr
 8004986:	bf00      	nop
 8004988:	24000040 	.word	0x24000040

0800498c <vTaskMissedYield>:
    xYieldPending = pdTRUE;
 800498c:	4b02      	ldr	r3, [pc, #8]	; (8004998 <vTaskMissedYield+0xc>)
 800498e:	2201      	movs	r2, #1
 8004990:	f8c3 24f0 	str.w	r2, [r3, #1264]	; 0x4f0
}
 8004994:	4770      	bx	lr
 8004996:	bf00      	nop
 8004998:	24000040 	.word	0x24000040

0800499c <xTaskGetSchedulerState>:
        if( xSchedulerRunning == pdFALSE )
 800499c:	4b06      	ldr	r3, [pc, #24]	; (80049b8 <xTaskGetSchedulerState+0x1c>)
 800499e:	f8d3 24dc 	ldr.w	r2, [r3, #1244]	; 0x4dc
 80049a2:	b132      	cbz	r2, 80049b2 <xTaskGetSchedulerState+0x16>
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80049a4:	f8d3 34ec 	ldr.w	r3, [r3, #1260]	; 0x4ec
                xReturn = taskSCHEDULER_SUSPENDED;
 80049a8:	2b00      	cmp	r3, #0
 80049aa:	bf0c      	ite	eq
 80049ac:	2002      	moveq	r0, #2
 80049ae:	2000      	movne	r0, #0
 80049b0:	4770      	bx	lr
            xReturn = taskSCHEDULER_NOT_STARTED;
 80049b2:	2001      	movs	r0, #1
    }
 80049b4:	4770      	bx	lr
 80049b6:	bf00      	nop
 80049b8:	24000040 	.word	0x24000040

080049bc <xTaskPriorityInherit>:
    {
 80049bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if( pxMutexHolder != NULL )
 80049be:	4604      	mov	r4, r0
 80049c0:	b308      	cbz	r0, 8004a06 <xTaskPriorityInherit+0x4a>
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 80049c2:	4d29      	ldr	r5, [pc, #164]	; (8004a68 <xTaskPriorityInherit+0xac>)
 80049c4:	f8d0 30ac 	ldr.w	r3, [r0, #172]	; 0xac
 80049c8:	686a      	ldr	r2, [r5, #4]
 80049ca:	f8d2 20ac 	ldr.w	r2, [r2, #172]	; 0xac
 80049ce:	4293      	cmp	r3, r2
 80049d0:	d21a      	bcs.n	8004a08 <xTaskPriorityInherit+0x4c>
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80049d2:	f8d0 2098 	ldr.w	r2, [r0, #152]	; 0x98
 80049d6:	2a00      	cmp	r2, #0
 80049d8:	db06      	blt.n	80049e8 <xTaskPriorityInherit+0x2c>
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80049da:	686a      	ldr	r2, [r5, #4]
 80049dc:	f8d2 20ac 	ldr.w	r2, [r2, #172]	; 0xac
 80049e0:	f1c2 0238 	rsb	r2, r2, #56	; 0x38
 80049e4:	f8c0 2098 	str.w	r2, [r0, #152]	; 0x98
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 80049e8:	4e20      	ldr	r6, [pc, #128]	; (8004a6c <xTaskPriorityInherit+0xb0>)
 80049ea:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80049ee:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
 80049f2:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 80049f6:	429a      	cmp	r2, r3
 80049f8:	d010      	beq.n	8004a1c <xTaskPriorityInherit+0x60>
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 80049fa:	686b      	ldr	r3, [r5, #4]
                xReturn = pdTRUE;
 80049fc:	2001      	movs	r0, #1
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 80049fe:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8004a02:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac
    }
 8004a06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 8004a08:	686b      	ldr	r3, [r5, #4]
 8004a0a:	f8d0 00cc 	ldr.w	r0, [r0, #204]	; 0xcc
 8004a0e:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8004a12:	4298      	cmp	r0, r3
 8004a14:	bf2c      	ite	cs
 8004a16:	2000      	movcs	r0, #0
 8004a18:	2001      	movcc	r0, #1
    }
 8004a1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8004a1c:	f104 0784 	add.w	r7, r4, #132	; 0x84
 8004a20:	4638      	mov	r0, r7
 8004a22:	f7fb fed9 	bl	80007d8 <uxListRemove>
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8004a26:	686b      	ldr	r3, [r5, #4]
                    prvAddTaskToReadyList( pxMutexHolderTCB );
 8004a28:	f8d5 24e4 	ldr.w	r2, [r5, #1252]	; 0x4e4
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8004a2c:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
                    prvAddTaskToReadyList( pxMutexHolderTCB );
 8004a30:	4293      	cmp	r3, r2
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8004a32:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac
                    prvAddTaskToReadyList( pxMutexHolderTCB );
 8004a36:	d901      	bls.n	8004a3c <xTaskPriorityInherit+0x80>
 8004a38:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
 8004a3c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
                xReturn = pdTRUE;
 8004a40:	2001      	movs	r0, #1
                    prvAddTaskToReadyList( pxMutexHolderTCB );
 8004a42:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 8004a46:	eb06 0683 	add.w	r6, r6, r3, lsl #2
 8004a4a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8004a4c:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8004a4e:	6899      	ldr	r1, [r3, #8]
 8004a50:	4402      	add	r2, r0
 8004a52:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
 8004a56:	f8c4 108c 	str.w	r1, [r4, #140]	; 0x8c
 8004a5a:	6899      	ldr	r1, [r3, #8]
 8004a5c:	604f      	str	r7, [r1, #4]
 8004a5e:	609f      	str	r7, [r3, #8]
 8004a60:	f8c4 6094 	str.w	r6, [r4, #148]	; 0x94
 8004a64:	62ea      	str	r2, [r5, #44]	; 0x2c
    }
 8004a66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004a68:	24000040 	.word	0x24000040
 8004a6c:	2400006c 	.word	0x2400006c

08004a70 <xTaskPriorityDisinherit>:
        if( pxMutexHolder != NULL )
 8004a70:	b330      	cbz	r0, 8004ac0 <xTaskPriorityDisinherit+0x50>
    {
 8004a72:	b570      	push	{r4, r5, r6, lr}
            configASSERT( pxTCB == pxCurrentTCB );
 8004a74:	4d28      	ldr	r5, [pc, #160]	; (8004b18 <xTaskPriorityDisinherit+0xa8>)
 8004a76:	4604      	mov	r4, r0
 8004a78:	686b      	ldr	r3, [r5, #4]
 8004a7a:	4283      	cmp	r3, r0
 8004a7c:	d008      	beq.n	8004a90 <xTaskPriorityDisinherit+0x20>
 8004a7e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004a82:	f383 8811 	msr	BASEPRI, r3
 8004a86:	f3bf 8f6f 	isb	sy
 8004a8a:	f3bf 8f4f 	dsb	sy
 8004a8e:	e7fe      	b.n	8004a8e <xTaskPriorityDisinherit+0x1e>
            configASSERT( pxTCB->uxMutexesHeld );
 8004a90:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 8004a94:	b15b      	cbz	r3, 8004aae <xTaskPriorityDisinherit+0x3e>
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8004a96:	f8d0 10ac 	ldr.w	r1, [r0, #172]	; 0xac
            ( pxTCB->uxMutexesHeld )--;
 8004a9a:	3b01      	subs	r3, #1
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8004a9c:	f8d0 20cc 	ldr.w	r2, [r0, #204]	; 0xcc
            ( pxTCB->uxMutexesHeld )--;
 8004aa0:	f8c0 30d0 	str.w	r3, [r0, #208]	; 0xd0
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8004aa4:	4291      	cmp	r1, r2
 8004aa6:	d000      	beq.n	8004aaa <xTaskPriorityDisinherit+0x3a>
 8004aa8:	b163      	cbz	r3, 8004ac4 <xTaskPriorityDisinherit+0x54>
        BaseType_t xReturn = pdFALSE;
 8004aaa:	2000      	movs	r0, #0
    }
 8004aac:	bd70      	pop	{r4, r5, r6, pc}
 8004aae:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004ab2:	f383 8811 	msr	BASEPRI, r3
 8004ab6:	f3bf 8f6f 	isb	sy
 8004aba:	f3bf 8f4f 	dsb	sy
            configASSERT( pxTCB->uxMutexesHeld );
 8004abe:	e7fe      	b.n	8004abe <xTaskPriorityDisinherit+0x4e>
        BaseType_t xReturn = pdFALSE;
 8004ac0:	2000      	movs	r0, #0
    }
 8004ac2:	4770      	bx	lr
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8004ac4:	f100 0684 	add.w	r6, r0, #132	; 0x84
 8004ac8:	4630      	mov	r0, r6
 8004aca:	f7fb fe85 	bl	80007d8 <uxListRemove>
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 8004ace:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004ad2:	f1c3 0238 	rsb	r2, r3, #56	; 0x38
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 8004ad6:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004ada:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
                    prvAddTaskToReadyList( pxTCB );
 8004ade:	f8d5 24e4 	ldr.w	r2, [r5, #1252]	; 0x4e4
 8004ae2:	4293      	cmp	r3, r2
 8004ae4:	d901      	bls.n	8004aea <xTaskPriorityDisinherit+0x7a>
 8004ae6:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
 8004aea:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004aee:	480b      	ldr	r0, [pc, #44]	; (8004b1c <xTaskPriorityDisinherit+0xac>)
 8004af0:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 8004af4:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8004af8:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8004afa:	6891      	ldr	r1, [r2, #8]
 8004afc:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
 8004b00:	f8c4 108c 	str.w	r1, [r4, #140]	; 0x8c
 8004b04:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 8004b06:	6890      	ldr	r0, [r2, #8]
 8004b08:	3101      	adds	r1, #1
 8004b0a:	6046      	str	r6, [r0, #4]
                    xReturn = pdTRUE;
 8004b0c:	2001      	movs	r0, #1
                    prvAddTaskToReadyList( pxTCB );
 8004b0e:	6096      	str	r6, [r2, #8]
 8004b10:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
 8004b14:	62e9      	str	r1, [r5, #44]	; 0x2c
    }
 8004b16:	bd70      	pop	{r4, r5, r6, pc}
 8004b18:	24000040 	.word	0x24000040
 8004b1c:	2400006c 	.word	0x2400006c

08004b20 <vTaskPriorityDisinheritAfterTimeout>:
        if( pxMutexHolder != NULL )
 8004b20:	2800      	cmp	r0, #0
 8004b22:	d052      	beq.n	8004bca <vTaskPriorityDisinheritAfterTimeout+0xaa>
    {
 8004b24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
            configASSERT( pxTCB->uxMutexesHeld );
 8004b26:	f8d0 30d0 	ldr.w	r3, [r0, #208]	; 0xd0
 8004b2a:	4604      	mov	r4, r0
 8004b2c:	b15b      	cbz	r3, 8004b46 <vTaskPriorityDisinheritAfterTimeout+0x26>
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 8004b2e:	f8d0 00cc 	ldr.w	r0, [r0, #204]	; 0xcc
            if( pxTCB->uxPriority != uxPriorityToUse )
 8004b32:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
 8004b36:	4281      	cmp	r1, r0
 8004b38:	bf38      	it	cc
 8004b3a:	4601      	movcc	r1, r0
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 8004b3c:	428a      	cmp	r2, r1
 8004b3e:	d001      	beq.n	8004b44 <vTaskPriorityDisinheritAfterTimeout+0x24>
 8004b40:	2b01      	cmp	r3, #1
 8004b42:	d009      	beq.n	8004b58 <vTaskPriorityDisinheritAfterTimeout+0x38>
    }
 8004b44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004b46:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004b4a:	f383 8811 	msr	BASEPRI, r3
 8004b4e:	f3bf 8f6f 	isb	sy
 8004b52:	f3bf 8f4f 	dsb	sy
            configASSERT( pxTCB->uxMutexesHeld );
 8004b56:	e7fe      	b.n	8004b56 <vTaskPriorityDisinheritAfterTimeout+0x36>
                    configASSERT( pxTCB != pxCurrentTCB );
 8004b58:	4d21      	ldr	r5, [pc, #132]	; (8004be0 <vTaskPriorityDisinheritAfterTimeout+0xc0>)
 8004b5a:	686b      	ldr	r3, [r5, #4]
 8004b5c:	42a3      	cmp	r3, r4
 8004b5e:	d035      	beq.n	8004bcc <vTaskPriorityDisinheritAfterTimeout+0xac>
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8004b60:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
                    pxTCB->uxPriority = uxPriorityToUse;
 8004b64:	f8c4 10ac 	str.w	r1, [r4, #172]	; 0xac
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8004b68:	2b00      	cmp	r3, #0
 8004b6a:	db03      	blt.n	8004b74 <vTaskPriorityDisinheritAfterTimeout+0x54>
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004b6c:	f1c1 0138 	rsb	r1, r1, #56	; 0x38
 8004b70:	f8c4 1098 	str.w	r1, [r4, #152]	; 0x98
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8004b74:	4e1b      	ldr	r6, [pc, #108]	; (8004be4 <vTaskPriorityDisinheritAfterTimeout+0xc4>)
 8004b76:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8004b7a:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
 8004b7e:	eb06 0382 	add.w	r3, r6, r2, lsl #2
 8004b82:	4299      	cmp	r1, r3
 8004b84:	d1de      	bne.n	8004b44 <vTaskPriorityDisinheritAfterTimeout+0x24>
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8004b86:	f104 0784 	add.w	r7, r4, #132	; 0x84
 8004b8a:	4638      	mov	r0, r7
 8004b8c:	f7fb fe24 	bl	80007d8 <uxListRemove>
                        prvAddTaskToReadyList( pxTCB );
 8004b90:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 8004b94:	f8d5 24e4 	ldr.w	r2, [r5, #1252]	; 0x4e4
 8004b98:	4293      	cmp	r3, r2
 8004b9a:	d901      	bls.n	8004ba0 <vTaskPriorityDisinheritAfterTimeout+0x80>
 8004b9c:	f8c5 34e4 	str.w	r3, [r5, #1252]	; 0x4e4
 8004ba0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004ba4:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 8004ba8:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8004bac:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8004bae:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 8004bb0:	6890      	ldr	r0, [r2, #8]
 8004bb2:	3101      	adds	r1, #1
 8004bb4:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
 8004bb8:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
 8004bbc:	6890      	ldr	r0, [r2, #8]
 8004bbe:	6047      	str	r7, [r0, #4]
 8004bc0:	6097      	str	r7, [r2, #8]
 8004bc2:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
 8004bc6:	62e9      	str	r1, [r5, #44]	; 0x2c
    }
 8004bc8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004bca:	4770      	bx	lr
 8004bcc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004bd0:	f383 8811 	msr	BASEPRI, r3
 8004bd4:	f3bf 8f6f 	isb	sy
 8004bd8:	f3bf 8f4f 	dsb	sy
                    configASSERT( pxTCB != pxCurrentTCB );
 8004bdc:	e7fe      	b.n	8004bdc <vTaskPriorityDisinheritAfterTimeout+0xbc>
 8004bde:	bf00      	nop
 8004be0:	24000040 	.word	0x24000040
 8004be4:	2400006c 	.word	0x2400006c

08004be8 <uxTaskGetTaskNumber>:
        if( xTask != NULL )
 8004be8:	b108      	cbz	r0, 8004bee <uxTaskGetTaskNumber+0x6>
            uxReturn = pxTCB->uxTaskNumber;
 8004bea:	f8d0 00c8 	ldr.w	r0, [r0, #200]	; 0xc8
    }
 8004bee:	4770      	bx	lr

08004bf0 <vTaskSetTaskNumber>:
        if( xTask != NULL )
 8004bf0:	b108      	cbz	r0, 8004bf6 <vTaskSetTaskNumber+0x6>
            pxTCB->uxTaskNumber = uxHandle;
 8004bf2:	f8c0 10c8 	str.w	r1, [r0, #200]	; 0xc8
    }
 8004bf6:	4770      	bx	lr

08004bf8 <pvTaskIncrementMutexHeldCount>:
        if( pxCurrentTCB != NULL )
 8004bf8:	4b05      	ldr	r3, [pc, #20]	; (8004c10 <pvTaskIncrementMutexHeldCount+0x18>)
 8004bfa:	685a      	ldr	r2, [r3, #4]
 8004bfc:	b12a      	cbz	r2, 8004c0a <pvTaskIncrementMutexHeldCount+0x12>
            ( pxCurrentTCB->uxMutexesHeld )++;
 8004bfe:	6859      	ldr	r1, [r3, #4]
 8004c00:	f8d1 20d0 	ldr.w	r2, [r1, #208]	; 0xd0
 8004c04:	3201      	adds	r2, #1
 8004c06:	f8c1 20d0 	str.w	r2, [r1, #208]	; 0xd0
        return pxCurrentTCB;
 8004c0a:	6858      	ldr	r0, [r3, #4]
    }
 8004c0c:	4770      	bx	lr
 8004c0e:	bf00      	nop
 8004c10:	24000040 	.word	0x24000040

08004c14 <vTaskInternalSetTimeOutState>:
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 8004c14:	4b03      	ldr	r3, [pc, #12]	; (8004c24 <vTaskInternalSetTimeOutState+0x10>)
 8004c16:	f8d3 24f4 	ldr.w	r2, [r3, #1268]	; 0x4f4
    pxTimeOut->xTimeOnEntering = xTickCount;
 8004c1a:	681b      	ldr	r3, [r3, #0]
 8004c1c:	e9c0 2300 	strd	r2, r3, [r0]
}
 8004c20:	4770      	bx	lr
 8004c22:	bf00      	nop
 8004c24:	24000040 	.word	0x24000040

08004c28 <prvTimerTask>:
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    }
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
 8004c28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004c2c:	4da3      	ldr	r5, [pc, #652]	; (8004ebc <prvTimerTask+0x294>)
 8004c2e:	b085      	sub	sp, #20
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
 8004c30:	f04f 28e0 	mov.w	r8, #3758153728	; 0xe000e000
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8004c34:	682b      	ldr	r3, [r5, #0]
 8004c36:	681c      	ldr	r4, [r3, #0]
 8004c38:	2c00      	cmp	r4, #0
 8004c3a:	f000 810d 	beq.w	8004e58 <prvTimerTask+0x230>

        if( *pxListWasEmpty == pdFALSE )
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8004c3e:	68db      	ldr	r3, [r3, #12]
 8004c40:	681c      	ldr	r4, [r3, #0]
        vTaskSuspendAll();
 8004c42:	f7fe fc8d 	bl	8003560 <vTaskSuspendAll>
    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
 8004c46:	f7fe fc95 	bl	8003574 <xTaskGetTickCount>

        if( xTimeNow < xLastTime )
 8004c4a:	686b      	ldr	r3, [r5, #4]
        xTimeNow = xTaskGetTickCount();
 8004c4c:	4681      	mov	r9, r0
        if( xTimeNow < xLastTime )
 8004c4e:	4298      	cmp	r0, r3
 8004c50:	d33f      	bcc.n	8004cd2 <prvTimerTask+0xaa>
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8004c52:	4284      	cmp	r4, r0
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
        }

        xLastTime = xTimeNow;
 8004c54:	6068      	str	r0, [r5, #4]
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8004c56:	f240 811b 	bls.w	8004e90 <prvTimerTask+0x268>
 8004c5a:	2200      	movs	r2, #0
                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8004c5c:	eba4 0109 	sub.w	r1, r4, r9
 8004c60:	68e8      	ldr	r0, [r5, #12]
 8004c62:	f7fd f8cd 	bl	8001e00 <vQueueWaitForMessageRestricted>
                    if( xTaskResumeAll() == pdFALSE )
 8004c66:	f7ff f919 	bl	8003e9c <xTaskResumeAll>
 8004c6a:	b938      	cbnz	r0, 8004c7c <prvTimerTask+0x54>
                        portYIELD_WITHIN_API();
 8004c6c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8004c70:	f8c8 3d04 	str.w	r3, [r8, #3332]	; 0xd04
 8004c74:	f3bf 8f4f 	dsb	sy
 8004c78:	f3bf 8f6f 	isb	sy
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8004c7c:	2200      	movs	r2, #0
 8004c7e:	4669      	mov	r1, sp
 8004c80:	68e8      	ldr	r0, [r5, #12]
 8004c82:	f7fc f941 	bl	8000f08 <xQueueReceive>
 8004c86:	2800      	cmp	r0, #0
 8004c88:	d0d4      	beq.n	8004c34 <prvTimerTask+0xc>
        {
            #if ( INCLUDE_xTimerPendFunctionCall == 1 )
                {
                    /* Negative commands are pended function calls rather than timer
                     * commands. */
                    if( xMessage.xMessageID < ( BaseType_t ) 0 )
 8004c8a:	9b00      	ldr	r3, [sp, #0]
 8004c8c:	2b00      	cmp	r3, #0
 8004c8e:	f2c0 80da 	blt.w	8004e46 <prvTimerTask+0x21e>
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8004c92:	9f02      	ldr	r7, [sp, #8]

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 8004c94:	697b      	ldr	r3, [r7, #20]
 8004c96:	b113      	cbz	r3, 8004c9e <prvTimerTask+0x76>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8004c98:	1d38      	adds	r0, r7, #4
 8004c9a:	f7fb fd9d 	bl	80007d8 <uxListRemove>
        xTimeNow = xTaskGetTickCount();
 8004c9e:	f7fe fc69 	bl	8003574 <xTaskGetTickCount>
        if( xTimeNow < xLastTime )
 8004ca2:	686b      	ldr	r3, [r5, #4]
        xTimeNow = xTaskGetTickCount();
 8004ca4:	4682      	mov	sl, r0
        if( xTimeNow < xLastTime )
 8004ca6:	4298      	cmp	r0, r3
 8004ca8:	d341      	bcc.n	8004d2e <prvTimerTask+0x106>
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

                switch( xMessage.xMessageID )
 8004caa:	9b00      	ldr	r3, [sp, #0]
        xLastTime = xTimeNow;
 8004cac:	f8c5 a004 	str.w	sl, [r5, #4]
                switch( xMessage.xMessageID )
 8004cb0:	3b01      	subs	r3, #1
 8004cb2:	2b08      	cmp	r3, #8
 8004cb4:	d8e2      	bhi.n	8004c7c <prvTimerTask+0x54>
 8004cb6:	e8df f003 	tbb	[pc, r3]
 8004cba:	6565      	.short	0x6565
 8004cbc:	65bda0b6 	.word	0x65bda0b6
 8004cc0:	b665      	.short	0xb665
 8004cc2:	a0          	.byte	0xa0
 8004cc3:	00          	.byte	0x00
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 8004cc4:	f023 0301 	bic.w	r3, r3, #1
 8004cc8:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004ccc:	6a23      	ldr	r3, [r4, #32]
 8004cce:	4620      	mov	r0, r4
 8004cd0:	4798      	blx	r3

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8004cd2:	682b      	ldr	r3, [r5, #0]
 8004cd4:	681a      	ldr	r2, [r3, #0]
 8004cd6:	2a00      	cmp	r2, #0
 8004cd8:	f000 80cf 	beq.w	8004e7a <prvTimerTask+0x252>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8004cdc:	68db      	ldr	r3, [r3, #12]
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004cde:	68dc      	ldr	r4, [r3, #12]
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8004ce0:	681e      	ldr	r6, [r3, #0]
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8004ce2:	f104 0a04 	add.w	sl, r4, #4
 8004ce6:	4650      	mov	r0, sl
 8004ce8:	f7fb fd76 	bl	80007d8 <uxListRemove>
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8004cec:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8004cf0:	0759      	lsls	r1, r3, #29
 8004cf2:	d5e7      	bpl.n	8004cc4 <prvTimerTask+0x9c>
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 8004cf4:	69a3      	ldr	r3, [r4, #24]
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004cf6:	43f2      	mvns	r2, r6
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8004cf8:	6124      	str	r4, [r4, #16]
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 8004cfa:	199f      	adds	r7, r3, r6
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004cfc:	429a      	cmp	r2, r3
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8004cfe:	6067      	str	r7, [r4, #4]
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004d00:	d309      	bcc.n	8004d16 <prvTimerTask+0xee>
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004d02:	6a23      	ldr	r3, [r4, #32]
 8004d04:	4620      	mov	r0, r4
 8004d06:	4798      	blx	r3
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004d08:	43fe      	mvns	r6, r7
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 8004d0a:	69a3      	ldr	r3, [r4, #24]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8004d0c:	6124      	str	r4, [r4, #16]
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 8004d0e:	441f      	add	r7, r3
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004d10:	42b3      	cmp	r3, r6
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8004d12:	6067      	str	r7, [r4, #4]
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004d14:	d9f5      	bls.n	8004d02 <prvTimerTask+0xda>
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8004d16:	4651      	mov	r1, sl
 8004d18:	68a8      	ldr	r0, [r5, #8]
 8004d1a:	f7fb fd35 	bl	8000788 <vListInsert>
        return xProcessTimerNow;
 8004d1e:	e7d5      	b.n	8004ccc <prvTimerTask+0xa4>
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 8004d20:	f023 0301 	bic.w	r3, r3, #1
 8004d24:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004d28:	6a23      	ldr	r3, [r4, #32]
 8004d2a:	4620      	mov	r0, r4
 8004d2c:	4798      	blx	r3
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8004d2e:	682b      	ldr	r3, [r5, #0]
 8004d30:	6819      	ldr	r1, [r3, #0]
 8004d32:	2900      	cmp	r1, #0
 8004d34:	f000 80a8 	beq.w	8004e88 <prvTimerTask+0x260>
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8004d38:	68db      	ldr	r3, [r3, #12]
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004d3a:	68dc      	ldr	r4, [r3, #12]
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8004d3c:	681e      	ldr	r6, [r3, #0]
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8004d3e:	f104 0b04 	add.w	fp, r4, #4
 8004d42:	4658      	mov	r0, fp
 8004d44:	f7fb fd48 	bl	80007d8 <uxListRemove>
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8004d48:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8004d4c:	0758      	lsls	r0, r3, #29
 8004d4e:	d5e7      	bpl.n	8004d20 <prvTimerTask+0xf8>
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 8004d50:	69a3      	ldr	r3, [r4, #24]
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004d52:	43f1      	mvns	r1, r6
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8004d54:	6124      	str	r4, [r4, #16]
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 8004d56:	eb06 0903 	add.w	r9, r6, r3
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004d5a:	4299      	cmp	r1, r3
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8004d5c:	f8c4 9004 	str.w	r9, [r4, #4]
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004d60:	d30b      	bcc.n	8004d7a <prvTimerTask+0x152>
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
 8004d62:	464e      	mov	r6, r9
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004d64:	6a23      	ldr	r3, [r4, #32]
 8004d66:	4620      	mov	r0, r4
 8004d68:	4798      	blx	r3
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004d6a:	43f6      	mvns	r6, r6
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 8004d6c:	69a3      	ldr	r3, [r4, #24]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8004d6e:	6124      	str	r4, [r4, #16]
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 8004d70:	4499      	add	r9, r3
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004d72:	42b3      	cmp	r3, r6
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8004d74:	f8c4 9004 	str.w	r9, [r4, #4]
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004d78:	d9f3      	bls.n	8004d62 <prvTimerTask+0x13a>
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8004d7a:	4659      	mov	r1, fp
 8004d7c:	68a8      	ldr	r0, [r5, #8]
 8004d7e:	f7fb fd03 	bl	8000788 <vListInsert>
        return xProcessTimerNow;
 8004d82:	e7d1      	b.n	8004d28 <prvTimerTask+0x100>
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8004d84:	f897 0028 	ldrb.w	r0, [r7, #40]	; 0x28
                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8004d88:	9901      	ldr	r1, [sp, #4]
 8004d8a:	69be      	ldr	r6, [r7, #24]
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8004d8c:	f040 0401 	orr.w	r4, r0, #1
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8004d90:	613f      	str	r7, [r7, #16]
 8004d92:	198b      	adds	r3, r1, r6
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8004d94:	f887 4028 	strb.w	r4, [r7, #40]	; 0x28
                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8004d98:	bf2c      	ite	cs
 8004d9a:	2401      	movcs	r4, #1
 8004d9c:	2400      	movcc	r4, #0
        if( xNextExpiryTime <= xTimeNow )
 8004d9e:	4553      	cmp	r3, sl
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8004da0:	607b      	str	r3, [r7, #4]
        if( xNextExpiryTime <= xTimeNow )
 8004da2:	f200 80ac 	bhi.w	8004efe <prvTimerTask+0x2d6>
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004da6:	ebaa 0101 	sub.w	r1, sl, r1
 8004daa:	428e      	cmp	r6, r1
 8004dac:	f200 80ba 	bhi.w	8004f24 <prvTimerTask+0x2fc>
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8004db0:	0741      	lsls	r1, r0, #29
 8004db2:	d40e      	bmi.n	8004dd2 <prvTimerTask+0x1aa>
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 8004db4:	f020 0001 	bic.w	r0, r0, #1
 8004db8:	f887 0028 	strb.w	r0, [r7, #40]	; 0x28
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004dbc:	6a3b      	ldr	r3, [r7, #32]
 8004dbe:	4638      	mov	r0, r7
 8004dc0:	4798      	blx	r3
 8004dc2:	e75b      	b.n	8004c7c <prvTimerTask+0x54>
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004dc4:	42b1      	cmp	r1, r6
 8004dc6:	f0c0 80a8 	bcc.w	8004f1a <prvTimerTask+0x2f2>
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004dca:	6a3b      	ldr	r3, [r7, #32]
 8004dcc:	4798      	blx	r3
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 8004dce:	69be      	ldr	r6, [r7, #24]
 8004dd0:	4623      	mov	r3, r4
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8004dd2:	199c      	adds	r4, r3, r6
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004dd4:	ebaa 0103 	sub.w	r1, sl, r3
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004dd8:	4638      	mov	r0, r7
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8004dda:	613f      	str	r7, [r7, #16]
 8004ddc:	bf2c      	ite	cs
 8004dde:	2201      	movcs	r2, #1
 8004de0:	2200      	movcc	r2, #0
        if( xNextExpiryTime <= xTimeNow )
 8004de2:	45a2      	cmp	sl, r4
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8004de4:	607c      	str	r4, [r7, #4]
        if( xNextExpiryTime <= xTimeNow )
 8004de6:	d2ed      	bcs.n	8004dc4 <prvTimerTask+0x19c>
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8004de8:	459a      	cmp	sl, r3
 8004dea:	d201      	bcs.n	8004df0 <prvTimerTask+0x1c8>
 8004dec:	2a00      	cmp	r2, #0
 8004dee:	d0ec      	beq.n	8004dca <prvTimerTask+0x1a2>
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8004df0:	1d39      	adds	r1, r7, #4
 8004df2:	6828      	ldr	r0, [r5, #0]
 8004df4:	f7fb fcc8 	bl	8000788 <vListInsert>
        return xProcessTimerNow;
 8004df8:	e7e0      	b.n	8004dbc <prvTimerTask+0x194>
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8004dfa:	f897 1028 	ldrb.w	r1, [r7, #40]	; 0x28
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8004dfe:	9b01      	ldr	r3, [sp, #4]
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8004e00:	f041 0101 	orr.w	r1, r1, #1
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8004e04:	61bb      	str	r3, [r7, #24]
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8004e06:	f887 1028 	strb.w	r1, [r7, #40]	; 0x28
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8004e0a:	2b00      	cmp	r3, #0
 8004e0c:	f000 808f 	beq.w	8004f2e <prvTimerTask+0x306>
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8004e10:	4453      	add	r3, sl
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8004e12:	1d39      	adds	r1, r7, #4
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8004e14:	613f      	str	r7, [r7, #16]
        if( xNextExpiryTime <= xTimeNow )
 8004e16:	4553      	cmp	r3, sl
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8004e18:	607b      	str	r3, [r7, #4]
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8004e1a:	bf94      	ite	ls
 8004e1c:	68a8      	ldrls	r0, [r5, #8]
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8004e1e:	6828      	ldrhi	r0, [r5, #0]
 8004e20:	f7fb fcb2 	bl	8000788 <vListInsert>
 8004e24:	e72a      	b.n	8004c7c <prvTimerTask+0x54>
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 8004e26:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8004e2a:	f023 0301 	bic.w	r3, r3, #1
 8004e2e:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
                        break;
 8004e32:	e723      	b.n	8004c7c <prvTimerTask+0x54>
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 8004e34:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8004e38:	079a      	lsls	r2, r3, #30
 8004e3a:	d56a      	bpl.n	8004f12 <prvTimerTask+0x2ea>
                                    pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 8004e3c:	f023 0301 	bic.w	r3, r3, #1
 8004e40:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
 8004e44:	e71a      	b.n	8004c7c <prvTimerTask+0x54>
                        pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
 8004e46:	9b01      	ldr	r3, [sp, #4]
 8004e48:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8004e4c:	4798      	blx	r3
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8004e4e:	9b00      	ldr	r3, [sp, #0]
 8004e50:	2b00      	cmp	r3, #0
 8004e52:	f6ff af13 	blt.w	8004c7c <prvTimerTask+0x54>
 8004e56:	e71c      	b.n	8004c92 <prvTimerTask+0x6a>
        vTaskSuspendAll();
 8004e58:	f7fe fb82 	bl	8003560 <vTaskSuspendAll>
        xTimeNow = xTaskGetTickCount();
 8004e5c:	f7fe fb8a 	bl	8003574 <xTaskGetTickCount>
        if( xTimeNow < xLastTime )
 8004e60:	686b      	ldr	r3, [r5, #4]
        xTimeNow = xTaskGetTickCount();
 8004e62:	4681      	mov	r9, r0
        if( xTimeNow < xLastTime )
 8004e64:	4283      	cmp	r3, r0
 8004e66:	f63f af34 	bhi.w	8004cd2 <prvTimerTask+0xaa>
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8004e6a:	68ab      	ldr	r3, [r5, #8]
        xLastTime = xTimeNow;
 8004e6c:	f8c5 9004 	str.w	r9, [r5, #4]
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8004e70:	681a      	ldr	r2, [r3, #0]
 8004e72:	fab2 f282 	clz	r2, r2
 8004e76:	0952      	lsrs	r2, r2, #5
 8004e78:	e6f0      	b.n	8004c5c <prvTimerTask+0x34>
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
        }

        pxTemp = pxCurrentTimerList;
        pxCurrentTimerList = pxOverflowTimerList;
 8004e7a:	68aa      	ldr	r2, [r5, #8]
        pxOverflowTimerList = pxTemp;
 8004e7c:	e9c5 9301 	strd	r9, r3, [r5, #4]
        pxCurrentTimerList = pxOverflowTimerList;
 8004e80:	602a      	str	r2, [r5, #0]
                ( void ) xTaskResumeAll();
 8004e82:	f7ff f80b 	bl	8003e9c <xTaskResumeAll>
 8004e86:	e6f9      	b.n	8004c7c <prvTimerTask+0x54>
        pxCurrentTimerList = pxOverflowTimerList;
 8004e88:	68a9      	ldr	r1, [r5, #8]
        pxOverflowTimerList = pxTemp;
 8004e8a:	60ab      	str	r3, [r5, #8]
        pxCurrentTimerList = pxOverflowTimerList;
 8004e8c:	6029      	str	r1, [r5, #0]
            *pxTimerListsWereSwitched = pdTRUE;
 8004e8e:	e70c      	b.n	8004caa <prvTimerTask+0x82>
                    ( void ) xTaskResumeAll();
 8004e90:	f7ff f804 	bl	8003e9c <xTaskResumeAll>
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8004e94:	682b      	ldr	r3, [r5, #0]
 8004e96:	68db      	ldr	r3, [r3, #12]
 8004e98:	68de      	ldr	r6, [r3, #12]
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8004e9a:	f106 0a04 	add.w	sl, r6, #4
 8004e9e:	4650      	mov	r0, sl
 8004ea0:	f7fb fc9a 	bl	80007d8 <uxListRemove>
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8004ea4:	f896 3028 	ldrb.w	r3, [r6, #40]	; 0x28
 8004ea8:	075a      	lsls	r2, r3, #29
 8004eaa:	d40e      	bmi.n	8004eca <prvTimerTask+0x2a2>
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 8004eac:	f023 0301 	bic.w	r3, r3, #1
 8004eb0:	f886 3028 	strb.w	r3, [r6, #40]	; 0x28
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004eb4:	6a33      	ldr	r3, [r6, #32]
 8004eb6:	4630      	mov	r0, r6
 8004eb8:	4798      	blx	r3
    }
 8004eba:	e6df      	b.n	8004c7c <prvTimerTask+0x54>
 8004ebc:	2400053c 	.word	0x2400053c
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004ec0:	428a      	cmp	r2, r1
 8004ec2:	d817      	bhi.n	8004ef4 <prvTimerTask+0x2cc>
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 8004ec4:	461c      	mov	r4, r3
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004ec6:	6a33      	ldr	r3, [r6, #32]
 8004ec8:	4798      	blx	r3
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 8004eca:	69b2      	ldr	r2, [r6, #24]
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004ecc:	eba9 0104 	sub.w	r1, r9, r4
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004ed0:	4630      	mov	r0, r6
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8004ed2:	6136      	str	r6, [r6, #16]
 8004ed4:	18a3      	adds	r3, r4, r2
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004ed6:	bf2c      	ite	cs
 8004ed8:	2701      	movcs	r7, #1
 8004eda:	2700      	movcc	r7, #0
        if( xNextExpiryTime <= xTimeNow )
 8004edc:	4599      	cmp	r9, r3
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8004ede:	6073      	str	r3, [r6, #4]
        if( xNextExpiryTime <= xTimeNow )
 8004ee0:	d2ee      	bcs.n	8004ec0 <prvTimerTask+0x298>
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8004ee2:	45a1      	cmp	r9, r4
 8004ee4:	d201      	bcs.n	8004eea <prvTimerTask+0x2c2>
 8004ee6:	2f00      	cmp	r7, #0
 8004ee8:	d0ec      	beq.n	8004ec4 <prvTimerTask+0x29c>
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8004eea:	4651      	mov	r1, sl
 8004eec:	6828      	ldr	r0, [r5, #0]
 8004eee:	f7fb fc4b 	bl	8000788 <vListInsert>
        return xProcessTimerNow;
 8004ef2:	e7df      	b.n	8004eb4 <prvTimerTask+0x28c>
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8004ef4:	4651      	mov	r1, sl
 8004ef6:	68a8      	ldr	r0, [r5, #8]
 8004ef8:	f7fb fc46 	bl	8000788 <vListInsert>
        return xProcessTimerNow;
 8004efc:	e7da      	b.n	8004eb4 <prvTimerTask+0x28c>
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8004efe:	4551      	cmp	r1, sl
 8004f00:	d902      	bls.n	8004f08 <prvTimerTask+0x2e0>
 8004f02:	2c00      	cmp	r4, #0
 8004f04:	f43f af54 	beq.w	8004db0 <prvTimerTask+0x188>
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8004f08:	1d39      	adds	r1, r7, #4
 8004f0a:	6828      	ldr	r0, [r5, #0]
 8004f0c:	f7fb fc3c 	bl	8000788 <vListInsert>
        return xProcessTimerNow;
 8004f10:	e6b4      	b.n	8004c7c <prvTimerTask+0x54>
                                    vPortFree( pxTimer );
 8004f12:	4638      	mov	r0, r7
 8004f14:	f000 fdd4 	bl	8005ac0 <vPortFree>
 8004f18:	e6b0      	b.n	8004c7c <prvTimerTask+0x54>
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8004f1a:	1d39      	adds	r1, r7, #4
 8004f1c:	68a8      	ldr	r0, [r5, #8]
 8004f1e:	f7fb fc33 	bl	8000788 <vListInsert>
        return xProcessTimerNow;
 8004f22:	e74b      	b.n	8004dbc <prvTimerTask+0x194>
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8004f24:	1d39      	adds	r1, r7, #4
 8004f26:	68a8      	ldr	r0, [r5, #8]
 8004f28:	f7fb fc2e 	bl	8000788 <vListInsert>
        return xProcessTimerNow;
 8004f2c:	e6a6      	b.n	8004c7c <prvTimerTask+0x54>
 8004f2e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004f32:	f383 8811 	msr	BASEPRI, r3
 8004f36:	f3bf 8f6f 	isb	sy
 8004f3a:	f3bf 8f4f 	dsb	sy
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8004f3e:	e7fe      	b.n	8004f3e <prvTimerTask+0x316>

08004f40 <xTimerCreate>:
        {
 8004f40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004f44:	4607      	mov	r7, r0
 8004f46:	b085      	sub	sp, #20
            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
 8004f48:	202c      	movs	r0, #44	; 0x2c
        {
 8004f4a:	4688      	mov	r8, r1
 8004f4c:	4616      	mov	r6, r2
 8004f4e:	461d      	mov	r5, r3
            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
 8004f50:	f000 fd06 	bl	8005960 <pvPortMalloc>
            if( pxNewTimer != NULL )
 8004f54:	4604      	mov	r4, r0
 8004f56:	b330      	cbz	r0, 8004fa6 <xTimerCreate+0x66>
                pxNewTimer->ucStatus = 0x00;
 8004f58:	2300      	movs	r3, #0
 8004f5a:	f880 3028 	strb.w	r3, [r0, #40]	; 0x28
        configASSERT( ( xTimerPeriodInTicks > 0 ) );
 8004f5e:	f1b8 0f00 	cmp.w	r8, #0
 8004f62:	d108      	bne.n	8004f76 <xTimerCreate+0x36>
 8004f64:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004f68:	f383 8811 	msr	BASEPRI, r3
 8004f6c:	f3bf 8f6f 	isb	sy
 8004f70:	f3bf 8f4f 	dsb	sy
 8004f74:	e7fe      	b.n	8004f74 <xTimerCreate+0x34>
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
        {
            if( xTimerQueue == NULL )
 8004f76:	f8df 907c 	ldr.w	r9, [pc, #124]	; 8004ff4 <xTimerCreate+0xb4>
        taskENTER_CRITICAL();
 8004f7a:	f004 fe3d 	bl	8009bf8 <vPortEnterCritical>
            if( xTimerQueue == NULL )
 8004f7e:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8004f82:	b1a3      	cbz	r3, 8004fae <xTimerCreate+0x6e>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 8004f84:	f004 fe4e 	bl	8009c24 <vPortExitCritical>
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8004f88:	9b0e      	ldr	r3, [sp, #56]	; 0x38
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8004f8a:	1d20      	adds	r0, r4, #4
        pxNewTimer->pcTimerName = pcTimerName;
 8004f8c:	6027      	str	r7, [r4, #0]
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8004f8e:	6223      	str	r3, [r4, #32]
        pxNewTimer->pvTimerID = pvTimerID;
 8004f90:	e9c4 8506 	strd	r8, r5, [r4, #24]
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8004f94:	f7fb fbf4 	bl	8000780 <vListInitialiseItem>
        if( uxAutoReload != pdFALSE )
 8004f98:	b12e      	cbz	r6, 8004fa6 <xTimerCreate+0x66>
            pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 8004f9a:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8004f9e:	f043 0304 	orr.w	r3, r3, #4
 8004fa2:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
        }
 8004fa6:	4620      	mov	r0, r4
 8004fa8:	b005      	add	sp, #20
 8004faa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                vListInitialise( &xActiveTimerList1 );
 8004fae:	f109 0b10 	add.w	fp, r9, #16
                vListInitialise( &xActiveTimerList2 );
 8004fb2:	f109 0a24 	add.w	sl, r9, #36	; 0x24
 8004fb6:	9303      	str	r3, [sp, #12]
                vListInitialise( &xActiveTimerList1 );
 8004fb8:	4658      	mov	r0, fp
 8004fba:	f7fb fbd5 	bl	8000768 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
 8004fbe:	4650      	mov	r0, sl
 8004fc0:	f7fb fbd2 	bl	8000768 <vListInitialise>
                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 8004fc4:	9b03      	ldr	r3, [sp, #12]
 8004fc6:	f109 0288 	add.w	r2, r9, #136	; 0x88
 8004fca:	2110      	movs	r1, #16
 8004fcc:	9300      	str	r3, [sp, #0]
 8004fce:	200a      	movs	r0, #10
 8004fd0:	f109 0338 	add.w	r3, r9, #56	; 0x38
                pxCurrentTimerList = &xActiveTimerList1;
 8004fd4:	f8c9 b000 	str.w	fp, [r9]
                pxOverflowTimerList = &xActiveTimerList2;
 8004fd8:	f8c9 a008 	str.w	sl, [r9, #8]
                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 8004fdc:	f7fc fff4 	bl	8001fc8 <xQueueGenericCreateStatic>
 8004fe0:	f8c9 000c 	str.w	r0, [r9, #12]
                        if( xTimerQueue != NULL )
 8004fe4:	2800      	cmp	r0, #0
 8004fe6:	d0cd      	beq.n	8004f84 <xTimerCreate+0x44>
                            vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 8004fe8:	4901      	ldr	r1, [pc, #4]	; (8004ff0 <xTimerCreate+0xb0>)
 8004fea:	f7fc fdfd 	bl	8001be8 <vQueueAddToRegistry>
 8004fee:	e7c9      	b.n	8004f84 <xTimerCreate+0x44>
 8004ff0:	24008258 	.word	0x24008258
 8004ff4:	2400053c 	.word	0x2400053c

08004ff8 <xTimerCreateStatic>:
        {
 8004ff8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                    volatile size_t xSize = sizeof( StaticTimer_t );
 8004ffc:	242c      	movs	r4, #44	; 0x2c
        {
 8004ffe:	b085      	sub	sp, #20
                    volatile size_t xSize = sizeof( StaticTimer_t );
 8005000:	9403      	str	r4, [sp, #12]
                    configASSERT( xSize == sizeof( Timer_t ) );
 8005002:	9c03      	ldr	r4, [sp, #12]
 8005004:	2c2c      	cmp	r4, #44	; 0x2c
 8005006:	d008      	beq.n	800501a <xTimerCreateStatic+0x22>
 8005008:	f04f 0350 	mov.w	r3, #80	; 0x50
 800500c:	f383 8811 	msr	BASEPRI, r3
 8005010:	f3bf 8f6f 	isb	sy
 8005014:	f3bf 8f4f 	dsb	sy
 8005018:	e7fe      	b.n	8005018 <xTimerCreateStatic+0x20>
                    ( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 800501a:	461d      	mov	r5, r3
 800501c:	9b03      	ldr	r3, [sp, #12]
            configASSERT( pxTimerBuffer );
 800501e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8005020:	b17b      	cbz	r3, 8005042 <xTimerCreateStatic+0x4a>
                pxNewTimer->ucStatus = tmrSTATUS_IS_STATICALLY_ALLOCATED;
 8005022:	4616      	mov	r6, r2
 8005024:	461a      	mov	r2, r3
 8005026:	2302      	movs	r3, #2
 8005028:	460f      	mov	r7, r1
 800502a:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
        configASSERT( ( xTimerPeriodInTicks > 0 ) );
 800502e:	b989      	cbnz	r1, 8005054 <xTimerCreateStatic+0x5c>
 8005030:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005034:	f383 8811 	msr	BASEPRI, r3
 8005038:	f3bf 8f6f 	isb	sy
 800503c:	f3bf 8f4f 	dsb	sy
 8005040:	e7fe      	b.n	8005040 <xTimerCreateStatic+0x48>
 8005042:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005046:	f383 8811 	msr	BASEPRI, r3
 800504a:	f3bf 8f6f 	isb	sy
 800504e:	f3bf 8f4f 	dsb	sy
            configASSERT( pxTimerBuffer );
 8005052:	e7fe      	b.n	8005052 <xTimerCreateStatic+0x5a>
            if( xTimerQueue == NULL )
 8005054:	4c20      	ldr	r4, [pc, #128]	; (80050d8 <xTimerCreateStatic+0xe0>)
 8005056:	4680      	mov	r8, r0
        taskENTER_CRITICAL();
 8005058:	f004 fdce 	bl	8009bf8 <vPortEnterCritical>
            if( xTimerQueue == NULL )
 800505c:	f8d4 b00c 	ldr.w	fp, [r4, #12]
 8005060:	f1bb 0f00 	cmp.w	fp, #0
 8005064:	d018      	beq.n	8005098 <xTimerCreateStatic+0xa0>
        taskEXIT_CRITICAL();
 8005066:	f004 fddd 	bl	8009c24 <vPortExitCritical>
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 800506a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 800506c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 800506e:	1d18      	adds	r0, r3, #4
        pxNewTimer->pcTimerName = pcTimerName;
 8005070:	f8c3 8000 	str.w	r8, [r3]
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8005074:	621a      	str	r2, [r3, #32]
        pxNewTimer->pvTimerID = pvTimerID;
 8005076:	e9c3 7506 	strd	r7, r5, [r3, #24]
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 800507a:	f7fb fb81 	bl	8000780 <vListInitialiseItem>
        if( uxAutoReload != pdFALSE )
 800507e:	b13e      	cbz	r6, 8005090 <xTimerCreateStatic+0x98>
            pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 8005080:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8005082:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8005084:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8005088:	f043 0304 	orr.w	r3, r3, #4
 800508c:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
        }
 8005090:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8005092:	b005      	add	sp, #20
 8005094:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                vListInitialise( &xActiveTimerList1 );
 8005098:	f104 0a10 	add.w	sl, r4, #16
                vListInitialise( &xActiveTimerList2 );
 800509c:	f104 0924 	add.w	r9, r4, #36	; 0x24
                vListInitialise( &xActiveTimerList1 );
 80050a0:	4650      	mov	r0, sl
 80050a2:	f7fb fb61 	bl	8000768 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
 80050a6:	4648      	mov	r0, r9
 80050a8:	f7fb fb5e 	bl	8000768 <vListInitialise>
                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 80050ac:	f8cd b000 	str.w	fp, [sp]
 80050b0:	f104 0338 	add.w	r3, r4, #56	; 0x38
 80050b4:	f104 0288 	add.w	r2, r4, #136	; 0x88
 80050b8:	2110      	movs	r1, #16
 80050ba:	200a      	movs	r0, #10
                pxCurrentTimerList = &xActiveTimerList1;
 80050bc:	f8c4 a000 	str.w	sl, [r4]
                pxOverflowTimerList = &xActiveTimerList2;
 80050c0:	f8c4 9008 	str.w	r9, [r4, #8]
                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 80050c4:	f7fc ff80 	bl	8001fc8 <xQueueGenericCreateStatic>
 80050c8:	60e0      	str	r0, [r4, #12]
                        if( xTimerQueue != NULL )
 80050ca:	2800      	cmp	r0, #0
 80050cc:	d0cb      	beq.n	8005066 <xTimerCreateStatic+0x6e>
                            vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 80050ce:	4903      	ldr	r1, [pc, #12]	; (80050dc <xTimerCreateStatic+0xe4>)
 80050d0:	f7fc fd8a 	bl	8001be8 <vQueueAddToRegistry>
 80050d4:	e7c7      	b.n	8005066 <xTimerCreateStatic+0x6e>
 80050d6:	bf00      	nop
 80050d8:	2400053c 	.word	0x2400053c
 80050dc:	24008258 	.word	0x24008258

080050e0 <pvTimerGetTimerID>:
    void * pvTimerGetTimerID( const TimerHandle_t xTimer )
    {
        Timer_t * const pxTimer = xTimer;
        void * pvReturn;

        configASSERT( xTimer );
 80050e0:	b158      	cbz	r0, 80050fa <pvTimerGetTimerID+0x1a>
    {
 80050e2:	b510      	push	{r4, lr}
 80050e4:	4604      	mov	r4, r0
 80050e6:	b082      	sub	sp, #8

        taskENTER_CRITICAL();
 80050e8:	f004 fd86 	bl	8009bf8 <vPortEnterCritical>
        {
            pvReturn = pxTimer->pvTimerID;
 80050ec:	69e0      	ldr	r0, [r4, #28]
 80050ee:	9001      	str	r0, [sp, #4]
        }
        taskEXIT_CRITICAL();
 80050f0:	f004 fd98 	bl	8009c24 <vPortExitCritical>

        return pvReturn;
    }
 80050f4:	9801      	ldr	r0, [sp, #4]
 80050f6:	b002      	add	sp, #8
 80050f8:	bd10      	pop	{r4, pc}
 80050fa:	f04f 0350 	mov.w	r3, #80	; 0x50
 80050fe:	f383 8811 	msr	BASEPRI, r3
 8005102:	f3bf 8f6f 	isb	sy
 8005106:	f3bf 8f4f 	dsb	sy
        configASSERT( xTimer );
 800510a:	e7fe      	b.n	800510a <pvTimerGetTimerID+0x2a>

0800510c <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

    void vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID )
    {
 800510c:	b538      	push	{r3, r4, r5, lr}
        Timer_t * const pxTimer = xTimer;

        configASSERT( xTimer );
 800510e:	b140      	cbz	r0, 8005122 <vTimerSetTimerID+0x16>
 8005110:	4604      	mov	r4, r0
 8005112:	460d      	mov	r5, r1

        taskENTER_CRITICAL();
 8005114:	f004 fd70 	bl	8009bf8 <vPortEnterCritical>
        {
            pxTimer->pvTimerID = pvNewID;
 8005118:	61e5      	str	r5, [r4, #28]
        }
        taskEXIT_CRITICAL();
    }
 800511a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        taskEXIT_CRITICAL();
 800511e:	f004 bd81 	b.w	8009c24 <vPortExitCritical>
 8005122:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005126:	f383 8811 	msr	BASEPRI, r3
 800512a:	f3bf 8f6f 	isb	sy
 800512e:	f3bf 8f4f 	dsb	sy
        configASSERT( xTimer );
 8005132:	e7fe      	b.n	8005132 <vTimerSetTimerID+0x26>

08005134 <xTimerIsTimerActive>:
        configASSERT( xTimer );
 8005134:	b170      	cbz	r0, 8005154 <xTimerIsTimerActive+0x20>
    {
 8005136:	b510      	push	{r4, lr}
 8005138:	4604      	mov	r4, r0
 800513a:	b082      	sub	sp, #8
        taskENTER_CRITICAL();
 800513c:	f004 fd5c 	bl	8009bf8 <vPortEnterCritical>
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
 8005140:	f894 0028 	ldrb.w	r0, [r4, #40]	; 0x28
 8005144:	f000 0001 	and.w	r0, r0, #1
 8005148:	9001      	str	r0, [sp, #4]
        taskEXIT_CRITICAL();
 800514a:	f004 fd6b 	bl	8009c24 <vPortExitCritical>
    } /*lint !e818 Can't be pointer to const due to the typedef. */
 800514e:	9801      	ldr	r0, [sp, #4]
 8005150:	b002      	add	sp, #8
 8005152:	bd10      	pop	{r4, pc}
 8005154:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005158:	f383 8811 	msr	BASEPRI, r3
 800515c:	f3bf 8f6f 	isb	sy
 8005160:	f3bf 8f4f 	dsb	sy
        configASSERT( xTimer );
 8005164:	e7fe      	b.n	8005164 <xTimerIsTimerActive+0x30>
 8005166:	bf00      	nop

08005168 <xTimerGetTimerDaemonTaskHandle>:
        configASSERT( ( xTimerTaskHandle != NULL ) );
 8005168:	4b06      	ldr	r3, [pc, #24]	; (8005184 <xTimerGetTimerDaemonTaskHandle+0x1c>)
 800516a:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128
 800516e:	b100      	cbz	r0, 8005172 <xTimerGetTimerDaemonTaskHandle+0xa>
    }
 8005170:	4770      	bx	lr
 8005172:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005176:	f383 8811 	msr	BASEPRI, r3
 800517a:	f3bf 8f6f 	isb	sy
 800517e:	f3bf 8f4f 	dsb	sy
        configASSERT( ( xTimerTaskHandle != NULL ) );
 8005182:	e7fe      	b.n	8005182 <xTimerGetTimerDaemonTaskHandle+0x1a>
 8005184:	2400053c 	.word	0x2400053c

08005188 <xTimerPendFunctionCallFromISR>:

        BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend,
                                                  void * pvParameter1,
                                                  uint32_t ulParameter2,
                                                  BaseType_t * pxHigherPriorityTaskWoken )
        {
 8005188:	b530      	push	{r4, r5, lr}
 800518a:	b085      	sub	sp, #20
 800518c:	4614      	mov	r4, r2
            DaemonTaskMessage_t xMessage;
            BaseType_t xReturn;

            /* Complete the message with the function parameters and post it to the
             * daemon task. */
            xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
 800518e:	f06f 0501 	mvn.w	r5, #1
            xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
            xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
            xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;

            xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8005192:	461a      	mov	r2, r3
            xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
 8005194:	9001      	str	r0, [sp, #4]
            xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8005196:	2300      	movs	r3, #0
 8005198:	4804      	ldr	r0, [pc, #16]	; (80051ac <xTimerPendFunctionCallFromISR+0x24>)
            xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
 800519a:	9102      	str	r1, [sp, #8]
            xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 800519c:	4669      	mov	r1, sp
 800519e:	68c0      	ldr	r0, [r0, #12]
            xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
 80051a0:	9500      	str	r5, [sp, #0]
            xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
 80051a2:	9403      	str	r4, [sp, #12]
            xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 80051a4:	f7fc f8a2 	bl	80012ec <xQueueGenericSendFromISR>

            tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

            return xReturn;
        }
 80051a8:	b005      	add	sp, #20
 80051aa:	bd30      	pop	{r4, r5, pc}
 80051ac:	2400053c 	.word	0x2400053c

080051b0 <xTimerPendFunctionCall>:

        BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend,
                                           void * pvParameter1,
                                           uint32_t ulParameter2,
                                           TickType_t xTicksToWait )
        {
 80051b0:	b530      	push	{r4, r5, lr}
            BaseType_t xReturn;

            /* This function can only be called after a timer has been created or
             * after the scheduler has been started because, until then, the timer
             * queue does not exist. */
            configASSERT( xTimerQueue );
 80051b2:	4c0e      	ldr	r4, [pc, #56]	; (80051ec <xTimerPendFunctionCall+0x3c>)
        {
 80051b4:	b085      	sub	sp, #20
            configASSERT( xTimerQueue );
 80051b6:	68e5      	ldr	r5, [r4, #12]
 80051b8:	b175      	cbz	r5, 80051d8 <xTimerPendFunctionCall+0x28>

            /* Complete the message with the function parameters and post it to the
             * daemon task. */
            xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
 80051ba:	4614      	mov	r4, r2
 80051bc:	461a      	mov	r2, r3
            xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
            xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
            xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;

            xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 80051be:	2300      	movs	r3, #0
            xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
 80051c0:	9001      	str	r0, [sp, #4]
            xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 80051c2:	4628      	mov	r0, r5
            xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
 80051c4:	e9cd 1402 	strd	r1, r4, [sp, #8]
            xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 80051c8:	4669      	mov	r1, sp
            xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
 80051ca:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 80051ce:	9400      	str	r4, [sp, #0]
            xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 80051d0:	f7fb fb58 	bl	8000884 <xQueueGenericSend>

            tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

            return xReturn;
        }
 80051d4:	b005      	add	sp, #20
 80051d6:	bd30      	pop	{r4, r5, pc}
 80051d8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80051dc:	f383 8811 	msr	BASEPRI, r3
 80051e0:	f3bf 8f6f 	isb	sy
 80051e4:	f3bf 8f4f 	dsb	sy
            configASSERT( xTimerQueue );
 80051e8:	e7fe      	b.n	80051e8 <xTimerPendFunctionCall+0x38>
 80051ea:	bf00      	nop
 80051ec:	2400053c 	.word	0x2400053c

080051f0 <pcTimerGetName>:
        configASSERT( xTimer );
 80051f0:	b108      	cbz	r0, 80051f6 <pcTimerGetName+0x6>
    }
 80051f2:	6800      	ldr	r0, [r0, #0]
 80051f4:	4770      	bx	lr
 80051f6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80051fa:	f383 8811 	msr	BASEPRI, r3
 80051fe:	f3bf 8f6f 	isb	sy
 8005202:	f3bf 8f4f 	dsb	sy
        configASSERT( xTimer );
 8005206:	e7fe      	b.n	8005206 <pcTimerGetName+0x16>

08005208 <vTimerSetReloadMode>:
    {
 8005208:	b538      	push	{r3, r4, r5, lr}
        configASSERT( xTimer );
 800520a:	b1b0      	cbz	r0, 800523a <vTimerSetReloadMode+0x32>
        taskENTER_CRITICAL();
 800520c:	4604      	mov	r4, r0
 800520e:	460d      	mov	r5, r1
 8005210:	f004 fcf2 	bl	8009bf8 <vPortEnterCritical>
                pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 8005214:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
            if( uxAutoReload != pdFALSE )
 8005218:	b93d      	cbnz	r5, 800522a <vTimerSetReloadMode+0x22>
                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
 800521a:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 800521e:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    }
 8005222:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        taskEXIT_CRITICAL();
 8005226:	f004 bcfd 	b.w	8009c24 <vPortExitCritical>
                pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 800522a:	f043 0304 	orr.w	r3, r3, #4
 800522e:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    }
 8005232:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        taskEXIT_CRITICAL();
 8005236:	f004 bcf5 	b.w	8009c24 <vPortExitCritical>
 800523a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800523e:	f383 8811 	msr	BASEPRI, r3
 8005242:	f3bf 8f6f 	isb	sy
 8005246:	f3bf 8f4f 	dsb	sy
        configASSERT( xTimer );
 800524a:	e7fe      	b.n	800524a <vTimerSetReloadMode+0x42>

0800524c <uxTimerGetReloadMode>:
        configASSERT( xTimer );
 800524c:	b170      	cbz	r0, 800526c <uxTimerGetReloadMode+0x20>
    {
 800524e:	b510      	push	{r4, lr}
 8005250:	4604      	mov	r4, r0
 8005252:	b082      	sub	sp, #8
        taskENTER_CRITICAL();
 8005254:	f004 fcd0 	bl	8009bf8 <vPortEnterCritical>
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
 8005258:	f894 0028 	ldrb.w	r0, [r4, #40]	; 0x28
 800525c:	f3c0 0080 	ubfx	r0, r0, #2, #1
 8005260:	9001      	str	r0, [sp, #4]
        taskEXIT_CRITICAL();
 8005262:	f004 fcdf 	bl	8009c24 <vPortExitCritical>
    }
 8005266:	9801      	ldr	r0, [sp, #4]
 8005268:	b002      	add	sp, #8
 800526a:	bd10      	pop	{r4, pc}
 800526c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005270:	f383 8811 	msr	BASEPRI, r3
 8005274:	f3bf 8f6f 	isb	sy
 8005278:	f3bf 8f4f 	dsb	sy
        configASSERT( xTimer );
 800527c:	e7fe      	b.n	800527c <uxTimerGetReloadMode+0x30>
 800527e:	bf00      	nop

08005280 <xTimerGetPeriod>:
        configASSERT( xTimer );
 8005280:	b108      	cbz	r0, 8005286 <xTimerGetPeriod+0x6>
    }
 8005282:	6980      	ldr	r0, [r0, #24]
 8005284:	4770      	bx	lr
 8005286:	f04f 0350 	mov.w	r3, #80	; 0x50
 800528a:	f383 8811 	msr	BASEPRI, r3
 800528e:	f3bf 8f6f 	isb	sy
 8005292:	f3bf 8f4f 	dsb	sy
        configASSERT( xTimer );
 8005296:	e7fe      	b.n	8005296 <xTimerGetPeriod+0x16>

08005298 <xTimerGetExpiryTime>:
        configASSERT( xTimer );
 8005298:	b108      	cbz	r0, 800529e <xTimerGetExpiryTime+0x6>
    }
 800529a:	6840      	ldr	r0, [r0, #4]
 800529c:	4770      	bx	lr
 800529e:	f04f 0350 	mov.w	r3, #80	; 0x50
 80052a2:	f383 8811 	msr	BASEPRI, r3
 80052a6:	f3bf 8f6f 	isb	sy
 80052aa:	f3bf 8f4f 	dsb	sy
        configASSERT( xTimer );
 80052ae:	e7fe      	b.n	80052ae <xTimerGetExpiryTime+0x16>

080052b0 <xTimerCreateTimerTask>:
    {
 80052b0:	b5f0      	push	{r4, r5, r6, r7, lr}
            if( xTimerQueue == NULL )
 80052b2:	4c24      	ldr	r4, [pc, #144]	; (8005344 <xTimerCreateTimerTask+0x94>)
    {
 80052b4:	b089      	sub	sp, #36	; 0x24
        taskENTER_CRITICAL();
 80052b6:	f004 fc9f 	bl	8009bf8 <vPortEnterCritical>
            if( xTimerQueue == NULL )
 80052ba:	68e5      	ldr	r5, [r4, #12]
 80052bc:	b335      	cbz	r5, 800530c <xTimerCreateTimerTask+0x5c>
        taskEXIT_CRITICAL();
 80052be:	f004 fcb1 	bl	8009c24 <vPortExitCritical>
        if( xTimerQueue != NULL )
 80052c2:	68e3      	ldr	r3, [r4, #12]
 80052c4:	b1cb      	cbz	r3, 80052fa <xTimerCreateTimerTask+0x4a>
                    StaticTask_t * pxTimerTaskTCBBuffer = NULL;
 80052c6:	2500      	movs	r5, #0
                    vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 80052c8:	aa07      	add	r2, sp, #28
 80052ca:	a906      	add	r1, sp, #24
 80052cc:	a805      	add	r0, sp, #20
                    StackType_t * pxTimerTaskStackBuffer = NULL;
 80052ce:	e9cd 5505 	strd	r5, r5, [sp, #20]
                    vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 80052d2:	f004 fd5b 	bl	8009d8c <vApplicationGetTimerTaskMemory>
                    xTimerTaskHandle = xTaskCreateStatic( prvTimerTask,
 80052d6:	481c      	ldr	r0, [pc, #112]	; (8005348 <xTimerCreateTimerTask+0x98>)
 80052d8:	462b      	mov	r3, r5
 80052da:	9000      	str	r0, [sp, #0]
 80052dc:	481b      	ldr	r0, [pc, #108]	; (800534c <xTimerCreateTimerTask+0x9c>)
 80052de:	e9dd 1205 	ldrd	r1, r2, [sp, #20]
 80052e2:	e9cd 2101 	strd	r2, r1, [sp, #4]
 80052e6:	9a07      	ldr	r2, [sp, #28]
 80052e8:	4919      	ldr	r1, [pc, #100]	; (8005350 <xTimerCreateTimerTask+0xa0>)
 80052ea:	f7fd fdb9 	bl	8002e60 <xTaskCreateStatic>
 80052ee:	f8c4 0128 	str.w	r0, [r4, #296]	; 0x128
                    if( xTimerTaskHandle != NULL )
 80052f2:	b110      	cbz	r0, 80052fa <xTimerCreateTimerTask+0x4a>
    }
 80052f4:	2001      	movs	r0, #1
 80052f6:	b009      	add	sp, #36	; 0x24
 80052f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80052fa:	f04f 0350 	mov.w	r3, #80	; 0x50
 80052fe:	f383 8811 	msr	BASEPRI, r3
 8005302:	f3bf 8f6f 	isb	sy
 8005306:	f3bf 8f4f 	dsb	sy
        configASSERT( xReturn );
 800530a:	e7fe      	b.n	800530a <xTimerCreateTimerTask+0x5a>
                vListInitialise( &xActiveTimerList1 );
 800530c:	f104 0710 	add.w	r7, r4, #16
                vListInitialise( &xActiveTimerList2 );
 8005310:	f104 0624 	add.w	r6, r4, #36	; 0x24
                vListInitialise( &xActiveTimerList1 );
 8005314:	4638      	mov	r0, r7
 8005316:	f7fb fa27 	bl	8000768 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
 800531a:	4630      	mov	r0, r6
 800531c:	f7fb fa24 	bl	8000768 <vListInitialise>
                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 8005320:	f104 0338 	add.w	r3, r4, #56	; 0x38
 8005324:	f104 0288 	add.w	r2, r4, #136	; 0x88
 8005328:	2110      	movs	r1, #16
 800532a:	200a      	movs	r0, #10
 800532c:	9500      	str	r5, [sp, #0]
                pxCurrentTimerList = &xActiveTimerList1;
 800532e:	6027      	str	r7, [r4, #0]
                pxOverflowTimerList = &xActiveTimerList2;
 8005330:	60a6      	str	r6, [r4, #8]
                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 8005332:	f7fc fe49 	bl	8001fc8 <xQueueGenericCreateStatic>
 8005336:	60e0      	str	r0, [r4, #12]
                        if( xTimerQueue != NULL )
 8005338:	2800      	cmp	r0, #0
 800533a:	d0c0      	beq.n	80052be <xTimerCreateTimerTask+0xe>
                            vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 800533c:	4905      	ldr	r1, [pc, #20]	; (8005354 <xTimerCreateTimerTask+0xa4>)
 800533e:	f7fc fc53 	bl	8001be8 <vQueueAddToRegistry>
 8005342:	e7bc      	b.n	80052be <xTimerCreateTimerTask+0xe>
 8005344:	2400053c 	.word	0x2400053c
 8005348:	80000002 	.word	0x80000002
 800534c:	08004c29 	.word	0x08004c29
 8005350:	24008260 	.word	0x24008260
 8005354:	24008258 	.word	0x24008258

08005358 <xTimerGenericCommand>:
        configASSERT( xTimer );
 8005358:	b1c8      	cbz	r0, 800538e <xTimerGenericCommand+0x36>
    {
 800535a:	b530      	push	{r4, r5, lr}
        if( xTimerQueue != NULL )
 800535c:	4d18      	ldr	r5, [pc, #96]	; (80053c0 <xTimerGenericCommand+0x68>)
    {
 800535e:	b085      	sub	sp, #20
        if( xTimerQueue != NULL )
 8005360:	68ec      	ldr	r4, [r5, #12]
 8005362:	b18c      	cbz	r4, 8005388 <xTimerGenericCommand+0x30>
            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8005364:	2905      	cmp	r1, #5
            xMessage.u.xTimerParameters.pxTimer = xTimer;
 8005366:	9002      	str	r0, [sp, #8]
            xMessage.xMessageID = xCommandID;
 8005368:	e9cd 1200 	strd	r1, r2, [sp]
            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 800536c:	dc18      	bgt.n	80053a0 <xTimerGenericCommand+0x48>
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 800536e:	f7ff fb15 	bl	800499c <xTaskGetSchedulerState>
 8005372:	2802      	cmp	r0, #2
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8005374:	f04f 0300 	mov.w	r3, #0
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8005378:	d01b      	beq.n	80053b2 <xTimerGenericCommand+0x5a>
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 800537a:	4669      	mov	r1, sp
 800537c:	461a      	mov	r2, r3
 800537e:	68e8      	ldr	r0, [r5, #12]
 8005380:	f7fb fa80 	bl	8000884 <xQueueGenericSend>
    }
 8005384:	b005      	add	sp, #20
 8005386:	bd30      	pop	{r4, r5, pc}
        BaseType_t xReturn = pdFAIL;
 8005388:	4620      	mov	r0, r4
    }
 800538a:	b005      	add	sp, #20
 800538c:	bd30      	pop	{r4, r5, pc}
 800538e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005392:	f383 8811 	msr	BASEPRI, r3
 8005396:	f3bf 8f6f 	isb	sy
 800539a:	f3bf 8f4f 	dsb	sy
        configASSERT( xTimer );
 800539e:	e7fe      	b.n	800539e <xTimerGenericCommand+0x46>
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 80053a0:	469c      	mov	ip, r3
 80053a2:	4669      	mov	r1, sp
 80053a4:	2300      	movs	r3, #0
 80053a6:	4620      	mov	r0, r4
 80053a8:	4662      	mov	r2, ip
 80053aa:	f7fb ff9f 	bl	80012ec <xQueueGenericSendFromISR>
    }
 80053ae:	b005      	add	sp, #20
 80053b0:	bd30      	pop	{r4, r5, pc}
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 80053b2:	9a08      	ldr	r2, [sp, #32]
 80053b4:	4669      	mov	r1, sp
 80053b6:	68e8      	ldr	r0, [r5, #12]
 80053b8:	f7fb fa64 	bl	8000884 <xQueueGenericSend>
 80053bc:	e7e5      	b.n	800538a <xTimerGenericCommand+0x32>
 80053be:	bf00      	nop
 80053c0:	2400053c 	.word	0x2400053c

080053c4 <vTimerSetTimerNumber>:
    #if ( configUSE_TRACE_FACILITY == 1 )

        void vTimerSetTimerNumber( TimerHandle_t xTimer,
                                   UBaseType_t uxTimerNumber )
        {
            ( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
 80053c4:	6241      	str	r1, [r0, #36]	; 0x24
        }
 80053c6:	4770      	bx	lr

080053c8 <uxTimerGetTimerNumber>:
        }
 80053c8:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80053ca:	4770      	bx	lr
 80053cc:	0000      	movs	r0, r0
	...

080053d0 <prvRestoreContextOfFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvRestoreContextOfFirstTask( void )
{
    __asm volatile
 80053d0:	f8df 044c 	ldr.w	r0, [pc, #1100]	; 8005820 <xPortStartScheduler+0xfc>
 80053d4:	6800      	ldr	r0, [r0, #0]
 80053d6:	6800      	ldr	r0, [r0, #0]
 80053d8:	f380 8808 	msr	MSP, r0
 80053dc:	4b18      	ldr	r3, [pc, #96]	; (8005440 <pxCurrentTCBConst2>)
 80053de:	6819      	ldr	r1, [r3, #0]
 80053e0:	6808      	ldr	r0, [r1, #0]
 80053e2:	f101 0104 	add.w	r1, r1, #4
 80053e6:	f3bf 8f5f 	dmb	sy
 80053ea:	f8df 2438 	ldr.w	r2, [pc, #1080]	; 8005824 <xPortStartScheduler+0x100>
 80053ee:	6813      	ldr	r3, [r2, #0]
 80053f0:	f023 0301 	bic.w	r3, r3, #1
 80053f4:	6013      	str	r3, [r2, #0]
 80053f6:	f8df 2430 	ldr.w	r2, [pc, #1072]	; 8005828 <xPortStartScheduler+0x104>
 80053fa:	e8b1 0ff0 	ldmia.w	r1!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80053fe:	e882 0ff0 	stmia.w	r2, {r4, r5, r6, r7, r8, r9, sl, fp}
 8005402:	e8b1 0ff0 	ldmia.w	r1!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8005406:	e882 0ff0 	stmia.w	r2, {r4, r5, r6, r7, r8, r9, sl, fp}
 800540a:	e8b1 0ff0 	ldmia.w	r1!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800540e:	e882 0ff0 	stmia.w	r2, {r4, r5, r6, r7, r8, r9, sl, fp}
 8005412:	f8df 2410 	ldr.w	r2, [pc, #1040]	; 8005824 <xPortStartScheduler+0x100>
 8005416:	6813      	ldr	r3, [r2, #0]
 8005418:	f043 0301 	orr.w	r3, r3, #1
 800541c:	6013      	str	r3, [r2, #0]
 800541e:	f3bf 8f4f 	dsb	sy
 8005422:	e8b0 4ff8 	ldmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005426:	f383 8814 	msr	CONTROL, r3
 800542a:	f380 8809 	msr	PSP, r0
 800542e:	f04f 0000 	mov.w	r0, #0
 8005432:	f380 8811 	msr	BASEPRI, r0
 8005436:	4770      	bx	lr
 8005438:	f3af 8000 	nop.w
 800543c:	f3af 8000 	nop.w

08005440 <pxCurrentTCBConst2>:
 8005440:	24000044 	.word	0x24000044

08005444 <prvSVCHandler>:
    ulPC = pulParam[ portOFFSET_TO_PC ];
 8005444:	6982      	ldr	r2, [r0, #24]
    ucSVCNumber = ( ( uint8_t * ) ulPC )[ -2 ];
 8005446:	f812 3c02 	ldrb.w	r3, [r2, #-2]
    switch( ucSVCNumber )
 800544a:	2b01      	cmp	r3, #1
 800544c:	d003      	beq.n	8005456 <prvSVCHandler+0x12>
 800544e:	2b02      	cmp	r3, #2
 8005450:	d015      	beq.n	800547e <prvSVCHandler+0x3a>
 8005452:	b15b      	cbz	r3, 800546c <prvSVCHandler+0x28>
}
 8005454:	4770      	bx	lr
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8005456:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800545a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800545e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
            __asm volatile ( "dsb" ::: "memory" );
 8005462:	f3bf 8f4f 	dsb	sy
            __asm volatile ( "isb" );
 8005466:	f3bf 8f6f 	isb	sy
            break;
 800546a:	4770      	bx	lr
            portNVIC_SHPR2_REG |= portNVIC_SVC_PRI;
 800546c:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
 8005470:	f8d2 3d1c 	ldr.w	r3, [r2, #3356]	; 0xd1c
 8005474:	f043 439e 	orr.w	r3, r3, #1325400064	; 0x4f000000
 8005478:	f8c2 3d1c 	str.w	r3, [r2, #3356]	; 0xd1c
            prvRestoreContextOfFirstTask();
 800547c:	e7a8      	b.n	80053d0 <prvRestoreContextOfFirstTask>
                    if( ( ulPC >= ( uint32_t ) __syscalls_flash_start__ ) &&
 800547e:	4b06      	ldr	r3, [pc, #24]	; (8005498 <prvSVCHandler+0x54>)
 8005480:	429a      	cmp	r2, r3
 8005482:	d3e7      	bcc.n	8005454 <prvSVCHandler+0x10>
 8005484:	4b05      	ldr	r3, [pc, #20]	; (800549c <prvSVCHandler+0x58>)
 8005486:	429a      	cmp	r2, r3
 8005488:	d8e4      	bhi.n	8005454 <prvSVCHandler+0x10>
                        __asm volatile
 800548a:	f3ef 8114 	mrs	r1, CONTROL
 800548e:	f021 0101 	bic.w	r1, r1, #1
 8005492:	f381 8814 	msr	CONTROL, r1
}
 8005496:	e7dd      	b.n	8005454 <prvSVCHandler+0x10>
 8005498:	08008000 	.word	0x08008000
 800549c:	08009020 	.word	0x08009020

080054a0 <pxPortInitialiseStack>:
        *pxTopOfStack = portINITIAL_CONTROL_IF_UNPRIVILEGED;
 80054a0:	2b01      	cmp	r3, #1
    *pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK; /* PC */
 80054a2:	f021 0101 	bic.w	r1, r1, #1
    *pxTopOfStack = portINITIAL_XPSR;                                    /* xPSR */
 80054a6:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
{
 80054aa:	b410      	push	{r4}
    *pxTopOfStack = ( StackType_t ) pvParameters;                        /* R0 */
 80054ac:	f840 2c20 	str.w	r2, [r0, #-32]
    *pxTopOfStack = 0;                                                   /* LR */
 80054b0:	f04f 0400 	mov.w	r4, #0
    *pxTopOfStack = portINITIAL_EXC_RETURN;
 80054b4:	f06f 0202 	mvn.w	r2, #2
    *pxTopOfStack = 0;                                                   /* LR */
 80054b8:	f840 4c0c 	str.w	r4, [r0, #-12]
    *pxTopOfStack = portINITIAL_EXC_RETURN;
 80054bc:	f840 2c24 	str.w	r2, [r0, #-36]
}
 80054c0:	f85d 4b04 	ldr.w	r4, [sp], #4
    *pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK; /* PC */
 80054c4:	e940 1302 	strd	r1, r3, [r0, #-8]
        *pxTopOfStack = portINITIAL_CONTROL_IF_UNPRIVILEGED;
 80054c8:	bf0c      	ite	eq
 80054ca:	2302      	moveq	r3, #2
 80054cc:	2303      	movne	r3, #3
}
 80054ce:	3848      	subs	r0, #72	; 0x48
 80054d0:	6003      	str	r3, [r0, #0]
 80054d2:	4770      	bx	lr

080054d4 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
    /* Not implemented in ports where there is nothing to return to.
     * Artificially force an assert. */
    configASSERT( uxCriticalNesting == 1000UL );
 80054d4:	4b07      	ldr	r3, [pc, #28]	; (80054f4 <vPortEndScheduler+0x20>)
 80054d6:	681b      	ldr	r3, [r3, #0]
 80054d8:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80054dc:	d008      	beq.n	80054f0 <vPortEndScheduler+0x1c>
 80054de:	f04f 0350 	mov.w	r3, #80	; 0x50
 80054e2:	f383 8811 	msr	BASEPRI, r3
 80054e6:	f3bf 8f6f 	isb	sy
 80054ea:	f3bf 8f4f 	dsb	sy
 80054ee:	e7fe      	b.n	80054ee <vPortEndScheduler+0x1a>
}
 80054f0:	4770      	bx	lr
 80054f2:	bf00      	nop
 80054f4:	24008014 	.word	0x24008014

080054f8 <vPortStoreTaskMPUSettings>:

void vPortStoreTaskMPUSettings( xMPU_SETTINGS * xMPUSettings,
                                const struct xMEMORY_REGION * const xRegions,
                                StackType_t * pxBottomOfStack,
                                uint32_t ulStackDepth )
{
 80054f8:	b530      	push	{r4, r5, lr}
    #endif /* if defined( __ARMCC_VERSION ) */

    int32_t lIndex;
    uint32_t ul;

    if( xRegions == NULL )
 80054fa:	b371      	cbz	r1, 800555a <vPortStoreTaskMPUSettings+0x62>
    {
        /* This function is called automatically when the task is created - in
         * which case the stack region parameters will be valid.  At all other
         * times the stack parameters will not be valid and it is assumed that the
         * stack region has already been configured. */
        if( ulStackDepth > 0 )
 80054fc:	2b00      	cmp	r3, #0
 80054fe:	d176      	bne.n	80055ee <vPortStoreTaskMPUSettings+0xf6>
 8005500:	468c      	mov	ip, r1
 8005502:	f04f 0e05 	mov.w	lr, #5
 8005506:	e00b      	b.n	8005520 <vPortStoreTaskMPUSettings+0x28>
                    ( portMPU_REGION_ENABLE );
            }
            else
            {
                /* Invalidate the region. */
                xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
 8005508:	f04e 0310 	orr.w	r3, lr, #16
 800550c:	e9c0 3102 	strd	r3, r1, [r0, #8]
        for( ul = 1; ul <= portNUM_CONFIGURABLE_REGIONS; ul++ )
 8005510:	f10e 0e01 	add.w	lr, lr, #1
 8005514:	f10c 0c0c 	add.w	ip, ip, #12
 8005518:	3008      	adds	r0, #8
 800551a:	f1be 0f10 	cmp.w	lr, #16
 800551e:	d063      	beq.n	80055e8 <vPortStoreTaskMPUSettings+0xf0>
            if( ( xRegions[ lIndex ] ).ulLengthInBytes > 0UL )
 8005520:	f8dc 1004 	ldr.w	r1, [ip, #4]
 8005524:	2900      	cmp	r1, #0
 8005526:	d0ef      	beq.n	8005508 <vPortStoreTaskMPUSettings+0x10>
                    ( portMPU_REGION_VALID ) |
 8005528:	f8dc 4000 	ldr.w	r4, [ip]
    uint32_t ulRegionSize, ulReturnValue = 4;
 800552c:	2304      	movs	r3, #4
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 800552e:	2220      	movs	r2, #32
                    ( portMPU_REGION_VALID ) |
 8005530:	ea44 040e 	orr.w	r4, r4, lr
 8005534:	f044 0410 	orr.w	r4, r4, #16
                xMPUSettings->xRegion[ ul ].ulRegionBaseAddress =
 8005538:	6084      	str	r4, [r0, #8]
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 800553a:	e002      	b.n	8005542 <vPortStoreTaskMPUSettings+0x4a>
            ulReturnValue++;
 800553c:	3301      	adds	r3, #1
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 800553e:	2b1f      	cmp	r3, #31
 8005540:	d053      	beq.n	80055ea <vPortStoreTaskMPUSettings+0xf2>
        if( ulActualSizeInBytes <= ulRegionSize )
 8005542:	4291      	cmp	r1, r2
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 8005544:	ea4f 0242 	mov.w	r2, r2, lsl #1
        if( ulActualSizeInBytes <= ulRegionSize )
 8005548:	d8f8      	bhi.n	800553c <vPortStoreTaskMPUSettings+0x44>
    return( ulReturnValue << 1UL );
 800554a:	005b      	lsls	r3, r3, #1
                    ( prvGetMPURegionSizeSetting( xRegions[ lIndex ].ulLengthInBytes ) ) |
 800554c:	f8dc 2008 	ldr.w	r2, [ip, #8]
 8005550:	4313      	orrs	r3, r2
                    ( xRegions[ lIndex ].ulParameters ) |
 8005552:	f043 0301 	orr.w	r3, r3, #1
                xMPUSettings->xRegion[ ul ].ulRegionAttribute =
 8005556:	60c3      	str	r3, [r0, #12]
 8005558:	e7da      	b.n	8005510 <vPortStoreTaskMPUSettings+0x18>
            ( ( uint32_t ) __SRAM_segment_start__ ) | /* Base address. */
 800555a:	4c31      	ldr	r4, [pc, #196]	; (8005620 <vPortStoreTaskMPUSettings+0x128>)
    uint32_t ulRegionSize, ulReturnValue = 4;
 800555c:	2204      	movs	r2, #4
            ( prvGetMPURegionSizeSetting( ( uint32_t ) __SRAM_segment_end__ - ( uint32_t ) __SRAM_segment_start__ ) ) |
 800555e:	4931      	ldr	r1, [pc, #196]	; (8005624 <vPortStoreTaskMPUSettings+0x12c>)
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 8005560:	2320      	movs	r3, #32
            ( portMPU_REGION_VALID ) |
 8005562:	f044 0514 	orr.w	r5, r4, #20
            ( prvGetMPURegionSizeSetting( ( uint32_t ) __SRAM_segment_end__ - ( uint32_t ) __SRAM_segment_start__ ) ) |
 8005566:	1b09      	subs	r1, r1, r4
        xMPUSettings->xRegion[ 0 ].ulRegionBaseAddress =
 8005568:	6005      	str	r5, [r0, #0]
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 800556a:	e002      	b.n	8005572 <vPortStoreTaskMPUSettings+0x7a>
            ulReturnValue++;
 800556c:	3201      	adds	r2, #1
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 800556e:	2a1f      	cmp	r2, #31
 8005570:	d054      	beq.n	800561c <vPortStoreTaskMPUSettings+0x124>
        if( ulActualSizeInBytes <= ulRegionSize )
 8005572:	4299      	cmp	r1, r3
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 8005574:	ea4f 0343 	mov.w	r3, r3, lsl #1
        if( ulActualSizeInBytes <= ulRegionSize )
 8005578:	d8f8      	bhi.n	800556c <vPortStoreTaskMPUSettings+0x74>
            ( prvGetMPURegionSizeSetting( ( uint32_t ) __SRAM_segment_end__ - ( uint32_t ) __SRAM_segment_start__ ) ) |
 800557a:	4b2b      	ldr	r3, [pc, #172]	; (8005628 <vPortStoreTaskMPUSettings+0x130>)
 800557c:	ea43 0242 	orr.w	r2, r3, r2, lsl #1
            ( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
 8005580:	4c2a      	ldr	r4, [pc, #168]	; (800562c <vPortStoreTaskMPUSettings+0x134>)
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 8005582:	2320      	movs	r3, #32
            prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
 8005584:	492a      	ldr	r1, [pc, #168]	; (8005630 <vPortStoreTaskMPUSettings+0x138>)
            ( portMPU_REGION_VALID ) |
 8005586:	f044 0515 	orr.w	r5, r4, #21
        xMPUSettings->xRegion[ 0 ].ulRegionAttribute =
 800558a:	6042      	str	r2, [r0, #4]
            prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
 800558c:	1b09      	subs	r1, r1, r4
    uint32_t ulRegionSize, ulReturnValue = 4;
 800558e:	2204      	movs	r2, #4
        xMPUSettings->xRegion[ 1 ].ulRegionBaseAddress =
 8005590:	6085      	str	r5, [r0, #8]
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 8005592:	e002      	b.n	800559a <vPortStoreTaskMPUSettings+0xa2>
            ulReturnValue++;
 8005594:	3201      	adds	r2, #1
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 8005596:	2a1f      	cmp	r2, #31
 8005598:	d03e      	beq.n	8005618 <vPortStoreTaskMPUSettings+0x120>
        if( ulActualSizeInBytes <= ulRegionSize )
 800559a:	4299      	cmp	r1, r3
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 800559c:	ea4f 0343 	mov.w	r3, r3, lsl #1
        if( ulActualSizeInBytes <= ulRegionSize )
 80055a0:	d8f8      	bhi.n	8005594 <vPortStoreTaskMPUSettings+0x9c>
            prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
 80055a2:	4b24      	ldr	r3, [pc, #144]	; (8005634 <vPortStoreTaskMPUSettings+0x13c>)
 80055a4:	ea43 0242 	orr.w	r2, r3, r2, lsl #1
            xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
 80055a8:	2416      	movs	r4, #22
            xMPUSettings->xRegion[ ul ].ulRegionAttribute = 0UL;
 80055aa:	2300      	movs	r3, #0
            xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
 80055ac:	2117      	movs	r1, #23
            xMPUSettings->xRegion[ ul ].ulRegionAttribute = 0UL;
 80055ae:	65c3      	str	r3, [r0, #92]	; 0x5c
            xMPUSettings->xRegion[ ul ].ulRegionBaseAddress = ( portSTACK_REGION + ul ) | portMPU_REGION_VALID;
 80055b0:	e9c0 2403 	strd	r2, r4, [r0, #12]
 80055b4:	2218      	movs	r2, #24
 80055b6:	2419      	movs	r4, #25
 80055b8:	e9c0 3207 	strd	r3, r2, [r0, #28]
 80055bc:	221a      	movs	r2, #26
 80055be:	e9c0 3105 	strd	r3, r1, [r0, #20]
 80055c2:	e9c0 320b 	strd	r3, r2, [r0, #44]	; 0x2c
 80055c6:	211b      	movs	r1, #27
 80055c8:	221c      	movs	r2, #28
 80055ca:	e9c0 3409 	strd	r3, r4, [r0, #36]	; 0x24
 80055ce:	e9c0 310d 	strd	r3, r1, [r0, #52]	; 0x34
 80055d2:	241d      	movs	r4, #29
 80055d4:	211e      	movs	r1, #30
 80055d6:	e9c0 320f 	strd	r3, r2, [r0, #60]	; 0x3c
 80055da:	221f      	movs	r2, #31
 80055dc:	e9c0 3411 	strd	r3, r4, [r0, #68]	; 0x44
 80055e0:	e9c0 3113 	strd	r3, r1, [r0, #76]	; 0x4c
 80055e4:	e9c0 3215 	strd	r3, r2, [r0, #84]	; 0x54
            }

            lIndex++;
        }
    }
}
 80055e8:	bd30      	pop	{r4, r5, pc}
 80055ea:	233e      	movs	r3, #62	; 0x3e
 80055ec:	e7ae      	b.n	800554c <vPortStoreTaskMPUSettings+0x54>
                ( portMPU_REGION_VALID ) |
 80055ee:	f042 0514 	orr.w	r5, r2, #20
                ( prvGetMPURegionSizeSetting( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) ) |
 80055f2:	009c      	lsls	r4, r3, #2
    uint32_t ulRegionSize, ulReturnValue = 4;
 80055f4:	2204      	movs	r2, #4
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 80055f6:	2320      	movs	r3, #32
            xMPUSettings->xRegion[ 0 ].ulRegionBaseAddress =
 80055f8:	6005      	str	r5, [r0, #0]
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 80055fa:	e002      	b.n	8005602 <vPortStoreTaskMPUSettings+0x10a>
            ulReturnValue++;
 80055fc:	3201      	adds	r2, #1
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 80055fe:	2a1f      	cmp	r2, #31
 8005600:	d008      	beq.n	8005614 <vPortStoreTaskMPUSettings+0x11c>
        if( ulActualSizeInBytes <= ulRegionSize )
 8005602:	429c      	cmp	r4, r3
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 8005604:	ea4f 0343 	mov.w	r3, r3, lsl #1
        if( ulActualSizeInBytes <= ulRegionSize )
 8005608:	d8f8      	bhi.n	80055fc <vPortStoreTaskMPUSettings+0x104>
                ( ( configTEX_S_C_B_SRAM & portMPU_RASR_TEX_S_C_B_MASK ) << portMPU_RASR_TEX_S_C_B_LOCATION ) |
 800560a:	4b07      	ldr	r3, [pc, #28]	; (8005628 <vPortStoreTaskMPUSettings+0x130>)
 800560c:	ea43 0242 	orr.w	r2, r3, r2, lsl #1
            xMPUSettings->xRegion[ 0 ].ulRegionAttribute =
 8005610:	6042      	str	r2, [r0, #4]
 8005612:	e775      	b.n	8005500 <vPortStoreTaskMPUSettings+0x8>
 8005614:	4a08      	ldr	r2, [pc, #32]	; (8005638 <vPortStoreTaskMPUSettings+0x140>)
 8005616:	e7fb      	b.n	8005610 <vPortStoreTaskMPUSettings+0x118>
 8005618:	4a08      	ldr	r2, [pc, #32]	; (800563c <vPortStoreTaskMPUSettings+0x144>)
 800561a:	e7c5      	b.n	80055a8 <vPortStoreTaskMPUSettings+0xb0>
 800561c:	4a06      	ldr	r2, [pc, #24]	; (8005638 <vPortStoreTaskMPUSettings+0x140>)
 800561e:	e7af      	b.n	8005580 <vPortStoreTaskMPUSettings+0x88>
 8005620:	24000000 	.word	0x24000000
 8005624:	24080000 	.word	0x24080000
 8005628:	03030001 	.word	0x03030001
 800562c:	24000000 	.word	0x24000000
 8005630:	24008000 	.word	0x24008000
 8005634:	01030001 	.word	0x01030001
 8005638:	0303003f 	.word	0x0303003f
 800563c:	0103003f 	.word	0x0103003f

08005640 <PendSV_Handler>:
    __asm volatile
 8005640:	f3ef 8009 	mrs	r0, PSP
 8005644:	f3bf 8f6f 	isb	sy
 8005648:	4b25      	ldr	r3, [pc, #148]	; (80056e0 <pxCurrentTCBConst>)
 800564a:	681a      	ldr	r2, [r3, #0]
 800564c:	f01e 0f10 	tst.w	lr, #16
 8005650:	bf08      	it	eq
 8005652:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8005656:	f3ef 8114 	mrs	r1, CONTROL
 800565a:	e920 4ff2 	stmdb	r0!, {r1, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800565e:	6010      	str	r0, [r2, #0]
 8005660:	e92d 0009 	stmdb	sp!, {r0, r3}
 8005664:	f04f 0050 	mov.w	r0, #80	; 0x50
 8005668:	f380 8811 	msr	BASEPRI, r0
 800566c:	f3bf 8f4f 	dsb	sy
 8005670:	f3bf 8f6f 	isb	sy
 8005674:	f7ff f8a8 	bl	80047c8 <vTaskSwitchContext>
 8005678:	f04f 0000 	mov.w	r0, #0
 800567c:	f380 8811 	msr	BASEPRI, r0
 8005680:	bc09      	pop	{r0, r3}
 8005682:	6819      	ldr	r1, [r3, #0]
 8005684:	6808      	ldr	r0, [r1, #0]
 8005686:	f101 0104 	add.w	r1, r1, #4
 800568a:	f3bf 8f5f 	dmb	sy
 800568e:	4a65      	ldr	r2, [pc, #404]	; (8005824 <xPortStartScheduler+0x100>)
 8005690:	6813      	ldr	r3, [r2, #0]
 8005692:	f023 0301 	bic.w	r3, r3, #1
 8005696:	6013      	str	r3, [r2, #0]
 8005698:	4a63      	ldr	r2, [pc, #396]	; (8005828 <xPortStartScheduler+0x104>)
 800569a:	e8b1 0ff0 	ldmia.w	r1!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800569e:	e882 0ff0 	stmia.w	r2, {r4, r5, r6, r7, r8, r9, sl, fp}
 80056a2:	e8b1 0ff0 	ldmia.w	r1!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80056a6:	e882 0ff0 	stmia.w	r2, {r4, r5, r6, r7, r8, r9, sl, fp}
 80056aa:	e8b1 0ff0 	ldmia.w	r1!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80056ae:	e882 0ff0 	stmia.w	r2, {r4, r5, r6, r7, r8, r9, sl, fp}
 80056b2:	4a5c      	ldr	r2, [pc, #368]	; (8005824 <xPortStartScheduler+0x100>)
 80056b4:	6813      	ldr	r3, [r2, #0]
 80056b6:	f043 0301 	orr.w	r3, r3, #1
 80056ba:	6013      	str	r3, [r2, #0]
 80056bc:	f3bf 8f4f 	dsb	sy
 80056c0:	e8b0 4ff8 	ldmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80056c4:	f383 8814 	msr	CONTROL, r3
 80056c8:	f01e 0f10 	tst.w	lr, #16
 80056cc:	bf08      	it	eq
 80056ce:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 80056d2:	f380 8809 	msr	PSP, r0
 80056d6:	4770      	bx	lr
 80056d8:	f3af 8000 	nop.w
 80056dc:	f3af 8000 	nop.w

080056e0 <pxCurrentTCBConst>:
 80056e0:	24000044 	.word	0x24000044

080056e4 <SysTick_Handler>:
{
 80056e4:	b510      	push	{r4, lr}
    __asm volatile
 80056e6:	f3ef 8411 	mrs	r4, BASEPRI
 80056ea:	f04f 0350 	mov.w	r3, #80	; 0x50
 80056ee:	f383 8811 	msr	BASEPRI, r3
 80056f2:	f3bf 8f6f 	isb	sy
 80056f6:	f3bf 8f4f 	dsb	sy
        if( xTaskIncrementTick() != pdFALSE )
 80056fa:	f7fe fb11 	bl	8003d20 <xTaskIncrementTick>
 80056fe:	b128      	cbz	r0, 800570c <SysTick_Handler+0x28>
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8005700:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8005704:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005708:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
    __asm volatile
 800570c:	f384 8811 	msr	BASEPRI, r4
}
 8005710:	bd10      	pop	{r4, pc}
 8005712:	bf00      	nop

08005714 <SVC_Handler>:
    __asm volatile
 8005714:	f01e 0f04 	tst.w	lr, #4
 8005718:	bf0c      	ite	eq
 800571a:	f3ef 8008 	mrseq	r0, MSP
 800571e:	f3ef 8009 	mrsne	r0, PSP
 8005722:	e68f      	b.n	8005444 <prvSVCHandler>

08005724 <xPortStartScheduler>:
            ulOriginalPriority = *pucFirstUserPriorityRegister;
 8005724:	4b7b      	ldr	r3, [pc, #492]	; (8005914 <xPortStartScheduler+0x1f0>)
            *pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8005726:	f04f 0cff 	mov.w	ip, #255	; 0xff
            ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 800572a:	487b      	ldr	r0, [pc, #492]	; (8005918 <xPortStartScheduler+0x1f4>)
            ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800572c:	497b      	ldr	r1, [pc, #492]	; (800591c <xPortStartScheduler+0x1f8>)
{
 800572e:	b530      	push	{r4, r5, lr}
            ulOriginalPriority = *pucFirstUserPriorityRegister;
 8005730:	781a      	ldrb	r2, [r3, #0]
{
 8005732:	b083      	sub	sp, #12
            ulOriginalPriority = *pucFirstUserPriorityRegister;
 8005734:	b2d2      	uxtb	r2, r2
 8005736:	9201      	str	r2, [sp, #4]
            ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8005738:	2207      	movs	r2, #7
            *pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 800573a:	f883 c000 	strb.w	ip, [r3]
            ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800573e:	781b      	ldrb	r3, [r3, #0]
            ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8005740:	6002      	str	r2, [r0, #0]
            ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8005742:	b2db      	uxtb	r3, r3
 8005744:	f88d 3003 	strb.w	r3, [sp, #3]
            ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8005748:	f89d 3003 	ldrb.w	r3, [sp, #3]
            while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800574c:	f89d 2003 	ldrb.w	r2, [sp, #3]
            ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8005750:	f003 0350 	and.w	r3, r3, #80	; 0x50
            while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8005754:	0612      	lsls	r2, r2, #24
            ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8005756:	700b      	strb	r3, [r1, #0]
            while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8005758:	d511      	bpl.n	800577e <xPortStartScheduler+0x5a>
 800575a:	2206      	movs	r2, #6
                ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 800575c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005760:	4611      	mov	r1, r2
            while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8005762:	3a01      	subs	r2, #1
                ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8005764:	005b      	lsls	r3, r3, #1
 8005766:	b2db      	uxtb	r3, r3
 8005768:	f88d 3003 	strb.w	r3, [sp, #3]
            while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800576c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005770:	061b      	lsls	r3, r3, #24
 8005772:	d4f3      	bmi.n	800575c <xPortStartScheduler+0x38>
                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8005774:	2903      	cmp	r1, #3
 8005776:	f1c1 0307 	rsb	r3, r1, #7
 800577a:	d009      	beq.n	8005790 <xPortStartScheduler+0x6c>
 800577c:	6001      	str	r1, [r0, #0]
    __asm volatile
 800577e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005782:	f383 8811 	msr	BASEPRI, r3
 8005786:	f3bf 8f6f 	isb	sy
 800578a:	f3bf 8f4f 	dsb	sy
 800578e:	e7fe      	b.n	800578e <xPortStartScheduler+0x6a>
            *pucFirstUserPriorityRegister = ulOriginalPriority;
 8005790:	9901      	ldr	r1, [sp, #4]
            ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8005792:	f44f 7440 	mov.w	r4, #768	; 0x300
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
 8005796:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
            ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 800579a:	6004      	str	r4, [r0, #0]
            *pucFirstUserPriorityRegister = ulOriginalPriority;
 800579c:	b2c9      	uxtb	r1, r1
 800579e:	485d      	ldr	r0, [pc, #372]	; (8005914 <xPortStartScheduler+0x1f0>)
 80057a0:	7001      	strb	r1, [r0, #0]
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
 80057a2:	f8d2 1d20 	ldr.w	r1, [r2, #3360]	; 0xd20
 80057a6:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80057aa:	f8c2 1d20 	str.w	r1, [r2, #3360]	; 0xd20
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
 80057ae:	f8d2 1d20 	ldr.w	r1, [r2, #3360]	; 0xd20
 80057b2:	f041 4170 	orr.w	r1, r1, #4026531840	; 0xf0000000
 80057b6:	f8c2 1d20 	str.w	r1, [r2, #3360]	; 0xd20
    configASSERT( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE );
 80057ba:	f8d2 1d90 	ldr.w	r1, [r2, #3472]	; 0xd90
 80057be:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 80057c2:	d008      	beq.n	80057d6 <xPortStartScheduler+0xb2>
 80057c4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80057c8:	f383 8811 	msr	BASEPRI, r3
 80057cc:	f3bf 8f6f 	isb	sy
 80057d0:	f3bf 8f4f 	dsb	sy
 80057d4:	e7fe      	b.n	80057d4 <xPortStartScheduler+0xb0>
    if( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )
 80057d6:	f8d2 1d90 	ldr.w	r1, [r2, #3472]	; 0xd90
 80057da:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 80057de:	d028      	beq.n	8005832 <xPortStartScheduler+0x10e>
    vPortSetupTimerInterrupt();
 80057e0:	f004 fa3a 	bl	8009c58 <vPortSetupTimerInterrupt>
    uxCriticalNesting = 0;
 80057e4:	2400      	movs	r4, #0
 80057e6:	4b4e      	ldr	r3, [pc, #312]	; (8005920 <xPortStartScheduler+0x1fc>)
 80057e8:	601c      	str	r4, [r3, #0]
    vPortEnableVFP();
 80057ea:	f004 f9fb 	bl	8009be4 <vPortEnableVFP>
    *( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 80057ee:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
 80057f2:	f8d2 3f34 	ldr.w	r3, [r2, #3892]	; 0xf34
 80057f6:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 80057fa:	f8c2 3f34 	str.w	r3, [r2, #3892]	; 0xf34
    __asm volatile (
 80057fe:	4808      	ldr	r0, [pc, #32]	; (8005820 <xPortStartScheduler+0xfc>)
 8005800:	6800      	ldr	r0, [r0, #0]
 8005802:	6800      	ldr	r0, [r0, #0]
 8005804:	f380 8808 	msr	MSP, r0
 8005808:	f04f 0000 	mov.w	r0, #0
 800580c:	f380 8814 	msr	CONTROL, r0
 8005810:	b662      	cpsie	i
 8005812:	b661      	cpsie	f
 8005814:	f3bf 8f4f 	dsb	sy
 8005818:	f3bf 8f6f 	isb	sy
 800581c:	df00      	svc	0
 800581e:	bf00      	nop
 8005820:	e000ed08 	.word	0xe000ed08
 8005824:	e000ed94 	.word	0xe000ed94
 8005828:	e000ed9c 	.word	0xe000ed9c
}
 800582c:	4620      	mov	r0, r4
 800582e:	b003      	add	sp, #12
 8005830:	bd30      	pop	{r4, r5, pc}
        portMPU_REGION_BASE_ADDRESS_REG = ( ( uint32_t ) __FLASH_segment_start__ ) | /* Base address. */
 8005832:	4d3c      	ldr	r5, [pc, #240]	; (8005924 <xPortStartScheduler+0x200>)
    uint32_t ulRegionSize, ulReturnValue = 4;
 8005834:	4619      	mov	r1, r3
                                       ( prvGetMPURegionSizeSetting( ( uint32_t ) __FLASH_segment_end__ - ( uint32_t ) __FLASH_segment_start__ ) ) |
 8005836:	483c      	ldr	r0, [pc, #240]	; (8005928 <xPortStartScheduler+0x204>)
                                          ( portMPU_REGION_VALID ) |
 8005838:	f045 0410 	orr.w	r4, r5, #16
                                       ( prvGetMPURegionSizeSetting( ( uint32_t ) __FLASH_segment_end__ - ( uint32_t ) __FLASH_segment_start__ ) ) |
 800583c:	1b40      	subs	r0, r0, r5
        portMPU_REGION_BASE_ADDRESS_REG = ( ( uint32_t ) __FLASH_segment_start__ ) | /* Base address. */
 800583e:	f8c2 4d9c 	str.w	r4, [r2, #3484]	; 0xd9c
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 8005842:	2220      	movs	r2, #32
 8005844:	e002      	b.n	800584c <xPortStartScheduler+0x128>
            ulReturnValue++;
 8005846:	3101      	adds	r1, #1
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 8005848:	291f      	cmp	r1, #31
 800584a:	d05e      	beq.n	800590a <xPortStartScheduler+0x1e6>
        if( ulActualSizeInBytes <= ulRegionSize )
 800584c:	4290      	cmp	r0, r2
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 800584e:	ea4f 0242 	mov.w	r2, r2, lsl #1
        if( ulActualSizeInBytes <= ulRegionSize )
 8005852:	d8f8      	bhi.n	8005846 <xPortStartScheduler+0x122>
                                       ( prvGetMPURegionSizeSetting( ( uint32_t ) __FLASH_segment_end__ - ( uint32_t ) __FLASH_segment_start__ ) ) |
 8005854:	4a35      	ldr	r2, [pc, #212]	; (800592c <xPortStartScheduler+0x208>)
 8005856:	ea42 0141 	orr.w	r1, r2, r1, lsl #1
        portMPU_REGION_BASE_ADDRESS_REG = ( ( uint32_t ) __privileged_functions_start__ ) | /* Base address. */
 800585a:	4a35      	ldr	r2, [pc, #212]	; (8005930 <xPortStartScheduler+0x20c>)
        portMPU_REGION_ATTRIBUTE_REG = ( portMPU_REGION_READ_ONLY ) |
 800585c:	f04f 2ce0 	mov.w	ip, #3758153728	; 0xe000e000
                                       ( prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_functions_end__ - ( uint32_t ) __privileged_functions_start__ ) ) |
 8005860:	4834      	ldr	r0, [pc, #208]	; (8005934 <xPortStartScheduler+0x210>)
        portMPU_REGION_ATTRIBUTE_REG = ( portMPU_REGION_READ_ONLY ) |
 8005862:	f8cc 1da0 	str.w	r1, [ip, #3488]	; 0xda0
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 8005866:	2120      	movs	r1, #32
                                       ( prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_functions_end__ - ( uint32_t ) __privileged_functions_start__ ) ) |
 8005868:	1a80      	subs	r0, r0, r2
                                          ( portMPU_REGION_VALID ) |
 800586a:	f042 0211 	orr.w	r2, r2, #17
        portMPU_REGION_BASE_ADDRESS_REG = ( ( uint32_t ) __privileged_functions_start__ ) | /* Base address. */
 800586e:	f8cc 2d9c 	str.w	r2, [ip, #3484]	; 0xd9c
    uint32_t ulRegionSize, ulReturnValue = 4;
 8005872:	2204      	movs	r2, #4
 8005874:	e002      	b.n	800587c <xPortStartScheduler+0x158>
            ulReturnValue++;
 8005876:	3201      	adds	r2, #1
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 8005878:	2a1f      	cmp	r2, #31
 800587a:	d048      	beq.n	800590e <xPortStartScheduler+0x1ea>
        if( ulActualSizeInBytes <= ulRegionSize )
 800587c:	4288      	cmp	r0, r1
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 800587e:	ea4f 0141 	mov.w	r1, r1, lsl #1
        if( ulActualSizeInBytes <= ulRegionSize )
 8005882:	d8f8      	bhi.n	8005876 <xPortStartScheduler+0x152>
                                       ( prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_functions_end__ - ( uint32_t ) __privileged_functions_start__ ) ) |
 8005884:	492c      	ldr	r1, [pc, #176]	; (8005938 <xPortStartScheduler+0x214>)
 8005886:	ea41 0142 	orr.w	r1, r1, r2, lsl #1
        portMPU_REGION_BASE_ADDRESS_REG = ( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
 800588a:	4a2c      	ldr	r2, [pc, #176]	; (800593c <xPortStartScheduler+0x218>)
        portMPU_REGION_ATTRIBUTE_REG = ( portMPU_REGION_PRIVILEGED_READ_ONLY ) |
 800588c:	f04f 2ce0 	mov.w	ip, #3758153728	; 0xe000e000
                                       prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
 8005890:	482b      	ldr	r0, [pc, #172]	; (8005940 <xPortStartScheduler+0x21c>)
        portMPU_REGION_ATTRIBUTE_REG = ( portMPU_REGION_PRIVILEGED_READ_ONLY ) |
 8005892:	f8cc 1da0 	str.w	r1, [ip, #3488]	; 0xda0
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 8005896:	2120      	movs	r1, #32
                                       prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
 8005898:	1a80      	subs	r0, r0, r2
                                          ( portMPU_REGION_VALID ) |
 800589a:	f042 0212 	orr.w	r2, r2, #18
        portMPU_REGION_BASE_ADDRESS_REG = ( ( uint32_t ) __privileged_data_start__ ) | /* Base address. */
 800589e:	f8cc 2d9c 	str.w	r2, [ip, #3484]	; 0xd9c
    uint32_t ulRegionSize, ulReturnValue = 4;
 80058a2:	2204      	movs	r2, #4
 80058a4:	e002      	b.n	80058ac <xPortStartScheduler+0x188>
            ulReturnValue++;
 80058a6:	3201      	adds	r2, #1
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 80058a8:	2a1f      	cmp	r2, #31
 80058aa:	d02c      	beq.n	8005906 <xPortStartScheduler+0x1e2>
        if( ulActualSizeInBytes <= ulRegionSize )
 80058ac:	4288      	cmp	r0, r1
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 80058ae:	ea4f 0141 	mov.w	r1, r1, lsl #1
        if( ulActualSizeInBytes <= ulRegionSize )
 80058b2:	d8f8      	bhi.n	80058a6 <xPortStartScheduler+0x182>
                                       prvGetMPURegionSizeSetting( ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__ ) |
 80058b4:	4923      	ldr	r1, [pc, #140]	; (8005944 <xPortStartScheduler+0x220>)
 80058b6:	ea41 0142 	orr.w	r1, r1, r2, lsl #1
        portMPU_REGION_ATTRIBUTE_REG = ( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
 80058ba:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
        portMPU_REGION_BASE_ADDRESS_REG = ( portPERIPHERALS_START_ADDRESS ) |
 80058be:	4c22      	ldr	r4, [pc, #136]	; (8005948 <xPortStartScheduler+0x224>)
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 80058c0:	2220      	movs	r2, #32
        portMPU_REGION_ATTRIBUTE_REG = ( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
 80058c2:	f8c0 1da0 	str.w	r1, [r0, #3488]	; 0xda0
        if( ulActualSizeInBytes <= ulRegionSize )
 80058c6:	f06f 4160 	mvn.w	r1, #3758096384	; 0xe0000000
        portMPU_REGION_BASE_ADDRESS_REG = ( portPERIPHERALS_START_ADDRESS ) |
 80058ca:	f8c0 4d9c 	str.w	r4, [r0, #3484]	; 0xd9c
            ulReturnValue++;
 80058ce:	3301      	adds	r3, #1
    for( ulRegionSize = 32UL; ulReturnValue < 31UL; ( ulRegionSize <<= 1UL ) )
 80058d0:	0052      	lsls	r2, r2, #1
 80058d2:	2b1f      	cmp	r3, #31
 80058d4:	d015      	beq.n	8005902 <xPortStartScheduler+0x1de>
        if( ulActualSizeInBytes <= ulRegionSize )
 80058d6:	428a      	cmp	r2, r1
 80058d8:	d3f9      	bcc.n	80058ce <xPortStartScheduler+0x1aa>
                                       ( prvGetMPURegionSizeSetting( portPERIPHERALS_END_ADDRESS - portPERIPHERALS_START_ADDRESS ) ) |
 80058da:	4a1c      	ldr	r2, [pc, #112]	; (800594c <xPortStartScheduler+0x228>)
 80058dc:	ea42 0243 	orr.w	r2, r2, r3, lsl #1
        portMPU_REGION_ATTRIBUTE_REG = ( portMPU_REGION_READ_WRITE | portMPU_REGION_EXECUTE_NEVER ) |
 80058e0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80058e4:	f8c3 2da0 	str.w	r2, [r3, #3488]	; 0xda0
        portNVIC_SYS_CTRL_STATE_REG |= portNVIC_MEM_FAULT_ENABLE;
 80058e8:	f8d3 2d24 	ldr.w	r2, [r3, #3364]	; 0xd24
 80058ec:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80058f0:	f8c3 2d24 	str.w	r2, [r3, #3364]	; 0xd24
        portMPU_CTRL_REG |= ( portMPU_ENABLE | portMPU_BACKGROUND_ENABLE );
 80058f4:	f8d3 2d94 	ldr.w	r2, [r3, #3476]	; 0xd94
 80058f8:	f042 0205 	orr.w	r2, r2, #5
 80058fc:	f8c3 2d94 	str.w	r2, [r3, #3476]	; 0xd94
 8005900:	e76e      	b.n	80057e0 <xPortStartScheduler+0xbc>
 8005902:	4a13      	ldr	r2, [pc, #76]	; (8005950 <xPortStartScheduler+0x22c>)
 8005904:	e7ec      	b.n	80058e0 <xPortStartScheduler+0x1bc>
 8005906:	4913      	ldr	r1, [pc, #76]	; (8005954 <xPortStartScheduler+0x230>)
 8005908:	e7d7      	b.n	80058ba <xPortStartScheduler+0x196>
 800590a:	4913      	ldr	r1, [pc, #76]	; (8005958 <xPortStartScheduler+0x234>)
 800590c:	e7a5      	b.n	800585a <xPortStartScheduler+0x136>
 800590e:	4913      	ldr	r1, [pc, #76]	; (800595c <xPortStartScheduler+0x238>)
 8005910:	e7bb      	b.n	800588a <xPortStartScheduler+0x166>
 8005912:	bf00      	nop
 8005914:	e000e400 	.word	0xe000e400
 8005918:	24010020 	.word	0x24010020
 800591c:	2401001d 	.word	0x2401001d
 8005920:	24008014 	.word	0x24008014
 8005924:	08000000 	.word	0x08000000
 8005928:	08100000 	.word	0x08100000
 800592c:	06070001 	.word	0x06070001
 8005930:	08000000 	.word	0x08000000
 8005934:	08008000 	.word	0x08008000
 8005938:	05070001 	.word	0x05070001
 800593c:	24000000 	.word	0x24000000
 8005940:	24008000 	.word	0x24008000
 8005944:	01030001 	.word	0x01030001
 8005948:	40000013 	.word	0x40000013
 800594c:	13000001 	.word	0x13000001
 8005950:	1300003f 	.word	0x1300003f
 8005954:	0103003f 	.word	0x0103003f
 8005958:	0607003f 	.word	0x0607003f
 800595c:	0507003f 	.word	0x0507003f

08005960 <pvPortMalloc>:
PRIVILEGED_DATA static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
 8005960:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

    vTaskSuspendAll();
    {
        /* If this is the first call to malloc then the heap will require
         * initialisation to setup the list of free blocks. */
        if( pxEnd == NULL )
 8005964:	4d54      	ldr	r5, [pc, #336]	; (8005ab8 <pvPortMalloc+0x158>)
{
 8005966:	4606      	mov	r6, r0
    vTaskSuspendAll();
 8005968:	f7fd fdfa 	bl	8003560 <vTaskSuspendAll>
        if( pxEnd == NULL )
 800596c:	68ab      	ldr	r3, [r5, #8]
 800596e:	2b00      	cmp	r3, #0
 8005970:	d03d      	beq.n	80059ee <pvPortMalloc+0x8e>

        /* Check the requested block size is not so large that the top bit is
         * set.  The top bit of the block size member of the BlockLink_t structure
         * is used to determine who owns the block - the application or the
         * kernel, so it must be free. */
        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8005972:	68ec      	ldr	r4, [r5, #12]
 8005974:	4226      	tst	r6, r4
 8005976:	d132      	bne.n	80059de <pvPortMalloc+0x7e>
        {
            /* The wanted size must be increased so it can contain a BlockLink_t
             * structure in addition to the requested amount of bytes. */
            if( ( xWantedSize > 0 ) &&
 8005978:	1e72      	subs	r2, r6, #1
 800597a:	320a      	adds	r2, #10
 800597c:	d82f      	bhi.n	80059de <pvPortMalloc+0x7e>
                ( ( xWantedSize + xHeapStructSize ) >  xWantedSize ) ) /* Overflow check */
            {
                xWantedSize += xHeapStructSize;

                /* Ensure that blocks are always aligned. */
                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800597e:	0772      	lsls	r2, r6, #29
                xWantedSize += xHeapStructSize;
 8005980:	f106 0c08 	add.w	ip, r6, #8
                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8005984:	d126      	bne.n	80059d4 <pvPortMalloc+0x74>
            else
            {
                xWantedSize = 0;
            }

            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8005986:	696f      	ldr	r7, [r5, #20]
 8005988:	4567      	cmp	r7, ip
 800598a:	d328      	bcc.n	80059de <pvPortMalloc+0x7e>
            {
                /* Traverse the list from the start (lowest address) block until
                 * one of adequate size is found. */
                pxPreviousBlock = &xStart;
                pxBlock = xStart.pxNextFreeBlock;
 800598c:	682a      	ldr	r2, [r5, #0]
                pxPreviousBlock = &xStart;
 800598e:	f8df e128 	ldr.w	lr, [pc, #296]	; 8005ab8 <pvPortMalloc+0x158>

                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8005992:	e003      	b.n	800599c <pvPortMalloc+0x3c>
 8005994:	6810      	ldr	r0, [r2, #0]
 8005996:	b120      	cbz	r0, 80059a2 <pvPortMalloc+0x42>
 8005998:	4696      	mov	lr, r2
 800599a:	4602      	mov	r2, r0
 800599c:	6851      	ldr	r1, [r2, #4]
 800599e:	4561      	cmp	r1, ip
 80059a0:	d3f8      	bcc.n	8005994 <pvPortMalloc+0x34>
                    pxBlock = pxBlock->pxNextFreeBlock;
                }

                /* If the end marker was reached then a block of adequate size
                 * was not found. */
                if( pxBlock != pxEnd )
 80059a2:	429a      	cmp	r2, r3
 80059a4:	d01b      	beq.n	80059de <pvPortMalloc+0x7e>
                {
                    /* Return the memory space pointed to - jumping over the
                     * BlockLink_t structure at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80059a6:	4616      	mov	r6, r2
                     * of the list of free blocks. */
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;

                    /* If the block is larger than required it can be split into
                     * two. */
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80059a8:	eba1 000c 	sub.w	r0, r1, ip
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80059ac:	f856 8b08 	ldr.w	r8, [r6], #8
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80059b0:	2810      	cmp	r0, #16
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80059b2:	f8ce 8000 	str.w	r8, [lr]
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80059b6:	d956      	bls.n	8005a66 <pvPortMalloc+0x106>
                    {
                        /* This block is to be split into two.  Create a new
                         * block following the number of bytes requested. The void
                         * cast is used to prevent byte alignment warnings from the
                         * compiler. */
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 80059b8:	eb02 010c 	add.w	r1, r2, ip
                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 80059bc:	f011 0f07 	tst.w	r1, #7
 80059c0:	d037      	beq.n	8005a32 <pvPortMalloc+0xd2>
 80059c2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80059c6:	f383 8811 	msr	BASEPRI, r3
 80059ca:	f3bf 8f6f 	isb	sy
 80059ce:	f3bf 8f4f 	dsb	sy
 80059d2:	e7fe      	b.n	80059d2 <pvPortMalloc+0x72>
                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) )
 80059d4:	f02c 0207 	bic.w	r2, ip, #7
 80059d8:	3208      	adds	r2, #8
 80059da:	4562      	cmp	r2, ip
 80059dc:	d827      	bhi.n	8005a2e <pvPortMalloc+0xce>
    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )
        {
            if( pvReturn == NULL )
            {
                extern void vApplicationMallocFailedHook( void );
                vApplicationMallocFailedHook();
 80059de:	2600      	movs	r6, #0
    ( void ) xTaskResumeAll();
 80059e0:	f7fe fa5c 	bl	8003e9c <xTaskResumeAll>
                vApplicationMallocFailedHook();
 80059e4:	f004 f9c0 	bl	8009d68 <vApplicationMallocFailedHook>
        }
    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */

    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
    return pvReturn;
}
 80059e8:	4630      	mov	r0, r6
 80059ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    uint8_t * pucAlignedHeap;
    size_t uxAddress;
    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

    /* Ensure the heap starts on a correctly aligned boundary. */
    uxAddress = ( size_t ) ucHeap;
 80059ee:	4b33      	ldr	r3, [pc, #204]	; (8005abc <pvPortMalloc+0x15c>)

    if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 80059f0:	0759      	lsls	r1, r3, #29
 80059f2:	d115      	bne.n	8005a20 <pvPortMalloc+0xc0>
    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    xStart.xBlockSize = ( size_t ) 0;

    /* pxEnd is used to mark the end of the list of free blocks and is inserted
     * at the end of the heap space. */
    uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 80059f4:	461a      	mov	r2, r3
 80059f6:	f503 5370 	add.w	r3, r3, #15360	; 0x3c00
 80059fa:	4610      	mov	r0, r2
    uxAddress -= xHeapStructSize;
 80059fc:	3b08      	subs	r3, #8
    xStart.xBlockSize = ( size_t ) 0;
 80059fe:	2100      	movs	r1, #0
    /* Only one block exists - and it covers the entire usable heap space. */
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;

    /* Work out the position of the top bit in a size_t variable. */
    xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8005a00:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8005a04:	6028      	str	r0, [r5, #0]
    uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8005a06:	f023 0307 	bic.w	r3, r3, #7
    xStart.xBlockSize = ( size_t ) 0;
 8005a0a:	6069      	str	r1, [r5, #4]
    xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8005a0c:	60ec      	str	r4, [r5, #12]
    pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8005a0e:	1a9a      	subs	r2, r3, r2
    pxEnd = ( void * ) uxAddress;
 8005a10:	60ab      	str	r3, [r5, #8]
    pxEnd->pxNextFreeBlock = NULL;
 8005a12:	e9c3 1100 	strd	r1, r1, [r3]
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8005a16:	e9c5 2204 	strd	r2, r2, [r5, #16]
    pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8005a1a:	e9c0 3200 	strd	r3, r2, [r0]
}
 8005a1e:	e7a9      	b.n	8005974 <pvPortMalloc+0x14>
        uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8005a20:	1dda      	adds	r2, r3, #7
        uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8005a22:	f503 5370 	add.w	r3, r3, #15360	; 0x3c00
 8005a26:	f022 0207 	bic.w	r2, r2, #7
    pucAlignedHeap = ( uint8_t * ) uxAddress;
 8005a2a:	4610      	mov	r0, r2
 8005a2c:	e7e6      	b.n	80059fc <pvPortMalloc+0x9c>
 8005a2e:	4694      	mov	ip, r2
 8005a30:	e7a9      	b.n	8005986 <pvPortMalloc+0x26>
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8005a32:	6048      	str	r0, [r1, #4]
    BlockLink_t * pxIterator;
    uint8_t * puc;

    /* Iterate through the list until a block is found that has a higher address
     * than the block being inserted. */
    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8005a34:	4820      	ldr	r0, [pc, #128]	; (8005ab8 <pvPortMalloc+0x158>)
                        pxBlock->xBlockSize = xWantedSize;
 8005a36:	f8c2 c004 	str.w	ip, [r2, #4]
    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8005a3a:	4684      	mov	ip, r0
 8005a3c:	6800      	ldr	r0, [r0, #0]
 8005a3e:	4281      	cmp	r1, r0
 8005a40:	d8fb      	bhi.n	8005a3a <pvPortMalloc+0xda>

    /* Do the block being inserted, and the block it is being inserted after
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxIterator;

    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8005a42:	f8dc e004 	ldr.w	lr, [ip, #4]
 8005a46:	eb0c 080e 	add.w	r8, ip, lr
 8005a4a:	4541      	cmp	r1, r8
 8005a4c:	d026      	beq.n	8005a9c <pvPortMalloc+0x13c>

    /* Do the block being inserted, and the block it is being inserted before
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxBlockToInsert;

    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8005a4e:	f8d1 e004 	ldr.w	lr, [r1, #4]
 8005a52:	eb01 080e 	add.w	r8, r1, lr
 8005a56:	4540      	cmp	r0, r8
 8005a58:	d026      	beq.n	8005aa8 <pvPortMalloc+0x148>
            pxBlockToInsert->pxNextFreeBlock = pxEnd;
        }
    }
    else
    {
        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8005a5a:	6008      	str	r0, [r1, #0]

    /* If the block being inserted plugged a gab, so was merged with the block
     * before and the block after, then it's pxNextFreeBlock pointer will have
     * already been set, and should not be set here as that would make it point
     * to itself. */
    if( pxIterator != pxBlockToInsert )
 8005a5c:	458c      	cmp	ip, r1
    {
        pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8005a5e:	bf18      	it	ne
 8005a60:	f8cc 1000 	strne.w	r1, [ip]
                    xFreeBytesRemaining -= pxBlock->xBlockSize;
 8005a64:	6851      	ldr	r1, [r2, #4]
 8005a66:	1a7f      	subs	r7, r7, r1
                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8005a68:	692b      	ldr	r3, [r5, #16]
 8005a6a:	429f      	cmp	r7, r3
                    xFreeBytesRemaining -= pxBlock->xBlockSize;
 8005a6c:	616f      	str	r7, [r5, #20]
                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8005a6e:	d313      	bcc.n	8005a98 <pvPortMalloc+0x138>
                    xNumberOfSuccessfulAllocations++;
 8005a70:	69ab      	ldr	r3, [r5, #24]
                    pxBlock->xBlockSize |= xBlockAllocatedBit;
 8005a72:	4321      	orrs	r1, r4
                    pxBlock->pxNextFreeBlock = NULL;
 8005a74:	2000      	movs	r0, #0
                    xNumberOfSuccessfulAllocations++;
 8005a76:	3301      	adds	r3, #1
                    pxBlock->xBlockSize |= xBlockAllocatedBit;
 8005a78:	6051      	str	r1, [r2, #4]
                    pxBlock->pxNextFreeBlock = NULL;
 8005a7a:	6010      	str	r0, [r2, #0]
                    xNumberOfSuccessfulAllocations++;
 8005a7c:	61ab      	str	r3, [r5, #24]
    ( void ) xTaskResumeAll();
 8005a7e:	f7fe fa0d 	bl	8003e9c <xTaskResumeAll>
    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8005a82:	0773      	lsls	r3, r6, #29
 8005a84:	d0b0      	beq.n	80059e8 <pvPortMalloc+0x88>
 8005a86:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005a8a:	f383 8811 	msr	BASEPRI, r3
 8005a8e:	f3bf 8f6f 	isb	sy
 8005a92:	f3bf 8f4f 	dsb	sy
 8005a96:	e7fe      	b.n	8005a96 <pvPortMalloc+0x136>
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8005a98:	612f      	str	r7, [r5, #16]
 8005a9a:	e7e9      	b.n	8005a70 <pvPortMalloc+0x110>
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8005a9c:	6849      	ldr	r1, [r1, #4]
 8005a9e:	448e      	add	lr, r1
 8005aa0:	4661      	mov	r1, ip
 8005aa2:	f8cc e004 	str.w	lr, [ip, #4]
        pxBlockToInsert = pxIterator;
 8005aa6:	e7d4      	b.n	8005a52 <pvPortMalloc+0xf2>
        if( pxIterator->pxNextFreeBlock != pxEnd )
 8005aa8:	4298      	cmp	r0, r3
 8005aaa:	d0d6      	beq.n	8005a5a <pvPortMalloc+0xfa>
            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8005aac:	6843      	ldr	r3, [r0, #4]
 8005aae:	4473      	add	r3, lr
 8005ab0:	604b      	str	r3, [r1, #4]
            pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8005ab2:	6803      	ldr	r3, [r0, #0]
 8005ab4:	600b      	str	r3, [r1, #0]
 8005ab6:	e7d1      	b.n	8005a5c <pvPortMalloc+0xfc>
 8005ab8:	24000668 	.word	0x24000668
 8005abc:	24000688 	.word	0x24000688

08005ac0 <vPortFree>:
    if( pv != NULL )
 8005ac0:	b1e0      	cbz	r0, 8005afc <vPortFree+0x3c>
        configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8005ac2:	f850 3c04 	ldr.w	r3, [r0, #-4]
{
 8005ac6:	b530      	push	{r4, r5, lr}
        configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8005ac8:	4c28      	ldr	r4, [pc, #160]	; (8005b6c <vPortFree+0xac>)
{
 8005aca:	b083      	sub	sp, #12
        configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8005acc:	68e2      	ldr	r2, [r4, #12]
 8005ace:	4213      	tst	r3, r2
 8005ad0:	d00b      	beq.n	8005aea <vPortFree+0x2a>
        configASSERT( pxLink->pxNextFreeBlock == NULL );
 8005ad2:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8005ad6:	b191      	cbz	r1, 8005afe <vPortFree+0x3e>
 8005ad8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005adc:	f383 8811 	msr	BASEPRI, r3
 8005ae0:	f3bf 8f6f 	isb	sy
 8005ae4:	f3bf 8f4f 	dsb	sy
 8005ae8:	e7fe      	b.n	8005ae8 <vPortFree+0x28>
 8005aea:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005aee:	f383 8811 	msr	BASEPRI, r3
 8005af2:	f3bf 8f6f 	isb	sy
 8005af6:	f3bf 8f4f 	dsb	sy
        configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8005afa:	e7fe      	b.n	8005afa <vPortFree+0x3a>
 8005afc:	4770      	bx	lr
                pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8005afe:	ea23 0302 	bic.w	r3, r3, r2
        puc -= xHeapStructSize;
 8005b02:	f1a0 0508 	sub.w	r5, r0, #8
                pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8005b06:	9001      	str	r0, [sp, #4]
 8005b08:	f840 3c04 	str.w	r3, [r0, #-4]
                vTaskSuspendAll();
 8005b0c:	f7fd fd28 	bl	8003560 <vTaskSuspendAll>
                    xFreeBytesRemaining += pxLink->xBlockSize;
 8005b10:	9801      	ldr	r0, [sp, #4]
 8005b12:	6962      	ldr	r2, [r4, #20]
    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8005b14:	4623      	mov	r3, r4
                    xFreeBytesRemaining += pxLink->xBlockSize;
 8005b16:	f850 1c04 	ldr.w	r1, [r0, #-4]
 8005b1a:	440a      	add	r2, r1
 8005b1c:	6162      	str	r2, [r4, #20]
    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8005b1e:	461a      	mov	r2, r3
 8005b20:	681b      	ldr	r3, [r3, #0]
 8005b22:	429d      	cmp	r5, r3
 8005b24:	d8fb      	bhi.n	8005b1e <vPortFree+0x5e>
    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8005b26:	6850      	ldr	r0, [r2, #4]
 8005b28:	eb02 0c00 	add.w	ip, r2, r0
 8005b2c:	4565      	cmp	r5, ip
 8005b2e:	d018      	beq.n	8005b62 <vPortFree+0xa2>
    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8005b30:	1868      	adds	r0, r5, r1
 8005b32:	4283      	cmp	r3, r0
 8005b34:	d00c      	beq.n	8005b50 <vPortFree+0x90>
        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8005b36:	602b      	str	r3, [r5, #0]
                    xNumberOfSuccessfulFrees++;
 8005b38:	69e3      	ldr	r3, [r4, #28]
    if( pxIterator != pxBlockToInsert )
 8005b3a:	42aa      	cmp	r2, r5
                    xNumberOfSuccessfulFrees++;
 8005b3c:	f103 0301 	add.w	r3, r3, #1
        pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8005b40:	bf18      	it	ne
 8005b42:	6015      	strne	r5, [r2, #0]
                    xNumberOfSuccessfulFrees++;
 8005b44:	61e3      	str	r3, [r4, #28]
}
 8005b46:	b003      	add	sp, #12
 8005b48:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
                ( void ) xTaskResumeAll();
 8005b4c:	f7fe b9a6 	b.w	8003e9c <xTaskResumeAll>
        if( pxIterator->pxNextFreeBlock != pxEnd )
 8005b50:	68a0      	ldr	r0, [r4, #8]
 8005b52:	4283      	cmp	r3, r0
 8005b54:	d0ef      	beq.n	8005b36 <vPortFree+0x76>
            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8005b56:	6858      	ldr	r0, [r3, #4]
            pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8005b58:	681b      	ldr	r3, [r3, #0]
            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8005b5a:	4401      	add	r1, r0
            pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8005b5c:	e9c5 3100 	strd	r3, r1, [r5]
 8005b60:	e7ea      	b.n	8005b38 <vPortFree+0x78>
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8005b62:	4401      	add	r1, r0
 8005b64:	4615      	mov	r5, r2
 8005b66:	6051      	str	r1, [r2, #4]
        pxBlockToInsert = pxIterator;
 8005b68:	e7e2      	b.n	8005b30 <vPortFree+0x70>
 8005b6a:	bf00      	nop
 8005b6c:	24000668 	.word	0x24000668

08005b70 <vPortInitialiseBlocks>:
}
 8005b70:	4770      	bx	lr
 8005b72:	bf00      	nop

08005b74 <xPortGetFreeHeapSize>:
    return xFreeBytesRemaining;
 8005b74:	4b01      	ldr	r3, [pc, #4]	; (8005b7c <xPortGetFreeHeapSize+0x8>)
}
 8005b76:	6958      	ldr	r0, [r3, #20]
 8005b78:	4770      	bx	lr
 8005b7a:	bf00      	nop
 8005b7c:	24000668 	.word	0x24000668

08005b80 <xPortGetMinimumEverFreeHeapSize>:
    return xMinimumEverFreeBytesRemaining;
 8005b80:	4b01      	ldr	r3, [pc, #4]	; (8005b88 <xPortGetMinimumEverFreeHeapSize+0x8>)
}
 8005b82:	6918      	ldr	r0, [r3, #16]
 8005b84:	4770      	bx	lr
 8005b86:	bf00      	nop
 8005b88:	24000668 	.word	0x24000668
 8005b8c:	addeadde 	.word	0xaddeadde
 8005b90:	addeadde 	.word	0xaddeadde
 8005b94:	addeadde 	.word	0xaddeadde
 8005b98:	addeadde 	.word	0xaddeadde
 8005b9c:	addeadde 	.word	0xaddeadde
 8005ba0:	addeadde 	.word	0xaddeadde
 8005ba4:	addeadde 	.word	0xaddeadde
 8005ba8:	addeadde 	.word	0xaddeadde
 8005bac:	addeadde 	.word	0xaddeadde
 8005bb0:	addeadde 	.word	0xaddeadde
 8005bb4:	addeadde 	.word	0xaddeadde
 8005bb8:	addeadde 	.word	0xaddeadde
 8005bbc:	addeadde 	.word	0xaddeadde
 8005bc0:	addeadde 	.word	0xaddeadde
 8005bc4:	addeadde 	.word	0xaddeadde
 8005bc8:	addeadde 	.word	0xaddeadde
 8005bcc:	addeadde 	.word	0xaddeadde
 8005bd0:	addeadde 	.word	0xaddeadde
 8005bd4:	addeadde 	.word	0xaddeadde
 8005bd8:	addeadde 	.word	0xaddeadde
 8005bdc:	addeadde 	.word	0xaddeadde
 8005be0:	addeadde 	.word	0xaddeadde
 8005be4:	addeadde 	.word	0xaddeadde
 8005be8:	addeadde 	.word	0xaddeadde
 8005bec:	addeadde 	.word	0xaddeadde
 8005bf0:	addeadde 	.word	0xaddeadde
 8005bf4:	addeadde 	.word	0xaddeadde
 8005bf8:	addeadde 	.word	0xaddeadde
 8005bfc:	addeadde 	.word	0xaddeadde
 8005c00:	addeadde 	.word	0xaddeadde
 8005c04:	addeadde 	.word	0xaddeadde
 8005c08:	addeadde 	.word	0xaddeadde
 8005c0c:	addeadde 	.word	0xaddeadde
 8005c10:	addeadde 	.word	0xaddeadde
 8005c14:	addeadde 	.word	0xaddeadde
 8005c18:	addeadde 	.word	0xaddeadde
 8005c1c:	addeadde 	.word	0xaddeadde
 8005c20:	addeadde 	.word	0xaddeadde
 8005c24:	addeadde 	.word	0xaddeadde
 8005c28:	addeadde 	.word	0xaddeadde
 8005c2c:	addeadde 	.word	0xaddeadde
 8005c30:	addeadde 	.word	0xaddeadde
 8005c34:	addeadde 	.word	0xaddeadde
 8005c38:	addeadde 	.word	0xaddeadde
 8005c3c:	addeadde 	.word	0xaddeadde
 8005c40:	addeadde 	.word	0xaddeadde
 8005c44:	addeadde 	.word	0xaddeadde
 8005c48:	addeadde 	.word	0xaddeadde
 8005c4c:	addeadde 	.word	0xaddeadde
 8005c50:	addeadde 	.word	0xaddeadde
 8005c54:	addeadde 	.word	0xaddeadde
 8005c58:	addeadde 	.word	0xaddeadde
 8005c5c:	addeadde 	.word	0xaddeadde
 8005c60:	addeadde 	.word	0xaddeadde
 8005c64:	addeadde 	.word	0xaddeadde
 8005c68:	addeadde 	.word	0xaddeadde
 8005c6c:	addeadde 	.word	0xaddeadde
 8005c70:	addeadde 	.word	0xaddeadde
 8005c74:	addeadde 	.word	0xaddeadde
 8005c78:	addeadde 	.word	0xaddeadde
 8005c7c:	addeadde 	.word	0xaddeadde
 8005c80:	addeadde 	.word	0xaddeadde
 8005c84:	addeadde 	.word	0xaddeadde
 8005c88:	addeadde 	.word	0xaddeadde
 8005c8c:	addeadde 	.word	0xaddeadde
 8005c90:	addeadde 	.word	0xaddeadde
 8005c94:	addeadde 	.word	0xaddeadde
 8005c98:	addeadde 	.word	0xaddeadde
 8005c9c:	addeadde 	.word	0xaddeadde
 8005ca0:	addeadde 	.word	0xaddeadde
 8005ca4:	addeadde 	.word	0xaddeadde
 8005ca8:	addeadde 	.word	0xaddeadde
 8005cac:	addeadde 	.word	0xaddeadde
 8005cb0:	addeadde 	.word	0xaddeadde
 8005cb4:	addeadde 	.word	0xaddeadde
 8005cb8:	addeadde 	.word	0xaddeadde
 8005cbc:	addeadde 	.word	0xaddeadde
 8005cc0:	addeadde 	.word	0xaddeadde
 8005cc4:	addeadde 	.word	0xaddeadde
 8005cc8:	addeadde 	.word	0xaddeadde
 8005ccc:	addeadde 	.word	0xaddeadde
 8005cd0:	addeadde 	.word	0xaddeadde
 8005cd4:	addeadde 	.word	0xaddeadde
 8005cd8:	addeadde 	.word	0xaddeadde
 8005cdc:	addeadde 	.word	0xaddeadde
 8005ce0:	addeadde 	.word	0xaddeadde
 8005ce4:	addeadde 	.word	0xaddeadde
 8005ce8:	addeadde 	.word	0xaddeadde
 8005cec:	addeadde 	.word	0xaddeadde
 8005cf0:	addeadde 	.word	0xaddeadde
 8005cf4:	addeadde 	.word	0xaddeadde
 8005cf8:	addeadde 	.word	0xaddeadde
 8005cfc:	addeadde 	.word	0xaddeadde
 8005d00:	addeadde 	.word	0xaddeadde
 8005d04:	addeadde 	.word	0xaddeadde
 8005d08:	addeadde 	.word	0xaddeadde
 8005d0c:	addeadde 	.word	0xaddeadde
 8005d10:	addeadde 	.word	0xaddeadde
 8005d14:	addeadde 	.word	0xaddeadde
 8005d18:	addeadde 	.word	0xaddeadde
 8005d1c:	addeadde 	.word	0xaddeadde
 8005d20:	addeadde 	.word	0xaddeadde
 8005d24:	addeadde 	.word	0xaddeadde
 8005d28:	addeadde 	.word	0xaddeadde
 8005d2c:	addeadde 	.word	0xaddeadde
 8005d30:	addeadde 	.word	0xaddeadde
 8005d34:	addeadde 	.word	0xaddeadde
 8005d38:	addeadde 	.word	0xaddeadde
 8005d3c:	addeadde 	.word	0xaddeadde
 8005d40:	addeadde 	.word	0xaddeadde
 8005d44:	addeadde 	.word	0xaddeadde
 8005d48:	addeadde 	.word	0xaddeadde
 8005d4c:	addeadde 	.word	0xaddeadde
 8005d50:	addeadde 	.word	0xaddeadde
 8005d54:	addeadde 	.word	0xaddeadde
 8005d58:	addeadde 	.word	0xaddeadde
 8005d5c:	addeadde 	.word	0xaddeadde
 8005d60:	addeadde 	.word	0xaddeadde
 8005d64:	addeadde 	.word	0xaddeadde
 8005d68:	addeadde 	.word	0xaddeadde
 8005d6c:	addeadde 	.word	0xaddeadde
 8005d70:	addeadde 	.word	0xaddeadde
 8005d74:	addeadde 	.word	0xaddeadde
 8005d78:	addeadde 	.word	0xaddeadde
 8005d7c:	addeadde 	.word	0xaddeadde
 8005d80:	addeadde 	.word	0xaddeadde
 8005d84:	addeadde 	.word	0xaddeadde
 8005d88:	addeadde 	.word	0xaddeadde
 8005d8c:	addeadde 	.word	0xaddeadde
 8005d90:	addeadde 	.word	0xaddeadde
 8005d94:	addeadde 	.word	0xaddeadde
 8005d98:	addeadde 	.word	0xaddeadde
 8005d9c:	addeadde 	.word	0xaddeadde
 8005da0:	addeadde 	.word	0xaddeadde
 8005da4:	addeadde 	.word	0xaddeadde
 8005da8:	addeadde 	.word	0xaddeadde
 8005dac:	addeadde 	.word	0xaddeadde
 8005db0:	addeadde 	.word	0xaddeadde
 8005db4:	addeadde 	.word	0xaddeadde
 8005db8:	addeadde 	.word	0xaddeadde
 8005dbc:	addeadde 	.word	0xaddeadde
 8005dc0:	addeadde 	.word	0xaddeadde
 8005dc4:	addeadde 	.word	0xaddeadde
 8005dc8:	addeadde 	.word	0xaddeadde
 8005dcc:	addeadde 	.word	0xaddeadde
 8005dd0:	addeadde 	.word	0xaddeadde
 8005dd4:	addeadde 	.word	0xaddeadde
 8005dd8:	addeadde 	.word	0xaddeadde
 8005ddc:	addeadde 	.word	0xaddeadde
 8005de0:	addeadde 	.word	0xaddeadde
 8005de4:	addeadde 	.word	0xaddeadde
 8005de8:	addeadde 	.word	0xaddeadde
 8005dec:	addeadde 	.word	0xaddeadde
 8005df0:	addeadde 	.word	0xaddeadde
 8005df4:	addeadde 	.word	0xaddeadde
 8005df8:	addeadde 	.word	0xaddeadde
 8005dfc:	addeadde 	.word	0xaddeadde
 8005e00:	addeadde 	.word	0xaddeadde
 8005e04:	addeadde 	.word	0xaddeadde
 8005e08:	addeadde 	.word	0xaddeadde
 8005e0c:	addeadde 	.word	0xaddeadde
 8005e10:	addeadde 	.word	0xaddeadde
 8005e14:	addeadde 	.word	0xaddeadde
 8005e18:	addeadde 	.word	0xaddeadde
 8005e1c:	addeadde 	.word	0xaddeadde
 8005e20:	addeadde 	.word	0xaddeadde
 8005e24:	addeadde 	.word	0xaddeadde
 8005e28:	addeadde 	.word	0xaddeadde
 8005e2c:	addeadde 	.word	0xaddeadde
 8005e30:	addeadde 	.word	0xaddeadde
 8005e34:	addeadde 	.word	0xaddeadde
 8005e38:	addeadde 	.word	0xaddeadde
 8005e3c:	addeadde 	.word	0xaddeadde
 8005e40:	addeadde 	.word	0xaddeadde
 8005e44:	addeadde 	.word	0xaddeadde
 8005e48:	addeadde 	.word	0xaddeadde
 8005e4c:	addeadde 	.word	0xaddeadde
 8005e50:	addeadde 	.word	0xaddeadde
 8005e54:	addeadde 	.word	0xaddeadde
 8005e58:	addeadde 	.word	0xaddeadde
 8005e5c:	addeadde 	.word	0xaddeadde
 8005e60:	addeadde 	.word	0xaddeadde
 8005e64:	addeadde 	.word	0xaddeadde
 8005e68:	addeadde 	.word	0xaddeadde
 8005e6c:	addeadde 	.word	0xaddeadde
 8005e70:	addeadde 	.word	0xaddeadde
 8005e74:	addeadde 	.word	0xaddeadde
 8005e78:	addeadde 	.word	0xaddeadde
 8005e7c:	addeadde 	.word	0xaddeadde
 8005e80:	addeadde 	.word	0xaddeadde
 8005e84:	addeadde 	.word	0xaddeadde
 8005e88:	addeadde 	.word	0xaddeadde
 8005e8c:	addeadde 	.word	0xaddeadde
 8005e90:	addeadde 	.word	0xaddeadde
 8005e94:	addeadde 	.word	0xaddeadde
 8005e98:	addeadde 	.word	0xaddeadde
 8005e9c:	addeadde 	.word	0xaddeadde
 8005ea0:	addeadde 	.word	0xaddeadde
 8005ea4:	addeadde 	.word	0xaddeadde
 8005ea8:	addeadde 	.word	0xaddeadde
 8005eac:	addeadde 	.word	0xaddeadde
 8005eb0:	addeadde 	.word	0xaddeadde
 8005eb4:	addeadde 	.word	0xaddeadde
 8005eb8:	addeadde 	.word	0xaddeadde
 8005ebc:	addeadde 	.word	0xaddeadde
 8005ec0:	addeadde 	.word	0xaddeadde
 8005ec4:	addeadde 	.word	0xaddeadde
 8005ec8:	addeadde 	.word	0xaddeadde
 8005ecc:	addeadde 	.word	0xaddeadde
 8005ed0:	addeadde 	.word	0xaddeadde
 8005ed4:	addeadde 	.word	0xaddeadde
 8005ed8:	addeadde 	.word	0xaddeadde
 8005edc:	addeadde 	.word	0xaddeadde
 8005ee0:	addeadde 	.word	0xaddeadde
 8005ee4:	addeadde 	.word	0xaddeadde
 8005ee8:	addeadde 	.word	0xaddeadde
 8005eec:	addeadde 	.word	0xaddeadde
 8005ef0:	addeadde 	.word	0xaddeadde
 8005ef4:	addeadde 	.word	0xaddeadde
 8005ef8:	addeadde 	.word	0xaddeadde
 8005efc:	addeadde 	.word	0xaddeadde
 8005f00:	addeadde 	.word	0xaddeadde
 8005f04:	addeadde 	.word	0xaddeadde
 8005f08:	addeadde 	.word	0xaddeadde
 8005f0c:	addeadde 	.word	0xaddeadde
 8005f10:	addeadde 	.word	0xaddeadde
 8005f14:	addeadde 	.word	0xaddeadde
 8005f18:	addeadde 	.word	0xaddeadde
 8005f1c:	addeadde 	.word	0xaddeadde
 8005f20:	addeadde 	.word	0xaddeadde
 8005f24:	addeadde 	.word	0xaddeadde
 8005f28:	addeadde 	.word	0xaddeadde
 8005f2c:	addeadde 	.word	0xaddeadde
 8005f30:	addeadde 	.word	0xaddeadde
 8005f34:	addeadde 	.word	0xaddeadde
 8005f38:	addeadde 	.word	0xaddeadde
 8005f3c:	addeadde 	.word	0xaddeadde
 8005f40:	addeadde 	.word	0xaddeadde
 8005f44:	addeadde 	.word	0xaddeadde
 8005f48:	addeadde 	.word	0xaddeadde
 8005f4c:	addeadde 	.word	0xaddeadde
 8005f50:	addeadde 	.word	0xaddeadde
 8005f54:	addeadde 	.word	0xaddeadde
 8005f58:	addeadde 	.word	0xaddeadde
 8005f5c:	addeadde 	.word	0xaddeadde
 8005f60:	addeadde 	.word	0xaddeadde
 8005f64:	addeadde 	.word	0xaddeadde
 8005f68:	addeadde 	.word	0xaddeadde
 8005f6c:	addeadde 	.word	0xaddeadde
 8005f70:	addeadde 	.word	0xaddeadde
 8005f74:	addeadde 	.word	0xaddeadde
 8005f78:	addeadde 	.word	0xaddeadde
 8005f7c:	addeadde 	.word	0xaddeadde
 8005f80:	addeadde 	.word	0xaddeadde
 8005f84:	addeadde 	.word	0xaddeadde
 8005f88:	addeadde 	.word	0xaddeadde
 8005f8c:	addeadde 	.word	0xaddeadde
 8005f90:	addeadde 	.word	0xaddeadde
 8005f94:	addeadde 	.word	0xaddeadde
 8005f98:	addeadde 	.word	0xaddeadde
 8005f9c:	addeadde 	.word	0xaddeadde
 8005fa0:	addeadde 	.word	0xaddeadde
 8005fa4:	addeadde 	.word	0xaddeadde
 8005fa8:	addeadde 	.word	0xaddeadde
 8005fac:	addeadde 	.word	0xaddeadde
 8005fb0:	addeadde 	.word	0xaddeadde
 8005fb4:	addeadde 	.word	0xaddeadde
 8005fb8:	addeadde 	.word	0xaddeadde
 8005fbc:	addeadde 	.word	0xaddeadde
 8005fc0:	addeadde 	.word	0xaddeadde
 8005fc4:	addeadde 	.word	0xaddeadde
 8005fc8:	addeadde 	.word	0xaddeadde
 8005fcc:	addeadde 	.word	0xaddeadde
 8005fd0:	addeadde 	.word	0xaddeadde
 8005fd4:	addeadde 	.word	0xaddeadde
 8005fd8:	addeadde 	.word	0xaddeadde
 8005fdc:	addeadde 	.word	0xaddeadde
 8005fe0:	addeadde 	.word	0xaddeadde
 8005fe4:	addeadde 	.word	0xaddeadde
 8005fe8:	addeadde 	.word	0xaddeadde
 8005fec:	addeadde 	.word	0xaddeadde
 8005ff0:	addeadde 	.word	0xaddeadde
 8005ff4:	addeadde 	.word	0xaddeadde
 8005ff8:	addeadde 	.word	0xaddeadde
 8005ffc:	addeadde 	.word	0xaddeadde
 8006000:	addeadde 	.word	0xaddeadde
 8006004:	addeadde 	.word	0xaddeadde
 8006008:	addeadde 	.word	0xaddeadde
 800600c:	addeadde 	.word	0xaddeadde
 8006010:	addeadde 	.word	0xaddeadde
 8006014:	addeadde 	.word	0xaddeadde
 8006018:	addeadde 	.word	0xaddeadde
 800601c:	addeadde 	.word	0xaddeadde
 8006020:	addeadde 	.word	0xaddeadde
 8006024:	addeadde 	.word	0xaddeadde
 8006028:	addeadde 	.word	0xaddeadde
 800602c:	addeadde 	.word	0xaddeadde
 8006030:	addeadde 	.word	0xaddeadde
 8006034:	addeadde 	.word	0xaddeadde
 8006038:	addeadde 	.word	0xaddeadde
 800603c:	addeadde 	.word	0xaddeadde
 8006040:	addeadde 	.word	0xaddeadde
 8006044:	addeadde 	.word	0xaddeadde
 8006048:	addeadde 	.word	0xaddeadde
 800604c:	addeadde 	.word	0xaddeadde
 8006050:	addeadde 	.word	0xaddeadde
 8006054:	addeadde 	.word	0xaddeadde
 8006058:	addeadde 	.word	0xaddeadde
 800605c:	addeadde 	.word	0xaddeadde
 8006060:	addeadde 	.word	0xaddeadde
 8006064:	addeadde 	.word	0xaddeadde
 8006068:	addeadde 	.word	0xaddeadde
 800606c:	addeadde 	.word	0xaddeadde
 8006070:	addeadde 	.word	0xaddeadde
 8006074:	addeadde 	.word	0xaddeadde
 8006078:	addeadde 	.word	0xaddeadde
 800607c:	addeadde 	.word	0xaddeadde
 8006080:	addeadde 	.word	0xaddeadde
 8006084:	addeadde 	.word	0xaddeadde
 8006088:	addeadde 	.word	0xaddeadde
 800608c:	addeadde 	.word	0xaddeadde
 8006090:	addeadde 	.word	0xaddeadde
 8006094:	addeadde 	.word	0xaddeadde
 8006098:	addeadde 	.word	0xaddeadde
 800609c:	addeadde 	.word	0xaddeadde
 80060a0:	addeadde 	.word	0xaddeadde
 80060a4:	addeadde 	.word	0xaddeadde
 80060a8:	addeadde 	.word	0xaddeadde
 80060ac:	addeadde 	.word	0xaddeadde
 80060b0:	addeadde 	.word	0xaddeadde
 80060b4:	addeadde 	.word	0xaddeadde
 80060b8:	addeadde 	.word	0xaddeadde
 80060bc:	addeadde 	.word	0xaddeadde
 80060c0:	addeadde 	.word	0xaddeadde
 80060c4:	addeadde 	.word	0xaddeadde
 80060c8:	addeadde 	.word	0xaddeadde
 80060cc:	addeadde 	.word	0xaddeadde
 80060d0:	addeadde 	.word	0xaddeadde
 80060d4:	addeadde 	.word	0xaddeadde
 80060d8:	addeadde 	.word	0xaddeadde
 80060dc:	addeadde 	.word	0xaddeadde
 80060e0:	addeadde 	.word	0xaddeadde
 80060e4:	addeadde 	.word	0xaddeadde
 80060e8:	addeadde 	.word	0xaddeadde
 80060ec:	addeadde 	.word	0xaddeadde
 80060f0:	addeadde 	.word	0xaddeadde
 80060f4:	addeadde 	.word	0xaddeadde
 80060f8:	addeadde 	.word	0xaddeadde
 80060fc:	addeadde 	.word	0xaddeadde
 8006100:	addeadde 	.word	0xaddeadde
 8006104:	addeadde 	.word	0xaddeadde
 8006108:	addeadde 	.word	0xaddeadde
 800610c:	addeadde 	.word	0xaddeadde
 8006110:	addeadde 	.word	0xaddeadde
 8006114:	addeadde 	.word	0xaddeadde
 8006118:	addeadde 	.word	0xaddeadde
 800611c:	addeadde 	.word	0xaddeadde
 8006120:	addeadde 	.word	0xaddeadde
 8006124:	addeadde 	.word	0xaddeadde
 8006128:	addeadde 	.word	0xaddeadde
 800612c:	addeadde 	.word	0xaddeadde
 8006130:	addeadde 	.word	0xaddeadde
 8006134:	addeadde 	.word	0xaddeadde
 8006138:	addeadde 	.word	0xaddeadde
 800613c:	addeadde 	.word	0xaddeadde
 8006140:	addeadde 	.word	0xaddeadde
 8006144:	addeadde 	.word	0xaddeadde
 8006148:	addeadde 	.word	0xaddeadde
 800614c:	addeadde 	.word	0xaddeadde
 8006150:	addeadde 	.word	0xaddeadde
 8006154:	addeadde 	.word	0xaddeadde
 8006158:	addeadde 	.word	0xaddeadde
 800615c:	addeadde 	.word	0xaddeadde
 8006160:	addeadde 	.word	0xaddeadde
 8006164:	addeadde 	.word	0xaddeadde
 8006168:	addeadde 	.word	0xaddeadde
 800616c:	addeadde 	.word	0xaddeadde
 8006170:	addeadde 	.word	0xaddeadde
 8006174:	addeadde 	.word	0xaddeadde
 8006178:	addeadde 	.word	0xaddeadde
 800617c:	addeadde 	.word	0xaddeadde
 8006180:	addeadde 	.word	0xaddeadde
 8006184:	addeadde 	.word	0xaddeadde
 8006188:	addeadde 	.word	0xaddeadde
 800618c:	addeadde 	.word	0xaddeadde
 8006190:	addeadde 	.word	0xaddeadde
 8006194:	addeadde 	.word	0xaddeadde
 8006198:	addeadde 	.word	0xaddeadde
 800619c:	addeadde 	.word	0xaddeadde
 80061a0:	addeadde 	.word	0xaddeadde
 80061a4:	addeadde 	.word	0xaddeadde
 80061a8:	addeadde 	.word	0xaddeadde
 80061ac:	addeadde 	.word	0xaddeadde
 80061b0:	addeadde 	.word	0xaddeadde
 80061b4:	addeadde 	.word	0xaddeadde
 80061b8:	addeadde 	.word	0xaddeadde
 80061bc:	addeadde 	.word	0xaddeadde
 80061c0:	addeadde 	.word	0xaddeadde
 80061c4:	addeadde 	.word	0xaddeadde
 80061c8:	addeadde 	.word	0xaddeadde
 80061cc:	addeadde 	.word	0xaddeadde
 80061d0:	addeadde 	.word	0xaddeadde
 80061d4:	addeadde 	.word	0xaddeadde
 80061d8:	addeadde 	.word	0xaddeadde
 80061dc:	addeadde 	.word	0xaddeadde
 80061e0:	addeadde 	.word	0xaddeadde
 80061e4:	addeadde 	.word	0xaddeadde
 80061e8:	addeadde 	.word	0xaddeadde
 80061ec:	addeadde 	.word	0xaddeadde
 80061f0:	addeadde 	.word	0xaddeadde
 80061f4:	addeadde 	.word	0xaddeadde
 80061f8:	addeadde 	.word	0xaddeadde
 80061fc:	addeadde 	.word	0xaddeadde
 8006200:	addeadde 	.word	0xaddeadde
 8006204:	addeadde 	.word	0xaddeadde
 8006208:	addeadde 	.word	0xaddeadde
 800620c:	addeadde 	.word	0xaddeadde
 8006210:	addeadde 	.word	0xaddeadde
 8006214:	addeadde 	.word	0xaddeadde
 8006218:	addeadde 	.word	0xaddeadde
 800621c:	addeadde 	.word	0xaddeadde
 8006220:	addeadde 	.word	0xaddeadde
 8006224:	addeadde 	.word	0xaddeadde
 8006228:	addeadde 	.word	0xaddeadde
 800622c:	addeadde 	.word	0xaddeadde
 8006230:	addeadde 	.word	0xaddeadde
 8006234:	addeadde 	.word	0xaddeadde
 8006238:	addeadde 	.word	0xaddeadde
 800623c:	addeadde 	.word	0xaddeadde
 8006240:	addeadde 	.word	0xaddeadde
 8006244:	addeadde 	.word	0xaddeadde
 8006248:	addeadde 	.word	0xaddeadde
 800624c:	addeadde 	.word	0xaddeadde
 8006250:	addeadde 	.word	0xaddeadde
 8006254:	addeadde 	.word	0xaddeadde
 8006258:	addeadde 	.word	0xaddeadde
 800625c:	addeadde 	.word	0xaddeadde
 8006260:	addeadde 	.word	0xaddeadde
 8006264:	addeadde 	.word	0xaddeadde
 8006268:	addeadde 	.word	0xaddeadde
 800626c:	addeadde 	.word	0xaddeadde
 8006270:	addeadde 	.word	0xaddeadde
 8006274:	addeadde 	.word	0xaddeadde
 8006278:	addeadde 	.word	0xaddeadde
 800627c:	addeadde 	.word	0xaddeadde
 8006280:	addeadde 	.word	0xaddeadde
 8006284:	addeadde 	.word	0xaddeadde
 8006288:	addeadde 	.word	0xaddeadde
 800628c:	addeadde 	.word	0xaddeadde
 8006290:	addeadde 	.word	0xaddeadde
 8006294:	addeadde 	.word	0xaddeadde
 8006298:	addeadde 	.word	0xaddeadde
 800629c:	addeadde 	.word	0xaddeadde
 80062a0:	addeadde 	.word	0xaddeadde
 80062a4:	addeadde 	.word	0xaddeadde
 80062a8:	addeadde 	.word	0xaddeadde
 80062ac:	addeadde 	.word	0xaddeadde
 80062b0:	addeadde 	.word	0xaddeadde
 80062b4:	addeadde 	.word	0xaddeadde
 80062b8:	addeadde 	.word	0xaddeadde
 80062bc:	addeadde 	.word	0xaddeadde
 80062c0:	addeadde 	.word	0xaddeadde
 80062c4:	addeadde 	.word	0xaddeadde
 80062c8:	addeadde 	.word	0xaddeadde
 80062cc:	addeadde 	.word	0xaddeadde
 80062d0:	addeadde 	.word	0xaddeadde
 80062d4:	addeadde 	.word	0xaddeadde
 80062d8:	addeadde 	.word	0xaddeadde
 80062dc:	addeadde 	.word	0xaddeadde
 80062e0:	addeadde 	.word	0xaddeadde
 80062e4:	addeadde 	.word	0xaddeadde
 80062e8:	addeadde 	.word	0xaddeadde
 80062ec:	addeadde 	.word	0xaddeadde
 80062f0:	addeadde 	.word	0xaddeadde
 80062f4:	addeadde 	.word	0xaddeadde
 80062f8:	addeadde 	.word	0xaddeadde
 80062fc:	addeadde 	.word	0xaddeadde
 8006300:	addeadde 	.word	0xaddeadde
 8006304:	addeadde 	.word	0xaddeadde
 8006308:	addeadde 	.word	0xaddeadde
 800630c:	addeadde 	.word	0xaddeadde
 8006310:	addeadde 	.word	0xaddeadde
 8006314:	addeadde 	.word	0xaddeadde
 8006318:	addeadde 	.word	0xaddeadde
 800631c:	addeadde 	.word	0xaddeadde
 8006320:	addeadde 	.word	0xaddeadde
 8006324:	addeadde 	.word	0xaddeadde
 8006328:	addeadde 	.word	0xaddeadde
 800632c:	addeadde 	.word	0xaddeadde
 8006330:	addeadde 	.word	0xaddeadde
 8006334:	addeadde 	.word	0xaddeadde
 8006338:	addeadde 	.word	0xaddeadde
 800633c:	addeadde 	.word	0xaddeadde
 8006340:	addeadde 	.word	0xaddeadde
 8006344:	addeadde 	.word	0xaddeadde
 8006348:	addeadde 	.word	0xaddeadde
 800634c:	addeadde 	.word	0xaddeadde
 8006350:	addeadde 	.word	0xaddeadde
 8006354:	addeadde 	.word	0xaddeadde
 8006358:	addeadde 	.word	0xaddeadde
 800635c:	addeadde 	.word	0xaddeadde
 8006360:	addeadde 	.word	0xaddeadde
 8006364:	addeadde 	.word	0xaddeadde
 8006368:	addeadde 	.word	0xaddeadde
 800636c:	addeadde 	.word	0xaddeadde
 8006370:	addeadde 	.word	0xaddeadde
 8006374:	addeadde 	.word	0xaddeadde
 8006378:	addeadde 	.word	0xaddeadde
 800637c:	addeadde 	.word	0xaddeadde
 8006380:	addeadde 	.word	0xaddeadde
 8006384:	addeadde 	.word	0xaddeadde
 8006388:	addeadde 	.word	0xaddeadde
 800638c:	addeadde 	.word	0xaddeadde
 8006390:	addeadde 	.word	0xaddeadde
 8006394:	addeadde 	.word	0xaddeadde
 8006398:	addeadde 	.word	0xaddeadde
 800639c:	addeadde 	.word	0xaddeadde
 80063a0:	addeadde 	.word	0xaddeadde
 80063a4:	addeadde 	.word	0xaddeadde
 80063a8:	addeadde 	.word	0xaddeadde
 80063ac:	addeadde 	.word	0xaddeadde
 80063b0:	addeadde 	.word	0xaddeadde
 80063b4:	addeadde 	.word	0xaddeadde
 80063b8:	addeadde 	.word	0xaddeadde
 80063bc:	addeadde 	.word	0xaddeadde
 80063c0:	addeadde 	.word	0xaddeadde
 80063c4:	addeadde 	.word	0xaddeadde
 80063c8:	addeadde 	.word	0xaddeadde
 80063cc:	addeadde 	.word	0xaddeadde
 80063d0:	addeadde 	.word	0xaddeadde
 80063d4:	addeadde 	.word	0xaddeadde
 80063d8:	addeadde 	.word	0xaddeadde
 80063dc:	addeadde 	.word	0xaddeadde
 80063e0:	addeadde 	.word	0xaddeadde
 80063e4:	addeadde 	.word	0xaddeadde
 80063e8:	addeadde 	.word	0xaddeadde
 80063ec:	addeadde 	.word	0xaddeadde
 80063f0:	addeadde 	.word	0xaddeadde
 80063f4:	addeadde 	.word	0xaddeadde
 80063f8:	addeadde 	.word	0xaddeadde
 80063fc:	addeadde 	.word	0xaddeadde
 8006400:	addeadde 	.word	0xaddeadde
 8006404:	addeadde 	.word	0xaddeadde
 8006408:	addeadde 	.word	0xaddeadde
 800640c:	addeadde 	.word	0xaddeadde
 8006410:	addeadde 	.word	0xaddeadde
 8006414:	addeadde 	.word	0xaddeadde
 8006418:	addeadde 	.word	0xaddeadde
 800641c:	addeadde 	.word	0xaddeadde
 8006420:	addeadde 	.word	0xaddeadde
 8006424:	addeadde 	.word	0xaddeadde
 8006428:	addeadde 	.word	0xaddeadde
 800642c:	addeadde 	.word	0xaddeadde
 8006430:	addeadde 	.word	0xaddeadde
 8006434:	addeadde 	.word	0xaddeadde
 8006438:	addeadde 	.word	0xaddeadde
 800643c:	addeadde 	.word	0xaddeadde
 8006440:	addeadde 	.word	0xaddeadde
 8006444:	addeadde 	.word	0xaddeadde
 8006448:	addeadde 	.word	0xaddeadde
 800644c:	addeadde 	.word	0xaddeadde
 8006450:	addeadde 	.word	0xaddeadde
 8006454:	addeadde 	.word	0xaddeadde
 8006458:	addeadde 	.word	0xaddeadde
 800645c:	addeadde 	.word	0xaddeadde
 8006460:	addeadde 	.word	0xaddeadde
 8006464:	addeadde 	.word	0xaddeadde
 8006468:	addeadde 	.word	0xaddeadde
 800646c:	addeadde 	.word	0xaddeadde
 8006470:	addeadde 	.word	0xaddeadde
 8006474:	addeadde 	.word	0xaddeadde
 8006478:	addeadde 	.word	0xaddeadde
 800647c:	addeadde 	.word	0xaddeadde
 8006480:	addeadde 	.word	0xaddeadde
 8006484:	addeadde 	.word	0xaddeadde
 8006488:	addeadde 	.word	0xaddeadde
 800648c:	addeadde 	.word	0xaddeadde
 8006490:	addeadde 	.word	0xaddeadde
 8006494:	addeadde 	.word	0xaddeadde
 8006498:	addeadde 	.word	0xaddeadde
 800649c:	addeadde 	.word	0xaddeadde
 80064a0:	addeadde 	.word	0xaddeadde
 80064a4:	addeadde 	.word	0xaddeadde
 80064a8:	addeadde 	.word	0xaddeadde
 80064ac:	addeadde 	.word	0xaddeadde
 80064b0:	addeadde 	.word	0xaddeadde
 80064b4:	addeadde 	.word	0xaddeadde
 80064b8:	addeadde 	.word	0xaddeadde
 80064bc:	addeadde 	.word	0xaddeadde
 80064c0:	addeadde 	.word	0xaddeadde
 80064c4:	addeadde 	.word	0xaddeadde
 80064c8:	addeadde 	.word	0xaddeadde
 80064cc:	addeadde 	.word	0xaddeadde
 80064d0:	addeadde 	.word	0xaddeadde
 80064d4:	addeadde 	.word	0xaddeadde
 80064d8:	addeadde 	.word	0xaddeadde
 80064dc:	addeadde 	.word	0xaddeadde
 80064e0:	addeadde 	.word	0xaddeadde
 80064e4:	addeadde 	.word	0xaddeadde
 80064e8:	addeadde 	.word	0xaddeadde
 80064ec:	addeadde 	.word	0xaddeadde
 80064f0:	addeadde 	.word	0xaddeadde
 80064f4:	addeadde 	.word	0xaddeadde
 80064f8:	addeadde 	.word	0xaddeadde
 80064fc:	addeadde 	.word	0xaddeadde
 8006500:	addeadde 	.word	0xaddeadde
 8006504:	addeadde 	.word	0xaddeadde
 8006508:	addeadde 	.word	0xaddeadde
 800650c:	addeadde 	.word	0xaddeadde
 8006510:	addeadde 	.word	0xaddeadde
 8006514:	addeadde 	.word	0xaddeadde
 8006518:	addeadde 	.word	0xaddeadde
 800651c:	addeadde 	.word	0xaddeadde
 8006520:	addeadde 	.word	0xaddeadde
 8006524:	addeadde 	.word	0xaddeadde
 8006528:	addeadde 	.word	0xaddeadde
 800652c:	addeadde 	.word	0xaddeadde
 8006530:	addeadde 	.word	0xaddeadde
 8006534:	addeadde 	.word	0xaddeadde
 8006538:	addeadde 	.word	0xaddeadde
 800653c:	addeadde 	.word	0xaddeadde
 8006540:	addeadde 	.word	0xaddeadde
 8006544:	addeadde 	.word	0xaddeadde
 8006548:	addeadde 	.word	0xaddeadde
 800654c:	addeadde 	.word	0xaddeadde
 8006550:	addeadde 	.word	0xaddeadde
 8006554:	addeadde 	.word	0xaddeadde
 8006558:	addeadde 	.word	0xaddeadde
 800655c:	addeadde 	.word	0xaddeadde
 8006560:	addeadde 	.word	0xaddeadde
 8006564:	addeadde 	.word	0xaddeadde
 8006568:	addeadde 	.word	0xaddeadde
 800656c:	addeadde 	.word	0xaddeadde
 8006570:	addeadde 	.word	0xaddeadde
 8006574:	addeadde 	.word	0xaddeadde
 8006578:	addeadde 	.word	0xaddeadde
 800657c:	addeadde 	.word	0xaddeadde
 8006580:	addeadde 	.word	0xaddeadde
 8006584:	addeadde 	.word	0xaddeadde
 8006588:	addeadde 	.word	0xaddeadde
 800658c:	addeadde 	.word	0xaddeadde
 8006590:	addeadde 	.word	0xaddeadde
 8006594:	addeadde 	.word	0xaddeadde
 8006598:	addeadde 	.word	0xaddeadde
 800659c:	addeadde 	.word	0xaddeadde
 80065a0:	addeadde 	.word	0xaddeadde
 80065a4:	addeadde 	.word	0xaddeadde
 80065a8:	addeadde 	.word	0xaddeadde
 80065ac:	addeadde 	.word	0xaddeadde
 80065b0:	addeadde 	.word	0xaddeadde
 80065b4:	addeadde 	.word	0xaddeadde
 80065b8:	addeadde 	.word	0xaddeadde
 80065bc:	addeadde 	.word	0xaddeadde
 80065c0:	addeadde 	.word	0xaddeadde
 80065c4:	addeadde 	.word	0xaddeadde
 80065c8:	addeadde 	.word	0xaddeadde
 80065cc:	addeadde 	.word	0xaddeadde
 80065d0:	addeadde 	.word	0xaddeadde
 80065d4:	addeadde 	.word	0xaddeadde
 80065d8:	addeadde 	.word	0xaddeadde
 80065dc:	addeadde 	.word	0xaddeadde
 80065e0:	addeadde 	.word	0xaddeadde
 80065e4:	addeadde 	.word	0xaddeadde
 80065e8:	addeadde 	.word	0xaddeadde
 80065ec:	addeadde 	.word	0xaddeadde
 80065f0:	addeadde 	.word	0xaddeadde
 80065f4:	addeadde 	.word	0xaddeadde
 80065f8:	addeadde 	.word	0xaddeadde
 80065fc:	addeadde 	.word	0xaddeadde
 8006600:	addeadde 	.word	0xaddeadde
 8006604:	addeadde 	.word	0xaddeadde
 8006608:	addeadde 	.word	0xaddeadde
 800660c:	addeadde 	.word	0xaddeadde
 8006610:	addeadde 	.word	0xaddeadde
 8006614:	addeadde 	.word	0xaddeadde
 8006618:	addeadde 	.word	0xaddeadde
 800661c:	addeadde 	.word	0xaddeadde
 8006620:	addeadde 	.word	0xaddeadde
 8006624:	addeadde 	.word	0xaddeadde
 8006628:	addeadde 	.word	0xaddeadde
 800662c:	addeadde 	.word	0xaddeadde
 8006630:	addeadde 	.word	0xaddeadde
 8006634:	addeadde 	.word	0xaddeadde
 8006638:	addeadde 	.word	0xaddeadde
 800663c:	addeadde 	.word	0xaddeadde
 8006640:	addeadde 	.word	0xaddeadde
 8006644:	addeadde 	.word	0xaddeadde
 8006648:	addeadde 	.word	0xaddeadde
 800664c:	addeadde 	.word	0xaddeadde
 8006650:	addeadde 	.word	0xaddeadde
 8006654:	addeadde 	.word	0xaddeadde
 8006658:	addeadde 	.word	0xaddeadde
 800665c:	addeadde 	.word	0xaddeadde
 8006660:	addeadde 	.word	0xaddeadde
 8006664:	addeadde 	.word	0xaddeadde
 8006668:	addeadde 	.word	0xaddeadde
 800666c:	addeadde 	.word	0xaddeadde
 8006670:	addeadde 	.word	0xaddeadde
 8006674:	addeadde 	.word	0xaddeadde
 8006678:	addeadde 	.word	0xaddeadde
 800667c:	addeadde 	.word	0xaddeadde
 8006680:	addeadde 	.word	0xaddeadde
 8006684:	addeadde 	.word	0xaddeadde
 8006688:	addeadde 	.word	0xaddeadde
 800668c:	addeadde 	.word	0xaddeadde
 8006690:	addeadde 	.word	0xaddeadde
 8006694:	addeadde 	.word	0xaddeadde
 8006698:	addeadde 	.word	0xaddeadde
 800669c:	addeadde 	.word	0xaddeadde
 80066a0:	addeadde 	.word	0xaddeadde
 80066a4:	addeadde 	.word	0xaddeadde
 80066a8:	addeadde 	.word	0xaddeadde
 80066ac:	addeadde 	.word	0xaddeadde
 80066b0:	addeadde 	.word	0xaddeadde
 80066b4:	addeadde 	.word	0xaddeadde
 80066b8:	addeadde 	.word	0xaddeadde
 80066bc:	addeadde 	.word	0xaddeadde
 80066c0:	addeadde 	.word	0xaddeadde
 80066c4:	addeadde 	.word	0xaddeadde
 80066c8:	addeadde 	.word	0xaddeadde
 80066cc:	addeadde 	.word	0xaddeadde
 80066d0:	addeadde 	.word	0xaddeadde
 80066d4:	addeadde 	.word	0xaddeadde
 80066d8:	addeadde 	.word	0xaddeadde
 80066dc:	addeadde 	.word	0xaddeadde
 80066e0:	addeadde 	.word	0xaddeadde
 80066e4:	addeadde 	.word	0xaddeadde
 80066e8:	addeadde 	.word	0xaddeadde
 80066ec:	addeadde 	.word	0xaddeadde
 80066f0:	addeadde 	.word	0xaddeadde
 80066f4:	addeadde 	.word	0xaddeadde
 80066f8:	addeadde 	.word	0xaddeadde
 80066fc:	addeadde 	.word	0xaddeadde
 8006700:	addeadde 	.word	0xaddeadde
 8006704:	addeadde 	.word	0xaddeadde
 8006708:	addeadde 	.word	0xaddeadde
 800670c:	addeadde 	.word	0xaddeadde
 8006710:	addeadde 	.word	0xaddeadde
 8006714:	addeadde 	.word	0xaddeadde
 8006718:	addeadde 	.word	0xaddeadde
 800671c:	addeadde 	.word	0xaddeadde
 8006720:	addeadde 	.word	0xaddeadde
 8006724:	addeadde 	.word	0xaddeadde
 8006728:	addeadde 	.word	0xaddeadde
 800672c:	addeadde 	.word	0xaddeadde
 8006730:	addeadde 	.word	0xaddeadde
 8006734:	addeadde 	.word	0xaddeadde
 8006738:	addeadde 	.word	0xaddeadde
 800673c:	addeadde 	.word	0xaddeadde
 8006740:	addeadde 	.word	0xaddeadde
 8006744:	addeadde 	.word	0xaddeadde
 8006748:	addeadde 	.word	0xaddeadde
 800674c:	addeadde 	.word	0xaddeadde
 8006750:	addeadde 	.word	0xaddeadde
 8006754:	addeadde 	.word	0xaddeadde
 8006758:	addeadde 	.word	0xaddeadde
 800675c:	addeadde 	.word	0xaddeadde
 8006760:	addeadde 	.word	0xaddeadde
 8006764:	addeadde 	.word	0xaddeadde
 8006768:	addeadde 	.word	0xaddeadde
 800676c:	addeadde 	.word	0xaddeadde
 8006770:	addeadde 	.word	0xaddeadde
 8006774:	addeadde 	.word	0xaddeadde
 8006778:	addeadde 	.word	0xaddeadde
 800677c:	addeadde 	.word	0xaddeadde
 8006780:	addeadde 	.word	0xaddeadde
 8006784:	addeadde 	.word	0xaddeadde
 8006788:	addeadde 	.word	0xaddeadde
 800678c:	addeadde 	.word	0xaddeadde
 8006790:	addeadde 	.word	0xaddeadde
 8006794:	addeadde 	.word	0xaddeadde
 8006798:	addeadde 	.word	0xaddeadde
 800679c:	addeadde 	.word	0xaddeadde
 80067a0:	addeadde 	.word	0xaddeadde
 80067a4:	addeadde 	.word	0xaddeadde
 80067a8:	addeadde 	.word	0xaddeadde
 80067ac:	addeadde 	.word	0xaddeadde
 80067b0:	addeadde 	.word	0xaddeadde
 80067b4:	addeadde 	.word	0xaddeadde
 80067b8:	addeadde 	.word	0xaddeadde
 80067bc:	addeadde 	.word	0xaddeadde
 80067c0:	addeadde 	.word	0xaddeadde
 80067c4:	addeadde 	.word	0xaddeadde
 80067c8:	addeadde 	.word	0xaddeadde
 80067cc:	addeadde 	.word	0xaddeadde
 80067d0:	addeadde 	.word	0xaddeadde
 80067d4:	addeadde 	.word	0xaddeadde
 80067d8:	addeadde 	.word	0xaddeadde
 80067dc:	addeadde 	.word	0xaddeadde
 80067e0:	addeadde 	.word	0xaddeadde
 80067e4:	addeadde 	.word	0xaddeadde
 80067e8:	addeadde 	.word	0xaddeadde
 80067ec:	addeadde 	.word	0xaddeadde
 80067f0:	addeadde 	.word	0xaddeadde
 80067f4:	addeadde 	.word	0xaddeadde
 80067f8:	addeadde 	.word	0xaddeadde
 80067fc:	addeadde 	.word	0xaddeadde
 8006800:	addeadde 	.word	0xaddeadde
 8006804:	addeadde 	.word	0xaddeadde
 8006808:	addeadde 	.word	0xaddeadde
 800680c:	addeadde 	.word	0xaddeadde
 8006810:	addeadde 	.word	0xaddeadde
 8006814:	addeadde 	.word	0xaddeadde
 8006818:	addeadde 	.word	0xaddeadde
 800681c:	addeadde 	.word	0xaddeadde
 8006820:	addeadde 	.word	0xaddeadde
 8006824:	addeadde 	.word	0xaddeadde
 8006828:	addeadde 	.word	0xaddeadde
 800682c:	addeadde 	.word	0xaddeadde
 8006830:	addeadde 	.word	0xaddeadde
 8006834:	addeadde 	.word	0xaddeadde
 8006838:	addeadde 	.word	0xaddeadde
 800683c:	addeadde 	.word	0xaddeadde
 8006840:	addeadde 	.word	0xaddeadde
 8006844:	addeadde 	.word	0xaddeadde
 8006848:	addeadde 	.word	0xaddeadde
 800684c:	addeadde 	.word	0xaddeadde
 8006850:	addeadde 	.word	0xaddeadde
 8006854:	addeadde 	.word	0xaddeadde
 8006858:	addeadde 	.word	0xaddeadde
 800685c:	addeadde 	.word	0xaddeadde
 8006860:	addeadde 	.word	0xaddeadde
 8006864:	addeadde 	.word	0xaddeadde
 8006868:	addeadde 	.word	0xaddeadde
 800686c:	addeadde 	.word	0xaddeadde
 8006870:	addeadde 	.word	0xaddeadde
 8006874:	addeadde 	.word	0xaddeadde
 8006878:	addeadde 	.word	0xaddeadde
 800687c:	addeadde 	.word	0xaddeadde
 8006880:	addeadde 	.word	0xaddeadde
 8006884:	addeadde 	.word	0xaddeadde
 8006888:	addeadde 	.word	0xaddeadde
 800688c:	addeadde 	.word	0xaddeadde
 8006890:	addeadde 	.word	0xaddeadde
 8006894:	addeadde 	.word	0xaddeadde
 8006898:	addeadde 	.word	0xaddeadde
 800689c:	addeadde 	.word	0xaddeadde
 80068a0:	addeadde 	.word	0xaddeadde
 80068a4:	addeadde 	.word	0xaddeadde
 80068a8:	addeadde 	.word	0xaddeadde
 80068ac:	addeadde 	.word	0xaddeadde
 80068b0:	addeadde 	.word	0xaddeadde
 80068b4:	addeadde 	.word	0xaddeadde
 80068b8:	addeadde 	.word	0xaddeadde
 80068bc:	addeadde 	.word	0xaddeadde
 80068c0:	addeadde 	.word	0xaddeadde
 80068c4:	addeadde 	.word	0xaddeadde
 80068c8:	addeadde 	.word	0xaddeadde
 80068cc:	addeadde 	.word	0xaddeadde
 80068d0:	addeadde 	.word	0xaddeadde
 80068d4:	addeadde 	.word	0xaddeadde
 80068d8:	addeadde 	.word	0xaddeadde
 80068dc:	addeadde 	.word	0xaddeadde
 80068e0:	addeadde 	.word	0xaddeadde
 80068e4:	addeadde 	.word	0xaddeadde
 80068e8:	addeadde 	.word	0xaddeadde
 80068ec:	addeadde 	.word	0xaddeadde
 80068f0:	addeadde 	.word	0xaddeadde
 80068f4:	addeadde 	.word	0xaddeadde
 80068f8:	addeadde 	.word	0xaddeadde
 80068fc:	addeadde 	.word	0xaddeadde
 8006900:	addeadde 	.word	0xaddeadde
 8006904:	addeadde 	.word	0xaddeadde
 8006908:	addeadde 	.word	0xaddeadde
 800690c:	addeadde 	.word	0xaddeadde
 8006910:	addeadde 	.word	0xaddeadde
 8006914:	addeadde 	.word	0xaddeadde
 8006918:	addeadde 	.word	0xaddeadde
 800691c:	addeadde 	.word	0xaddeadde
 8006920:	addeadde 	.word	0xaddeadde
 8006924:	addeadde 	.word	0xaddeadde
 8006928:	addeadde 	.word	0xaddeadde
 800692c:	addeadde 	.word	0xaddeadde
 8006930:	addeadde 	.word	0xaddeadde
 8006934:	addeadde 	.word	0xaddeadde
 8006938:	addeadde 	.word	0xaddeadde
 800693c:	addeadde 	.word	0xaddeadde
 8006940:	addeadde 	.word	0xaddeadde
 8006944:	addeadde 	.word	0xaddeadde
 8006948:	addeadde 	.word	0xaddeadde
 800694c:	addeadde 	.word	0xaddeadde
 8006950:	addeadde 	.word	0xaddeadde
 8006954:	addeadde 	.word	0xaddeadde
 8006958:	addeadde 	.word	0xaddeadde
 800695c:	addeadde 	.word	0xaddeadde
 8006960:	addeadde 	.word	0xaddeadde
 8006964:	addeadde 	.word	0xaddeadde
 8006968:	addeadde 	.word	0xaddeadde
 800696c:	addeadde 	.word	0xaddeadde
 8006970:	addeadde 	.word	0xaddeadde
 8006974:	addeadde 	.word	0xaddeadde
 8006978:	addeadde 	.word	0xaddeadde
 800697c:	addeadde 	.word	0xaddeadde
 8006980:	addeadde 	.word	0xaddeadde
 8006984:	addeadde 	.word	0xaddeadde
 8006988:	addeadde 	.word	0xaddeadde
 800698c:	addeadde 	.word	0xaddeadde
 8006990:	addeadde 	.word	0xaddeadde
 8006994:	addeadde 	.word	0xaddeadde
 8006998:	addeadde 	.word	0xaddeadde
 800699c:	addeadde 	.word	0xaddeadde
 80069a0:	addeadde 	.word	0xaddeadde
 80069a4:	addeadde 	.word	0xaddeadde
 80069a8:	addeadde 	.word	0xaddeadde
 80069ac:	addeadde 	.word	0xaddeadde
 80069b0:	addeadde 	.word	0xaddeadde
 80069b4:	addeadde 	.word	0xaddeadde
 80069b8:	addeadde 	.word	0xaddeadde
 80069bc:	addeadde 	.word	0xaddeadde
 80069c0:	addeadde 	.word	0xaddeadde
 80069c4:	addeadde 	.word	0xaddeadde
 80069c8:	addeadde 	.word	0xaddeadde
 80069cc:	addeadde 	.word	0xaddeadde
 80069d0:	addeadde 	.word	0xaddeadde
 80069d4:	addeadde 	.word	0xaddeadde
 80069d8:	addeadde 	.word	0xaddeadde
 80069dc:	addeadde 	.word	0xaddeadde
 80069e0:	addeadde 	.word	0xaddeadde
 80069e4:	addeadde 	.word	0xaddeadde
 80069e8:	addeadde 	.word	0xaddeadde
 80069ec:	addeadde 	.word	0xaddeadde
 80069f0:	addeadde 	.word	0xaddeadde
 80069f4:	addeadde 	.word	0xaddeadde
 80069f8:	addeadde 	.word	0xaddeadde
 80069fc:	addeadde 	.word	0xaddeadde
 8006a00:	addeadde 	.word	0xaddeadde
 8006a04:	addeadde 	.word	0xaddeadde
 8006a08:	addeadde 	.word	0xaddeadde
 8006a0c:	addeadde 	.word	0xaddeadde
 8006a10:	addeadde 	.word	0xaddeadde
 8006a14:	addeadde 	.word	0xaddeadde
 8006a18:	addeadde 	.word	0xaddeadde
 8006a1c:	addeadde 	.word	0xaddeadde
 8006a20:	addeadde 	.word	0xaddeadde
 8006a24:	addeadde 	.word	0xaddeadde
 8006a28:	addeadde 	.word	0xaddeadde
 8006a2c:	addeadde 	.word	0xaddeadde
 8006a30:	addeadde 	.word	0xaddeadde
 8006a34:	addeadde 	.word	0xaddeadde
 8006a38:	addeadde 	.word	0xaddeadde
 8006a3c:	addeadde 	.word	0xaddeadde
 8006a40:	addeadde 	.word	0xaddeadde
 8006a44:	addeadde 	.word	0xaddeadde
 8006a48:	addeadde 	.word	0xaddeadde
 8006a4c:	addeadde 	.word	0xaddeadde
 8006a50:	addeadde 	.word	0xaddeadde
 8006a54:	addeadde 	.word	0xaddeadde
 8006a58:	addeadde 	.word	0xaddeadde
 8006a5c:	addeadde 	.word	0xaddeadde
 8006a60:	addeadde 	.word	0xaddeadde
 8006a64:	addeadde 	.word	0xaddeadde
 8006a68:	addeadde 	.word	0xaddeadde
 8006a6c:	addeadde 	.word	0xaddeadde
 8006a70:	addeadde 	.word	0xaddeadde
 8006a74:	addeadde 	.word	0xaddeadde
 8006a78:	addeadde 	.word	0xaddeadde
 8006a7c:	addeadde 	.word	0xaddeadde
 8006a80:	addeadde 	.word	0xaddeadde
 8006a84:	addeadde 	.word	0xaddeadde
 8006a88:	addeadde 	.word	0xaddeadde
 8006a8c:	addeadde 	.word	0xaddeadde
 8006a90:	addeadde 	.word	0xaddeadde
 8006a94:	addeadde 	.word	0xaddeadde
 8006a98:	addeadde 	.word	0xaddeadde
 8006a9c:	addeadde 	.word	0xaddeadde
 8006aa0:	addeadde 	.word	0xaddeadde
 8006aa4:	addeadde 	.word	0xaddeadde
 8006aa8:	addeadde 	.word	0xaddeadde
 8006aac:	addeadde 	.word	0xaddeadde
 8006ab0:	addeadde 	.word	0xaddeadde
 8006ab4:	addeadde 	.word	0xaddeadde
 8006ab8:	addeadde 	.word	0xaddeadde
 8006abc:	addeadde 	.word	0xaddeadde
 8006ac0:	addeadde 	.word	0xaddeadde
 8006ac4:	addeadde 	.word	0xaddeadde
 8006ac8:	addeadde 	.word	0xaddeadde
 8006acc:	addeadde 	.word	0xaddeadde
 8006ad0:	addeadde 	.word	0xaddeadde
 8006ad4:	addeadde 	.word	0xaddeadde
 8006ad8:	addeadde 	.word	0xaddeadde
 8006adc:	addeadde 	.word	0xaddeadde
 8006ae0:	addeadde 	.word	0xaddeadde
 8006ae4:	addeadde 	.word	0xaddeadde
 8006ae8:	addeadde 	.word	0xaddeadde
 8006aec:	addeadde 	.word	0xaddeadde
 8006af0:	addeadde 	.word	0xaddeadde
 8006af4:	addeadde 	.word	0xaddeadde
 8006af8:	addeadde 	.word	0xaddeadde
 8006afc:	addeadde 	.word	0xaddeadde
 8006b00:	addeadde 	.word	0xaddeadde
 8006b04:	addeadde 	.word	0xaddeadde
 8006b08:	addeadde 	.word	0xaddeadde
 8006b0c:	addeadde 	.word	0xaddeadde
 8006b10:	addeadde 	.word	0xaddeadde
 8006b14:	addeadde 	.word	0xaddeadde
 8006b18:	addeadde 	.word	0xaddeadde
 8006b1c:	addeadde 	.word	0xaddeadde
 8006b20:	addeadde 	.word	0xaddeadde
 8006b24:	addeadde 	.word	0xaddeadde
 8006b28:	addeadde 	.word	0xaddeadde
 8006b2c:	addeadde 	.word	0xaddeadde
 8006b30:	addeadde 	.word	0xaddeadde
 8006b34:	addeadde 	.word	0xaddeadde
 8006b38:	addeadde 	.word	0xaddeadde
 8006b3c:	addeadde 	.word	0xaddeadde
 8006b40:	addeadde 	.word	0xaddeadde
 8006b44:	addeadde 	.word	0xaddeadde
 8006b48:	addeadde 	.word	0xaddeadde
 8006b4c:	addeadde 	.word	0xaddeadde
 8006b50:	addeadde 	.word	0xaddeadde
 8006b54:	addeadde 	.word	0xaddeadde
 8006b58:	addeadde 	.word	0xaddeadde
 8006b5c:	addeadde 	.word	0xaddeadde
 8006b60:	addeadde 	.word	0xaddeadde
 8006b64:	addeadde 	.word	0xaddeadde
 8006b68:	addeadde 	.word	0xaddeadde
 8006b6c:	addeadde 	.word	0xaddeadde
 8006b70:	addeadde 	.word	0xaddeadde
 8006b74:	addeadde 	.word	0xaddeadde
 8006b78:	addeadde 	.word	0xaddeadde
 8006b7c:	addeadde 	.word	0xaddeadde
 8006b80:	addeadde 	.word	0xaddeadde
 8006b84:	addeadde 	.word	0xaddeadde
 8006b88:	addeadde 	.word	0xaddeadde
 8006b8c:	addeadde 	.word	0xaddeadde
 8006b90:	addeadde 	.word	0xaddeadde
 8006b94:	addeadde 	.word	0xaddeadde
 8006b98:	addeadde 	.word	0xaddeadde
 8006b9c:	addeadde 	.word	0xaddeadde
 8006ba0:	addeadde 	.word	0xaddeadde
 8006ba4:	addeadde 	.word	0xaddeadde
 8006ba8:	addeadde 	.word	0xaddeadde
 8006bac:	addeadde 	.word	0xaddeadde
 8006bb0:	addeadde 	.word	0xaddeadde
 8006bb4:	addeadde 	.word	0xaddeadde
 8006bb8:	addeadde 	.word	0xaddeadde
 8006bbc:	addeadde 	.word	0xaddeadde
 8006bc0:	addeadde 	.word	0xaddeadde
 8006bc4:	addeadde 	.word	0xaddeadde
 8006bc8:	addeadde 	.word	0xaddeadde
 8006bcc:	addeadde 	.word	0xaddeadde
 8006bd0:	addeadde 	.word	0xaddeadde
 8006bd4:	addeadde 	.word	0xaddeadde
 8006bd8:	addeadde 	.word	0xaddeadde
 8006bdc:	addeadde 	.word	0xaddeadde
 8006be0:	addeadde 	.word	0xaddeadde
 8006be4:	addeadde 	.word	0xaddeadde
 8006be8:	addeadde 	.word	0xaddeadde
 8006bec:	addeadde 	.word	0xaddeadde
 8006bf0:	addeadde 	.word	0xaddeadde
 8006bf4:	addeadde 	.word	0xaddeadde
 8006bf8:	addeadde 	.word	0xaddeadde
 8006bfc:	addeadde 	.word	0xaddeadde
 8006c00:	addeadde 	.word	0xaddeadde
 8006c04:	addeadde 	.word	0xaddeadde
 8006c08:	addeadde 	.word	0xaddeadde
 8006c0c:	addeadde 	.word	0xaddeadde
 8006c10:	addeadde 	.word	0xaddeadde
 8006c14:	addeadde 	.word	0xaddeadde
 8006c18:	addeadde 	.word	0xaddeadde
 8006c1c:	addeadde 	.word	0xaddeadde
 8006c20:	addeadde 	.word	0xaddeadde
 8006c24:	addeadde 	.word	0xaddeadde
 8006c28:	addeadde 	.word	0xaddeadde
 8006c2c:	addeadde 	.word	0xaddeadde
 8006c30:	addeadde 	.word	0xaddeadde
 8006c34:	addeadde 	.word	0xaddeadde
 8006c38:	addeadde 	.word	0xaddeadde
 8006c3c:	addeadde 	.word	0xaddeadde
 8006c40:	addeadde 	.word	0xaddeadde
 8006c44:	addeadde 	.word	0xaddeadde
 8006c48:	addeadde 	.word	0xaddeadde
 8006c4c:	addeadde 	.word	0xaddeadde
 8006c50:	addeadde 	.word	0xaddeadde
 8006c54:	addeadde 	.word	0xaddeadde
 8006c58:	addeadde 	.word	0xaddeadde
 8006c5c:	addeadde 	.word	0xaddeadde
 8006c60:	addeadde 	.word	0xaddeadde
 8006c64:	addeadde 	.word	0xaddeadde
 8006c68:	addeadde 	.word	0xaddeadde
 8006c6c:	addeadde 	.word	0xaddeadde
 8006c70:	addeadde 	.word	0xaddeadde
 8006c74:	addeadde 	.word	0xaddeadde
 8006c78:	addeadde 	.word	0xaddeadde
 8006c7c:	addeadde 	.word	0xaddeadde
 8006c80:	addeadde 	.word	0xaddeadde
 8006c84:	addeadde 	.word	0xaddeadde
 8006c88:	addeadde 	.word	0xaddeadde
 8006c8c:	addeadde 	.word	0xaddeadde
 8006c90:	addeadde 	.word	0xaddeadde
 8006c94:	addeadde 	.word	0xaddeadde
 8006c98:	addeadde 	.word	0xaddeadde
 8006c9c:	addeadde 	.word	0xaddeadde
 8006ca0:	addeadde 	.word	0xaddeadde
 8006ca4:	addeadde 	.word	0xaddeadde
 8006ca8:	addeadde 	.word	0xaddeadde
 8006cac:	addeadde 	.word	0xaddeadde
 8006cb0:	addeadde 	.word	0xaddeadde
 8006cb4:	addeadde 	.word	0xaddeadde
 8006cb8:	addeadde 	.word	0xaddeadde
 8006cbc:	addeadde 	.word	0xaddeadde
 8006cc0:	addeadde 	.word	0xaddeadde
 8006cc4:	addeadde 	.word	0xaddeadde
 8006cc8:	addeadde 	.word	0xaddeadde
 8006ccc:	addeadde 	.word	0xaddeadde
 8006cd0:	addeadde 	.word	0xaddeadde
 8006cd4:	addeadde 	.word	0xaddeadde
 8006cd8:	addeadde 	.word	0xaddeadde
 8006cdc:	addeadde 	.word	0xaddeadde
 8006ce0:	addeadde 	.word	0xaddeadde
 8006ce4:	addeadde 	.word	0xaddeadde
 8006ce8:	addeadde 	.word	0xaddeadde
 8006cec:	addeadde 	.word	0xaddeadde
 8006cf0:	addeadde 	.word	0xaddeadde
 8006cf4:	addeadde 	.word	0xaddeadde
 8006cf8:	addeadde 	.word	0xaddeadde
 8006cfc:	addeadde 	.word	0xaddeadde
 8006d00:	addeadde 	.word	0xaddeadde
 8006d04:	addeadde 	.word	0xaddeadde
 8006d08:	addeadde 	.word	0xaddeadde
 8006d0c:	addeadde 	.word	0xaddeadde
 8006d10:	addeadde 	.word	0xaddeadde
 8006d14:	addeadde 	.word	0xaddeadde
 8006d18:	addeadde 	.word	0xaddeadde
 8006d1c:	addeadde 	.word	0xaddeadde
 8006d20:	addeadde 	.word	0xaddeadde
 8006d24:	addeadde 	.word	0xaddeadde
 8006d28:	addeadde 	.word	0xaddeadde
 8006d2c:	addeadde 	.word	0xaddeadde
 8006d30:	addeadde 	.word	0xaddeadde
 8006d34:	addeadde 	.word	0xaddeadde
 8006d38:	addeadde 	.word	0xaddeadde
 8006d3c:	addeadde 	.word	0xaddeadde
 8006d40:	addeadde 	.word	0xaddeadde
 8006d44:	addeadde 	.word	0xaddeadde
 8006d48:	addeadde 	.word	0xaddeadde
 8006d4c:	addeadde 	.word	0xaddeadde
 8006d50:	addeadde 	.word	0xaddeadde
 8006d54:	addeadde 	.word	0xaddeadde
 8006d58:	addeadde 	.word	0xaddeadde
 8006d5c:	addeadde 	.word	0xaddeadde
 8006d60:	addeadde 	.word	0xaddeadde
 8006d64:	addeadde 	.word	0xaddeadde
 8006d68:	addeadde 	.word	0xaddeadde
 8006d6c:	addeadde 	.word	0xaddeadde
 8006d70:	addeadde 	.word	0xaddeadde
 8006d74:	addeadde 	.word	0xaddeadde
 8006d78:	addeadde 	.word	0xaddeadde
 8006d7c:	addeadde 	.word	0xaddeadde
 8006d80:	addeadde 	.word	0xaddeadde
 8006d84:	addeadde 	.word	0xaddeadde
 8006d88:	addeadde 	.word	0xaddeadde
 8006d8c:	addeadde 	.word	0xaddeadde
 8006d90:	addeadde 	.word	0xaddeadde
 8006d94:	addeadde 	.word	0xaddeadde
 8006d98:	addeadde 	.word	0xaddeadde
 8006d9c:	addeadde 	.word	0xaddeadde
 8006da0:	addeadde 	.word	0xaddeadde
 8006da4:	addeadde 	.word	0xaddeadde
 8006da8:	addeadde 	.word	0xaddeadde
 8006dac:	addeadde 	.word	0xaddeadde
 8006db0:	addeadde 	.word	0xaddeadde
 8006db4:	addeadde 	.word	0xaddeadde
 8006db8:	addeadde 	.word	0xaddeadde
 8006dbc:	addeadde 	.word	0xaddeadde
 8006dc0:	addeadde 	.word	0xaddeadde
 8006dc4:	addeadde 	.word	0xaddeadde
 8006dc8:	addeadde 	.word	0xaddeadde
 8006dcc:	addeadde 	.word	0xaddeadde
 8006dd0:	addeadde 	.word	0xaddeadde
 8006dd4:	addeadde 	.word	0xaddeadde
 8006dd8:	addeadde 	.word	0xaddeadde
 8006ddc:	addeadde 	.word	0xaddeadde
 8006de0:	addeadde 	.word	0xaddeadde
 8006de4:	addeadde 	.word	0xaddeadde
 8006de8:	addeadde 	.word	0xaddeadde
 8006dec:	addeadde 	.word	0xaddeadde
 8006df0:	addeadde 	.word	0xaddeadde
 8006df4:	addeadde 	.word	0xaddeadde
 8006df8:	addeadde 	.word	0xaddeadde
 8006dfc:	addeadde 	.word	0xaddeadde
 8006e00:	addeadde 	.word	0xaddeadde
 8006e04:	addeadde 	.word	0xaddeadde
 8006e08:	addeadde 	.word	0xaddeadde
 8006e0c:	addeadde 	.word	0xaddeadde
 8006e10:	addeadde 	.word	0xaddeadde
 8006e14:	addeadde 	.word	0xaddeadde
 8006e18:	addeadde 	.word	0xaddeadde
 8006e1c:	addeadde 	.word	0xaddeadde
 8006e20:	addeadde 	.word	0xaddeadde
 8006e24:	addeadde 	.word	0xaddeadde
 8006e28:	addeadde 	.word	0xaddeadde
 8006e2c:	addeadde 	.word	0xaddeadde
 8006e30:	addeadde 	.word	0xaddeadde
 8006e34:	addeadde 	.word	0xaddeadde
 8006e38:	addeadde 	.word	0xaddeadde
 8006e3c:	addeadde 	.word	0xaddeadde
 8006e40:	addeadde 	.word	0xaddeadde
 8006e44:	addeadde 	.word	0xaddeadde
 8006e48:	addeadde 	.word	0xaddeadde
 8006e4c:	addeadde 	.word	0xaddeadde
 8006e50:	addeadde 	.word	0xaddeadde
 8006e54:	addeadde 	.word	0xaddeadde
 8006e58:	addeadde 	.word	0xaddeadde
 8006e5c:	addeadde 	.word	0xaddeadde
 8006e60:	addeadde 	.word	0xaddeadde
 8006e64:	addeadde 	.word	0xaddeadde
 8006e68:	addeadde 	.word	0xaddeadde
 8006e6c:	addeadde 	.word	0xaddeadde
 8006e70:	addeadde 	.word	0xaddeadde
 8006e74:	addeadde 	.word	0xaddeadde
 8006e78:	addeadde 	.word	0xaddeadde
 8006e7c:	addeadde 	.word	0xaddeadde
 8006e80:	addeadde 	.word	0xaddeadde
 8006e84:	addeadde 	.word	0xaddeadde
 8006e88:	addeadde 	.word	0xaddeadde
 8006e8c:	addeadde 	.word	0xaddeadde
 8006e90:	addeadde 	.word	0xaddeadde
 8006e94:	addeadde 	.word	0xaddeadde
 8006e98:	addeadde 	.word	0xaddeadde
 8006e9c:	addeadde 	.word	0xaddeadde
 8006ea0:	addeadde 	.word	0xaddeadde
 8006ea4:	addeadde 	.word	0xaddeadde
 8006ea8:	addeadde 	.word	0xaddeadde
 8006eac:	addeadde 	.word	0xaddeadde
 8006eb0:	addeadde 	.word	0xaddeadde
 8006eb4:	addeadde 	.word	0xaddeadde
 8006eb8:	addeadde 	.word	0xaddeadde
 8006ebc:	addeadde 	.word	0xaddeadde
 8006ec0:	addeadde 	.word	0xaddeadde
 8006ec4:	addeadde 	.word	0xaddeadde
 8006ec8:	addeadde 	.word	0xaddeadde
 8006ecc:	addeadde 	.word	0xaddeadde
 8006ed0:	addeadde 	.word	0xaddeadde
 8006ed4:	addeadde 	.word	0xaddeadde
 8006ed8:	addeadde 	.word	0xaddeadde
 8006edc:	addeadde 	.word	0xaddeadde
 8006ee0:	addeadde 	.word	0xaddeadde
 8006ee4:	addeadde 	.word	0xaddeadde
 8006ee8:	addeadde 	.word	0xaddeadde
 8006eec:	addeadde 	.word	0xaddeadde
 8006ef0:	addeadde 	.word	0xaddeadde
 8006ef4:	addeadde 	.word	0xaddeadde
 8006ef8:	addeadde 	.word	0xaddeadde
 8006efc:	addeadde 	.word	0xaddeadde
 8006f00:	addeadde 	.word	0xaddeadde
 8006f04:	addeadde 	.word	0xaddeadde
 8006f08:	addeadde 	.word	0xaddeadde
 8006f0c:	addeadde 	.word	0xaddeadde
 8006f10:	addeadde 	.word	0xaddeadde
 8006f14:	addeadde 	.word	0xaddeadde
 8006f18:	addeadde 	.word	0xaddeadde
 8006f1c:	addeadde 	.word	0xaddeadde
 8006f20:	addeadde 	.word	0xaddeadde
 8006f24:	addeadde 	.word	0xaddeadde
 8006f28:	addeadde 	.word	0xaddeadde
 8006f2c:	addeadde 	.word	0xaddeadde
 8006f30:	addeadde 	.word	0xaddeadde
 8006f34:	addeadde 	.word	0xaddeadde
 8006f38:	addeadde 	.word	0xaddeadde
 8006f3c:	addeadde 	.word	0xaddeadde
 8006f40:	addeadde 	.word	0xaddeadde
 8006f44:	addeadde 	.word	0xaddeadde
 8006f48:	addeadde 	.word	0xaddeadde
 8006f4c:	addeadde 	.word	0xaddeadde
 8006f50:	addeadde 	.word	0xaddeadde
 8006f54:	addeadde 	.word	0xaddeadde
 8006f58:	addeadde 	.word	0xaddeadde
 8006f5c:	addeadde 	.word	0xaddeadde
 8006f60:	addeadde 	.word	0xaddeadde
 8006f64:	addeadde 	.word	0xaddeadde
 8006f68:	addeadde 	.word	0xaddeadde
 8006f6c:	addeadde 	.word	0xaddeadde
 8006f70:	addeadde 	.word	0xaddeadde
 8006f74:	addeadde 	.word	0xaddeadde
 8006f78:	addeadde 	.word	0xaddeadde
 8006f7c:	addeadde 	.word	0xaddeadde
 8006f80:	addeadde 	.word	0xaddeadde
 8006f84:	addeadde 	.word	0xaddeadde
 8006f88:	addeadde 	.word	0xaddeadde
 8006f8c:	addeadde 	.word	0xaddeadde
 8006f90:	addeadde 	.word	0xaddeadde
 8006f94:	addeadde 	.word	0xaddeadde
 8006f98:	addeadde 	.word	0xaddeadde
 8006f9c:	addeadde 	.word	0xaddeadde
 8006fa0:	addeadde 	.word	0xaddeadde
 8006fa4:	addeadde 	.word	0xaddeadde
 8006fa8:	addeadde 	.word	0xaddeadde
 8006fac:	addeadde 	.word	0xaddeadde
 8006fb0:	addeadde 	.word	0xaddeadde
 8006fb4:	addeadde 	.word	0xaddeadde
 8006fb8:	addeadde 	.word	0xaddeadde
 8006fbc:	addeadde 	.word	0xaddeadde
 8006fc0:	addeadde 	.word	0xaddeadde
 8006fc4:	addeadde 	.word	0xaddeadde
 8006fc8:	addeadde 	.word	0xaddeadde
 8006fcc:	addeadde 	.word	0xaddeadde
 8006fd0:	addeadde 	.word	0xaddeadde
 8006fd4:	addeadde 	.word	0xaddeadde
 8006fd8:	addeadde 	.word	0xaddeadde
 8006fdc:	addeadde 	.word	0xaddeadde
 8006fe0:	addeadde 	.word	0xaddeadde
 8006fe4:	addeadde 	.word	0xaddeadde
 8006fe8:	addeadde 	.word	0xaddeadde
 8006fec:	addeadde 	.word	0xaddeadde
 8006ff0:	addeadde 	.word	0xaddeadde
 8006ff4:	addeadde 	.word	0xaddeadde
 8006ff8:	addeadde 	.word	0xaddeadde
 8006ffc:	addeadde 	.word	0xaddeadde
 8007000:	addeadde 	.word	0xaddeadde
 8007004:	addeadde 	.word	0xaddeadde
 8007008:	addeadde 	.word	0xaddeadde
 800700c:	addeadde 	.word	0xaddeadde
 8007010:	addeadde 	.word	0xaddeadde
 8007014:	addeadde 	.word	0xaddeadde
 8007018:	addeadde 	.word	0xaddeadde
 800701c:	addeadde 	.word	0xaddeadde
 8007020:	addeadde 	.word	0xaddeadde
 8007024:	addeadde 	.word	0xaddeadde
 8007028:	addeadde 	.word	0xaddeadde
 800702c:	addeadde 	.word	0xaddeadde
 8007030:	addeadde 	.word	0xaddeadde
 8007034:	addeadde 	.word	0xaddeadde
 8007038:	addeadde 	.word	0xaddeadde
 800703c:	addeadde 	.word	0xaddeadde
 8007040:	addeadde 	.word	0xaddeadde
 8007044:	addeadde 	.word	0xaddeadde
 8007048:	addeadde 	.word	0xaddeadde
 800704c:	addeadde 	.word	0xaddeadde
 8007050:	addeadde 	.word	0xaddeadde
 8007054:	addeadde 	.word	0xaddeadde
 8007058:	addeadde 	.word	0xaddeadde
 800705c:	addeadde 	.word	0xaddeadde
 8007060:	addeadde 	.word	0xaddeadde
 8007064:	addeadde 	.word	0xaddeadde
 8007068:	addeadde 	.word	0xaddeadde
 800706c:	addeadde 	.word	0xaddeadde
 8007070:	addeadde 	.word	0xaddeadde
 8007074:	addeadde 	.word	0xaddeadde
 8007078:	addeadde 	.word	0xaddeadde
 800707c:	addeadde 	.word	0xaddeadde
 8007080:	addeadde 	.word	0xaddeadde
 8007084:	addeadde 	.word	0xaddeadde
 8007088:	addeadde 	.word	0xaddeadde
 800708c:	addeadde 	.word	0xaddeadde
 8007090:	addeadde 	.word	0xaddeadde
 8007094:	addeadde 	.word	0xaddeadde
 8007098:	addeadde 	.word	0xaddeadde
 800709c:	addeadde 	.word	0xaddeadde
 80070a0:	addeadde 	.word	0xaddeadde
 80070a4:	addeadde 	.word	0xaddeadde
 80070a8:	addeadde 	.word	0xaddeadde
 80070ac:	addeadde 	.word	0xaddeadde
 80070b0:	addeadde 	.word	0xaddeadde
 80070b4:	addeadde 	.word	0xaddeadde
 80070b8:	addeadde 	.word	0xaddeadde
 80070bc:	addeadde 	.word	0xaddeadde
 80070c0:	addeadde 	.word	0xaddeadde
 80070c4:	addeadde 	.word	0xaddeadde
 80070c8:	addeadde 	.word	0xaddeadde
 80070cc:	addeadde 	.word	0xaddeadde
 80070d0:	addeadde 	.word	0xaddeadde
 80070d4:	addeadde 	.word	0xaddeadde
 80070d8:	addeadde 	.word	0xaddeadde
 80070dc:	addeadde 	.word	0xaddeadde
 80070e0:	addeadde 	.word	0xaddeadde
 80070e4:	addeadde 	.word	0xaddeadde
 80070e8:	addeadde 	.word	0xaddeadde
 80070ec:	addeadde 	.word	0xaddeadde
 80070f0:	addeadde 	.word	0xaddeadde
 80070f4:	addeadde 	.word	0xaddeadde
 80070f8:	addeadde 	.word	0xaddeadde
 80070fc:	addeadde 	.word	0xaddeadde
 8007100:	addeadde 	.word	0xaddeadde
 8007104:	addeadde 	.word	0xaddeadde
 8007108:	addeadde 	.word	0xaddeadde
 800710c:	addeadde 	.word	0xaddeadde
 8007110:	addeadde 	.word	0xaddeadde
 8007114:	addeadde 	.word	0xaddeadde
 8007118:	addeadde 	.word	0xaddeadde
 800711c:	addeadde 	.word	0xaddeadde
 8007120:	addeadde 	.word	0xaddeadde
 8007124:	addeadde 	.word	0xaddeadde
 8007128:	addeadde 	.word	0xaddeadde
 800712c:	addeadde 	.word	0xaddeadde
 8007130:	addeadde 	.word	0xaddeadde
 8007134:	addeadde 	.word	0xaddeadde
 8007138:	addeadde 	.word	0xaddeadde
 800713c:	addeadde 	.word	0xaddeadde
 8007140:	addeadde 	.word	0xaddeadde
 8007144:	addeadde 	.word	0xaddeadde
 8007148:	addeadde 	.word	0xaddeadde
 800714c:	addeadde 	.word	0xaddeadde
 8007150:	addeadde 	.word	0xaddeadde
 8007154:	addeadde 	.word	0xaddeadde
 8007158:	addeadde 	.word	0xaddeadde
 800715c:	addeadde 	.word	0xaddeadde
 8007160:	addeadde 	.word	0xaddeadde
 8007164:	addeadde 	.word	0xaddeadde
 8007168:	addeadde 	.word	0xaddeadde
 800716c:	addeadde 	.word	0xaddeadde
 8007170:	addeadde 	.word	0xaddeadde
 8007174:	addeadde 	.word	0xaddeadde
 8007178:	addeadde 	.word	0xaddeadde
 800717c:	addeadde 	.word	0xaddeadde
 8007180:	addeadde 	.word	0xaddeadde
 8007184:	addeadde 	.word	0xaddeadde
 8007188:	addeadde 	.word	0xaddeadde
 800718c:	addeadde 	.word	0xaddeadde
 8007190:	addeadde 	.word	0xaddeadde
 8007194:	addeadde 	.word	0xaddeadde
 8007198:	addeadde 	.word	0xaddeadde
 800719c:	addeadde 	.word	0xaddeadde
 80071a0:	addeadde 	.word	0xaddeadde
 80071a4:	addeadde 	.word	0xaddeadde
 80071a8:	addeadde 	.word	0xaddeadde
 80071ac:	addeadde 	.word	0xaddeadde
 80071b0:	addeadde 	.word	0xaddeadde
 80071b4:	addeadde 	.word	0xaddeadde
 80071b8:	addeadde 	.word	0xaddeadde
 80071bc:	addeadde 	.word	0xaddeadde
 80071c0:	addeadde 	.word	0xaddeadde
 80071c4:	addeadde 	.word	0xaddeadde
 80071c8:	addeadde 	.word	0xaddeadde
 80071cc:	addeadde 	.word	0xaddeadde
 80071d0:	addeadde 	.word	0xaddeadde
 80071d4:	addeadde 	.word	0xaddeadde
 80071d8:	addeadde 	.word	0xaddeadde
 80071dc:	addeadde 	.word	0xaddeadde
 80071e0:	addeadde 	.word	0xaddeadde
 80071e4:	addeadde 	.word	0xaddeadde
 80071e8:	addeadde 	.word	0xaddeadde
 80071ec:	addeadde 	.word	0xaddeadde
 80071f0:	addeadde 	.word	0xaddeadde
 80071f4:	addeadde 	.word	0xaddeadde
 80071f8:	addeadde 	.word	0xaddeadde
 80071fc:	addeadde 	.word	0xaddeadde
 8007200:	addeadde 	.word	0xaddeadde
 8007204:	addeadde 	.word	0xaddeadde
 8007208:	addeadde 	.word	0xaddeadde
 800720c:	addeadde 	.word	0xaddeadde
 8007210:	addeadde 	.word	0xaddeadde
 8007214:	addeadde 	.word	0xaddeadde
 8007218:	addeadde 	.word	0xaddeadde
 800721c:	addeadde 	.word	0xaddeadde
 8007220:	addeadde 	.word	0xaddeadde
 8007224:	addeadde 	.word	0xaddeadde
 8007228:	addeadde 	.word	0xaddeadde
 800722c:	addeadde 	.word	0xaddeadde
 8007230:	addeadde 	.word	0xaddeadde
 8007234:	addeadde 	.word	0xaddeadde
 8007238:	addeadde 	.word	0xaddeadde
 800723c:	addeadde 	.word	0xaddeadde
 8007240:	addeadde 	.word	0xaddeadde
 8007244:	addeadde 	.word	0xaddeadde
 8007248:	addeadde 	.word	0xaddeadde
 800724c:	addeadde 	.word	0xaddeadde
 8007250:	addeadde 	.word	0xaddeadde
 8007254:	addeadde 	.word	0xaddeadde
 8007258:	addeadde 	.word	0xaddeadde
 800725c:	addeadde 	.word	0xaddeadde
 8007260:	addeadde 	.word	0xaddeadde
 8007264:	addeadde 	.word	0xaddeadde
 8007268:	addeadde 	.word	0xaddeadde
 800726c:	addeadde 	.word	0xaddeadde
 8007270:	addeadde 	.word	0xaddeadde
 8007274:	addeadde 	.word	0xaddeadde
 8007278:	addeadde 	.word	0xaddeadde
 800727c:	addeadde 	.word	0xaddeadde
 8007280:	addeadde 	.word	0xaddeadde
 8007284:	addeadde 	.word	0xaddeadde
 8007288:	addeadde 	.word	0xaddeadde
 800728c:	addeadde 	.word	0xaddeadde
 8007290:	addeadde 	.word	0xaddeadde
 8007294:	addeadde 	.word	0xaddeadde
 8007298:	addeadde 	.word	0xaddeadde
 800729c:	addeadde 	.word	0xaddeadde
 80072a0:	addeadde 	.word	0xaddeadde
 80072a4:	addeadde 	.word	0xaddeadde
 80072a8:	addeadde 	.word	0xaddeadde
 80072ac:	addeadde 	.word	0xaddeadde
 80072b0:	addeadde 	.word	0xaddeadde
 80072b4:	addeadde 	.word	0xaddeadde
 80072b8:	addeadde 	.word	0xaddeadde
 80072bc:	addeadde 	.word	0xaddeadde
 80072c0:	addeadde 	.word	0xaddeadde
 80072c4:	addeadde 	.word	0xaddeadde
 80072c8:	addeadde 	.word	0xaddeadde
 80072cc:	addeadde 	.word	0xaddeadde
 80072d0:	addeadde 	.word	0xaddeadde
 80072d4:	addeadde 	.word	0xaddeadde
 80072d8:	addeadde 	.word	0xaddeadde
 80072dc:	addeadde 	.word	0xaddeadde
 80072e0:	addeadde 	.word	0xaddeadde
 80072e4:	addeadde 	.word	0xaddeadde
 80072e8:	addeadde 	.word	0xaddeadde
 80072ec:	addeadde 	.word	0xaddeadde
 80072f0:	addeadde 	.word	0xaddeadde
 80072f4:	addeadde 	.word	0xaddeadde
 80072f8:	addeadde 	.word	0xaddeadde
 80072fc:	addeadde 	.word	0xaddeadde
 8007300:	addeadde 	.word	0xaddeadde
 8007304:	addeadde 	.word	0xaddeadde
 8007308:	addeadde 	.word	0xaddeadde
 800730c:	addeadde 	.word	0xaddeadde
 8007310:	addeadde 	.word	0xaddeadde
 8007314:	addeadde 	.word	0xaddeadde
 8007318:	addeadde 	.word	0xaddeadde
 800731c:	addeadde 	.word	0xaddeadde
 8007320:	addeadde 	.word	0xaddeadde
 8007324:	addeadde 	.word	0xaddeadde
 8007328:	addeadde 	.word	0xaddeadde
 800732c:	addeadde 	.word	0xaddeadde
 8007330:	addeadde 	.word	0xaddeadde
 8007334:	addeadde 	.word	0xaddeadde
 8007338:	addeadde 	.word	0xaddeadde
 800733c:	addeadde 	.word	0xaddeadde
 8007340:	addeadde 	.word	0xaddeadde
 8007344:	addeadde 	.word	0xaddeadde
 8007348:	addeadde 	.word	0xaddeadde
 800734c:	addeadde 	.word	0xaddeadde
 8007350:	addeadde 	.word	0xaddeadde
 8007354:	addeadde 	.word	0xaddeadde
 8007358:	addeadde 	.word	0xaddeadde
 800735c:	addeadde 	.word	0xaddeadde
 8007360:	addeadde 	.word	0xaddeadde
 8007364:	addeadde 	.word	0xaddeadde
 8007368:	addeadde 	.word	0xaddeadde
 800736c:	addeadde 	.word	0xaddeadde
 8007370:	addeadde 	.word	0xaddeadde
 8007374:	addeadde 	.word	0xaddeadde
 8007378:	addeadde 	.word	0xaddeadde
 800737c:	addeadde 	.word	0xaddeadde
 8007380:	addeadde 	.word	0xaddeadde
 8007384:	addeadde 	.word	0xaddeadde
 8007388:	addeadde 	.word	0xaddeadde
 800738c:	addeadde 	.word	0xaddeadde
 8007390:	addeadde 	.word	0xaddeadde
 8007394:	addeadde 	.word	0xaddeadde
 8007398:	addeadde 	.word	0xaddeadde
 800739c:	addeadde 	.word	0xaddeadde
 80073a0:	addeadde 	.word	0xaddeadde
 80073a4:	addeadde 	.word	0xaddeadde
 80073a8:	addeadde 	.word	0xaddeadde
 80073ac:	addeadde 	.word	0xaddeadde
 80073b0:	addeadde 	.word	0xaddeadde
 80073b4:	addeadde 	.word	0xaddeadde
 80073b8:	addeadde 	.word	0xaddeadde
 80073bc:	addeadde 	.word	0xaddeadde
 80073c0:	addeadde 	.word	0xaddeadde
 80073c4:	addeadde 	.word	0xaddeadde
 80073c8:	addeadde 	.word	0xaddeadde
 80073cc:	addeadde 	.word	0xaddeadde
 80073d0:	addeadde 	.word	0xaddeadde
 80073d4:	addeadde 	.word	0xaddeadde
 80073d8:	addeadde 	.word	0xaddeadde
 80073dc:	addeadde 	.word	0xaddeadde
 80073e0:	addeadde 	.word	0xaddeadde
 80073e4:	addeadde 	.word	0xaddeadde
 80073e8:	addeadde 	.word	0xaddeadde
 80073ec:	addeadde 	.word	0xaddeadde
 80073f0:	addeadde 	.word	0xaddeadde
 80073f4:	addeadde 	.word	0xaddeadde
 80073f8:	addeadde 	.word	0xaddeadde
 80073fc:	addeadde 	.word	0xaddeadde
 8007400:	addeadde 	.word	0xaddeadde
 8007404:	addeadde 	.word	0xaddeadde
 8007408:	addeadde 	.word	0xaddeadde
 800740c:	addeadde 	.word	0xaddeadde
 8007410:	addeadde 	.word	0xaddeadde
 8007414:	addeadde 	.word	0xaddeadde
 8007418:	addeadde 	.word	0xaddeadde
 800741c:	addeadde 	.word	0xaddeadde
 8007420:	addeadde 	.word	0xaddeadde
 8007424:	addeadde 	.word	0xaddeadde
 8007428:	addeadde 	.word	0xaddeadde
 800742c:	addeadde 	.word	0xaddeadde
 8007430:	addeadde 	.word	0xaddeadde
 8007434:	addeadde 	.word	0xaddeadde
 8007438:	addeadde 	.word	0xaddeadde
 800743c:	addeadde 	.word	0xaddeadde
 8007440:	addeadde 	.word	0xaddeadde
 8007444:	addeadde 	.word	0xaddeadde
 8007448:	addeadde 	.word	0xaddeadde
 800744c:	addeadde 	.word	0xaddeadde
 8007450:	addeadde 	.word	0xaddeadde
 8007454:	addeadde 	.word	0xaddeadde
 8007458:	addeadde 	.word	0xaddeadde
 800745c:	addeadde 	.word	0xaddeadde
 8007460:	addeadde 	.word	0xaddeadde
 8007464:	addeadde 	.word	0xaddeadde
 8007468:	addeadde 	.word	0xaddeadde
 800746c:	addeadde 	.word	0xaddeadde
 8007470:	addeadde 	.word	0xaddeadde
 8007474:	addeadde 	.word	0xaddeadde
 8007478:	addeadde 	.word	0xaddeadde
 800747c:	addeadde 	.word	0xaddeadde
 8007480:	addeadde 	.word	0xaddeadde
 8007484:	addeadde 	.word	0xaddeadde
 8007488:	addeadde 	.word	0xaddeadde
 800748c:	addeadde 	.word	0xaddeadde
 8007490:	addeadde 	.word	0xaddeadde
 8007494:	addeadde 	.word	0xaddeadde
 8007498:	addeadde 	.word	0xaddeadde
 800749c:	addeadde 	.word	0xaddeadde
 80074a0:	addeadde 	.word	0xaddeadde
 80074a4:	addeadde 	.word	0xaddeadde
 80074a8:	addeadde 	.word	0xaddeadde
 80074ac:	addeadde 	.word	0xaddeadde
 80074b0:	addeadde 	.word	0xaddeadde
 80074b4:	addeadde 	.word	0xaddeadde
 80074b8:	addeadde 	.word	0xaddeadde
 80074bc:	addeadde 	.word	0xaddeadde
 80074c0:	addeadde 	.word	0xaddeadde
 80074c4:	addeadde 	.word	0xaddeadde
 80074c8:	addeadde 	.word	0xaddeadde
 80074cc:	addeadde 	.word	0xaddeadde
 80074d0:	addeadde 	.word	0xaddeadde
 80074d4:	addeadde 	.word	0xaddeadde
 80074d8:	addeadde 	.word	0xaddeadde
 80074dc:	addeadde 	.word	0xaddeadde
 80074e0:	addeadde 	.word	0xaddeadde
 80074e4:	addeadde 	.word	0xaddeadde
 80074e8:	addeadde 	.word	0xaddeadde
 80074ec:	addeadde 	.word	0xaddeadde
 80074f0:	addeadde 	.word	0xaddeadde
 80074f4:	addeadde 	.word	0xaddeadde
 80074f8:	addeadde 	.word	0xaddeadde
 80074fc:	addeadde 	.word	0xaddeadde
 8007500:	addeadde 	.word	0xaddeadde
 8007504:	addeadde 	.word	0xaddeadde
 8007508:	addeadde 	.word	0xaddeadde
 800750c:	addeadde 	.word	0xaddeadde
 8007510:	addeadde 	.word	0xaddeadde
 8007514:	addeadde 	.word	0xaddeadde
 8007518:	addeadde 	.word	0xaddeadde
 800751c:	addeadde 	.word	0xaddeadde
 8007520:	addeadde 	.word	0xaddeadde
 8007524:	addeadde 	.word	0xaddeadde
 8007528:	addeadde 	.word	0xaddeadde
 800752c:	addeadde 	.word	0xaddeadde
 8007530:	addeadde 	.word	0xaddeadde
 8007534:	addeadde 	.word	0xaddeadde
 8007538:	addeadde 	.word	0xaddeadde
 800753c:	addeadde 	.word	0xaddeadde
 8007540:	addeadde 	.word	0xaddeadde
 8007544:	addeadde 	.word	0xaddeadde
 8007548:	addeadde 	.word	0xaddeadde
 800754c:	addeadde 	.word	0xaddeadde
 8007550:	addeadde 	.word	0xaddeadde
 8007554:	addeadde 	.word	0xaddeadde
 8007558:	addeadde 	.word	0xaddeadde
 800755c:	addeadde 	.word	0xaddeadde
 8007560:	addeadde 	.word	0xaddeadde
 8007564:	addeadde 	.word	0xaddeadde
 8007568:	addeadde 	.word	0xaddeadde
 800756c:	addeadde 	.word	0xaddeadde
 8007570:	addeadde 	.word	0xaddeadde
 8007574:	addeadde 	.word	0xaddeadde
 8007578:	addeadde 	.word	0xaddeadde
 800757c:	addeadde 	.word	0xaddeadde
 8007580:	addeadde 	.word	0xaddeadde
 8007584:	addeadde 	.word	0xaddeadde
 8007588:	addeadde 	.word	0xaddeadde
 800758c:	addeadde 	.word	0xaddeadde
 8007590:	addeadde 	.word	0xaddeadde
 8007594:	addeadde 	.word	0xaddeadde
 8007598:	addeadde 	.word	0xaddeadde
 800759c:	addeadde 	.word	0xaddeadde
 80075a0:	addeadde 	.word	0xaddeadde
 80075a4:	addeadde 	.word	0xaddeadde
 80075a8:	addeadde 	.word	0xaddeadde
 80075ac:	addeadde 	.word	0xaddeadde
 80075b0:	addeadde 	.word	0xaddeadde
 80075b4:	addeadde 	.word	0xaddeadde
 80075b8:	addeadde 	.word	0xaddeadde
 80075bc:	addeadde 	.word	0xaddeadde
 80075c0:	addeadde 	.word	0xaddeadde
 80075c4:	addeadde 	.word	0xaddeadde
 80075c8:	addeadde 	.word	0xaddeadde
 80075cc:	addeadde 	.word	0xaddeadde
 80075d0:	addeadde 	.word	0xaddeadde
 80075d4:	addeadde 	.word	0xaddeadde
 80075d8:	addeadde 	.word	0xaddeadde
 80075dc:	addeadde 	.word	0xaddeadde
 80075e0:	addeadde 	.word	0xaddeadde
 80075e4:	addeadde 	.word	0xaddeadde
 80075e8:	addeadde 	.word	0xaddeadde
 80075ec:	addeadde 	.word	0xaddeadde
 80075f0:	addeadde 	.word	0xaddeadde
 80075f4:	addeadde 	.word	0xaddeadde
 80075f8:	addeadde 	.word	0xaddeadde
 80075fc:	addeadde 	.word	0xaddeadde
 8007600:	addeadde 	.word	0xaddeadde
 8007604:	addeadde 	.word	0xaddeadde
 8007608:	addeadde 	.word	0xaddeadde
 800760c:	addeadde 	.word	0xaddeadde
 8007610:	addeadde 	.word	0xaddeadde
 8007614:	addeadde 	.word	0xaddeadde
 8007618:	addeadde 	.word	0xaddeadde
 800761c:	addeadde 	.word	0xaddeadde
 8007620:	addeadde 	.word	0xaddeadde
 8007624:	addeadde 	.word	0xaddeadde
 8007628:	addeadde 	.word	0xaddeadde
 800762c:	addeadde 	.word	0xaddeadde
 8007630:	addeadde 	.word	0xaddeadde
 8007634:	addeadde 	.word	0xaddeadde
 8007638:	addeadde 	.word	0xaddeadde
 800763c:	addeadde 	.word	0xaddeadde
 8007640:	addeadde 	.word	0xaddeadde
 8007644:	addeadde 	.word	0xaddeadde
 8007648:	addeadde 	.word	0xaddeadde
 800764c:	addeadde 	.word	0xaddeadde
 8007650:	addeadde 	.word	0xaddeadde
 8007654:	addeadde 	.word	0xaddeadde
 8007658:	addeadde 	.word	0xaddeadde
 800765c:	addeadde 	.word	0xaddeadde
 8007660:	addeadde 	.word	0xaddeadde
 8007664:	addeadde 	.word	0xaddeadde
 8007668:	addeadde 	.word	0xaddeadde
 800766c:	addeadde 	.word	0xaddeadde
 8007670:	addeadde 	.word	0xaddeadde
 8007674:	addeadde 	.word	0xaddeadde
 8007678:	addeadde 	.word	0xaddeadde
 800767c:	addeadde 	.word	0xaddeadde
 8007680:	addeadde 	.word	0xaddeadde
 8007684:	addeadde 	.word	0xaddeadde
 8007688:	addeadde 	.word	0xaddeadde
 800768c:	addeadde 	.word	0xaddeadde
 8007690:	addeadde 	.word	0xaddeadde
 8007694:	addeadde 	.word	0xaddeadde
 8007698:	addeadde 	.word	0xaddeadde
 800769c:	addeadde 	.word	0xaddeadde
 80076a0:	addeadde 	.word	0xaddeadde
 80076a4:	addeadde 	.word	0xaddeadde
 80076a8:	addeadde 	.word	0xaddeadde
 80076ac:	addeadde 	.word	0xaddeadde
 80076b0:	addeadde 	.word	0xaddeadde
 80076b4:	addeadde 	.word	0xaddeadde
 80076b8:	addeadde 	.word	0xaddeadde
 80076bc:	addeadde 	.word	0xaddeadde
 80076c0:	addeadde 	.word	0xaddeadde
 80076c4:	addeadde 	.word	0xaddeadde
 80076c8:	addeadde 	.word	0xaddeadde
 80076cc:	addeadde 	.word	0xaddeadde
 80076d0:	addeadde 	.word	0xaddeadde
 80076d4:	addeadde 	.word	0xaddeadde
 80076d8:	addeadde 	.word	0xaddeadde
 80076dc:	addeadde 	.word	0xaddeadde
 80076e0:	addeadde 	.word	0xaddeadde
 80076e4:	addeadde 	.word	0xaddeadde
 80076e8:	addeadde 	.word	0xaddeadde
 80076ec:	addeadde 	.word	0xaddeadde
 80076f0:	addeadde 	.word	0xaddeadde
 80076f4:	addeadde 	.word	0xaddeadde
 80076f8:	addeadde 	.word	0xaddeadde
 80076fc:	addeadde 	.word	0xaddeadde
 8007700:	addeadde 	.word	0xaddeadde
 8007704:	addeadde 	.word	0xaddeadde
 8007708:	addeadde 	.word	0xaddeadde
 800770c:	addeadde 	.word	0xaddeadde
 8007710:	addeadde 	.word	0xaddeadde
 8007714:	addeadde 	.word	0xaddeadde
 8007718:	addeadde 	.word	0xaddeadde
 800771c:	addeadde 	.word	0xaddeadde
 8007720:	addeadde 	.word	0xaddeadde
 8007724:	addeadde 	.word	0xaddeadde
 8007728:	addeadde 	.word	0xaddeadde
 800772c:	addeadde 	.word	0xaddeadde
 8007730:	addeadde 	.word	0xaddeadde
 8007734:	addeadde 	.word	0xaddeadde
 8007738:	addeadde 	.word	0xaddeadde
 800773c:	addeadde 	.word	0xaddeadde
 8007740:	addeadde 	.word	0xaddeadde
 8007744:	addeadde 	.word	0xaddeadde
 8007748:	addeadde 	.word	0xaddeadde
 800774c:	addeadde 	.word	0xaddeadde
 8007750:	addeadde 	.word	0xaddeadde
 8007754:	addeadde 	.word	0xaddeadde
 8007758:	addeadde 	.word	0xaddeadde
 800775c:	addeadde 	.word	0xaddeadde
 8007760:	addeadde 	.word	0xaddeadde
 8007764:	addeadde 	.word	0xaddeadde
 8007768:	addeadde 	.word	0xaddeadde
 800776c:	addeadde 	.word	0xaddeadde
 8007770:	addeadde 	.word	0xaddeadde
 8007774:	addeadde 	.word	0xaddeadde
 8007778:	addeadde 	.word	0xaddeadde
 800777c:	addeadde 	.word	0xaddeadde
 8007780:	addeadde 	.word	0xaddeadde
 8007784:	addeadde 	.word	0xaddeadde
 8007788:	addeadde 	.word	0xaddeadde
 800778c:	addeadde 	.word	0xaddeadde
 8007790:	addeadde 	.word	0xaddeadde
 8007794:	addeadde 	.word	0xaddeadde
 8007798:	addeadde 	.word	0xaddeadde
 800779c:	addeadde 	.word	0xaddeadde
 80077a0:	addeadde 	.word	0xaddeadde
 80077a4:	addeadde 	.word	0xaddeadde
 80077a8:	addeadde 	.word	0xaddeadde
 80077ac:	addeadde 	.word	0xaddeadde
 80077b0:	addeadde 	.word	0xaddeadde
 80077b4:	addeadde 	.word	0xaddeadde
 80077b8:	addeadde 	.word	0xaddeadde
 80077bc:	addeadde 	.word	0xaddeadde
 80077c0:	addeadde 	.word	0xaddeadde
 80077c4:	addeadde 	.word	0xaddeadde
 80077c8:	addeadde 	.word	0xaddeadde
 80077cc:	addeadde 	.word	0xaddeadde
 80077d0:	addeadde 	.word	0xaddeadde
 80077d4:	addeadde 	.word	0xaddeadde
 80077d8:	addeadde 	.word	0xaddeadde
 80077dc:	addeadde 	.word	0xaddeadde
 80077e0:	addeadde 	.word	0xaddeadde
 80077e4:	addeadde 	.word	0xaddeadde
 80077e8:	addeadde 	.word	0xaddeadde
 80077ec:	addeadde 	.word	0xaddeadde
 80077f0:	addeadde 	.word	0xaddeadde
 80077f4:	addeadde 	.word	0xaddeadde
 80077f8:	addeadde 	.word	0xaddeadde
 80077fc:	addeadde 	.word	0xaddeadde
 8007800:	addeadde 	.word	0xaddeadde
 8007804:	addeadde 	.word	0xaddeadde
 8007808:	addeadde 	.word	0xaddeadde
 800780c:	addeadde 	.word	0xaddeadde
 8007810:	addeadde 	.word	0xaddeadde
 8007814:	addeadde 	.word	0xaddeadde
 8007818:	addeadde 	.word	0xaddeadde
 800781c:	addeadde 	.word	0xaddeadde
 8007820:	addeadde 	.word	0xaddeadde
 8007824:	addeadde 	.word	0xaddeadde
 8007828:	addeadde 	.word	0xaddeadde
 800782c:	addeadde 	.word	0xaddeadde
 8007830:	addeadde 	.word	0xaddeadde
 8007834:	addeadde 	.word	0xaddeadde
 8007838:	addeadde 	.word	0xaddeadde
 800783c:	addeadde 	.word	0xaddeadde
 8007840:	addeadde 	.word	0xaddeadde
 8007844:	addeadde 	.word	0xaddeadde
 8007848:	addeadde 	.word	0xaddeadde
 800784c:	addeadde 	.word	0xaddeadde
 8007850:	addeadde 	.word	0xaddeadde
 8007854:	addeadde 	.word	0xaddeadde
 8007858:	addeadde 	.word	0xaddeadde
 800785c:	addeadde 	.word	0xaddeadde
 8007860:	addeadde 	.word	0xaddeadde
 8007864:	addeadde 	.word	0xaddeadde
 8007868:	addeadde 	.word	0xaddeadde
 800786c:	addeadde 	.word	0xaddeadde
 8007870:	addeadde 	.word	0xaddeadde
 8007874:	addeadde 	.word	0xaddeadde
 8007878:	addeadde 	.word	0xaddeadde
 800787c:	addeadde 	.word	0xaddeadde
 8007880:	addeadde 	.word	0xaddeadde
 8007884:	addeadde 	.word	0xaddeadde
 8007888:	addeadde 	.word	0xaddeadde
 800788c:	addeadde 	.word	0xaddeadde
 8007890:	addeadde 	.word	0xaddeadde
 8007894:	addeadde 	.word	0xaddeadde
 8007898:	addeadde 	.word	0xaddeadde
 800789c:	addeadde 	.word	0xaddeadde
 80078a0:	addeadde 	.word	0xaddeadde
 80078a4:	addeadde 	.word	0xaddeadde
 80078a8:	addeadde 	.word	0xaddeadde
 80078ac:	addeadde 	.word	0xaddeadde
 80078b0:	addeadde 	.word	0xaddeadde
 80078b4:	addeadde 	.word	0xaddeadde
 80078b8:	addeadde 	.word	0xaddeadde
 80078bc:	addeadde 	.word	0xaddeadde
 80078c0:	addeadde 	.word	0xaddeadde
 80078c4:	addeadde 	.word	0xaddeadde
 80078c8:	addeadde 	.word	0xaddeadde
 80078cc:	addeadde 	.word	0xaddeadde
 80078d0:	addeadde 	.word	0xaddeadde
 80078d4:	addeadde 	.word	0xaddeadde
 80078d8:	addeadde 	.word	0xaddeadde
 80078dc:	addeadde 	.word	0xaddeadde
 80078e0:	addeadde 	.word	0xaddeadde
 80078e4:	addeadde 	.word	0xaddeadde
 80078e8:	addeadde 	.word	0xaddeadde
 80078ec:	addeadde 	.word	0xaddeadde
 80078f0:	addeadde 	.word	0xaddeadde
 80078f4:	addeadde 	.word	0xaddeadde
 80078f8:	addeadde 	.word	0xaddeadde
 80078fc:	addeadde 	.word	0xaddeadde
 8007900:	addeadde 	.word	0xaddeadde
 8007904:	addeadde 	.word	0xaddeadde
 8007908:	addeadde 	.word	0xaddeadde
 800790c:	addeadde 	.word	0xaddeadde
 8007910:	addeadde 	.word	0xaddeadde
 8007914:	addeadde 	.word	0xaddeadde
 8007918:	addeadde 	.word	0xaddeadde
 800791c:	addeadde 	.word	0xaddeadde
 8007920:	addeadde 	.word	0xaddeadde
 8007924:	addeadde 	.word	0xaddeadde
 8007928:	addeadde 	.word	0xaddeadde
 800792c:	addeadde 	.word	0xaddeadde
 8007930:	addeadde 	.word	0xaddeadde
 8007934:	addeadde 	.word	0xaddeadde
 8007938:	addeadde 	.word	0xaddeadde
 800793c:	addeadde 	.word	0xaddeadde
 8007940:	addeadde 	.word	0xaddeadde
 8007944:	addeadde 	.word	0xaddeadde
 8007948:	addeadde 	.word	0xaddeadde
 800794c:	addeadde 	.word	0xaddeadde
 8007950:	addeadde 	.word	0xaddeadde
 8007954:	addeadde 	.word	0xaddeadde
 8007958:	addeadde 	.word	0xaddeadde
 800795c:	addeadde 	.word	0xaddeadde
 8007960:	addeadde 	.word	0xaddeadde
 8007964:	addeadde 	.word	0xaddeadde
 8007968:	addeadde 	.word	0xaddeadde
 800796c:	addeadde 	.word	0xaddeadde
 8007970:	addeadde 	.word	0xaddeadde
 8007974:	addeadde 	.word	0xaddeadde
 8007978:	addeadde 	.word	0xaddeadde
 800797c:	addeadde 	.word	0xaddeadde
 8007980:	addeadde 	.word	0xaddeadde
 8007984:	addeadde 	.word	0xaddeadde
 8007988:	addeadde 	.word	0xaddeadde
 800798c:	addeadde 	.word	0xaddeadde
 8007990:	addeadde 	.word	0xaddeadde
 8007994:	addeadde 	.word	0xaddeadde
 8007998:	addeadde 	.word	0xaddeadde
 800799c:	addeadde 	.word	0xaddeadde
 80079a0:	addeadde 	.word	0xaddeadde
 80079a4:	addeadde 	.word	0xaddeadde
 80079a8:	addeadde 	.word	0xaddeadde
 80079ac:	addeadde 	.word	0xaddeadde
 80079b0:	addeadde 	.word	0xaddeadde
 80079b4:	addeadde 	.word	0xaddeadde
 80079b8:	addeadde 	.word	0xaddeadde
 80079bc:	addeadde 	.word	0xaddeadde
 80079c0:	addeadde 	.word	0xaddeadde
 80079c4:	addeadde 	.word	0xaddeadde
 80079c8:	addeadde 	.word	0xaddeadde
 80079cc:	addeadde 	.word	0xaddeadde
 80079d0:	addeadde 	.word	0xaddeadde
 80079d4:	addeadde 	.word	0xaddeadde
 80079d8:	addeadde 	.word	0xaddeadde
 80079dc:	addeadde 	.word	0xaddeadde
 80079e0:	addeadde 	.word	0xaddeadde
 80079e4:	addeadde 	.word	0xaddeadde
 80079e8:	addeadde 	.word	0xaddeadde
 80079ec:	addeadde 	.word	0xaddeadde
 80079f0:	addeadde 	.word	0xaddeadde
 80079f4:	addeadde 	.word	0xaddeadde
 80079f8:	addeadde 	.word	0xaddeadde
 80079fc:	addeadde 	.word	0xaddeadde
 8007a00:	addeadde 	.word	0xaddeadde
 8007a04:	addeadde 	.word	0xaddeadde
 8007a08:	addeadde 	.word	0xaddeadde
 8007a0c:	addeadde 	.word	0xaddeadde
 8007a10:	addeadde 	.word	0xaddeadde
 8007a14:	addeadde 	.word	0xaddeadde
 8007a18:	addeadde 	.word	0xaddeadde
 8007a1c:	addeadde 	.word	0xaddeadde
 8007a20:	addeadde 	.word	0xaddeadde
 8007a24:	addeadde 	.word	0xaddeadde
 8007a28:	addeadde 	.word	0xaddeadde
 8007a2c:	addeadde 	.word	0xaddeadde
 8007a30:	addeadde 	.word	0xaddeadde
 8007a34:	addeadde 	.word	0xaddeadde
 8007a38:	addeadde 	.word	0xaddeadde
 8007a3c:	addeadde 	.word	0xaddeadde
 8007a40:	addeadde 	.word	0xaddeadde
 8007a44:	addeadde 	.word	0xaddeadde
 8007a48:	addeadde 	.word	0xaddeadde
 8007a4c:	addeadde 	.word	0xaddeadde
 8007a50:	addeadde 	.word	0xaddeadde
 8007a54:	addeadde 	.word	0xaddeadde
 8007a58:	addeadde 	.word	0xaddeadde
 8007a5c:	addeadde 	.word	0xaddeadde
 8007a60:	addeadde 	.word	0xaddeadde
 8007a64:	addeadde 	.word	0xaddeadde
 8007a68:	addeadde 	.word	0xaddeadde
 8007a6c:	addeadde 	.word	0xaddeadde
 8007a70:	addeadde 	.word	0xaddeadde
 8007a74:	addeadde 	.word	0xaddeadde
 8007a78:	addeadde 	.word	0xaddeadde
 8007a7c:	addeadde 	.word	0xaddeadde
 8007a80:	addeadde 	.word	0xaddeadde
 8007a84:	addeadde 	.word	0xaddeadde
 8007a88:	addeadde 	.word	0xaddeadde
 8007a8c:	addeadde 	.word	0xaddeadde
 8007a90:	addeadde 	.word	0xaddeadde
 8007a94:	addeadde 	.word	0xaddeadde
 8007a98:	addeadde 	.word	0xaddeadde
 8007a9c:	addeadde 	.word	0xaddeadde
 8007aa0:	addeadde 	.word	0xaddeadde
 8007aa4:	addeadde 	.word	0xaddeadde
 8007aa8:	addeadde 	.word	0xaddeadde
 8007aac:	addeadde 	.word	0xaddeadde
 8007ab0:	addeadde 	.word	0xaddeadde
 8007ab4:	addeadde 	.word	0xaddeadde
 8007ab8:	addeadde 	.word	0xaddeadde
 8007abc:	addeadde 	.word	0xaddeadde
 8007ac0:	addeadde 	.word	0xaddeadde
 8007ac4:	addeadde 	.word	0xaddeadde
 8007ac8:	addeadde 	.word	0xaddeadde
 8007acc:	addeadde 	.word	0xaddeadde
 8007ad0:	addeadde 	.word	0xaddeadde
 8007ad4:	addeadde 	.word	0xaddeadde
 8007ad8:	addeadde 	.word	0xaddeadde
 8007adc:	addeadde 	.word	0xaddeadde
 8007ae0:	addeadde 	.word	0xaddeadde
 8007ae4:	addeadde 	.word	0xaddeadde
 8007ae8:	addeadde 	.word	0xaddeadde
 8007aec:	addeadde 	.word	0xaddeadde
 8007af0:	addeadde 	.word	0xaddeadde
 8007af4:	addeadde 	.word	0xaddeadde
 8007af8:	addeadde 	.word	0xaddeadde
 8007afc:	addeadde 	.word	0xaddeadde
 8007b00:	addeadde 	.word	0xaddeadde
 8007b04:	addeadde 	.word	0xaddeadde
 8007b08:	addeadde 	.word	0xaddeadde
 8007b0c:	addeadde 	.word	0xaddeadde
 8007b10:	addeadde 	.word	0xaddeadde
 8007b14:	addeadde 	.word	0xaddeadde
 8007b18:	addeadde 	.word	0xaddeadde
 8007b1c:	addeadde 	.word	0xaddeadde
 8007b20:	addeadde 	.word	0xaddeadde
 8007b24:	addeadde 	.word	0xaddeadde
 8007b28:	addeadde 	.word	0xaddeadde
 8007b2c:	addeadde 	.word	0xaddeadde
 8007b30:	addeadde 	.word	0xaddeadde
 8007b34:	addeadde 	.word	0xaddeadde
 8007b38:	addeadde 	.word	0xaddeadde
 8007b3c:	addeadde 	.word	0xaddeadde
 8007b40:	addeadde 	.word	0xaddeadde
 8007b44:	addeadde 	.word	0xaddeadde
 8007b48:	addeadde 	.word	0xaddeadde
 8007b4c:	addeadde 	.word	0xaddeadde
 8007b50:	addeadde 	.word	0xaddeadde
 8007b54:	addeadde 	.word	0xaddeadde
 8007b58:	addeadde 	.word	0xaddeadde
 8007b5c:	addeadde 	.word	0xaddeadde
 8007b60:	addeadde 	.word	0xaddeadde
 8007b64:	addeadde 	.word	0xaddeadde
 8007b68:	addeadde 	.word	0xaddeadde
 8007b6c:	addeadde 	.word	0xaddeadde
 8007b70:	addeadde 	.word	0xaddeadde
 8007b74:	addeadde 	.word	0xaddeadde
 8007b78:	addeadde 	.word	0xaddeadde
 8007b7c:	addeadde 	.word	0xaddeadde
 8007b80:	addeadde 	.word	0xaddeadde
 8007b84:	addeadde 	.word	0xaddeadde
 8007b88:	addeadde 	.word	0xaddeadde
 8007b8c:	addeadde 	.word	0xaddeadde
 8007b90:	addeadde 	.word	0xaddeadde
 8007b94:	addeadde 	.word	0xaddeadde
 8007b98:	addeadde 	.word	0xaddeadde
 8007b9c:	addeadde 	.word	0xaddeadde
 8007ba0:	addeadde 	.word	0xaddeadde
 8007ba4:	addeadde 	.word	0xaddeadde
 8007ba8:	addeadde 	.word	0xaddeadde
 8007bac:	addeadde 	.word	0xaddeadde
 8007bb0:	addeadde 	.word	0xaddeadde
 8007bb4:	addeadde 	.word	0xaddeadde
 8007bb8:	addeadde 	.word	0xaddeadde
 8007bbc:	addeadde 	.word	0xaddeadde
 8007bc0:	addeadde 	.word	0xaddeadde
 8007bc4:	addeadde 	.word	0xaddeadde
 8007bc8:	addeadde 	.word	0xaddeadde
 8007bcc:	addeadde 	.word	0xaddeadde
 8007bd0:	addeadde 	.word	0xaddeadde
 8007bd4:	addeadde 	.word	0xaddeadde
 8007bd8:	addeadde 	.word	0xaddeadde
 8007bdc:	addeadde 	.word	0xaddeadde
 8007be0:	addeadde 	.word	0xaddeadde
 8007be4:	addeadde 	.word	0xaddeadde
 8007be8:	addeadde 	.word	0xaddeadde
 8007bec:	addeadde 	.word	0xaddeadde
 8007bf0:	addeadde 	.word	0xaddeadde
 8007bf4:	addeadde 	.word	0xaddeadde
 8007bf8:	addeadde 	.word	0xaddeadde
 8007bfc:	addeadde 	.word	0xaddeadde
 8007c00:	addeadde 	.word	0xaddeadde
 8007c04:	addeadde 	.word	0xaddeadde
 8007c08:	addeadde 	.word	0xaddeadde
 8007c0c:	addeadde 	.word	0xaddeadde
 8007c10:	addeadde 	.word	0xaddeadde
 8007c14:	addeadde 	.word	0xaddeadde
 8007c18:	addeadde 	.word	0xaddeadde
 8007c1c:	addeadde 	.word	0xaddeadde
 8007c20:	addeadde 	.word	0xaddeadde
 8007c24:	addeadde 	.word	0xaddeadde
 8007c28:	addeadde 	.word	0xaddeadde
 8007c2c:	addeadde 	.word	0xaddeadde
 8007c30:	addeadde 	.word	0xaddeadde
 8007c34:	addeadde 	.word	0xaddeadde
 8007c38:	addeadde 	.word	0xaddeadde
 8007c3c:	addeadde 	.word	0xaddeadde
 8007c40:	addeadde 	.word	0xaddeadde
 8007c44:	addeadde 	.word	0xaddeadde
 8007c48:	addeadde 	.word	0xaddeadde
 8007c4c:	addeadde 	.word	0xaddeadde
 8007c50:	addeadde 	.word	0xaddeadde
 8007c54:	addeadde 	.word	0xaddeadde
 8007c58:	addeadde 	.word	0xaddeadde
 8007c5c:	addeadde 	.word	0xaddeadde
 8007c60:	addeadde 	.word	0xaddeadde
 8007c64:	addeadde 	.word	0xaddeadde
 8007c68:	addeadde 	.word	0xaddeadde
 8007c6c:	addeadde 	.word	0xaddeadde
 8007c70:	addeadde 	.word	0xaddeadde
 8007c74:	addeadde 	.word	0xaddeadde
 8007c78:	addeadde 	.word	0xaddeadde
 8007c7c:	addeadde 	.word	0xaddeadde
 8007c80:	addeadde 	.word	0xaddeadde
 8007c84:	addeadde 	.word	0xaddeadde
 8007c88:	addeadde 	.word	0xaddeadde
 8007c8c:	addeadde 	.word	0xaddeadde
 8007c90:	addeadde 	.word	0xaddeadde
 8007c94:	addeadde 	.word	0xaddeadde
 8007c98:	addeadde 	.word	0xaddeadde
 8007c9c:	addeadde 	.word	0xaddeadde
 8007ca0:	addeadde 	.word	0xaddeadde
 8007ca4:	addeadde 	.word	0xaddeadde
 8007ca8:	addeadde 	.word	0xaddeadde
 8007cac:	addeadde 	.word	0xaddeadde
 8007cb0:	addeadde 	.word	0xaddeadde
 8007cb4:	addeadde 	.word	0xaddeadde
 8007cb8:	addeadde 	.word	0xaddeadde
 8007cbc:	addeadde 	.word	0xaddeadde
 8007cc0:	addeadde 	.word	0xaddeadde
 8007cc4:	addeadde 	.word	0xaddeadde
 8007cc8:	addeadde 	.word	0xaddeadde
 8007ccc:	addeadde 	.word	0xaddeadde
 8007cd0:	addeadde 	.word	0xaddeadde
 8007cd4:	addeadde 	.word	0xaddeadde
 8007cd8:	addeadde 	.word	0xaddeadde
 8007cdc:	addeadde 	.word	0xaddeadde
 8007ce0:	addeadde 	.word	0xaddeadde
 8007ce4:	addeadde 	.word	0xaddeadde
 8007ce8:	addeadde 	.word	0xaddeadde
 8007cec:	addeadde 	.word	0xaddeadde
 8007cf0:	addeadde 	.word	0xaddeadde
 8007cf4:	addeadde 	.word	0xaddeadde
 8007cf8:	addeadde 	.word	0xaddeadde
 8007cfc:	addeadde 	.word	0xaddeadde
 8007d00:	addeadde 	.word	0xaddeadde
 8007d04:	addeadde 	.word	0xaddeadde
 8007d08:	addeadde 	.word	0xaddeadde
 8007d0c:	addeadde 	.word	0xaddeadde
 8007d10:	addeadde 	.word	0xaddeadde
 8007d14:	addeadde 	.word	0xaddeadde
 8007d18:	addeadde 	.word	0xaddeadde
 8007d1c:	addeadde 	.word	0xaddeadde
 8007d20:	addeadde 	.word	0xaddeadde
 8007d24:	addeadde 	.word	0xaddeadde
 8007d28:	addeadde 	.word	0xaddeadde
 8007d2c:	addeadde 	.word	0xaddeadde
 8007d30:	addeadde 	.word	0xaddeadde
 8007d34:	addeadde 	.word	0xaddeadde
 8007d38:	addeadde 	.word	0xaddeadde
 8007d3c:	addeadde 	.word	0xaddeadde
 8007d40:	addeadde 	.word	0xaddeadde
 8007d44:	addeadde 	.word	0xaddeadde
 8007d48:	addeadde 	.word	0xaddeadde
 8007d4c:	addeadde 	.word	0xaddeadde
 8007d50:	addeadde 	.word	0xaddeadde
 8007d54:	addeadde 	.word	0xaddeadde
 8007d58:	addeadde 	.word	0xaddeadde
 8007d5c:	addeadde 	.word	0xaddeadde
 8007d60:	addeadde 	.word	0xaddeadde
 8007d64:	addeadde 	.word	0xaddeadde
 8007d68:	addeadde 	.word	0xaddeadde
 8007d6c:	addeadde 	.word	0xaddeadde
 8007d70:	addeadde 	.word	0xaddeadde
 8007d74:	addeadde 	.word	0xaddeadde
 8007d78:	addeadde 	.word	0xaddeadde
 8007d7c:	addeadde 	.word	0xaddeadde
 8007d80:	addeadde 	.word	0xaddeadde
 8007d84:	addeadde 	.word	0xaddeadde
 8007d88:	addeadde 	.word	0xaddeadde
 8007d8c:	addeadde 	.word	0xaddeadde
 8007d90:	addeadde 	.word	0xaddeadde
 8007d94:	addeadde 	.word	0xaddeadde
 8007d98:	addeadde 	.word	0xaddeadde
 8007d9c:	addeadde 	.word	0xaddeadde
 8007da0:	addeadde 	.word	0xaddeadde
 8007da4:	addeadde 	.word	0xaddeadde
 8007da8:	addeadde 	.word	0xaddeadde
 8007dac:	addeadde 	.word	0xaddeadde
 8007db0:	addeadde 	.word	0xaddeadde
 8007db4:	addeadde 	.word	0xaddeadde
 8007db8:	addeadde 	.word	0xaddeadde
 8007dbc:	addeadde 	.word	0xaddeadde
 8007dc0:	addeadde 	.word	0xaddeadde
 8007dc4:	addeadde 	.word	0xaddeadde
 8007dc8:	addeadde 	.word	0xaddeadde
 8007dcc:	addeadde 	.word	0xaddeadde
 8007dd0:	addeadde 	.word	0xaddeadde
 8007dd4:	addeadde 	.word	0xaddeadde
 8007dd8:	addeadde 	.word	0xaddeadde
 8007ddc:	addeadde 	.word	0xaddeadde
 8007de0:	addeadde 	.word	0xaddeadde
 8007de4:	addeadde 	.word	0xaddeadde
 8007de8:	addeadde 	.word	0xaddeadde
 8007dec:	addeadde 	.word	0xaddeadde
 8007df0:	addeadde 	.word	0xaddeadde
 8007df4:	addeadde 	.word	0xaddeadde
 8007df8:	addeadde 	.word	0xaddeadde
 8007dfc:	addeadde 	.word	0xaddeadde
 8007e00:	addeadde 	.word	0xaddeadde
 8007e04:	addeadde 	.word	0xaddeadde
 8007e08:	addeadde 	.word	0xaddeadde
 8007e0c:	addeadde 	.word	0xaddeadde
 8007e10:	addeadde 	.word	0xaddeadde
 8007e14:	addeadde 	.word	0xaddeadde
 8007e18:	addeadde 	.word	0xaddeadde
 8007e1c:	addeadde 	.word	0xaddeadde
 8007e20:	addeadde 	.word	0xaddeadde
 8007e24:	addeadde 	.word	0xaddeadde
 8007e28:	addeadde 	.word	0xaddeadde
 8007e2c:	addeadde 	.word	0xaddeadde
 8007e30:	addeadde 	.word	0xaddeadde
 8007e34:	addeadde 	.word	0xaddeadde
 8007e38:	addeadde 	.word	0xaddeadde
 8007e3c:	addeadde 	.word	0xaddeadde
 8007e40:	addeadde 	.word	0xaddeadde
 8007e44:	addeadde 	.word	0xaddeadde
 8007e48:	addeadde 	.word	0xaddeadde
 8007e4c:	addeadde 	.word	0xaddeadde
 8007e50:	addeadde 	.word	0xaddeadde
 8007e54:	addeadde 	.word	0xaddeadde
 8007e58:	addeadde 	.word	0xaddeadde
 8007e5c:	addeadde 	.word	0xaddeadde
 8007e60:	addeadde 	.word	0xaddeadde
 8007e64:	addeadde 	.word	0xaddeadde
 8007e68:	addeadde 	.word	0xaddeadde
 8007e6c:	addeadde 	.word	0xaddeadde
 8007e70:	addeadde 	.word	0xaddeadde
 8007e74:	addeadde 	.word	0xaddeadde
 8007e78:	addeadde 	.word	0xaddeadde
 8007e7c:	addeadde 	.word	0xaddeadde
 8007e80:	addeadde 	.word	0xaddeadde
 8007e84:	addeadde 	.word	0xaddeadde
 8007e88:	addeadde 	.word	0xaddeadde
 8007e8c:	addeadde 	.word	0xaddeadde
 8007e90:	addeadde 	.word	0xaddeadde
 8007e94:	addeadde 	.word	0xaddeadde
 8007e98:	addeadde 	.word	0xaddeadde
 8007e9c:	addeadde 	.word	0xaddeadde
 8007ea0:	addeadde 	.word	0xaddeadde
 8007ea4:	addeadde 	.word	0xaddeadde
 8007ea8:	addeadde 	.word	0xaddeadde
 8007eac:	addeadde 	.word	0xaddeadde
 8007eb0:	addeadde 	.word	0xaddeadde
 8007eb4:	addeadde 	.word	0xaddeadde
 8007eb8:	addeadde 	.word	0xaddeadde
 8007ebc:	addeadde 	.word	0xaddeadde
 8007ec0:	addeadde 	.word	0xaddeadde
 8007ec4:	addeadde 	.word	0xaddeadde
 8007ec8:	addeadde 	.word	0xaddeadde
 8007ecc:	addeadde 	.word	0xaddeadde
 8007ed0:	addeadde 	.word	0xaddeadde
 8007ed4:	addeadde 	.word	0xaddeadde
 8007ed8:	addeadde 	.word	0xaddeadde
 8007edc:	addeadde 	.word	0xaddeadde
 8007ee0:	addeadde 	.word	0xaddeadde
 8007ee4:	addeadde 	.word	0xaddeadde
 8007ee8:	addeadde 	.word	0xaddeadde
 8007eec:	addeadde 	.word	0xaddeadde
 8007ef0:	addeadde 	.word	0xaddeadde
 8007ef4:	addeadde 	.word	0xaddeadde
 8007ef8:	addeadde 	.word	0xaddeadde
 8007efc:	addeadde 	.word	0xaddeadde
 8007f00:	addeadde 	.word	0xaddeadde
 8007f04:	addeadde 	.word	0xaddeadde
 8007f08:	addeadde 	.word	0xaddeadde
 8007f0c:	addeadde 	.word	0xaddeadde
 8007f10:	addeadde 	.word	0xaddeadde
 8007f14:	addeadde 	.word	0xaddeadde
 8007f18:	addeadde 	.word	0xaddeadde
 8007f1c:	addeadde 	.word	0xaddeadde
 8007f20:	addeadde 	.word	0xaddeadde
 8007f24:	addeadde 	.word	0xaddeadde
 8007f28:	addeadde 	.word	0xaddeadde
 8007f2c:	addeadde 	.word	0xaddeadde
 8007f30:	addeadde 	.word	0xaddeadde
 8007f34:	addeadde 	.word	0xaddeadde
 8007f38:	addeadde 	.word	0xaddeadde
 8007f3c:	addeadde 	.word	0xaddeadde
 8007f40:	addeadde 	.word	0xaddeadde
 8007f44:	addeadde 	.word	0xaddeadde
 8007f48:	addeadde 	.word	0xaddeadde
 8007f4c:	addeadde 	.word	0xaddeadde
 8007f50:	addeadde 	.word	0xaddeadde
 8007f54:	addeadde 	.word	0xaddeadde
 8007f58:	addeadde 	.word	0xaddeadde
 8007f5c:	addeadde 	.word	0xaddeadde
 8007f60:	addeadde 	.word	0xaddeadde
 8007f64:	addeadde 	.word	0xaddeadde
 8007f68:	addeadde 	.word	0xaddeadde
 8007f6c:	addeadde 	.word	0xaddeadde
 8007f70:	addeadde 	.word	0xaddeadde
 8007f74:	addeadde 	.word	0xaddeadde
 8007f78:	addeadde 	.word	0xaddeadde
 8007f7c:	addeadde 	.word	0xaddeadde
 8007f80:	addeadde 	.word	0xaddeadde
 8007f84:	addeadde 	.word	0xaddeadde
 8007f88:	addeadde 	.word	0xaddeadde
 8007f8c:	addeadde 	.word	0xaddeadde
 8007f90:	addeadde 	.word	0xaddeadde
 8007f94:	addeadde 	.word	0xaddeadde
 8007f98:	addeadde 	.word	0xaddeadde
 8007f9c:	addeadde 	.word	0xaddeadde
 8007fa0:	addeadde 	.word	0xaddeadde
 8007fa4:	addeadde 	.word	0xaddeadde
 8007fa8:	addeadde 	.word	0xaddeadde
 8007fac:	addeadde 	.word	0xaddeadde
 8007fb0:	addeadde 	.word	0xaddeadde
 8007fb4:	addeadde 	.word	0xaddeadde
 8007fb8:	addeadde 	.word	0xaddeadde
 8007fbc:	addeadde 	.word	0xaddeadde
 8007fc0:	addeadde 	.word	0xaddeadde
 8007fc4:	addeadde 	.word	0xaddeadde
 8007fc8:	addeadde 	.word	0xaddeadde
 8007fcc:	addeadde 	.word	0xaddeadde
 8007fd0:	addeadde 	.word	0xaddeadde
 8007fd4:	addeadde 	.word	0xaddeadde
 8007fd8:	addeadde 	.word	0xaddeadde
 8007fdc:	addeadde 	.word	0xaddeadde
 8007fe0:	addeadde 	.word	0xaddeadde
 8007fe4:	addeadde 	.word	0xaddeadde
 8007fe8:	addeadde 	.word	0xaddeadde
 8007fec:	addeadde 	.word	0xaddeadde
 8007ff0:	addeadde 	.word	0xaddeadde
 8007ff4:	addeadde 	.word	0xaddeadde
 8007ff8:	addeadde 	.word	0xaddeadde
 8007ffc:	addeadde 	.word	0xaddeadde

Disassembly of section .text:

08008000 <MPU_SytemCall_1>:
}



void MPU_SytemCall_1()
{
 8008000:	b508      	push	{r3, lr}
BaseType_t xPortRaisePrivilege( void ) /* FREERTOS_SYSTEM_CALL */
{
    BaseType_t xRunningPrivileged;

    /* Check whether the processor is already privileged. */
    xRunningPrivileged = portIS_PRIVILEGED();
 8008002:	f001 fe3d 	bl	8009c80 <xIsPrivileged>

    /* If the processor is not already privileged, raise privilege. */
    if( xRunningPrivileged == pdFALSE )
 8008006:	b930      	cbnz	r0, 8008016 <MPU_SytemCall_1+0x16>
    {
        portRAISE_PRIVILEGE();
 8008008:	df02      	svc	2

	BaseType_t xRunningPrivileged = xPortRaisePrivilege();

	SytemCall_1_code();
 800800a:	f00a fa6f 	bl	80124ec <SytemCall_1_code>

	vPortResetPrivilege( xRunningPrivileged );

}
 800800e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

void vPortResetPrivilege( BaseType_t xRunningPrivileged )
{
    if( xRunningPrivileged == pdFALSE )
    {
        portRESET_PRIVILEGE();
 8008012:	f001 be3d 	b.w	8009c90 <vResetPrivilege>
 8008016:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	SytemCall_1_code();
 800801a:	f00a ba67 	b.w	80124ec <SytemCall_1_code>
 800801e:	bf00      	nop

08008020 <MPU_SytemCall_2>:


void MPU_SytemCall_2()
{
 8008020:	b508      	push	{r3, lr}
    xRunningPrivileged = portIS_PRIVILEGED();
 8008022:	f001 fe2d 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008026:	b930      	cbnz	r0, 8008036 <MPU_SytemCall_2+0x16>
        portRAISE_PRIVILEGE();
 8008028:	df02      	svc	2

	BaseType_t xRunningPrivileged = xPortRaisePrivilege();

	SytemCall_2_code();
 800802a:	f00a fa95 	bl	8012558 <SytemCall_2_code>

	vPortResetPrivilege( xRunningPrivileged );

}
 800802e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        portRESET_PRIVILEGE();
 8008032:	f001 be2d 	b.w	8009c90 <vResetPrivilege>
 8008036:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	SytemCall_2_code();
 800803a:	f00a ba8d 	b.w	8012558 <SytemCall_2_code>
 800803e:	bf00      	nop

08008040 <MPU_SytemCall_3>:


void MPU_SytemCall_3()
{
 8008040:	b508      	push	{r3, lr}
    xRunningPrivileged = portIS_PRIVILEGED();
 8008042:	f001 fe1d 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008046:	b930      	cbnz	r0, 8008056 <MPU_SytemCall_3+0x16>
        portRAISE_PRIVILEGE();
 8008048:	df02      	svc	2

	BaseType_t xRunningPrivileged = xPortRaisePrivilege();

	SytemCall_3_code();
 800804a:	f001 fa6f 	bl	800952c <SytemCall_3_code>

	vPortResetPrivilege( xRunningPrivileged );

}
 800804e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        portRESET_PRIVILEGE();
 8008052:	f001 be1d 	b.w	8009c90 <vResetPrivilege>
 8008056:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	SytemCall_3_code();
 800805a:	f001 ba67 	b.w	800952c <SytemCall_3_code>
 800805e:	bf00      	nop

08008060 <MPU_SytemCall_4>:



void MPU_SytemCall_4(void *val)
{
 8008060:	b510      	push	{r4, lr}
 8008062:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008064:	f001 fe0c 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008068:	b938      	cbnz	r0, 800807a <MPU_SytemCall_4+0x1a>
        portRAISE_PRIVILEGE();
 800806a:	df02      	svc	2

	BaseType_t xRunningPrivileged = xPortRaisePrivilege();

	SytemCall_4_code(val);
 800806c:	4620      	mov	r0, r4
 800806e:	f001 fa5f 	bl	8009530 <SytemCall_4_code>

	vPortResetPrivilege( xRunningPrivileged );

}
 8008072:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 8008076:	f001 be0b 	b.w	8009c90 <vResetPrivilege>
	SytemCall_4_code(val);
 800807a:	4620      	mov	r0, r4
}
 800807c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SytemCall_4_code(val);
 8008080:	f001 ba56 	b.w	8009530 <SytemCall_4_code>

08008084 <MPU_SytemCall_5>:

void MPU_SytemCall_5(void *val)
{
 8008084:	b510      	push	{r4, lr}
 8008086:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008088:	f001 fdfa 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 800808c:	b938      	cbnz	r0, 800809e <MPU_SytemCall_5+0x1a>
        portRAISE_PRIVILEGE();
 800808e:	df02      	svc	2

	BaseType_t xRunningPrivileged = xPortRaisePrivilege();

	SytemCall_5_code(val);
 8008090:	4620      	mov	r0, r4
 8008092:	f001 fa4f 	bl	8009534 <SytemCall_5_code>

	vPortResetPrivilege( xRunningPrivileged );

}
 8008096:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 800809a:	f001 bdf9 	b.w	8009c90 <vResetPrivilege>
	SytemCall_5_code(val);
 800809e:	4620      	mov	r0, r4
}
 80080a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SytemCall_5_code(val);
 80080a4:	f001 ba46 	b.w	8009534 <SytemCall_5_code>

080080a8 <MPU_xTaskCreate>:
                                const char * const pcName,
                                uint16_t usStackDepth,
                                void * pvParameters,
                                UBaseType_t uxPriority,
                                TaskHandle_t * pxCreatedTask ) /* FREERTOS_SYSTEM_CALL */
    {
 80080a8:	b570      	push	{r4, r5, r6, lr}
 80080aa:	b086      	sub	sp, #24
 80080ac:	4604      	mov	r4, r0
 80080ae:	e9cd 2104 	strd	r2, r1, [sp, #16]
 80080b2:	9303      	str	r3, [sp, #12]
 80080b4:	e9dd 560a 	ldrd	r5, r6, [sp, #40]	; 0x28
    xRunningPrivileged = portIS_PRIVILEGED();
 80080b8:	f001 fde2 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80080bc:	9905      	ldr	r1, [sp, #20]
 80080be:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 80080c2:	b138      	cbz	r0, 80080d4 <MPU_xTaskCreate+0x2c>
        BaseType_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        xReturn = xTaskCreate( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask );
 80080c4:	4620      	mov	r0, r4
 80080c6:	960b      	str	r6, [sp, #44]	; 0x2c
 80080c8:	950a      	str	r5, [sp, #40]	; 0x28
        vPortResetPrivilege( xRunningPrivileged );
        return xReturn;
    }
 80080ca:	b006      	add	sp, #24
 80080cc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        xReturn = xTaskCreate( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask );
 80080d0:	f7fa be90 	b.w	8002df4 <xTaskCreate>
        portRAISE_PRIVILEGE();
 80080d4:	df02      	svc	2
        xReturn = xTaskCreate( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask );
 80080d6:	4620      	mov	r0, r4
 80080d8:	9601      	str	r6, [sp, #4]
 80080da:	9500      	str	r5, [sp, #0]
 80080dc:	f7fa fe8a 	bl	8002df4 <xTaskCreate>
 80080e0:	9003      	str	r0, [sp, #12]
        portRESET_PRIVILEGE();
 80080e2:	f001 fdd5 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 80080e6:	9803      	ldr	r0, [sp, #12]
    }
 80080e8:	b006      	add	sp, #24
 80080ea:	bd70      	pop	{r4, r5, r6, pc}

080080ec <MPU_xTaskCreateStatic>:
                                        const uint32_t ulStackDepth,
                                        void * const pvParameters,
                                        UBaseType_t uxPriority,
                                        StackType_t * const puxStackBuffer,
                                        StaticTask_t * const pxTaskBuffer ) /* FREERTOS_SYSTEM_CALL */
    {
 80080ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 80080ee:	b089      	sub	sp, #36	; 0x24
 80080f0:	4604      	mov	r4, r0
 80080f2:	e9cd 2106 	strd	r2, r1, [sp, #24]
 80080f6:	9305      	str	r3, [sp, #20]
 80080f8:	9f10      	ldr	r7, [sp, #64]	; 0x40
 80080fa:	e9dd 560e 	ldrd	r5, r6, [sp, #56]	; 0x38
    xRunningPrivileged = portIS_PRIVILEGED();
 80080fe:	f001 fdbf 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008102:	9907      	ldr	r1, [sp, #28]
 8008104:	e9dd 3205 	ldrd	r3, r2, [sp, #20]
 8008108:	b140      	cbz	r0, 800811c <MPU_xTaskCreateStatic+0x30>
        TaskHandle_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        xReturn = xTaskCreateStatic( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, puxStackBuffer, pxTaskBuffer );
 800810a:	4620      	mov	r0, r4
 800810c:	950e      	str	r5, [sp, #56]	; 0x38
 800810e:	e9cd 670f 	strd	r6, r7, [sp, #60]	; 0x3c
        vPortResetPrivilege( xRunningPrivileged );
        return xReturn;
    }
 8008112:	b009      	add	sp, #36	; 0x24
 8008114:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
        xReturn = xTaskCreateStatic( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, puxStackBuffer, pxTaskBuffer );
 8008118:	f7fa bea2 	b.w	8002e60 <xTaskCreateStatic>
        portRAISE_PRIVILEGE();
 800811c:	df02      	svc	2
        xReturn = xTaskCreateStatic( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, puxStackBuffer, pxTaskBuffer );
 800811e:	4620      	mov	r0, r4
 8008120:	9500      	str	r5, [sp, #0]
 8008122:	e9cd 6701 	strd	r6, r7, [sp, #4]
 8008126:	f7fa fe9b 	bl	8002e60 <xTaskCreateStatic>
 800812a:	9005      	str	r0, [sp, #20]
        portRESET_PRIVILEGE();
 800812c:	f001 fdb0 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008130:	9805      	ldr	r0, [sp, #20]
    }
 8008132:	b009      	add	sp, #36	; 0x24
 8008134:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008136:	bf00      	nop

08008138 <MPU_vTaskDelete>:
#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )
    void MPU_vTaskDelete( TaskHandle_t pxTaskToDelete ) /* FREERTOS_SYSTEM_CALL */
    {
 8008138:	b510      	push	{r4, lr}
 800813a:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 800813c:	f001 fda0 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008140:	b938      	cbnz	r0, 8008152 <MPU_vTaskDelete+0x1a>
        portRAISE_PRIVILEGE();
 8008142:	df02      	svc	2
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        vTaskDelete( pxTaskToDelete );
 8008144:	4620      	mov	r0, r4
 8008146:	f7fa ff41 	bl	8002fcc <vTaskDelete>
        vPortResetPrivilege( xRunningPrivileged );
    }
 800814a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 800814e:	f001 bd9f 	b.w	8009c90 <vResetPrivilege>
        vTaskDelete( pxTaskToDelete );
 8008152:	4620      	mov	r0, r4
    }
 8008154:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        vTaskDelete( pxTaskToDelete );
 8008158:	f7fa bf38 	b.w	8002fcc <vTaskDelete>

0800815c <MPU_vTaskDelay>:
#endif
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )
    void MPU_vTaskDelay( TickType_t xTicksToDelay ) /* FREERTOS_SYSTEM_CALL */
    {
 800815c:	b510      	push	{r4, lr}
 800815e:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008160:	f001 fd8e 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008164:	b938      	cbnz	r0, 8008176 <MPU_vTaskDelay+0x1a>
        portRAISE_PRIVILEGE();
 8008166:	df02      	svc	2
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        vTaskDelay( xTicksToDelay );
 8008168:	4620      	mov	r0, r4
 800816a:	f7fb ff3f 	bl	8003fec <vTaskDelay>
        vPortResetPrivilege( xRunningPrivileged );
    }
 800816e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 8008172:	f001 bd8d 	b.w	8009c90 <vResetPrivilege>
        vTaskDelay( xTicksToDelay );
 8008176:	4620      	mov	r0, r4
    }
 8008178:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        vTaskDelay( xTicksToDelay );
 800817c:	f7fb bf36 	b.w	8003fec <vTaskDelay>

08008180 <MPU_xTaskDelayUntil>:
    {
 8008180:	b510      	push	{r4, lr}
 8008182:	b082      	sub	sp, #8
 8008184:	4604      	mov	r4, r0
 8008186:	9101      	str	r1, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008188:	f001 fd7a 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 800818c:	9901      	ldr	r1, [sp, #4]
 800818e:	b128      	cbz	r0, 800819c <MPU_xTaskDelayUntil+0x1c>
        xReturn = xTaskDelayUntil( pxPreviousWakeTime, xTimeIncrement );
 8008190:	4620      	mov	r0, r4
    }
 8008192:	b002      	add	sp, #8
 8008194:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        xReturn = xTaskDelayUntil( pxPreviousWakeTime, xTimeIncrement );
 8008198:	f7fb bf4e 	b.w	8004038 <xTaskDelayUntil>
        portRAISE_PRIVILEGE();
 800819c:	df02      	svc	2
        xReturn = xTaskDelayUntil( pxPreviousWakeTime, xTimeIncrement );
 800819e:	4620      	mov	r0, r4
 80081a0:	f7fb ff4a 	bl	8004038 <xTaskDelayUntil>
 80081a4:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 80081a6:	f001 fd73 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 80081aa:	9801      	ldr	r0, [sp, #4]
    }
 80081ac:	b002      	add	sp, #8
 80081ae:	bd10      	pop	{r4, pc}

080081b0 <MPU_uxTaskPriorityGet>:
#endif
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )
    UBaseType_t MPU_uxTaskPriorityGet( const TaskHandle_t pxTask ) /* FREERTOS_SYSTEM_CALL */
    {
 80081b0:	b510      	push	{r4, lr}
 80081b2:	b082      	sub	sp, #8
 80081b4:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 80081b6:	f001 fd63 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80081ba:	b128      	cbz	r0, 80081c8 <MPU_uxTaskPriorityGet+0x18>
        UBaseType_t uxReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        uxReturn = uxTaskPriorityGet( pxTask );
 80081bc:	4620      	mov	r0, r4
        vPortResetPrivilege( xRunningPrivileged );
        return uxReturn;
    }
 80081be:	b002      	add	sp, #8
 80081c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        uxReturn = uxTaskPriorityGet( pxTask );
 80081c4:	f7fa bf82 	b.w	80030cc <uxTaskPriorityGet>
        portRAISE_PRIVILEGE();
 80081c8:	df02      	svc	2
        uxReturn = uxTaskPriorityGet( pxTask );
 80081ca:	4620      	mov	r0, r4
 80081cc:	f7fa ff7e 	bl	80030cc <uxTaskPriorityGet>
 80081d0:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 80081d2:	f001 fd5d 	bl	8009c90 <vResetPrivilege>
        return uxReturn;
 80081d6:	9801      	ldr	r0, [sp, #4]
    }
 80081d8:	b002      	add	sp, #8
 80081da:	bd10      	pop	{r4, pc}

080081dc <MPU_eTaskGetState>:
#endif
/*-----------------------------------------------------------*/

#if ( INCLUDE_eTaskGetState == 1 )
    eTaskState MPU_eTaskGetState( TaskHandle_t pxTask ) /* FREERTOS_SYSTEM_CALL */
    {
 80081dc:	b510      	push	{r4, lr}
 80081de:	b082      	sub	sp, #8
 80081e0:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 80081e2:	f001 fd4d 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80081e6:	b128      	cbz	r0, 80081f4 <MPU_eTaskGetState+0x18>
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();
        eTaskState eReturn;

        eReturn = eTaskGetState( pxTask );
 80081e8:	4620      	mov	r0, r4
        vPortResetPrivilege( xRunningPrivileged );
        return eReturn;
    }
 80081ea:	b002      	add	sp, #8
 80081ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        eReturn = eTaskGetState( pxTask );
 80081f0:	f7fa bf9e 	b.w	8003130 <eTaskGetState>
        portRAISE_PRIVILEGE();
 80081f4:	df02      	svc	2
        eReturn = eTaskGetState( pxTask );
 80081f6:	4620      	mov	r0, r4
 80081f8:	f7fa ff9a 	bl	8003130 <eTaskGetState>
 80081fc:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 80081fe:	f001 fd47 	bl	8009c90 <vResetPrivilege>
        return eReturn;
 8008202:	9801      	ldr	r0, [sp, #4]
    }
 8008204:	b002      	add	sp, #8
 8008206:	bd10      	pop	{r4, pc}

08008208 <MPU_vTaskGetInfo>:
#if ( configUSE_TRACE_FACILITY == 1 )
    void MPU_vTaskGetInfo( TaskHandle_t xTask,
                           TaskStatus_t * pxTaskStatus,
                           BaseType_t xGetFreeStackSpace,
                           eTaskState eState ) /* FREERTOS_SYSTEM_CALL */
    {
 8008208:	b510      	push	{r4, lr}
 800820a:	b084      	sub	sp, #16
 800820c:	4604      	mov	r4, r0
 800820e:	e9cd 2102 	strd	r2, r1, [sp, #8]
 8008212:	9301      	str	r3, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008214:	f001 fd34 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008218:	9903      	ldr	r1, [sp, #12]
 800821a:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
 800821e:	b940      	cbnz	r0, 8008232 <MPU_vTaskGetInfo+0x2a>
        portRAISE_PRIVILEGE();
 8008220:	df02      	svc	2
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        vTaskGetInfo( xTask, pxTaskStatus, xGetFreeStackSpace, eState );
 8008222:	4620      	mov	r0, r4
 8008224:	f7fb ff60 	bl	80040e8 <vTaskGetInfo>
        vPortResetPrivilege( xRunningPrivileged );
    }
 8008228:	b004      	add	sp, #16
 800822a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 800822e:	f001 bd2f 	b.w	8009c90 <vResetPrivilege>
        vTaskGetInfo( xTask, pxTaskStatus, xGetFreeStackSpace, eState );
 8008232:	4620      	mov	r0, r4
    }
 8008234:	b004      	add	sp, #16
 8008236:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        vTaskGetInfo( xTask, pxTaskStatus, xGetFreeStackSpace, eState );
 800823a:	f7fb bf55 	b.w	80040e8 <vTaskGetInfo>
 800823e:	bf00      	nop

08008240 <MPU_vTaskPrioritySet>:
    {
 8008240:	b510      	push	{r4, lr}
 8008242:	b082      	sub	sp, #8
 8008244:	4604      	mov	r4, r0
 8008246:	9101      	str	r1, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008248:	f001 fd1a 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 800824c:	9901      	ldr	r1, [sp, #4]
 800824e:	b940      	cbnz	r0, 8008262 <MPU_vTaskPrioritySet+0x22>
        portRAISE_PRIVILEGE();
 8008250:	df02      	svc	2
        vTaskPrioritySet( pxTask, uxNewPriority );
 8008252:	4620      	mov	r0, r4
 8008254:	f7fa ffb2 	bl	80031bc <vTaskPrioritySet>
    }
 8008258:	b002      	add	sp, #8
 800825a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 800825e:	f001 bd17 	b.w	8009c90 <vResetPrivilege>
        vTaskPrioritySet( pxTask, uxNewPriority );
 8008262:	4620      	mov	r0, r4
    }
 8008264:	b002      	add	sp, #8
 8008266:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        vTaskPrioritySet( pxTask, uxNewPriority );
 800826a:	f7fa bfa7 	b.w	80031bc <vTaskPrioritySet>
 800826e:	bf00      	nop

08008270 <MPU_vTaskSuspend>:
#endif
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )
    void MPU_vTaskSuspend( TaskHandle_t pxTaskToSuspend ) /* FREERTOS_SYSTEM_CALL */
    {
 8008270:	b510      	push	{r4, lr}
 8008272:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008274:	f001 fd04 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008278:	b938      	cbnz	r0, 800828a <MPU_vTaskSuspend+0x1a>
        portRAISE_PRIVILEGE();
 800827a:	df02      	svc	2
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        vTaskSuspend( pxTaskToSuspend );
 800827c:	4620      	mov	r0, r4
 800827e:	f7fc faff 	bl	8004880 <vTaskSuspend>
        vPortResetPrivilege( xRunningPrivileged );
    }
 8008282:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 8008286:	f001 bd03 	b.w	8009c90 <vResetPrivilege>
        vTaskSuspend( pxTaskToSuspend );
 800828a:	4620      	mov	r0, r4
    }
 800828c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        vTaskSuspend( pxTaskToSuspend );
 8008290:	f7fc baf6 	b.w	8004880 <vTaskSuspend>

08008294 <MPU_vTaskResume>:
#endif
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )
    void MPU_vTaskResume( TaskHandle_t pxTaskToResume ) /* FREERTOS_SYSTEM_CALL */
    {
 8008294:	b510      	push	{r4, lr}
 8008296:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008298:	f001 fcf2 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 800829c:	b938      	cbnz	r0, 80082ae <MPU_vTaskResume+0x1a>
        portRAISE_PRIVILEGE();
 800829e:	df02      	svc	2
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        vTaskResume( pxTaskToResume );
 80082a0:	4620      	mov	r0, r4
 80082a2:	f7fb f809 	bl	80032b8 <vTaskResume>
        vPortResetPrivilege( xRunningPrivileged );
    }
 80082a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 80082aa:	f001 bcf1 	b.w	8009c90 <vResetPrivilege>
        vTaskResume( pxTaskToResume );
 80082ae:	4620      	mov	r0, r4
    }
 80082b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        vTaskResume( pxTaskToResume );
 80082b4:	f7fb b800 	b.w	80032b8 <vTaskResume>

080082b8 <MPU_vTaskSuspendAll>:
#endif
/*-----------------------------------------------------------*/

void MPU_vTaskSuspendAll( void ) /* FREERTOS_SYSTEM_CALL */
{
 80082b8:	b508      	push	{r3, lr}
    xRunningPrivileged = portIS_PRIVILEGED();
 80082ba:	f001 fce1 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80082be:	b930      	cbnz	r0, 80082ce <MPU_vTaskSuspendAll+0x16>
        portRAISE_PRIVILEGE();
 80082c0:	df02      	svc	2
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    vTaskSuspendAll();
 80082c2:	f7fb f94d 	bl	8003560 <vTaskSuspendAll>
    vPortResetPrivilege( xRunningPrivileged );
}
 80082c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        portRESET_PRIVILEGE();
 80082ca:	f001 bce1 	b.w	8009c90 <vResetPrivilege>
}
 80082ce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    vTaskSuspendAll();
 80082d2:	f7fb b945 	b.w	8003560 <vTaskSuspendAll>
 80082d6:	bf00      	nop

080082d8 <MPU_xTaskResumeAll>:
/*-----------------------------------------------------------*/

BaseType_t MPU_xTaskResumeAll( void ) /* FREERTOS_SYSTEM_CALL */
{
 80082d8:	b500      	push	{lr}
 80082da:	b083      	sub	sp, #12
    xRunningPrivileged = portIS_PRIVILEGED();
 80082dc:	f001 fcd0 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80082e0:	b120      	cbz	r0, 80082ec <MPU_xTaskResumeAll+0x14>
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    xReturn = xTaskResumeAll();
    vPortResetPrivilege( xRunningPrivileged );
    return xReturn;
}
 80082e2:	b003      	add	sp, #12
 80082e4:	f85d eb04 	ldr.w	lr, [sp], #4
    xReturn = xTaskResumeAll();
 80082e8:	f7fb bdd8 	b.w	8003e9c <xTaskResumeAll>
        portRAISE_PRIVILEGE();
 80082ec:	df02      	svc	2
    xReturn = xTaskResumeAll();
 80082ee:	f7fb fdd5 	bl	8003e9c <xTaskResumeAll>
 80082f2:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 80082f4:	f001 fccc 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 80082f8:	9801      	ldr	r0, [sp, #4]
}
 80082fa:	b003      	add	sp, #12
 80082fc:	f85d fb04 	ldr.w	pc, [sp], #4

08008300 <MPU_xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t MPU_xTaskGetTickCount( void ) /* FREERTOS_SYSTEM_CALL */
{
 8008300:	b500      	push	{lr}
 8008302:	b083      	sub	sp, #12
    xRunningPrivileged = portIS_PRIVILEGED();
 8008304:	f001 fcbc 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008308:	b120      	cbz	r0, 8008314 <MPU_xTaskGetTickCount+0x14>
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    xReturn = xTaskGetTickCount();
    vPortResetPrivilege( xRunningPrivileged );
    return xReturn;
}
 800830a:	b003      	add	sp, #12
 800830c:	f85d eb04 	ldr.w	lr, [sp], #4
    xReturn = xTaskGetTickCount();
 8008310:	f7fb b930 	b.w	8003574 <xTaskGetTickCount>
        portRAISE_PRIVILEGE();
 8008314:	df02      	svc	2
    xReturn = xTaskGetTickCount();
 8008316:	f7fb f92d 	bl	8003574 <xTaskGetTickCount>
 800831a:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 800831c:	f001 fcb8 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 8008320:	9801      	ldr	r0, [sp, #4]
}
 8008322:	b003      	add	sp, #12
 8008324:	f85d fb04 	ldr.w	pc, [sp], #4

08008328 <MPU_uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t MPU_uxTaskGetNumberOfTasks( void ) /* FREERTOS_SYSTEM_CALL */
{
 8008328:	b500      	push	{lr}
 800832a:	b083      	sub	sp, #12
    xRunningPrivileged = portIS_PRIVILEGED();
 800832c:	f001 fca8 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008330:	b120      	cbz	r0, 800833c <MPU_uxTaskGetNumberOfTasks+0x14>
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    uxReturn = uxTaskGetNumberOfTasks();
    vPortResetPrivilege( xRunningPrivileged );
    return uxReturn;
}
 8008332:	b003      	add	sp, #12
 8008334:	f85d eb04 	ldr.w	lr, [sp], #4
    uxReturn = uxTaskGetNumberOfTasks();
 8008338:	f7fb b92a 	b.w	8003590 <uxTaskGetNumberOfTasks>
        portRAISE_PRIVILEGE();
 800833c:	df02      	svc	2
    uxReturn = uxTaskGetNumberOfTasks();
 800833e:	f7fb f927 	bl	8003590 <uxTaskGetNumberOfTasks>
 8008342:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008344:	f001 fca4 	bl	8009c90 <vResetPrivilege>
    return uxReturn;
 8008348:	9801      	ldr	r0, [sp, #4]
}
 800834a:	b003      	add	sp, #12
 800834c:	f85d fb04 	ldr.w	pc, [sp], #4

08008350 <MPU_pcTaskGetName>:
/*-----------------------------------------------------------*/

char * MPU_pcTaskGetName( TaskHandle_t xTaskToQuery ) /* FREERTOS_SYSTEM_CALL */
{
 8008350:	b510      	push	{r4, lr}
 8008352:	b082      	sub	sp, #8
 8008354:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008356:	f001 fc93 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 800835a:	b128      	cbz	r0, 8008368 <MPU_pcTaskGetName+0x18>
    char * pcReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    pcReturn = pcTaskGetName( xTaskToQuery );
 800835c:	4620      	mov	r0, r4
    vPortResetPrivilege( xRunningPrivileged );
    return pcReturn;
}
 800835e:	b002      	add	sp, #8
 8008360:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    pcReturn = pcTaskGetName( xTaskToQuery );
 8008364:	f7fb b91a 	b.w	800359c <pcTaskGetName>
        portRAISE_PRIVILEGE();
 8008368:	df02      	svc	2
    pcReturn = pcTaskGetName( xTaskToQuery );
 800836a:	4620      	mov	r0, r4
 800836c:	f7fb f916 	bl	800359c <pcTaskGetName>
 8008370:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008372:	f001 fc8d 	bl	8009c90 <vResetPrivilege>
    return pcReturn;
 8008376:	9801      	ldr	r0, [sp, #4]
}
 8008378:	b002      	add	sp, #8
 800837a:	bd10      	pop	{r4, pc}

0800837c <MPU_uxTaskGetStackHighWaterMark>:
}
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
    UBaseType_t MPU_uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) /* FREERTOS_SYSTEM_CALL */
    {
 800837c:	b510      	push	{r4, lr}
 800837e:	b082      	sub	sp, #8
 8008380:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008382:	f001 fc7d 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008386:	b128      	cbz	r0, 8008394 <MPU_uxTaskGetStackHighWaterMark+0x18>
        UBaseType_t uxReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        uxReturn = uxTaskGetStackHighWaterMark( xTask );
 8008388:	4620      	mov	r0, r4
        vPortResetPrivilege( xRunningPrivileged );
        return uxReturn;
    }
 800838a:	b002      	add	sp, #8
 800838c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        uxReturn = uxTaskGetStackHighWaterMark( xTask );
 8008390:	f7fb b916 	b.w	80035c0 <uxTaskGetStackHighWaterMark>
        portRAISE_PRIVILEGE();
 8008394:	df02      	svc	2
        uxReturn = uxTaskGetStackHighWaterMark( xTask );
 8008396:	4620      	mov	r0, r4
 8008398:	f7fb f912 	bl	80035c0 <uxTaskGetStackHighWaterMark>
 800839c:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 800839e:	f001 fc77 	bl	8009c90 <vResetPrivilege>
        return uxReturn;
 80083a2:	9801      	ldr	r0, [sp, #4]
    }
 80083a4:	b002      	add	sp, #8
 80083a6:	bd10      	pop	{r4, pc}

080083a8 <MPU_uxTaskGetSystemState>:
    {
 80083a8:	b510      	push	{r4, lr}
 80083aa:	b082      	sub	sp, #8
 80083ac:	4604      	mov	r4, r0
 80083ae:	e9cd 2100 	strd	r2, r1, [sp]
    xRunningPrivileged = portIS_PRIVILEGED();
 80083b2:	f001 fc65 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80083b6:	e9dd 2100 	ldrd	r2, r1, [sp]
 80083ba:	b128      	cbz	r0, 80083c8 <MPU_uxTaskGetSystemState+0x20>
        uxReturn = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, pulTotalRunTime );
 80083bc:	4620      	mov	r0, r4
    }
 80083be:	b002      	add	sp, #8
 80083c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        uxReturn = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, pulTotalRunTime );
 80083c4:	f7fb bf80 	b.w	80042c8 <uxTaskGetSystemState>
        portRAISE_PRIVILEGE();
 80083c8:	df02      	svc	2
        uxReturn = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, pulTotalRunTime );
 80083ca:	4620      	mov	r0, r4
 80083cc:	f7fb ff7c 	bl	80042c8 <uxTaskGetSystemState>
 80083d0:	9000      	str	r0, [sp, #0]
        portRESET_PRIVILEGE();
 80083d2:	f001 fc5d 	bl	8009c90 <vResetPrivilege>
        return uxReturn;
 80083d6:	9800      	ldr	r0, [sp, #0]
    }
 80083d8:	b002      	add	sp, #8
 80083da:	bd10      	pop	{r4, pc}

080083dc <MPU_xTaskGenericNotify>:
    BaseType_t MPU_xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                       UBaseType_t uxIndexToNotify,
                                       uint32_t ulValue,
                                       eNotifyAction eAction,
                                       uint32_t * pulPreviousNotificationValue ) /* FREERTOS_SYSTEM_CALL */
    {
 80083dc:	b530      	push	{r4, r5, lr}
 80083de:	b087      	sub	sp, #28
 80083e0:	4604      	mov	r4, r0
 80083e2:	e9cd 2104 	strd	r2, r1, [sp, #16]
 80083e6:	9303      	str	r3, [sp, #12]
 80083e8:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    xRunningPrivileged = portIS_PRIVILEGED();
 80083ea:	f001 fc49 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80083ee:	9905      	ldr	r1, [sp, #20]
 80083f0:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 80083f4:	b130      	cbz	r0, 8008404 <MPU_xTaskGenericNotify+0x28>
        BaseType_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        xReturn = xTaskGenericNotify( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue );
 80083f6:	4620      	mov	r0, r4
 80083f8:	950a      	str	r5, [sp, #40]	; 0x28
        vPortResetPrivilege( xRunningPrivileged );
        return xReturn;
    }
 80083fa:	b007      	add	sp, #28
 80083fc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        xReturn = xTaskGenericNotify( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue );
 8008400:	f7fb b8fa 	b.w	80035f8 <xTaskGenericNotify>
        portRAISE_PRIVILEGE();
 8008404:	df02      	svc	2
        xReturn = xTaskGenericNotify( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue );
 8008406:	4620      	mov	r0, r4
 8008408:	9500      	str	r5, [sp, #0]
 800840a:	f7fb f8f5 	bl	80035f8 <xTaskGenericNotify>
 800840e:	9003      	str	r0, [sp, #12]
        portRESET_PRIVILEGE();
 8008410:	f001 fc3e 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008414:	9803      	ldr	r0, [sp, #12]
    }
 8008416:	b007      	add	sp, #28
 8008418:	bd30      	pop	{r4, r5, pc}
 800841a:	bf00      	nop

0800841c <MPU_xTaskGenericNotifyWait>:
    BaseType_t MPU_xTaskGenericNotifyWait( UBaseType_t uxIndexToWaitOn,
                                           uint32_t ulBitsToClearOnEntry,
                                           uint32_t ulBitsToClearOnExit,
                                           uint32_t * pulNotificationValue,
                                           TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
    {
 800841c:	b530      	push	{r4, r5, lr}
 800841e:	b087      	sub	sp, #28
 8008420:	4604      	mov	r4, r0
 8008422:	e9cd 2104 	strd	r2, r1, [sp, #16]
 8008426:	9303      	str	r3, [sp, #12]
 8008428:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    xRunningPrivileged = portIS_PRIVILEGED();
 800842a:	f001 fc29 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 800842e:	9905      	ldr	r1, [sp, #20]
 8008430:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 8008434:	b130      	cbz	r0, 8008444 <MPU_xTaskGenericNotifyWait+0x28>
        BaseType_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        xReturn = xTaskGenericNotifyWait( uxIndexToWaitOn, ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait );
 8008436:	4620      	mov	r0, r4
 8008438:	950a      	str	r5, [sp, #40]	; 0x28
        vPortResetPrivilege( xRunningPrivileged );
        return xReturn;
    }
 800843a:	b007      	add	sp, #28
 800843c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        xReturn = xTaskGenericNotifyWait( uxIndexToWaitOn, ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait );
 8008440:	f7fb ba60 	b.w	8003904 <xTaskGenericNotifyWait>
        portRAISE_PRIVILEGE();
 8008444:	df02      	svc	2
        xReturn = xTaskGenericNotifyWait( uxIndexToWaitOn, ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait );
 8008446:	4620      	mov	r0, r4
 8008448:	9500      	str	r5, [sp, #0]
 800844a:	f7fb fa5b 	bl	8003904 <xTaskGenericNotifyWait>
 800844e:	9003      	str	r0, [sp, #12]
        portRESET_PRIVILEGE();
 8008450:	f001 fc1e 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008454:	9803      	ldr	r0, [sp, #12]
    }
 8008456:	b007      	add	sp, #28
 8008458:	bd30      	pop	{r4, r5, pc}
 800845a:	bf00      	nop

0800845c <MPU_ulTaskGenericNotifyTake>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )
    uint32_t MPU_ulTaskGenericNotifyTake( UBaseType_t uxIndexToWaitOn,
                                          BaseType_t xClearCountOnExit,
                                          TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
    {
 800845c:	b510      	push	{r4, lr}
 800845e:	b082      	sub	sp, #8
 8008460:	4604      	mov	r4, r0
 8008462:	e9cd 2100 	strd	r2, r1, [sp]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008466:	f001 fc0b 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 800846a:	e9dd 2100 	ldrd	r2, r1, [sp]
 800846e:	b128      	cbz	r0, 800847c <MPU_ulTaskGenericNotifyTake+0x20>
        uint32_t ulReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        ulReturn = ulTaskGenericNotifyTake( uxIndexToWaitOn, xClearCountOnExit, xTicksToWait );
 8008470:	4620      	mov	r0, r4
        vPortResetPrivilege( xRunningPrivileged );
        return ulReturn;
    }
 8008472:	b002      	add	sp, #8
 8008474:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        ulReturn = ulTaskGenericNotifyTake( uxIndexToWaitOn, xClearCountOnExit, xTicksToWait );
 8008478:	f7fb bb56 	b.w	8003b28 <ulTaskGenericNotifyTake>
        portRAISE_PRIVILEGE();
 800847c:	df02      	svc	2
        ulReturn = ulTaskGenericNotifyTake( uxIndexToWaitOn, xClearCountOnExit, xTicksToWait );
 800847e:	4620      	mov	r0, r4
 8008480:	f7fb fb52 	bl	8003b28 <ulTaskGenericNotifyTake>
 8008484:	9000      	str	r0, [sp, #0]
        portRESET_PRIVILEGE();
 8008486:	f001 fc03 	bl	8009c90 <vResetPrivilege>
        return ulReturn;
 800848a:	9800      	ldr	r0, [sp, #0]
    }
 800848c:	b002      	add	sp, #8
 800848e:	bd10      	pop	{r4, pc}

08008490 <MPU_xTaskGenericNotifyStateClear>:
/*-----------------------------------------------------------*/

#if ( configUSE_TASK_NOTIFICATIONS == 1 )
    BaseType_t MPU_xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                                 UBaseType_t uxIndexToClear ) /* FREERTOS_SYSTEM_CALL */
    {
 8008490:	b510      	push	{r4, lr}
 8008492:	b082      	sub	sp, #8
 8008494:	4604      	mov	r4, r0
 8008496:	9101      	str	r1, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008498:	f001 fbf2 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 800849c:	9901      	ldr	r1, [sp, #4]
 800849e:	b128      	cbz	r0, 80084ac <MPU_xTaskGenericNotifyStateClear+0x1c>
        BaseType_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        xReturn = xTaskGenericNotifyStateClear( xTask, uxIndexToClear );
 80084a0:	4620      	mov	r0, r4
        vPortResetPrivilege( xRunningPrivileged );
        return xReturn;
    }
 80084a2:	b002      	add	sp, #8
 80084a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        xReturn = xTaskGenericNotifyStateClear( xTask, uxIndexToClear );
 80084a8:	f7fb bb90 	b.w	8003bcc <xTaskGenericNotifyStateClear>
        portRAISE_PRIVILEGE();
 80084ac:	df02      	svc	2
        xReturn = xTaskGenericNotifyStateClear( xTask, uxIndexToClear );
 80084ae:	4620      	mov	r0, r4
 80084b0:	f7fb fb8c 	bl	8003bcc <xTaskGenericNotifyStateClear>
 80084b4:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 80084b6:	f001 fbeb 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 80084ba:	9801      	ldr	r0, [sp, #4]
    }
 80084bc:	b002      	add	sp, #8
 80084be:	bd10      	pop	{r4, pc}

080084c0 <MPU_ulTaskGenericNotifyValueClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )
    uint32_t MPU_ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                                UBaseType_t uxIndexToClear,
                                                uint32_t ulBitsToClear ) /* FREERTOS_SYSTEM_CALL */
    {
 80084c0:	b510      	push	{r4, lr}
 80084c2:	b082      	sub	sp, #8
 80084c4:	4604      	mov	r4, r0
 80084c6:	e9cd 2100 	strd	r2, r1, [sp]
    xRunningPrivileged = portIS_PRIVILEGED();
 80084ca:	f001 fbd9 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80084ce:	e9dd 2100 	ldrd	r2, r1, [sp]
 80084d2:	b128      	cbz	r0, 80084e0 <MPU_ulTaskGenericNotifyValueClear+0x20>
        uint32_t ulReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        ulReturn = ulTaskGenericNotifyValueClear( xTask, uxIndexToClear, ulBitsToClear );
 80084d4:	4620      	mov	r0, r4
        vPortResetPrivilege( xRunningPrivileged );
        return ulReturn;
    }
 80084d6:	b002      	add	sp, #8
 80084d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        ulReturn = ulTaskGenericNotifyValueClear( xTask, uxIndexToClear, ulBitsToClear );
 80084dc:	f7fb bba6 	b.w	8003c2c <ulTaskGenericNotifyValueClear>
        portRAISE_PRIVILEGE();
 80084e0:	df02      	svc	2
        ulReturn = ulTaskGenericNotifyValueClear( xTask, uxIndexToClear, ulBitsToClear );
 80084e2:	4620      	mov	r0, r4
 80084e4:	f7fb fba2 	bl	8003c2c <ulTaskGenericNotifyValueClear>
 80084e8:	9000      	str	r0, [sp, #0]
        portRESET_PRIVILEGE();
 80084ea:	f001 fbd1 	bl	8009c90 <vResetPrivilege>
        return ulReturn;
 80084ee:	9800      	ldr	r0, [sp, #0]
    }
 80084f0:	b002      	add	sp, #8
 80084f2:	bd10      	pop	{r4, pc}

080084f4 <MPU_xTaskGetCurrentTaskHandle>:
    {
 80084f4:	b500      	push	{lr}
 80084f6:	b083      	sub	sp, #12
    xRunningPrivileged = portIS_PRIVILEGED();
 80084f8:	f001 fbc2 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80084fc:	b120      	cbz	r0, 8008508 <MPU_xTaskGetCurrentTaskHandle+0x14>
    }
 80084fe:	b003      	add	sp, #12
 8008500:	f85d eb04 	ldr.w	lr, [sp], #4
        xReturn = xTaskGetCurrentTaskHandle();
 8008504:	f7fc ba3c 	b.w	8004980 <xTaskGetCurrentTaskHandle>
        portRAISE_PRIVILEGE();
 8008508:	df02      	svc	2
        xReturn = xTaskGetCurrentTaskHandle();
 800850a:	f7fc fa39 	bl	8004980 <xTaskGetCurrentTaskHandle>
 800850e:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008510:	f001 fbbe 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008514:	9801      	ldr	r0, [sp, #4]
    }
 8008516:	b003      	add	sp, #12
 8008518:	f85d fb04 	ldr.w	pc, [sp], #4

0800851c <MPU_vTaskSetTimeOutState>:
{
 800851c:	b510      	push	{r4, lr}
 800851e:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008520:	f001 fbae 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008524:	b938      	cbnz	r0, 8008536 <MPU_vTaskSetTimeOutState+0x1a>
        portRAISE_PRIVILEGE();
 8008526:	df02      	svc	2
    vTaskSetTimeOutState( pxTimeOut );
 8008528:	4620      	mov	r0, r4
 800852a:	f7fb fb9d 	bl	8003c68 <vTaskSetTimeOutState>
}
 800852e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 8008532:	f001 bbad 	b.w	8009c90 <vResetPrivilege>
    vTaskSetTimeOutState( pxTimeOut );
 8008536:	4620      	mov	r0, r4
}
 8008538:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    vTaskSetTimeOutState( pxTimeOut );
 800853c:	f7fb bb94 	b.w	8003c68 <vTaskSetTimeOutState>

08008540 <MPU_xTaskCheckForTimeOut>:
{
 8008540:	b510      	push	{r4, lr}
 8008542:	b082      	sub	sp, #8
 8008544:	4604      	mov	r4, r0
 8008546:	9101      	str	r1, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008548:	f001 fb9a 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 800854c:	9901      	ldr	r1, [sp, #4]
 800854e:	b128      	cbz	r0, 800855c <MPU_xTaskCheckForTimeOut+0x1c>
    xReturn = xTaskCheckForTimeOut( pxTimeOut, pxTicksToWait );
 8008550:	4620      	mov	r0, r4
}
 8008552:	b002      	add	sp, #8
 8008554:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xTaskCheckForTimeOut( pxTimeOut, pxTicksToWait );
 8008558:	f7fb bba0 	b.w	8003c9c <xTaskCheckForTimeOut>
        portRAISE_PRIVILEGE();
 800855c:	df02      	svc	2
    xReturn = xTaskCheckForTimeOut( pxTimeOut, pxTicksToWait );
 800855e:	4620      	mov	r0, r4
 8008560:	f7fb fb9c 	bl	8003c9c <xTaskCheckForTimeOut>
 8008564:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008566:	f001 fb93 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 800856a:	9801      	ldr	r0, [sp, #4]
}
 800856c:	b002      	add	sp, #8
 800856e:	bd10      	pop	{r4, pc}

08008570 <MPU_xTaskGetSchedulerState>:
    {
 8008570:	b500      	push	{lr}
 8008572:	b083      	sub	sp, #12
    xRunningPrivileged = portIS_PRIVILEGED();
 8008574:	f001 fb84 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008578:	b120      	cbz	r0, 8008584 <MPU_xTaskGetSchedulerState+0x14>
    }
 800857a:	b003      	add	sp, #12
 800857c:	f85d eb04 	ldr.w	lr, [sp], #4
        xReturn = xTaskGetSchedulerState();
 8008580:	f7fc ba0c 	b.w	800499c <xTaskGetSchedulerState>
        portRAISE_PRIVILEGE();
 8008584:	df02      	svc	2
        xReturn = xTaskGetSchedulerState();
 8008586:	f7fc fa09 	bl	800499c <xTaskGetSchedulerState>
 800858a:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 800858c:	f001 fb80 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008590:	9801      	ldr	r0, [sp, #4]
    }
 8008592:	b003      	add	sp, #12
 8008594:	f85d fb04 	ldr.w	pc, [sp], #4

08008598 <MPU_xTaskCatchUpTicks>:
{
 8008598:	b510      	push	{r4, lr}
 800859a:	b082      	sub	sp, #8
 800859c:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 800859e:	f001 fb6f 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80085a2:	b128      	cbz	r0, 80085b0 <MPU_xTaskCatchUpTicks+0x18>
    xReturn = xTaskCatchUpTicks( xTicksToCatchUp );
 80085a4:	4620      	mov	r0, r4
}
 80085a6:	b002      	add	sp, #8
 80085a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xTaskCatchUpTicks( xTicksToCatchUp );
 80085ac:	f7fb bdec 	b.w	8004188 <xTaskCatchUpTicks>
        portRAISE_PRIVILEGE();
 80085b0:	df02      	svc	2
    xReturn = xTaskCatchUpTicks( xTicksToCatchUp );
 80085b2:	4620      	mov	r0, r4
 80085b4:	f7fb fde8 	bl	8004188 <xTaskCatchUpTicks>
 80085b8:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 80085ba:	f001 fb69 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 80085be:	9801      	ldr	r0, [sp, #4]
}
 80085c0:	b002      	add	sp, #8
 80085c2:	bd10      	pop	{r4, pc}

080085c4 <MPU_xQueueGenericSend>:

BaseType_t MPU_xQueueGenericSend( QueueHandle_t xQueue,
                                  const void * const pvItemToQueue,
                                  TickType_t xTicksToWait,
                                  BaseType_t xCopyPosition ) /* FREERTOS_SYSTEM_CALL */
{
 80085c4:	b510      	push	{r4, lr}
 80085c6:	b084      	sub	sp, #16
 80085c8:	4604      	mov	r4, r0
 80085ca:	e9cd 2102 	strd	r2, r1, [sp, #8]
 80085ce:	9301      	str	r3, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 80085d0:	f001 fb56 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80085d4:	9903      	ldr	r1, [sp, #12]
 80085d6:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
 80085da:	b128      	cbz	r0, 80085e8 <MPU_xQueueGenericSend+0x24>
    BaseType_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    xReturn = xQueueGenericSend( xQueue, pvItemToQueue, xTicksToWait, xCopyPosition );
 80085dc:	4620      	mov	r0, r4
    vPortResetPrivilege( xRunningPrivileged );
    return xReturn;
}
 80085de:	b004      	add	sp, #16
 80085e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xQueueGenericSend( xQueue, pvItemToQueue, xTicksToWait, xCopyPosition );
 80085e4:	f7f8 b94e 	b.w	8000884 <xQueueGenericSend>
        portRAISE_PRIVILEGE();
 80085e8:	df02      	svc	2
    xReturn = xQueueGenericSend( xQueue, pvItemToQueue, xTicksToWait, xCopyPosition );
 80085ea:	4620      	mov	r0, r4
 80085ec:	f7f8 f94a 	bl	8000884 <xQueueGenericSend>
 80085f0:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 80085f2:	f001 fb4d 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 80085f6:	9801      	ldr	r0, [sp, #4]
}
 80085f8:	b004      	add	sp, #16
 80085fa:	bd10      	pop	{r4, pc}

080085fc <MPU_xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t MPU_xQueueReceive( QueueHandle_t pxQueue,
                              void * const pvBuffer,
                              TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
{
 80085fc:	b510      	push	{r4, lr}
 80085fe:	b082      	sub	sp, #8
 8008600:	4604      	mov	r4, r0
 8008602:	e9cd 2100 	strd	r2, r1, [sp]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008606:	f001 fb3b 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 800860a:	e9dd 2100 	ldrd	r2, r1, [sp]
 800860e:	b128      	cbz	r0, 800861c <MPU_xQueueReceive+0x20>
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    BaseType_t xReturn;

    xReturn = xQueueReceive( pxQueue, pvBuffer, xTicksToWait );
 8008610:	4620      	mov	r0, r4
    vPortResetPrivilege( xRunningPrivileged );
    return xReturn;
}
 8008612:	b002      	add	sp, #8
 8008614:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xQueueReceive( pxQueue, pvBuffer, xTicksToWait );
 8008618:	f7f8 bc76 	b.w	8000f08 <xQueueReceive>
        portRAISE_PRIVILEGE();
 800861c:	df02      	svc	2
    xReturn = xQueueReceive( pxQueue, pvBuffer, xTicksToWait );
 800861e:	4620      	mov	r0, r4
 8008620:	f7f8 fc72 	bl	8000f08 <xQueueReceive>
 8008624:	9000      	str	r0, [sp, #0]
        portRESET_PRIVILEGE();
 8008626:	f001 fb33 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 800862a:	9800      	ldr	r0, [sp, #0]
}
 800862c:	b002      	add	sp, #8
 800862e:	bd10      	pop	{r4, pc}

08008630 <MPU_xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t MPU_xQueuePeek( QueueHandle_t xQueue,
                           void * const pvBuffer,
                           TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
{
 8008630:	b510      	push	{r4, lr}
 8008632:	b082      	sub	sp, #8
 8008634:	4604      	mov	r4, r0
 8008636:	e9cd 2100 	strd	r2, r1, [sp]
    xRunningPrivileged = portIS_PRIVILEGED();
 800863a:	f001 fb21 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 800863e:	e9dd 2100 	ldrd	r2, r1, [sp]
 8008642:	b128      	cbz	r0, 8008650 <MPU_xQueuePeek+0x20>
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    BaseType_t xReturn;

    xReturn = xQueuePeek( xQueue, pvBuffer, xTicksToWait );
 8008644:	4620      	mov	r0, r4
    vPortResetPrivilege( xRunningPrivileged );
    return xReturn;
}
 8008646:	b002      	add	sp, #8
 8008648:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xQueuePeek( xQueue, pvBuffer, xTicksToWait );
 800864c:	f7f8 ba9c 	b.w	8000b88 <xQueuePeek>
        portRAISE_PRIVILEGE();
 8008650:	df02      	svc	2
    xReturn = xQueuePeek( xQueue, pvBuffer, xTicksToWait );
 8008652:	4620      	mov	r0, r4
 8008654:	f7f8 fa98 	bl	8000b88 <xQueuePeek>
 8008658:	9000      	str	r0, [sp, #0]
        portRESET_PRIVILEGE();
 800865a:	f001 fb19 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 800865e:	9800      	ldr	r0, [sp, #0]
}
 8008660:	b002      	add	sp, #8
 8008662:	bd10      	pop	{r4, pc}

08008664 <MPU_xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t MPU_xQueueSemaphoreTake( QueueHandle_t xQueue,
                                    TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
{
 8008664:	b510      	push	{r4, lr}
 8008666:	b082      	sub	sp, #8
 8008668:	4604      	mov	r4, r0
 800866a:	9101      	str	r1, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 800866c:	f001 fb08 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008670:	9901      	ldr	r1, [sp, #4]
 8008672:	b128      	cbz	r0, 8008680 <MPU_xQueueSemaphoreTake+0x1c>
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
    BaseType_t xReturn;

    xReturn = xQueueSemaphoreTake( xQueue, xTicksToWait );
 8008674:	4620      	mov	r0, r4
    vPortResetPrivilege( xRunningPrivileged );
    return xReturn;
}
 8008676:	b002      	add	sp, #8
 8008678:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xQueueSemaphoreTake( xQueue, xTicksToWait );
 800867c:	f7f9 b8c2 	b.w	8001804 <xQueueSemaphoreTake>
        portRAISE_PRIVILEGE();
 8008680:	df02      	svc	2
    xReturn = xQueueSemaphoreTake( xQueue, xTicksToWait );
 8008682:	4620      	mov	r0, r4
 8008684:	f7f9 f8be 	bl	8001804 <xQueueSemaphoreTake>
 8008688:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 800868a:	f001 fb01 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 800868e:	9801      	ldr	r0, [sp, #4]
}
 8008690:	b002      	add	sp, #8
 8008692:	bd10      	pop	{r4, pc}

08008694 <MPU_uxQueueMessagesWaiting>:
{
 8008694:	b510      	push	{r4, lr}
 8008696:	b082      	sub	sp, #8
 8008698:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 800869a:	f001 faf1 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 800869e:	b128      	cbz	r0, 80086ac <MPU_uxQueueMessagesWaiting+0x18>
    uxReturn = uxQueueMessagesWaiting( pxQueue );
 80086a0:	4620      	mov	r0, r4
}
 80086a2:	b002      	add	sp, #8
 80086a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    uxReturn = uxQueueMessagesWaiting( pxQueue );
 80086a8:	f7f8 bdb0 	b.w	800120c <uxQueueMessagesWaiting>
        portRAISE_PRIVILEGE();
 80086ac:	df02      	svc	2
    uxReturn = uxQueueMessagesWaiting( pxQueue );
 80086ae:	4620      	mov	r0, r4
 80086b0:	f7f8 fdac 	bl	800120c <uxQueueMessagesWaiting>
 80086b4:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 80086b6:	f001 faeb 	bl	8009c90 <vResetPrivilege>
    return uxReturn;
 80086ba:	9801      	ldr	r0, [sp, #4]
}
 80086bc:	b002      	add	sp, #8
 80086be:	bd10      	pop	{r4, pc}

080086c0 <MPU_uxQueueSpacesAvailable>:
{
 80086c0:	b510      	push	{r4, lr}
 80086c2:	b082      	sub	sp, #8
 80086c4:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 80086c6:	f001 fadb 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80086ca:	b128      	cbz	r0, 80086d8 <MPU_uxQueueSpacesAvailable+0x18>
    uxReturn = uxQueueSpacesAvailable( xQueue );
 80086cc:	4620      	mov	r0, r4
}
 80086ce:	b002      	add	sp, #8
 80086d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    uxReturn = uxQueueSpacesAvailable( xQueue );
 80086d4:	f7f8 bdb0 	b.w	8001238 <uxQueueSpacesAvailable>
        portRAISE_PRIVILEGE();
 80086d8:	df02      	svc	2
    uxReturn = uxQueueSpacesAvailable( xQueue );
 80086da:	4620      	mov	r0, r4
 80086dc:	f7f8 fdac 	bl	8001238 <uxQueueSpacesAvailable>
 80086e0:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 80086e2:	f001 fad5 	bl	8009c90 <vResetPrivilege>
    return uxReturn;
 80086e6:	9801      	ldr	r0, [sp, #4]
}
 80086e8:	b002      	add	sp, #8
 80086ea:	bd10      	pop	{r4, pc}

080086ec <MPU_vQueueDelete>:
    }
#endif /* if configQUEUE_REGISTRY_SIZE > 0 */
/*-----------------------------------------------------------*/

void MPU_vQueueDelete( QueueHandle_t xQueue ) /* FREERTOS_SYSTEM_CALL */
{
 80086ec:	b510      	push	{r4, lr}
 80086ee:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 80086f0:	f001 fac6 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80086f4:	b938      	cbnz	r0, 8008706 <MPU_vQueueDelete+0x1a>
        portRAISE_PRIVILEGE();
 80086f6:	df02      	svc	2
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    vQueueDelete( xQueue );
 80086f8:	4620      	mov	r0, r4
 80086fa:	f7f8 fdb5 	bl	8001268 <vQueueDelete>

    vPortResetPrivilege( xRunningPrivileged );
}
 80086fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 8008702:	f001 bac5 	b.w	8009c90 <vResetPrivilege>
    vQueueDelete( xQueue );
 8008706:	4620      	mov	r0, r4
}
 8008708:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    vQueueDelete( xQueue );
 800870c:	f7f8 bdac 	b.w	8001268 <vQueueDelete>

08008710 <MPU_xQueueCreateMutex>:
    {
 8008710:	b510      	push	{r4, lr}
 8008712:	b082      	sub	sp, #8
 8008714:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008716:	f001 fab3 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 800871a:	b128      	cbz	r0, 8008728 <MPU_xQueueCreateMutex+0x18>
        xReturn = xQueueCreateMutex( ucQueueType );
 800871c:	4620      	mov	r0, r4
    }
 800871e:	b002      	add	sp, #8
 8008720:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        xReturn = xQueueCreateMutex( ucQueueType );
 8008724:	f7f8 bf50 	b.w	80015c8 <xQueueCreateMutex>
        portRAISE_PRIVILEGE();
 8008728:	df02      	svc	2
        xReturn = xQueueCreateMutex( ucQueueType );
 800872a:	4620      	mov	r0, r4
 800872c:	f7f8 ff4c 	bl	80015c8 <xQueueCreateMutex>
 8008730:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008732:	f001 faad 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008736:	9801      	ldr	r0, [sp, #4]
    }
 8008738:	b002      	add	sp, #8
 800873a:	bd10      	pop	{r4, pc}

0800873c <MPU_xQueueCreateMutexStatic>:
    {
 800873c:	b510      	push	{r4, lr}
 800873e:	b082      	sub	sp, #8
 8008740:	4604      	mov	r4, r0
 8008742:	9101      	str	r1, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008744:	f001 fa9c 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008748:	9901      	ldr	r1, [sp, #4]
 800874a:	b128      	cbz	r0, 8008758 <MPU_xQueueCreateMutexStatic+0x1c>
        xReturn = xQueueCreateMutexStatic( ucQueueType, pxStaticQueue );
 800874c:	4620      	mov	r0, r4
    }
 800874e:	b002      	add	sp, #8
 8008750:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        xReturn = xQueueCreateMutexStatic( ucQueueType, pxStaticQueue );
 8008754:	f7f8 bf70 	b.w	8001638 <xQueueCreateMutexStatic>
        portRAISE_PRIVILEGE();
 8008758:	df02      	svc	2
        xReturn = xQueueCreateMutexStatic( ucQueueType, pxStaticQueue );
 800875a:	4620      	mov	r0, r4
 800875c:	f7f8 ff6c 	bl	8001638 <xQueueCreateMutexStatic>
 8008760:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008762:	f001 fa95 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008766:	9801      	ldr	r0, [sp, #4]
    }
 8008768:	b002      	add	sp, #8
 800876a:	bd10      	pop	{r4, pc}

0800876c <MPU_xQueueCreateCountingSemaphore>:
    {
 800876c:	b510      	push	{r4, lr}
 800876e:	b082      	sub	sp, #8
 8008770:	4604      	mov	r4, r0
 8008772:	9101      	str	r1, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008774:	f001 fa84 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008778:	9901      	ldr	r1, [sp, #4]
 800877a:	b128      	cbz	r0, 8008788 <MPU_xQueueCreateCountingSemaphore+0x1c>
        xReturn = xQueueCreateCountingSemaphore( uxCountValue, uxInitialCount );
 800877c:	4620      	mov	r0, r4
    }
 800877e:	b002      	add	sp, #8
 8008780:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        xReturn = xQueueCreateCountingSemaphore( uxCountValue, uxInitialCount );
 8008784:	f7f8 bfa8 	b.w	80016d8 <xQueueCreateCountingSemaphore>
        portRAISE_PRIVILEGE();
 8008788:	df02      	svc	2
        xReturn = xQueueCreateCountingSemaphore( uxCountValue, uxInitialCount );
 800878a:	4620      	mov	r0, r4
 800878c:	f7f8 ffa4 	bl	80016d8 <xQueueCreateCountingSemaphore>
 8008790:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008792:	f001 fa7d 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008796:	9801      	ldr	r0, [sp, #4]
    }
 8008798:	b002      	add	sp, #8
 800879a:	bd10      	pop	{r4, pc}

0800879c <MPU_xQueueCreateCountingSemaphoreStatic>:
    {
 800879c:	b510      	push	{r4, lr}
 800879e:	b082      	sub	sp, #8
 80087a0:	4604      	mov	r4, r0
 80087a2:	e9cd 2100 	strd	r2, r1, [sp]
    xRunningPrivileged = portIS_PRIVILEGED();
 80087a6:	f001 fa6b 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80087aa:	e9dd 2100 	ldrd	r2, r1, [sp]
 80087ae:	b128      	cbz	r0, 80087bc <MPU_xQueueCreateCountingSemaphoreStatic+0x20>
        xReturn = xQueueCreateCountingSemaphoreStatic( uxMaxCount, uxInitialCount, pxStaticQueue );
 80087b0:	4620      	mov	r0, r4
    }
 80087b2:	b002      	add	sp, #8
 80087b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        xReturn = xQueueCreateCountingSemaphoreStatic( uxMaxCount, uxInitialCount, pxStaticQueue );
 80087b8:	f7f8 bfcc 	b.w	8001754 <xQueueCreateCountingSemaphoreStatic>
        portRAISE_PRIVILEGE();
 80087bc:	df02      	svc	2
        xReturn = xQueueCreateCountingSemaphoreStatic( uxMaxCount, uxInitialCount, pxStaticQueue );
 80087be:	4620      	mov	r0, r4
 80087c0:	f7f8 ffc8 	bl	8001754 <xQueueCreateCountingSemaphoreStatic>
 80087c4:	9000      	str	r0, [sp, #0]
        portRESET_PRIVILEGE();
 80087c6:	f001 fa63 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 80087ca:	9800      	ldr	r0, [sp, #0]
    }
 80087cc:	b002      	add	sp, #8
 80087ce:	bd10      	pop	{r4, pc}

080087d0 <MPU_xQueueGetMutexHolder>:
    {
 80087d0:	b510      	push	{r4, lr}
 80087d2:	b082      	sub	sp, #8
 80087d4:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 80087d6:	f001 fa53 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80087da:	b128      	cbz	r0, 80087e8 <MPU_xQueueGetMutexHolder+0x18>
        xReturn = xQueueGetMutexHolder( xSemaphore );
 80087dc:	4620      	mov	r0, r4
    }
 80087de:	b002      	add	sp, #8
 80087e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        xReturn = xQueueGetMutexHolder( xSemaphore );
 80087e4:	f7f9 b996 	b.w	8001b14 <xQueueGetMutexHolder>
        portRAISE_PRIVILEGE();
 80087e8:	df02      	svc	2
        xReturn = xQueueGetMutexHolder( xSemaphore );
 80087ea:	4620      	mov	r0, r4
 80087ec:	f7f9 f992 	bl	8001b14 <xQueueGetMutexHolder>
 80087f0:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 80087f2:	f001 fa4d 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 80087f6:	9801      	ldr	r0, [sp, #4]
    }
 80087f8:	b002      	add	sp, #8
 80087fa:	bd10      	pop	{r4, pc}

080087fc <MPU_xQueueTakeMutexRecursive>:
    {
 80087fc:	b510      	push	{r4, lr}
 80087fe:	b082      	sub	sp, #8
 8008800:	4604      	mov	r4, r0
 8008802:	9101      	str	r1, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008804:	f001 fa3c 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008808:	9901      	ldr	r1, [sp, #4]
 800880a:	b128      	cbz	r0, 8008818 <MPU_xQueueTakeMutexRecursive+0x1c>
        xReturn = xQueueTakeMutexRecursive( xMutex, xBlockTime );
 800880c:	4620      	mov	r0, r4
    }
 800880e:	b002      	add	sp, #8
 8008810:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        xReturn = xQueueTakeMutexRecursive( xMutex, xBlockTime );
 8008814:	f7f9 b9a8 	b.w	8001b68 <xQueueTakeMutexRecursive>
        portRAISE_PRIVILEGE();
 8008818:	df02      	svc	2
        xReturn = xQueueTakeMutexRecursive( xMutex, xBlockTime );
 800881a:	4620      	mov	r0, r4
 800881c:	f7f9 f9a4 	bl	8001b68 <xQueueTakeMutexRecursive>
 8008820:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008822:	f001 fa35 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008826:	9801      	ldr	r0, [sp, #4]
    }
 8008828:	b002      	add	sp, #8
 800882a:	bd10      	pop	{r4, pc}

0800882c <MPU_xQueueGiveMutexRecursive>:
    {
 800882c:	b510      	push	{r4, lr}
 800882e:	b082      	sub	sp, #8
 8008830:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008832:	f001 fa25 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008836:	b128      	cbz	r0, 8008844 <MPU_xQueueGiveMutexRecursive+0x18>
        xReturn = xQueueGiveMutexRecursive( xMutex );
 8008838:	4620      	mov	r0, r4
    }
 800883a:	b002      	add	sp, #8
 800883c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        xReturn = xQueueGiveMutexRecursive( xMutex );
 8008840:	f7f9 b9b2 	b.w	8001ba8 <xQueueGiveMutexRecursive>
        portRAISE_PRIVILEGE();
 8008844:	df02      	svc	2
        xReturn = xQueueGiveMutexRecursive( xMutex );
 8008846:	4620      	mov	r0, r4
 8008848:	f7f9 f9ae 	bl	8001ba8 <xQueueGiveMutexRecursive>
 800884c:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 800884e:	f001 fa1f 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008852:	9801      	ldr	r0, [sp, #4]
    }
 8008854:	b002      	add	sp, #8
 8008856:	bd10      	pop	{r4, pc}

08008858 <MPU_vQueueAddToRegistry>:
    {
 8008858:	b510      	push	{r4, lr}
 800885a:	b082      	sub	sp, #8
 800885c:	4604      	mov	r4, r0
 800885e:	9101      	str	r1, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008860:	f001 fa0e 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008864:	9901      	ldr	r1, [sp, #4]
 8008866:	b940      	cbnz	r0, 800887a <MPU_vQueueAddToRegistry+0x22>
        portRAISE_PRIVILEGE();
 8008868:	df02      	svc	2
        vQueueAddToRegistry( xQueue, pcName );
 800886a:	4620      	mov	r0, r4
 800886c:	f7f9 f9bc 	bl	8001be8 <vQueueAddToRegistry>
    }
 8008870:	b002      	add	sp, #8
 8008872:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 8008876:	f001 ba0b 	b.w	8009c90 <vResetPrivilege>
        vQueueAddToRegistry( xQueue, pcName );
 800887a:	4620      	mov	r0, r4
    }
 800887c:	b002      	add	sp, #8
 800887e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        vQueueAddToRegistry( xQueue, pcName );
 8008882:	f7f9 b9b1 	b.w	8001be8 <vQueueAddToRegistry>
 8008886:	bf00      	nop

08008888 <MPU_vQueueUnregisterQueue>:
    {
 8008888:	b510      	push	{r4, lr}
 800888a:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 800888c:	f001 f9f8 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008890:	b938      	cbnz	r0, 80088a2 <MPU_vQueueUnregisterQueue+0x1a>
        portRAISE_PRIVILEGE();
 8008892:	df02      	svc	2
        vQueueUnregisterQueue( xQueue );
 8008894:	4620      	mov	r0, r4
 8008896:	f7f9 fa3d 	bl	8001d14 <vQueueUnregisterQueue>
    }
 800889a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 800889e:	f001 b9f7 	b.w	8009c90 <vResetPrivilege>
        vQueueUnregisterQueue( xQueue );
 80088a2:	4620      	mov	r0, r4
    }
 80088a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        vQueueUnregisterQueue( xQueue );
 80088a8:	f7f9 ba34 	b.w	8001d14 <vQueueUnregisterQueue>

080088ac <MPU_pcQueueGetName>:
    {
 80088ac:	b510      	push	{r4, lr}
 80088ae:	b082      	sub	sp, #8
 80088b0:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 80088b2:	f001 f9e5 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80088b6:	b128      	cbz	r0, 80088c4 <MPU_pcQueueGetName+0x18>
        pcReturn = pcQueueGetName( xQueue );
 80088b8:	4620      	mov	r0, r4
    }
 80088ba:	b002      	add	sp, #8
 80088bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        pcReturn = pcQueueGetName( xQueue );
 80088c0:	f7f9 ba64 	b.w	8001d8c <pcQueueGetName>
        portRAISE_PRIVILEGE();
 80088c4:	df02      	svc	2
        pcReturn = pcQueueGetName( xQueue );
 80088c6:	4620      	mov	r0, r4
 80088c8:	f7f9 fa60 	bl	8001d8c <pcQueueGetName>
 80088cc:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 80088ce:	f001 f9df 	bl	8009c90 <vResetPrivilege>
        return pcReturn;
 80088d2:	9801      	ldr	r0, [sp, #4]
    }
 80088d4:	b002      	add	sp, #8
 80088d6:	bd10      	pop	{r4, pc}

080088d8 <MPU_xQueueGenericCreate>:
    {
 80088d8:	b510      	push	{r4, lr}
 80088da:	b082      	sub	sp, #8
 80088dc:	4604      	mov	r4, r0
 80088de:	e9cd 2100 	strd	r2, r1, [sp]
    xRunningPrivileged = portIS_PRIVILEGED();
 80088e2:	f001 f9cd 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80088e6:	e9dd 2100 	ldrd	r2, r1, [sp]
 80088ea:	b128      	cbz	r0, 80088f8 <MPU_xQueueGenericCreate+0x20>
        xReturn = xQueueGenericCreate( uxQueueLength, uxItemSize, ucQueueType );
 80088ec:	4620      	mov	r0, r4
    }
 80088ee:	b002      	add	sp, #8
 80088f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        xReturn = xQueueGenericCreate( uxQueueLength, uxItemSize, ucQueueType );
 80088f4:	f7f9 bb38 	b.w	8001f68 <xQueueGenericCreate>
        portRAISE_PRIVILEGE();
 80088f8:	df02      	svc	2
        xReturn = xQueueGenericCreate( uxQueueLength, uxItemSize, ucQueueType );
 80088fa:	4620      	mov	r0, r4
 80088fc:	f7f9 fb34 	bl	8001f68 <xQueueGenericCreate>
 8008900:	9000      	str	r0, [sp, #0]
        portRESET_PRIVILEGE();
 8008902:	f001 f9c5 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008906:	9800      	ldr	r0, [sp, #0]
    }
 8008908:	b002      	add	sp, #8
 800890a:	bd10      	pop	{r4, pc}

0800890c <MPU_xQueueGenericCreateStatic>:
    {
 800890c:	b530      	push	{r4, r5, lr}
 800890e:	b087      	sub	sp, #28
 8008910:	4604      	mov	r4, r0
 8008912:	e9cd 2104 	strd	r2, r1, [sp, #16]
 8008916:	9303      	str	r3, [sp, #12]
 8008918:	f89d 5028 	ldrb.w	r5, [sp, #40]	; 0x28
    xRunningPrivileged = portIS_PRIVILEGED();
 800891c:	f001 f9b0 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008920:	9905      	ldr	r1, [sp, #20]
 8008922:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 8008926:	b130      	cbz	r0, 8008936 <MPU_xQueueGenericCreateStatic+0x2a>
        xReturn = xQueueGenericCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxStaticQueue, ucQueueType );
 8008928:	4620      	mov	r0, r4
 800892a:	950a      	str	r5, [sp, #40]	; 0x28
    }
 800892c:	b007      	add	sp, #28
 800892e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        xReturn = xQueueGenericCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxStaticQueue, ucQueueType );
 8008932:	f7f9 bb49 	b.w	8001fc8 <xQueueGenericCreateStatic>
        portRAISE_PRIVILEGE();
 8008936:	df02      	svc	2
        xReturn = xQueueGenericCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxStaticQueue, ucQueueType );
 8008938:	4620      	mov	r0, r4
 800893a:	9500      	str	r5, [sp, #0]
 800893c:	f7f9 fb44 	bl	8001fc8 <xQueueGenericCreateStatic>
 8008940:	9003      	str	r0, [sp, #12]
        portRESET_PRIVILEGE();
 8008942:	f001 f9a5 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008946:	9803      	ldr	r0, [sp, #12]
    }
 8008948:	b007      	add	sp, #28
 800894a:	bd30      	pop	{r4, r5, pc}

0800894c <MPU_xQueueGenericReset>:
{
 800894c:	b510      	push	{r4, lr}
 800894e:	b082      	sub	sp, #8
 8008950:	4604      	mov	r4, r0
 8008952:	9101      	str	r1, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008954:	f001 f994 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008958:	9901      	ldr	r1, [sp, #4]
 800895a:	b128      	cbz	r0, 8008968 <MPU_xQueueGenericReset+0x1c>
    xReturn = xQueueGenericReset( pxQueue, xNewQueue );
 800895c:	4620      	mov	r0, r4
}
 800895e:	b002      	add	sp, #8
 8008960:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xQueueGenericReset( pxQueue, xNewQueue );
 8008964:	f7f9 bab0 	b.w	8001ec8 <xQueueGenericReset>
        portRAISE_PRIVILEGE();
 8008968:	df02      	svc	2
    xReturn = xQueueGenericReset( pxQueue, xNewQueue );
 800896a:	4620      	mov	r0, r4
 800896c:	f7f9 faac 	bl	8001ec8 <xQueueGenericReset>
 8008970:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008972:	f001 f98d 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 8008976:	9801      	ldr	r0, [sp, #4]
}
 8008978:	b002      	add	sp, #8
 800897a:	bd10      	pop	{r4, pc}

0800897c <MPU_xTimerCreate>:
    TimerHandle_t MPU_xTimerCreate( const char * const pcTimerName,
                                    const TickType_t xTimerPeriodInTicks,
                                    const UBaseType_t uxAutoReload,
                                    void * const pvTimerID,
                                    TimerCallbackFunction_t pxCallbackFunction ) /* FREERTOS_SYSTEM_CALL */
    {
 800897c:	b530      	push	{r4, r5, lr}
 800897e:	b087      	sub	sp, #28
 8008980:	4604      	mov	r4, r0
 8008982:	e9cd 2104 	strd	r2, r1, [sp, #16]
 8008986:	9303      	str	r3, [sp, #12]
 8008988:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    xRunningPrivileged = portIS_PRIVILEGED();
 800898a:	f001 f979 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 800898e:	9905      	ldr	r1, [sp, #20]
 8008990:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 8008994:	b130      	cbz	r0, 80089a4 <MPU_xTimerCreate+0x28>
        TimerHandle_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        xReturn = xTimerCreate( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction );
 8008996:	4620      	mov	r0, r4
 8008998:	950a      	str	r5, [sp, #40]	; 0x28
        vPortResetPrivilege( xRunningPrivileged );

        return xReturn;
    }
 800899a:	b007      	add	sp, #28
 800899c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        xReturn = xTimerCreate( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction );
 80089a0:	f7fc bace 	b.w	8004f40 <xTimerCreate>
        portRAISE_PRIVILEGE();
 80089a4:	df02      	svc	2
        xReturn = xTimerCreate( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction );
 80089a6:	4620      	mov	r0, r4
 80089a8:	9500      	str	r5, [sp, #0]
 80089aa:	f7fc fac9 	bl	8004f40 <xTimerCreate>
 80089ae:	9003      	str	r0, [sp, #12]
        portRESET_PRIVILEGE();
 80089b0:	f001 f96e 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 80089b4:	9803      	ldr	r0, [sp, #12]
    }
 80089b6:	b007      	add	sp, #28
 80089b8:	bd30      	pop	{r4, r5, pc}
 80089ba:	bf00      	nop

080089bc <MPU_xTimerCreateStatic>:
                                          const TickType_t xTimerPeriodInTicks,
                                          const UBaseType_t uxAutoReload,
                                          void * const pvTimerID,
                                          TimerCallbackFunction_t pxCallbackFunction,
                                          StaticTimer_t * pxTimerBuffer ) /* FREERTOS_SYSTEM_CALL */
    {
 80089bc:	b570      	push	{r4, r5, r6, lr}
 80089be:	b086      	sub	sp, #24
 80089c0:	4604      	mov	r4, r0
 80089c2:	e9cd 2104 	strd	r2, r1, [sp, #16]
 80089c6:	9303      	str	r3, [sp, #12]
 80089c8:	e9dd 560a 	ldrd	r5, r6, [sp, #40]	; 0x28
    xRunningPrivileged = portIS_PRIVILEGED();
 80089cc:	f001 f958 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 80089d0:	9905      	ldr	r1, [sp, #20]
 80089d2:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 80089d6:	b138      	cbz	r0, 80089e8 <MPU_xTimerCreateStatic+0x2c>
        TimerHandle_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        xReturn = xTimerCreateStatic( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxTimerBuffer );
 80089d8:	4620      	mov	r0, r4
 80089da:	960b      	str	r6, [sp, #44]	; 0x2c
 80089dc:	950a      	str	r5, [sp, #40]	; 0x28
        vPortResetPrivilege( xRunningPrivileged );

        return xReturn;
    }
 80089de:	b006      	add	sp, #24
 80089e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        xReturn = xTimerCreateStatic( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxTimerBuffer );
 80089e4:	f7fc bb08 	b.w	8004ff8 <xTimerCreateStatic>
        portRAISE_PRIVILEGE();
 80089e8:	df02      	svc	2
        xReturn = xTimerCreateStatic( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxTimerBuffer );
 80089ea:	4620      	mov	r0, r4
 80089ec:	9601      	str	r6, [sp, #4]
 80089ee:	9500      	str	r5, [sp, #0]
 80089f0:	f7fc fb02 	bl	8004ff8 <xTimerCreateStatic>
 80089f4:	9003      	str	r0, [sp, #12]
        portRESET_PRIVILEGE();
 80089f6:	f001 f94b 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 80089fa:	9803      	ldr	r0, [sp, #12]
    }
 80089fc:	b006      	add	sp, #24
 80089fe:	bd70      	pop	{r4, r5, r6, pc}

08008a00 <MPU_pvTimerGetTimerID>:
#endif /* if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )
    void * MPU_pvTimerGetTimerID( const TimerHandle_t xTimer ) /* FREERTOS_SYSTEM_CALL */
    {
 8008a00:	b510      	push	{r4, lr}
 8008a02:	b082      	sub	sp, #8
 8008a04:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008a06:	f001 f93b 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008a0a:	b128      	cbz	r0, 8008a18 <MPU_pvTimerGetTimerID+0x18>
        void * pvReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        pvReturn = pvTimerGetTimerID( xTimer );
 8008a0c:	4620      	mov	r0, r4
        vPortResetPrivilege( xRunningPrivileged );

        return pvReturn;
    }
 8008a0e:	b002      	add	sp, #8
 8008a10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        pvReturn = pvTimerGetTimerID( xTimer );
 8008a14:	f7fc bb64 	b.w	80050e0 <pvTimerGetTimerID>
        portRAISE_PRIVILEGE();
 8008a18:	df02      	svc	2
        pvReturn = pvTimerGetTimerID( xTimer );
 8008a1a:	4620      	mov	r0, r4
 8008a1c:	f7fc fb60 	bl	80050e0 <pvTimerGetTimerID>
 8008a20:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008a22:	f001 f935 	bl	8009c90 <vResetPrivilege>
        return pvReturn;
 8008a26:	9801      	ldr	r0, [sp, #4]
    }
 8008a28:	b002      	add	sp, #8
 8008a2a:	bd10      	pop	{r4, pc}

08008a2c <MPU_vTimerSetTimerID>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )
    void MPU_vTimerSetTimerID( TimerHandle_t xTimer,
                               void * pvNewID ) /* FREERTOS_SYSTEM_CALL */
    {
 8008a2c:	b510      	push	{r4, lr}
 8008a2e:	b082      	sub	sp, #8
 8008a30:	4604      	mov	r4, r0
 8008a32:	9101      	str	r1, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008a34:	f001 f924 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008a38:	9901      	ldr	r1, [sp, #4]
 8008a3a:	b940      	cbnz	r0, 8008a4e <MPU_vTimerSetTimerID+0x22>
        portRAISE_PRIVILEGE();
 8008a3c:	df02      	svc	2
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        vTimerSetTimerID( xTimer, pvNewID );
 8008a3e:	4620      	mov	r0, r4
 8008a40:	f7fc fb64 	bl	800510c <vTimerSetTimerID>
        vPortResetPrivilege( xRunningPrivileged );
    }
 8008a44:	b002      	add	sp, #8
 8008a46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 8008a4a:	f001 b921 	b.w	8009c90 <vResetPrivilege>
        vTimerSetTimerID( xTimer, pvNewID );
 8008a4e:	4620      	mov	r0, r4
    }
 8008a50:	b002      	add	sp, #8
 8008a52:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        vTimerSetTimerID( xTimer, pvNewID );
 8008a56:	f7fc bb59 	b.w	800510c <vTimerSetTimerID>
 8008a5a:	bf00      	nop

08008a5c <MPU_xTimerIsTimerActive>:
#endif
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )
    BaseType_t MPU_xTimerIsTimerActive( TimerHandle_t xTimer ) /* FREERTOS_SYSTEM_CALL */
    {
 8008a5c:	b510      	push	{r4, lr}
 8008a5e:	b082      	sub	sp, #8
 8008a60:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008a62:	f001 f90d 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008a66:	b128      	cbz	r0, 8008a74 <MPU_xTimerIsTimerActive+0x18>
        BaseType_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        xReturn = xTimerIsTimerActive( xTimer );
 8008a68:	4620      	mov	r0, r4
        vPortResetPrivilege( xRunningPrivileged );

        return xReturn;
    }
 8008a6a:	b002      	add	sp, #8
 8008a6c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        xReturn = xTimerIsTimerActive( xTimer );
 8008a70:	f7fc bb60 	b.w	8005134 <xTimerIsTimerActive>
        portRAISE_PRIVILEGE();
 8008a74:	df02      	svc	2
        xReturn = xTimerIsTimerActive( xTimer );
 8008a76:	4620      	mov	r0, r4
 8008a78:	f7fc fb5c 	bl	8005134 <xTimerIsTimerActive>
 8008a7c:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008a7e:	f001 f907 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008a82:	9801      	ldr	r0, [sp, #4]
    }
 8008a84:	b002      	add	sp, #8
 8008a86:	bd10      	pop	{r4, pc}

08008a88 <MPU_xTimerGetTimerDaemonTaskHandle>:
#endif /* if ( configUSE_TIMERS == 1 ) */
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )
    TaskHandle_t MPU_xTimerGetTimerDaemonTaskHandle( void ) /* FREERTOS_SYSTEM_CALL */
    {
 8008a88:	b500      	push	{lr}
 8008a8a:	b083      	sub	sp, #12
    xRunningPrivileged = portIS_PRIVILEGED();
 8008a8c:	f001 f8f8 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008a90:	b120      	cbz	r0, 8008a9c <MPU_xTimerGetTimerDaemonTaskHandle+0x14>

        xReturn = xTimerGetTimerDaemonTaskHandle();
        vPortResetPrivilege( xRunningPrivileged );

        return xReturn;
    }
 8008a92:	b003      	add	sp, #12
 8008a94:	f85d eb04 	ldr.w	lr, [sp], #4
        xReturn = xTimerGetTimerDaemonTaskHandle();
 8008a98:	f7fc bb66 	b.w	8005168 <xTimerGetTimerDaemonTaskHandle>
        portRAISE_PRIVILEGE();
 8008a9c:	df02      	svc	2
        xReturn = xTimerGetTimerDaemonTaskHandle();
 8008a9e:	f7fc fb63 	bl	8005168 <xTimerGetTimerDaemonTaskHandle>
 8008aa2:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008aa4:	f001 f8f4 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008aa8:	9801      	ldr	r0, [sp, #4]
    }
 8008aaa:	b003      	add	sp, #12
 8008aac:	f85d fb04 	ldr.w	pc, [sp], #4

08008ab0 <MPU_xTimerPendFunctionCall>:
#if ( ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
    BaseType_t MPU_xTimerPendFunctionCall( PendedFunction_t xFunctionToPend,
                                           void * pvParameter1,
                                           uint32_t ulParameter2,
                                           TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
    {
 8008ab0:	b510      	push	{r4, lr}
 8008ab2:	b084      	sub	sp, #16
 8008ab4:	4604      	mov	r4, r0
 8008ab6:	e9cd 2102 	strd	r2, r1, [sp, #8]
 8008aba:	9301      	str	r3, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008abc:	f001 f8e0 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008ac0:	9903      	ldr	r1, [sp, #12]
 8008ac2:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
 8008ac6:	b128      	cbz	r0, 8008ad4 <MPU_xTimerPendFunctionCall+0x24>
        BaseType_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        xReturn = xTimerPendFunctionCall( xFunctionToPend, pvParameter1, ulParameter2, xTicksToWait );
 8008ac8:	4620      	mov	r0, r4
        vPortResetPrivilege( xRunningPrivileged );

        return xReturn;
    }
 8008aca:	b004      	add	sp, #16
 8008acc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        xReturn = xTimerPendFunctionCall( xFunctionToPend, pvParameter1, ulParameter2, xTicksToWait );
 8008ad0:	f7fc bb6e 	b.w	80051b0 <xTimerPendFunctionCall>
        portRAISE_PRIVILEGE();
 8008ad4:	df02      	svc	2
        xReturn = xTimerPendFunctionCall( xFunctionToPend, pvParameter1, ulParameter2, xTicksToWait );
 8008ad6:	4620      	mov	r0, r4
 8008ad8:	f7fc fb6a 	bl	80051b0 <xTimerPendFunctionCall>
 8008adc:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008ade:	f001 f8d7 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008ae2:	9801      	ldr	r0, [sp, #4]
    }
 8008ae4:	b004      	add	sp, #16
 8008ae6:	bd10      	pop	{r4, pc}

08008ae8 <MPU_pcTimerGetName>:
#endif
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )
    const char * MPU_pcTimerGetName( TimerHandle_t xTimer ) /* FREERTOS_SYSTEM_CALL */
    {
 8008ae8:	b510      	push	{r4, lr}
 8008aea:	b082      	sub	sp, #8
 8008aec:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008aee:	f001 f8c7 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008af2:	b128      	cbz	r0, 8008b00 <MPU_pcTimerGetName+0x18>
        const char * pcReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        pcReturn = pcTimerGetName( xTimer );
 8008af4:	4620      	mov	r0, r4
        vPortResetPrivilege( xRunningPrivileged );

        return pcReturn;
    }
 8008af6:	b002      	add	sp, #8
 8008af8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        pcReturn = pcTimerGetName( xTimer );
 8008afc:	f7fc bb78 	b.w	80051f0 <pcTimerGetName>
        portRAISE_PRIVILEGE();
 8008b00:	df02      	svc	2
        pcReturn = pcTimerGetName( xTimer );
 8008b02:	4620      	mov	r0, r4
 8008b04:	f7fc fb74 	bl	80051f0 <pcTimerGetName>
 8008b08:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008b0a:	f001 f8c1 	bl	8009c90 <vResetPrivilege>
        return pcReturn;
 8008b0e:	9801      	ldr	r0, [sp, #4]
    }
 8008b10:	b002      	add	sp, #8
 8008b12:	bd10      	pop	{r4, pc}

08008b14 <MPU_vTimerSetReloadMode>:
    {
 8008b14:	b510      	push	{r4, lr}
 8008b16:	b082      	sub	sp, #8
 8008b18:	4604      	mov	r4, r0
 8008b1a:	9101      	str	r1, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008b1c:	f001 f8b0 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008b20:	9901      	ldr	r1, [sp, #4]
 8008b22:	b940      	cbnz	r0, 8008b36 <MPU_vTimerSetReloadMode+0x22>
        portRAISE_PRIVILEGE();
 8008b24:	df02      	svc	2
        vTimerSetReloadMode( xTimer, uxAutoReload );
 8008b26:	4620      	mov	r0, r4
 8008b28:	f7fc fb6e 	bl	8005208 <vTimerSetReloadMode>
    }
 8008b2c:	b002      	add	sp, #8
 8008b2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 8008b32:	f001 b8ad 	b.w	8009c90 <vResetPrivilege>
        vTimerSetReloadMode( xTimer, uxAutoReload );
 8008b36:	4620      	mov	r0, r4
    }
 8008b38:	b002      	add	sp, #8
 8008b3a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        vTimerSetReloadMode( xTimer, uxAutoReload );
 8008b3e:	f7fc bb63 	b.w	8005208 <vTimerSetReloadMode>
 8008b42:	bf00      	nop

08008b44 <MPU_uxTimerGetReloadMode>:
    {
 8008b44:	b510      	push	{r4, lr}
 8008b46:	b082      	sub	sp, #8
 8008b48:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008b4a:	f001 f899 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008b4e:	b128      	cbz	r0, 8008b5c <MPU_uxTimerGetReloadMode+0x18>
        uxReturn = uxTimerGetReloadMode( xTimer );
 8008b50:	4620      	mov	r0, r4
    }
 8008b52:	b002      	add	sp, #8
 8008b54:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        uxReturn = uxTimerGetReloadMode( xTimer );
 8008b58:	f7fc bb78 	b.w	800524c <uxTimerGetReloadMode>
        portRAISE_PRIVILEGE();
 8008b5c:	df02      	svc	2
        uxReturn = uxTimerGetReloadMode( xTimer );
 8008b5e:	4620      	mov	r0, r4
 8008b60:	f7fc fb74 	bl	800524c <uxTimerGetReloadMode>
 8008b64:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008b66:	f001 f893 	bl	8009c90 <vResetPrivilege>
        return uxReturn;
 8008b6a:	9801      	ldr	r0, [sp, #4]
    }
 8008b6c:	b002      	add	sp, #8
 8008b6e:	bd10      	pop	{r4, pc}

08008b70 <MPU_xTimerGetPeriod>:
#endif /* if ( configUSE_TIMERS == 1 ) */
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )
    TickType_t MPU_xTimerGetPeriod( TimerHandle_t xTimer ) /* FREERTOS_SYSTEM_CALL */
    {
 8008b70:	b510      	push	{r4, lr}
 8008b72:	b082      	sub	sp, #8
 8008b74:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008b76:	f001 f883 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008b7a:	b128      	cbz	r0, 8008b88 <MPU_xTimerGetPeriod+0x18>
        TickType_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        xReturn = xTimerGetPeriod( xTimer );
 8008b7c:	4620      	mov	r0, r4
        vPortResetPrivilege( xRunningPrivileged );

        return xReturn;
    }
 8008b7e:	b002      	add	sp, #8
 8008b80:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        xReturn = xTimerGetPeriod( xTimer );
 8008b84:	f7fc bb7c 	b.w	8005280 <xTimerGetPeriod>
        portRAISE_PRIVILEGE();
 8008b88:	df02      	svc	2
        xReturn = xTimerGetPeriod( xTimer );
 8008b8a:	4620      	mov	r0, r4
 8008b8c:	f7fc fb78 	bl	8005280 <xTimerGetPeriod>
 8008b90:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008b92:	f001 f87d 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008b96:	9801      	ldr	r0, [sp, #4]
    }
 8008b98:	b002      	add	sp, #8
 8008b9a:	bd10      	pop	{r4, pc}

08008b9c <MPU_xTimerGetExpiryTime>:
#endif /* if ( configUSE_TIMERS == 1 ) */
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )
    TickType_t MPU_xTimerGetExpiryTime( TimerHandle_t xTimer ) /* FREERTOS_SYSTEM_CALL */
    {
 8008b9c:	b510      	push	{r4, lr}
 8008b9e:	b082      	sub	sp, #8
 8008ba0:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008ba2:	f001 f86d 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008ba6:	b128      	cbz	r0, 8008bb4 <MPU_xTimerGetExpiryTime+0x18>
        TickType_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        xReturn = xTimerGetExpiryTime( xTimer );
 8008ba8:	4620      	mov	r0, r4
        vPortResetPrivilege( xRunningPrivileged );

        return xReturn;
    }
 8008baa:	b002      	add	sp, #8
 8008bac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        xReturn = xTimerGetExpiryTime( xTimer );
 8008bb0:	f7fc bb72 	b.w	8005298 <xTimerGetExpiryTime>
        portRAISE_PRIVILEGE();
 8008bb4:	df02      	svc	2
        xReturn = xTimerGetExpiryTime( xTimer );
 8008bb6:	4620      	mov	r0, r4
 8008bb8:	f7fc fb6e 	bl	8005298 <xTimerGetExpiryTime>
 8008bbc:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008bbe:	f001 f867 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008bc2:	9801      	ldr	r0, [sp, #4]
    }
 8008bc4:	b002      	add	sp, #8
 8008bc6:	bd10      	pop	{r4, pc}

08008bc8 <MPU_xTimerGenericCommand>:
    BaseType_t MPU_xTimerGenericCommand( TimerHandle_t xTimer,
                                         const BaseType_t xCommandID,
                                         const TickType_t xOptionalValue,
                                         BaseType_t * const pxHigherPriorityTaskWoken,
                                         const TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
    {
 8008bc8:	b530      	push	{r4, r5, lr}
 8008bca:	b087      	sub	sp, #28
 8008bcc:	4604      	mov	r4, r0
 8008bce:	e9cd 2104 	strd	r2, r1, [sp, #16]
 8008bd2:	9303      	str	r3, [sp, #12]
 8008bd4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    xRunningPrivileged = portIS_PRIVILEGED();
 8008bd6:	f001 f853 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008bda:	9905      	ldr	r1, [sp, #20]
 8008bdc:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 8008be0:	b130      	cbz	r0, 8008bf0 <MPU_xTimerGenericCommand+0x28>
        BaseType_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        xReturn = xTimerGenericCommand( xTimer, xCommandID, xOptionalValue, pxHigherPriorityTaskWoken, xTicksToWait );
 8008be2:	4620      	mov	r0, r4
 8008be4:	950a      	str	r5, [sp, #40]	; 0x28
        vPortResetPrivilege( xRunningPrivileged );

        return xReturn;
    }
 8008be6:	b007      	add	sp, #28
 8008be8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        xReturn = xTimerGenericCommand( xTimer, xCommandID, xOptionalValue, pxHigherPriorityTaskWoken, xTicksToWait );
 8008bec:	f7fc bbb4 	b.w	8005358 <xTimerGenericCommand>
        portRAISE_PRIVILEGE();
 8008bf0:	df02      	svc	2
        xReturn = xTimerGenericCommand( xTimer, xCommandID, xOptionalValue, pxHigherPriorityTaskWoken, xTicksToWait );
 8008bf2:	4620      	mov	r0, r4
 8008bf4:	9500      	str	r5, [sp, #0]
 8008bf6:	f7fc fbaf 	bl	8005358 <xTimerGenericCommand>
 8008bfa:	9003      	str	r0, [sp, #12]
        portRESET_PRIVILEGE();
 8008bfc:	f001 f848 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008c00:	9803      	ldr	r0, [sp, #12]
    }
 8008c02:	b007      	add	sp, #28
 8008c04:	bd30      	pop	{r4, r5, pc}
 8008c06:	bf00      	nop

08008c08 <MPU_xEventGroupCreate>:
#endif /* if ( configUSE_TIMERS == 1 ) */
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    EventGroupHandle_t MPU_xEventGroupCreate( void ) /* FREERTOS_SYSTEM_CALL */
    {
 8008c08:	b500      	push	{lr}
 8008c0a:	b083      	sub	sp, #12
    xRunningPrivileged = portIS_PRIVILEGED();
 8008c0c:	f001 f838 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008c10:	b120      	cbz	r0, 8008c1c <MPU_xEventGroupCreate+0x14>

        xReturn = xEventGroupCreate();
        vPortResetPrivilege( xRunningPrivileged );

        return xReturn;
    }
 8008c12:	b003      	add	sp, #12
 8008c14:	f85d eb04 	ldr.w	lr, [sp], #4
        xReturn = xEventGroupCreate();
 8008c18:	f7f7 bbac 	b.w	8000374 <xEventGroupCreate>
        portRAISE_PRIVILEGE();
 8008c1c:	df02      	svc	2
        xReturn = xEventGroupCreate();
 8008c1e:	f7f7 fba9 	bl	8000374 <xEventGroupCreate>
 8008c22:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008c24:	f001 f834 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008c28:	9801      	ldr	r0, [sp, #4]
    }
 8008c2a:	b003      	add	sp, #12
 8008c2c:	f85d fb04 	ldr.w	pc, [sp], #4

08008c30 <MPU_xEventGroupCreateStatic>:
#endif /* if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

#if ( configSUPPORT_STATIC_ALLOCATION == 1 )
    EventGroupHandle_t MPU_xEventGroupCreateStatic( StaticEventGroup_t * pxEventGroupBuffer ) /* FREERTOS_SYSTEM_CALL */
    {
 8008c30:	b510      	push	{r4, lr}
 8008c32:	b082      	sub	sp, #8
 8008c34:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008c36:	f001 f823 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008c3a:	b128      	cbz	r0, 8008c48 <MPU_xEventGroupCreateStatic+0x18>
        EventGroupHandle_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        xReturn = xEventGroupCreateStatic( pxEventGroupBuffer );
 8008c3c:	4620      	mov	r0, r4
        vPortResetPrivilege( xRunningPrivileged );

        return xReturn;
    }
 8008c3e:	b002      	add	sp, #8
 8008c40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        xReturn = xEventGroupCreateStatic( pxEventGroupBuffer );
 8008c44:	f7f7 bba4 	b.w	8000390 <xEventGroupCreateStatic>
        portRAISE_PRIVILEGE();
 8008c48:	df02      	svc	2
        xReturn = xEventGroupCreateStatic( pxEventGroupBuffer );
 8008c4a:	4620      	mov	r0, r4
 8008c4c:	f7f7 fba0 	bl	8000390 <xEventGroupCreateStatic>
 8008c50:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008c52:	f001 f81d 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008c56:	9801      	ldr	r0, [sp, #4]
    }
 8008c58:	b002      	add	sp, #8
 8008c5a:	bd10      	pop	{r4, pc}

08008c5c <MPU_xEventGroupWaitBits>:
EventBits_t MPU_xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                     const EventBits_t uxBitsToWaitFor,
                                     const BaseType_t xClearOnExit,
                                     const BaseType_t xWaitForAllBits,
                                     TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
{
 8008c5c:	b530      	push	{r4, r5, lr}
 8008c5e:	b087      	sub	sp, #28
 8008c60:	4604      	mov	r4, r0
 8008c62:	e9cd 2104 	strd	r2, r1, [sp, #16]
 8008c66:	9303      	str	r3, [sp, #12]
 8008c68:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    xRunningPrivileged = portIS_PRIVILEGED();
 8008c6a:	f001 f809 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008c6e:	9905      	ldr	r1, [sp, #20]
 8008c70:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 8008c74:	b130      	cbz	r0, 8008c84 <MPU_xEventGroupWaitBits+0x28>
    EventBits_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    xReturn = xEventGroupWaitBits( xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait );
 8008c76:	4620      	mov	r0, r4
 8008c78:	950a      	str	r5, [sp, #40]	; 0x28
    vPortResetPrivilege( xRunningPrivileged );

    return xReturn;
}
 8008c7a:	b007      	add	sp, #28
 8008c7c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    xReturn = xEventGroupWaitBits( xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait );
 8008c80:	f7f7 bbac 	b.w	80003dc <xEventGroupWaitBits>
        portRAISE_PRIVILEGE();
 8008c84:	df02      	svc	2
    xReturn = xEventGroupWaitBits( xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait );
 8008c86:	4620      	mov	r0, r4
 8008c88:	9500      	str	r5, [sp, #0]
 8008c8a:	f7f7 fba7 	bl	80003dc <xEventGroupWaitBits>
 8008c8e:	9003      	str	r0, [sp, #12]
        portRESET_PRIVILEGE();
 8008c90:	f000 fffe 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 8008c94:	9803      	ldr	r0, [sp, #12]
}
 8008c96:	b007      	add	sp, #28
 8008c98:	bd30      	pop	{r4, r5, pc}
 8008c9a:	bf00      	nop

08008c9c <MPU_xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t MPU_xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                      const EventBits_t uxBitsToClear ) /* FREERTOS_SYSTEM_CALL */
{
 8008c9c:	b510      	push	{r4, lr}
 8008c9e:	b082      	sub	sp, #8
 8008ca0:	4604      	mov	r4, r0
 8008ca2:	9101      	str	r1, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008ca4:	f000 ffec 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008ca8:	9901      	ldr	r1, [sp, #4]
 8008caa:	b128      	cbz	r0, 8008cb8 <MPU_xEventGroupClearBits+0x1c>
    EventBits_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    xReturn = xEventGroupClearBits( xEventGroup, uxBitsToClear );
 8008cac:	4620      	mov	r0, r4
    vPortResetPrivilege( xRunningPrivileged );

    return xReturn;
}
 8008cae:	b002      	add	sp, #8
 8008cb0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xEventGroupClearBits( xEventGroup, uxBitsToClear );
 8008cb4:	f7f7 bc1a 	b.w	80004ec <xEventGroupClearBits>
        portRAISE_PRIVILEGE();
 8008cb8:	df02      	svc	2
    xReturn = xEventGroupClearBits( xEventGroup, uxBitsToClear );
 8008cba:	4620      	mov	r0, r4
 8008cbc:	f7f7 fc16 	bl	80004ec <xEventGroupClearBits>
 8008cc0:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008cc2:	f000 ffe5 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 8008cc6:	9801      	ldr	r0, [sp, #4]
}
 8008cc8:	b002      	add	sp, #8
 8008cca:	bd10      	pop	{r4, pc}

08008ccc <MPU_xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t MPU_xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                    const EventBits_t uxBitsToSet ) /* FREERTOS_SYSTEM_CALL */
{
 8008ccc:	b510      	push	{r4, lr}
 8008cce:	b082      	sub	sp, #8
 8008cd0:	4604      	mov	r4, r0
 8008cd2:	9101      	str	r1, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008cd4:	f000 ffd4 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008cd8:	9901      	ldr	r1, [sp, #4]
 8008cda:	b128      	cbz	r0, 8008ce8 <MPU_xEventGroupSetBits+0x1c>
    EventBits_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    xReturn = xEventGroupSetBits( xEventGroup, uxBitsToSet );
 8008cdc:	4620      	mov	r0, r4
    vPortResetPrivilege( xRunningPrivileged );

    return xReturn;
}
 8008cde:	b002      	add	sp, #8
 8008ce0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xEventGroupSetBits( xEventGroup, uxBitsToSet );
 8008ce4:	f7f7 bc30 	b.w	8000548 <xEventGroupSetBits>
        portRAISE_PRIVILEGE();
 8008ce8:	df02      	svc	2
    xReturn = xEventGroupSetBits( xEventGroup, uxBitsToSet );
 8008cea:	4620      	mov	r0, r4
 8008cec:	f7f7 fc2c 	bl	8000548 <xEventGroupSetBits>
 8008cf0:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008cf2:	f000 ffcd 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 8008cf6:	9801      	ldr	r0, [sp, #4]
}
 8008cf8:	b002      	add	sp, #8
 8008cfa:	bd10      	pop	{r4, pc}

08008cfc <MPU_xEventGroupSync>:

EventBits_t MPU_xEventGroupSync( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToSet,
                                 const EventBits_t uxBitsToWaitFor,
                                 TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
{
 8008cfc:	b510      	push	{r4, lr}
 8008cfe:	b084      	sub	sp, #16
 8008d00:	4604      	mov	r4, r0
 8008d02:	e9cd 2102 	strd	r2, r1, [sp, #8]
 8008d06:	9301      	str	r3, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008d08:	f000 ffba 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008d0c:	9903      	ldr	r1, [sp, #12]
 8008d0e:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
 8008d12:	b128      	cbz	r0, 8008d20 <MPU_xEventGroupSync+0x24>
    EventBits_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    xReturn = xEventGroupSync( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait );
 8008d14:	4620      	mov	r0, r4
    vPortResetPrivilege( xRunningPrivileged );

    return xReturn;
}
 8008d16:	b004      	add	sp, #16
 8008d18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xEventGroupSync( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait );
 8008d1c:	f7f7 bc68 	b.w	80005f0 <xEventGroupSync>
        portRAISE_PRIVILEGE();
 8008d20:	df02      	svc	2
    xReturn = xEventGroupSync( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait );
 8008d22:	4620      	mov	r0, r4
 8008d24:	f7f7 fc64 	bl	80005f0 <xEventGroupSync>
 8008d28:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008d2a:	f000 ffb1 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 8008d2e:	9801      	ldr	r0, [sp, #4]
}
 8008d30:	b004      	add	sp, #16
 8008d32:	bd10      	pop	{r4, pc}

08008d34 <MPU_vEventGroupDelete>:
/*-----------------------------------------------------------*/

void MPU_vEventGroupDelete( EventGroupHandle_t xEventGroup ) /* FREERTOS_SYSTEM_CALL */
{
 8008d34:	b510      	push	{r4, lr}
 8008d36:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008d38:	f000 ffa2 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008d3c:	b938      	cbnz	r0, 8008d4e <MPU_vEventGroupDelete+0x1a>
        portRAISE_PRIVILEGE();
 8008d3e:	df02      	svc	2
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    vEventGroupDelete( xEventGroup );
 8008d40:	4620      	mov	r0, r4
 8008d42:	f7f7 fcdb 	bl	80006fc <vEventGroupDelete>
    vPortResetPrivilege( xRunningPrivileged );
}
 8008d46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 8008d4a:	f000 bfa1 	b.w	8009c90 <vResetPrivilege>
    vEventGroupDelete( xEventGroup );
 8008d4e:	4620      	mov	r0, r4
}
 8008d50:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    vEventGroupDelete( xEventGroup );
 8008d54:	f7f7 bcd2 	b.w	80006fc <vEventGroupDelete>

08008d58 <MPU_xStreamBufferSend>:

size_t MPU_xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                              const void * pvTxData,
                              size_t xDataLengthBytes,
                              TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
{
 8008d58:	b510      	push	{r4, lr}
 8008d5a:	b084      	sub	sp, #16
 8008d5c:	4604      	mov	r4, r0
 8008d5e:	e9cd 2102 	strd	r2, r1, [sp, #8]
 8008d62:	9301      	str	r3, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008d64:	f000 ff8c 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008d68:	9903      	ldr	r1, [sp, #12]
 8008d6a:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
 8008d6e:	b128      	cbz	r0, 8008d7c <MPU_xStreamBufferSend+0x24>
    size_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    xReturn = xStreamBufferSend( xStreamBuffer, pvTxData, xDataLengthBytes, xTicksToWait );
 8008d70:	4620      	mov	r0, r4
    vPortResetPrivilege( xRunningPrivileged );

    return xReturn;
}
 8008d72:	b004      	add	sp, #16
 8008d74:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xStreamBufferSend( xStreamBuffer, pvTxData, xDataLengthBytes, xTicksToWait );
 8008d78:	f7f9 b9f2 	b.w	8002160 <xStreamBufferSend>
        portRAISE_PRIVILEGE();
 8008d7c:	df02      	svc	2
    xReturn = xStreamBufferSend( xStreamBuffer, pvTxData, xDataLengthBytes, xTicksToWait );
 8008d7e:	4620      	mov	r0, r4
 8008d80:	f7f9 f9ee 	bl	8002160 <xStreamBufferSend>
 8008d84:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008d86:	f000 ff83 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 8008d8a:	9801      	ldr	r0, [sp, #4]
}
 8008d8c:	b004      	add	sp, #16
 8008d8e:	bd10      	pop	{r4, pc}

08008d90 <MPU_xStreamBufferReceive>:

size_t MPU_xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                                 void * pvRxData,
                                 size_t xBufferLengthBytes,
                                 TickType_t xTicksToWait ) /* FREERTOS_SYSTEM_CALL */
{
 8008d90:	b510      	push	{r4, lr}
 8008d92:	b084      	sub	sp, #16
 8008d94:	4604      	mov	r4, r0
 8008d96:	e9cd 2102 	strd	r2, r1, [sp, #8]
 8008d9a:	9301      	str	r3, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008d9c:	f000 ff70 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008da0:	9903      	ldr	r1, [sp, #12]
 8008da2:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
 8008da6:	b128      	cbz	r0, 8008db4 <MPU_xStreamBufferReceive+0x24>
    size_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    xReturn = xStreamBufferReceive( xStreamBuffer, pvRxData, xBufferLengthBytes, xTicksToWait );
 8008da8:	4620      	mov	r0, r4
    vPortResetPrivilege( xRunningPrivileged );

    return xReturn;
}
 8008daa:	b004      	add	sp, #16
 8008dac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xStreamBufferReceive( xStreamBuffer, pvRxData, xBufferLengthBytes, xTicksToWait );
 8008db0:	f7f9 bb20 	b.w	80023f4 <xStreamBufferReceive>
        portRAISE_PRIVILEGE();
 8008db4:	df02      	svc	2
    xReturn = xStreamBufferReceive( xStreamBuffer, pvRxData, xBufferLengthBytes, xTicksToWait );
 8008db6:	4620      	mov	r0, r4
 8008db8:	f7f9 fb1c 	bl	80023f4 <xStreamBufferReceive>
 8008dbc:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008dbe:	f000 ff67 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 8008dc2:	9801      	ldr	r0, [sp, #4]
}
 8008dc4:	b004      	add	sp, #16
 8008dc6:	bd10      	pop	{r4, pc}

08008dc8 <MPU_xStreamBufferNextMessageLengthBytes>:
{
 8008dc8:	b510      	push	{r4, lr}
 8008dca:	b082      	sub	sp, #8
 8008dcc:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008dce:	f000 ff57 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008dd2:	b128      	cbz	r0, 8008de0 <MPU_xStreamBufferNextMessageLengthBytes+0x18>
    xReturn = xStreamBufferNextMessageLengthBytes( xStreamBuffer );
 8008dd4:	4620      	mov	r0, r4
}
 8008dd6:	b002      	add	sp, #8
 8008dd8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xStreamBufferNextMessageLengthBytes( xStreamBuffer );
 8008ddc:	f7f9 bddc 	b.w	8002998 <xStreamBufferNextMessageLengthBytes>
        portRAISE_PRIVILEGE();
 8008de0:	df02      	svc	2
    xReturn = xStreamBufferNextMessageLengthBytes( xStreamBuffer );
 8008de2:	4620      	mov	r0, r4
 8008de4:	f7f9 fdd8 	bl	8002998 <xStreamBufferNextMessageLengthBytes>
 8008de8:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008dea:	f000 ff51 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 8008dee:	9801      	ldr	r0, [sp, #4]
}
 8008df0:	b002      	add	sp, #8
 8008df2:	bd10      	pop	{r4, pc}

08008df4 <MPU_vStreamBufferDelete>:
/*-----------------------------------------------------------*/

void MPU_vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */
{
 8008df4:	b510      	push	{r4, lr}
 8008df6:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008df8:	f000 ff42 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008dfc:	b938      	cbnz	r0, 8008e0e <MPU_vStreamBufferDelete+0x1a>
        portRAISE_PRIVILEGE();
 8008dfe:	df02      	svc	2
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    vStreamBufferDelete( xStreamBuffer );
 8008e00:	4620      	mov	r0, r4
 8008e02:	f7f9 fbe5 	bl	80025d0 <vStreamBufferDelete>
    vPortResetPrivilege( xRunningPrivileged );
}
 8008e06:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 8008e0a:	f000 bf41 	b.w	8009c90 <vResetPrivilege>
    vStreamBufferDelete( xStreamBuffer );
 8008e0e:	4620      	mov	r0, r4
}
 8008e10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    vStreamBufferDelete( xStreamBuffer );
 8008e14:	f7f9 bbdc 	b.w	80025d0 <vStreamBufferDelete>

08008e18 <MPU_xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t MPU_xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */
{
 8008e18:	b510      	push	{r4, lr}
 8008e1a:	b082      	sub	sp, #8
 8008e1c:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008e1e:	f000 ff2f 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008e22:	b128      	cbz	r0, 8008e30 <MPU_xStreamBufferIsFull+0x18>
    BaseType_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    xReturn = xStreamBufferIsFull( xStreamBuffer );
 8008e24:	4620      	mov	r0, r4
    vPortResetPrivilege( xRunningPrivileged );

    return xReturn;
}
 8008e26:	b002      	add	sp, #8
 8008e28:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xStreamBufferIsFull( xStreamBuffer );
 8008e2c:	f7f9 bbe4 	b.w	80025f8 <xStreamBufferIsFull>
        portRAISE_PRIVILEGE();
 8008e30:	df02      	svc	2
    xReturn = xStreamBufferIsFull( xStreamBuffer );
 8008e32:	4620      	mov	r0, r4
 8008e34:	f7f9 fbe0 	bl	80025f8 <xStreamBufferIsFull>
 8008e38:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008e3a:	f000 ff29 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 8008e3e:	9801      	ldr	r0, [sp, #4]
}
 8008e40:	b002      	add	sp, #8
 8008e42:	bd10      	pop	{r4, pc}

08008e44 <MPU_xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t MPU_xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */
{
 8008e44:	b510      	push	{r4, lr}
 8008e46:	b082      	sub	sp, #8
 8008e48:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008e4a:	f000 ff19 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008e4e:	b128      	cbz	r0, 8008e5c <MPU_xStreamBufferIsEmpty+0x18>
    BaseType_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    xReturn = xStreamBufferIsEmpty( xStreamBuffer );
 8008e50:	4620      	mov	r0, r4
    vPortResetPrivilege( xRunningPrivileged );

    return xReturn;
}
 8008e52:	b002      	add	sp, #8
 8008e54:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xStreamBufferIsEmpty( xStreamBuffer );
 8008e58:	f7f9 bbf6 	b.w	8002648 <xStreamBufferIsEmpty>
        portRAISE_PRIVILEGE();
 8008e5c:	df02      	svc	2
    xReturn = xStreamBufferIsEmpty( xStreamBuffer );
 8008e5e:	4620      	mov	r0, r4
 8008e60:	f7f9 fbf2 	bl	8002648 <xStreamBufferIsEmpty>
 8008e64:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008e66:	f000 ff13 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 8008e6a:	9801      	ldr	r0, [sp, #4]
}
 8008e6c:	b002      	add	sp, #8
 8008e6e:	bd10      	pop	{r4, pc}

08008e70 <MPU_xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t MPU_xStreamBufferReset( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */
{
 8008e70:	b510      	push	{r4, lr}
 8008e72:	b082      	sub	sp, #8
 8008e74:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008e76:	f000 ff03 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008e7a:	b128      	cbz	r0, 8008e88 <MPU_xStreamBufferReset+0x18>
    BaseType_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    xReturn = xStreamBufferReset( xStreamBuffer );
 8008e7c:	4620      	mov	r0, r4
    vPortResetPrivilege( xRunningPrivileged );

    return xReturn;
}
 8008e7e:	b002      	add	sp, #8
 8008e80:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xStreamBufferReset( xStreamBuffer );
 8008e84:	f7f9 bbf2 	b.w	800266c <xStreamBufferReset>
        portRAISE_PRIVILEGE();
 8008e88:	df02      	svc	2
    xReturn = xStreamBufferReset( xStreamBuffer );
 8008e8a:	4620      	mov	r0, r4
 8008e8c:	f7f9 fbee 	bl	800266c <xStreamBufferReset>
 8008e90:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008e92:	f000 fefd 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 8008e96:	9801      	ldr	r0, [sp, #4]
}
 8008e98:	b002      	add	sp, #8
 8008e9a:	bd10      	pop	{r4, pc}

08008e9c <MPU_xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t MPU_xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */
{
 8008e9c:	b510      	push	{r4, lr}
 8008e9e:	b082      	sub	sp, #8
 8008ea0:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008ea2:	f000 feed 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008ea6:	b128      	cbz	r0, 8008eb4 <MPU_xStreamBufferSpacesAvailable+0x18>
    size_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    xReturn = xStreamBufferSpacesAvailable( xStreamBuffer );
 8008ea8:	4620      	mov	r0, r4
    vPortResetPrivilege( xRunningPrivileged );

    return xReturn;
}
 8008eaa:	b002      	add	sp, #8
 8008eac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xStreamBufferSpacesAvailable( xStreamBuffer );
 8008eb0:	f7f9 bc22 	b.w	80026f8 <xStreamBufferSpacesAvailable>
        portRAISE_PRIVILEGE();
 8008eb4:	df02      	svc	2
    xReturn = xStreamBufferSpacesAvailable( xStreamBuffer );
 8008eb6:	4620      	mov	r0, r4
 8008eb8:	f7f9 fc1e 	bl	80026f8 <xStreamBufferSpacesAvailable>
 8008ebc:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008ebe:	f000 fee7 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 8008ec2:	9801      	ldr	r0, [sp, #4]
}
 8008ec4:	b002      	add	sp, #8
 8008ec6:	bd10      	pop	{r4, pc}

08008ec8 <MPU_xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t MPU_xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer ) /* FREERTOS_SYSTEM_CALL */
{
 8008ec8:	b510      	push	{r4, lr}
 8008eca:	b082      	sub	sp, #8
 8008ecc:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008ece:	f000 fed7 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008ed2:	b128      	cbz	r0, 8008ee0 <MPU_xStreamBufferBytesAvailable+0x18>
    size_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    xReturn = xStreamBufferBytesAvailable( xStreamBuffer );
 8008ed4:	4620      	mov	r0, r4
    vPortResetPrivilege( xRunningPrivileged );

    return xReturn;
}
 8008ed6:	b002      	add	sp, #8
 8008ed8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xStreamBufferBytesAvailable( xStreamBuffer );
 8008edc:	f7f9 bc26 	b.w	800272c <xStreamBufferBytesAvailable>
        portRAISE_PRIVILEGE();
 8008ee0:	df02      	svc	2
    xReturn = xStreamBufferBytesAvailable( xStreamBuffer );
 8008ee2:	4620      	mov	r0, r4
 8008ee4:	f7f9 fc22 	bl	800272c <xStreamBufferBytesAvailable>
 8008ee8:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008eea:	f000 fed1 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 8008eee:	9801      	ldr	r0, [sp, #4]
}
 8008ef0:	b002      	add	sp, #8
 8008ef2:	bd10      	pop	{r4, pc}

08008ef4 <MPU_xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t MPU_xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                             size_t xTriggerLevel ) /* FREERTOS_SYSTEM_CALL */
{
 8008ef4:	b510      	push	{r4, lr}
 8008ef6:	b082      	sub	sp, #8
 8008ef8:	4604      	mov	r4, r0
 8008efa:	9101      	str	r1, [sp, #4]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008efc:	f000 fec0 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008f00:	9901      	ldr	r1, [sp, #4]
 8008f02:	b128      	cbz	r0, 8008f10 <MPU_xStreamBufferSetTriggerLevel+0x1c>
    BaseType_t xReturn;
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();

    xReturn = xStreamBufferSetTriggerLevel( xStreamBuffer, xTriggerLevel );
 8008f04:	4620      	mov	r0, r4
    vPortResetPrivilege( xRunningPrivileged );

    return xReturn;
}
 8008f06:	b002      	add	sp, #8
 8008f08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    xReturn = xStreamBufferSetTriggerLevel( xStreamBuffer, xTriggerLevel );
 8008f0c:	f7f9 bc22 	b.w	8002754 <xStreamBufferSetTriggerLevel>
        portRAISE_PRIVILEGE();
 8008f10:	df02      	svc	2
    xReturn = xStreamBufferSetTriggerLevel( xStreamBuffer, xTriggerLevel );
 8008f12:	4620      	mov	r0, r4
 8008f14:	f7f9 fc1e 	bl	8002754 <xStreamBufferSetTriggerLevel>
 8008f18:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008f1a:	f000 feb9 	bl	8009c90 <vResetPrivilege>
    return xReturn;
 8008f1e:	9801      	ldr	r0, [sp, #4]
}
 8008f20:	b002      	add	sp, #8
 8008f22:	bd10      	pop	{r4, pc}

08008f24 <MPU_xStreamBufferGenericCreate>:

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    StreamBufferHandle_t MPU_xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                         size_t xTriggerLevelBytes,
                                                         BaseType_t xIsMessageBuffer ) /* FREERTOS_SYSTEM_CALL */
    {
 8008f24:	b510      	push	{r4, lr}
 8008f26:	b082      	sub	sp, #8
 8008f28:	4604      	mov	r4, r0
 8008f2a:	e9cd 2100 	strd	r2, r1, [sp]
    xRunningPrivileged = portIS_PRIVILEGED();
 8008f2e:	f000 fea7 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008f32:	e9dd 2100 	ldrd	r2, r1, [sp]
 8008f36:	b128      	cbz	r0, 8008f44 <MPU_xStreamBufferGenericCreate+0x20>
        StreamBufferHandle_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        xReturn = xStreamBufferGenericCreate( xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer );
 8008f38:	4620      	mov	r0, r4
        vPortResetPrivilege( xRunningPrivileged );

        return xReturn;
    }
 8008f3a:	b002      	add	sp, #8
 8008f3c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        xReturn = xStreamBufferGenericCreate( xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer );
 8008f40:	f7f9 bc6e 	b.w	8002820 <xStreamBufferGenericCreate>
        portRAISE_PRIVILEGE();
 8008f44:	df02      	svc	2
        xReturn = xStreamBufferGenericCreate( xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer );
 8008f46:	4620      	mov	r0, r4
 8008f48:	f7f9 fc6a 	bl	8002820 <xStreamBufferGenericCreate>
 8008f4c:	9000      	str	r0, [sp, #0]
        portRESET_PRIVILEGE();
 8008f4e:	f000 fe9f 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008f52:	9800      	ldr	r0, [sp, #0]
    }
 8008f54:	b002      	add	sp, #8
 8008f56:	bd10      	pop	{r4, pc}

08008f58 <MPU_xStreamBufferGenericCreateStatic>:
    StreamBufferHandle_t MPU_xStreamBufferGenericCreateStatic( size_t xBufferSizeBytes,
                                                               size_t xTriggerLevelBytes,
                                                               BaseType_t xIsMessageBuffer,
                                                               uint8_t * const pucStreamBufferStorageArea,
                                                               StaticStreamBuffer_t * const pxStaticStreamBuffer ) /* FREERTOS_SYSTEM_CALL */
    {
 8008f58:	b530      	push	{r4, r5, lr}
 8008f5a:	b087      	sub	sp, #28
 8008f5c:	4604      	mov	r4, r0
 8008f5e:	e9cd 2104 	strd	r2, r1, [sp, #16]
 8008f62:	9303      	str	r3, [sp, #12]
 8008f64:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    xRunningPrivileged = portIS_PRIVILEGED();
 8008f66:	f000 fe8b 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008f6a:	9905      	ldr	r1, [sp, #20]
 8008f6c:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 8008f70:	b130      	cbz	r0, 8008f80 <MPU_xStreamBufferGenericCreateStatic+0x28>
        StreamBufferHandle_t xReturn;
        BaseType_t xRunningPrivileged = xPortRaisePrivilege();

        xReturn = xStreamBufferGenericCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer, pucStreamBufferStorageArea, pxStaticStreamBuffer );
 8008f72:	4620      	mov	r0, r4
 8008f74:	950a      	str	r5, [sp, #40]	; 0x28
        vPortResetPrivilege( xRunningPrivileged );

        return xReturn;
    }
 8008f76:	b007      	add	sp, #28
 8008f78:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        xReturn = xStreamBufferGenericCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer, pucStreamBufferStorageArea, pxStaticStreamBuffer );
 8008f7c:	f7f9 bca8 	b.w	80028d0 <xStreamBufferGenericCreateStatic>
        portRAISE_PRIVILEGE();
 8008f80:	df02      	svc	2
        xReturn = xStreamBufferGenericCreateStatic( xBufferSizeBytes, xTriggerLevelBytes, xIsMessageBuffer, pucStreamBufferStorageArea, pxStaticStreamBuffer );
 8008f82:	4620      	mov	r0, r4
 8008f84:	9500      	str	r5, [sp, #0]
 8008f86:	f7f9 fca3 	bl	80028d0 <xStreamBufferGenericCreateStatic>
 8008f8a:	9003      	str	r0, [sp, #12]
        portRESET_PRIVILEGE();
 8008f8c:	f000 fe80 	bl	8009c90 <vResetPrivilege>
        return xReturn;
 8008f90:	9803      	ldr	r0, [sp, #12]
    }
 8008f92:	b007      	add	sp, #28
 8008f94:	bd30      	pop	{r4, r5, pc}
 8008f96:	bf00      	nop

08008f98 <MPU_ASAN_malloc>:
{
 8008f98:	b510      	push	{r4, lr}
 8008f9a:	b082      	sub	sp, #8
 8008f9c:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008f9e:	f000 fe6f 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008fa2:	b140      	cbz	r0, 8008fb6 <MPU_ASAN_malloc+0x1e>
	void *ptr = Allocate(size, 8, FROM_MALLOC, true);
 8008fa4:	2301      	movs	r3, #1
 8008fa6:	2108      	movs	r1, #8
 8008fa8:	4620      	mov	r0, r4
 8008faa:	461a      	mov	r2, r3
}
 8008fac:	b002      	add	sp, #8
 8008fae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	void *ptr = Allocate(size, 8, FROM_MALLOC, true);
 8008fb2:	f000 bb47 	b.w	8009644 <Allocate>
        portRAISE_PRIVILEGE();
 8008fb6:	df02      	svc	2
 8008fb8:	2301      	movs	r3, #1
 8008fba:	2108      	movs	r1, #8
 8008fbc:	4620      	mov	r0, r4
 8008fbe:	461a      	mov	r2, r3
 8008fc0:	f000 fb40 	bl	8009644 <Allocate>
 8008fc4:	9001      	str	r0, [sp, #4]
        portRESET_PRIVILEGE();
 8008fc6:	f000 fe63 	bl	8009c90 <vResetPrivilege>
	return  (void *	)ptr;
 8008fca:	9801      	ldr	r0, [sp, #4]
}
 8008fcc:	b002      	add	sp, #8
 8008fce:	bd10      	pop	{r4, pc}

08008fd0 <MPU_ASAN_free>:
{
 8008fd0:	b510      	push	{r4, lr}
 8008fd2:	4604      	mov	r4, r0
    xRunningPrivileged = portIS_PRIVILEGED();
 8008fd4:	f000 fe54 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8008fd8:	b950      	cbnz	r0, 8008ff0 <MPU_ASAN_free+0x20>
 8008fda:	4602      	mov	r2, r0
        portRAISE_PRIVILEGE();
 8008fdc:	df02      	svc	2
	Deallocate(ptr, 0, 0, FROM_MALLOC);
 8008fde:	2301      	movs	r3, #1
 8008fe0:	4601      	mov	r1, r0
 8008fe2:	4620      	mov	r0, r4
 8008fe4:	f000 fd86 	bl	8009af4 <Deallocate>
}
 8008fe8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        portRESET_PRIVILEGE();
 8008fec:	f000 be50 	b.w	8009c90 <vResetPrivilege>
	Deallocate(ptr, 0, 0, FROM_MALLOC);
 8008ff0:	2200      	movs	r2, #0
 8008ff2:	4620      	mov	r0, r4
 8008ff4:	2301      	movs	r3, #1
 8008ff6:	4611      	mov	r1, r2
}
 8008ff8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	Deallocate(ptr, 0, 0, FROM_MALLOC);
 8008ffc:	f000 bd7a 	b.w	8009af4 <Deallocate>

08009000 <MPU_ASAN_flush_alloc>:
{
 8009000:	b508      	push	{r3, lr}
    xRunningPrivileged = portIS_PRIVILEGED();
 8009002:	f000 fe3d 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 8009006:	b920      	cbnz	r0, 8009012 <MPU_ASAN_flush_alloc+0x12>
        portRAISE_PRIVILEGE();
 8009008:	df02      	svc	2
}
 800900a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        portRESET_PRIVILEGE();
 800900e:	f000 be3f 	b.w	8009c90 <vResetPrivilege>
 8009012:	bd08      	pop	{r3, pc}

08009014 <xPortRaisePrivilege>:
{
 8009014:	b508      	push	{r3, lr}
    xRunningPrivileged = portIS_PRIVILEGED();
 8009016:	f000 fe33 	bl	8009c80 <xIsPrivileged>
    if( xRunningPrivileged == pdFALSE )
 800901a:	b900      	cbnz	r0, 800901e <xPortRaisePrivilege+0xa>
        portRAISE_PRIVILEGE();
 800901c:	df02      	svc	2
}
 800901e:	bd08      	pop	{r3, pc}

08009020 <__do_global_dtors_aux>:
 8009020:	b510      	push	{r4, lr}
 8009022:	4c05      	ldr	r4, [pc, #20]	; (8009038 <__do_global_dtors_aux+0x18>)
 8009024:	7823      	ldrb	r3, [r4, #0]
 8009026:	b933      	cbnz	r3, 8009036 <__do_global_dtors_aux+0x16>
 8009028:	4b04      	ldr	r3, [pc, #16]	; (800903c <__do_global_dtors_aux+0x1c>)
 800902a:	b113      	cbz	r3, 8009032 <__do_global_dtors_aux+0x12>
 800902c:	4804      	ldr	r0, [pc, #16]	; (8009040 <__do_global_dtors_aux+0x20>)
 800902e:	f3af 8000 	nop.w
 8009032:	2301      	movs	r3, #1
 8009034:	7023      	strb	r3, [r4, #0]
 8009036:	bd10      	pop	{r4, pc}
 8009038:	24010000 	.word	0x24010000
 800903c:	00000000 	.word	0x00000000
 8009040:	0801520c 	.word	0x0801520c

08009044 <frame_dummy>:
 8009044:	b508      	push	{r3, lr}
 8009046:	4b03      	ldr	r3, [pc, #12]	; (8009054 <frame_dummy+0x10>)
 8009048:	b11b      	cbz	r3, 8009052 <frame_dummy+0xe>
 800904a:	4903      	ldr	r1, [pc, #12]	; (8009058 <frame_dummy+0x14>)
 800904c:	4803      	ldr	r0, [pc, #12]	; (800905c <frame_dummy+0x18>)
 800904e:	f3af 8000 	nop.w
 8009052:	bd08      	pop	{r3, pc}
 8009054:	00000000 	.word	0x00000000
 8009058:	24010004 	.word	0x24010004
 800905c:	0801520c 	.word	0x0801520c

08009060 <memchr>:
 8009060:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8009064:	2a10      	cmp	r2, #16
 8009066:	db2b      	blt.n	80090c0 <memchr+0x60>
 8009068:	f010 0f07 	tst.w	r0, #7
 800906c:	d008      	beq.n	8009080 <memchr+0x20>
 800906e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8009072:	3a01      	subs	r2, #1
 8009074:	428b      	cmp	r3, r1
 8009076:	d02d      	beq.n	80090d4 <memchr+0x74>
 8009078:	f010 0f07 	tst.w	r0, #7
 800907c:	b342      	cbz	r2, 80090d0 <memchr+0x70>
 800907e:	d1f6      	bne.n	800906e <memchr+0xe>
 8009080:	b4f0      	push	{r4, r5, r6, r7}
 8009082:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8009086:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800908a:	f022 0407 	bic.w	r4, r2, #7
 800908e:	f07f 0700 	mvns.w	r7, #0
 8009092:	2300      	movs	r3, #0
 8009094:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8009098:	3c08      	subs	r4, #8
 800909a:	ea85 0501 	eor.w	r5, r5, r1
 800909e:	ea86 0601 	eor.w	r6, r6, r1
 80090a2:	fa85 f547 	uadd8	r5, r5, r7
 80090a6:	faa3 f587 	sel	r5, r3, r7
 80090aa:	fa86 f647 	uadd8	r6, r6, r7
 80090ae:	faa5 f687 	sel	r6, r5, r7
 80090b2:	b98e      	cbnz	r6, 80090d8 <memchr+0x78>
 80090b4:	d1ee      	bne.n	8009094 <memchr+0x34>
 80090b6:	bcf0      	pop	{r4, r5, r6, r7}
 80090b8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80090bc:	f002 0207 	and.w	r2, r2, #7
 80090c0:	b132      	cbz	r2, 80090d0 <memchr+0x70>
 80090c2:	f810 3b01 	ldrb.w	r3, [r0], #1
 80090c6:	3a01      	subs	r2, #1
 80090c8:	ea83 0301 	eor.w	r3, r3, r1
 80090cc:	b113      	cbz	r3, 80090d4 <memchr+0x74>
 80090ce:	d1f8      	bne.n	80090c2 <memchr+0x62>
 80090d0:	2000      	movs	r0, #0
 80090d2:	4770      	bx	lr
 80090d4:	3801      	subs	r0, #1
 80090d6:	4770      	bx	lr
 80090d8:	2d00      	cmp	r5, #0
 80090da:	bf06      	itte	eq
 80090dc:	4635      	moveq	r5, r6
 80090de:	3803      	subeq	r0, #3
 80090e0:	3807      	subne	r0, #7
 80090e2:	f015 0f01 	tst.w	r5, #1
 80090e6:	d107      	bne.n	80090f8 <memchr+0x98>
 80090e8:	3001      	adds	r0, #1
 80090ea:	f415 7f80 	tst.w	r5, #256	; 0x100
 80090ee:	bf02      	ittt	eq
 80090f0:	3001      	addeq	r0, #1
 80090f2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80090f6:	3001      	addeq	r0, #1
 80090f8:	bcf0      	pop	{r4, r5, r6, r7}
 80090fa:	3801      	subs	r0, #1
 80090fc:	4770      	bx	lr
 80090fe:	bf00      	nop

08009100 <__aeabi_uldivmod>:
 8009100:	b953      	cbnz	r3, 8009118 <__aeabi_uldivmod+0x18>
 8009102:	b94a      	cbnz	r2, 8009118 <__aeabi_uldivmod+0x18>
 8009104:	2900      	cmp	r1, #0
 8009106:	bf08      	it	eq
 8009108:	2800      	cmpeq	r0, #0
 800910a:	bf1c      	itt	ne
 800910c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 8009110:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 8009114:	f000 b974 	b.w	8009400 <__aeabi_idiv0>
 8009118:	f1ad 0c08 	sub.w	ip, sp, #8
 800911c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8009120:	f000 f806 	bl	8009130 <__udivmoddi4>
 8009124:	f8dd e004 	ldr.w	lr, [sp, #4]
 8009128:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800912c:	b004      	add	sp, #16
 800912e:	4770      	bx	lr

08009130 <__udivmoddi4>:
 8009130:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8009134:	9d08      	ldr	r5, [sp, #32]
 8009136:	4604      	mov	r4, r0
 8009138:	468e      	mov	lr, r1
 800913a:	2b00      	cmp	r3, #0
 800913c:	d14d      	bne.n	80091da <__udivmoddi4+0xaa>
 800913e:	428a      	cmp	r2, r1
 8009140:	4694      	mov	ip, r2
 8009142:	d969      	bls.n	8009218 <__udivmoddi4+0xe8>
 8009144:	fab2 f282 	clz	r2, r2
 8009148:	b152      	cbz	r2, 8009160 <__udivmoddi4+0x30>
 800914a:	fa01 f302 	lsl.w	r3, r1, r2
 800914e:	f1c2 0120 	rsb	r1, r2, #32
 8009152:	fa20 f101 	lsr.w	r1, r0, r1
 8009156:	fa0c fc02 	lsl.w	ip, ip, r2
 800915a:	ea41 0e03 	orr.w	lr, r1, r3
 800915e:	4094      	lsls	r4, r2
 8009160:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8009164:	0c21      	lsrs	r1, r4, #16
 8009166:	fbbe f6f8 	udiv	r6, lr, r8
 800916a:	fa1f f78c 	uxth.w	r7, ip
 800916e:	fb08 e316 	mls	r3, r8, r6, lr
 8009172:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 8009176:	fb06 f107 	mul.w	r1, r6, r7
 800917a:	4299      	cmp	r1, r3
 800917c:	d90a      	bls.n	8009194 <__udivmoddi4+0x64>
 800917e:	eb1c 0303 	adds.w	r3, ip, r3
 8009182:	f106 30ff 	add.w	r0, r6, #4294967295	; 0xffffffff
 8009186:	f080 811f 	bcs.w	80093c8 <__udivmoddi4+0x298>
 800918a:	4299      	cmp	r1, r3
 800918c:	f240 811c 	bls.w	80093c8 <__udivmoddi4+0x298>
 8009190:	3e02      	subs	r6, #2
 8009192:	4463      	add	r3, ip
 8009194:	1a5b      	subs	r3, r3, r1
 8009196:	b2a4      	uxth	r4, r4
 8009198:	fbb3 f0f8 	udiv	r0, r3, r8
 800919c:	fb08 3310 	mls	r3, r8, r0, r3
 80091a0:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 80091a4:	fb00 f707 	mul.w	r7, r0, r7
 80091a8:	42a7      	cmp	r7, r4
 80091aa:	d90a      	bls.n	80091c2 <__udivmoddi4+0x92>
 80091ac:	eb1c 0404 	adds.w	r4, ip, r4
 80091b0:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80091b4:	f080 810a 	bcs.w	80093cc <__udivmoddi4+0x29c>
 80091b8:	42a7      	cmp	r7, r4
 80091ba:	f240 8107 	bls.w	80093cc <__udivmoddi4+0x29c>
 80091be:	4464      	add	r4, ip
 80091c0:	3802      	subs	r0, #2
 80091c2:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 80091c6:	1be4      	subs	r4, r4, r7
 80091c8:	2600      	movs	r6, #0
 80091ca:	b11d      	cbz	r5, 80091d4 <__udivmoddi4+0xa4>
 80091cc:	40d4      	lsrs	r4, r2
 80091ce:	2300      	movs	r3, #0
 80091d0:	e9c5 4300 	strd	r4, r3, [r5]
 80091d4:	4631      	mov	r1, r6
 80091d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80091da:	428b      	cmp	r3, r1
 80091dc:	d909      	bls.n	80091f2 <__udivmoddi4+0xc2>
 80091de:	2d00      	cmp	r5, #0
 80091e0:	f000 80ef 	beq.w	80093c2 <__udivmoddi4+0x292>
 80091e4:	2600      	movs	r6, #0
 80091e6:	e9c5 0100 	strd	r0, r1, [r5]
 80091ea:	4630      	mov	r0, r6
 80091ec:	4631      	mov	r1, r6
 80091ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80091f2:	fab3 f683 	clz	r6, r3
 80091f6:	2e00      	cmp	r6, #0
 80091f8:	d14a      	bne.n	8009290 <__udivmoddi4+0x160>
 80091fa:	428b      	cmp	r3, r1
 80091fc:	d302      	bcc.n	8009204 <__udivmoddi4+0xd4>
 80091fe:	4282      	cmp	r2, r0
 8009200:	f200 80f9 	bhi.w	80093f6 <__udivmoddi4+0x2c6>
 8009204:	1a84      	subs	r4, r0, r2
 8009206:	eb61 0303 	sbc.w	r3, r1, r3
 800920a:	2001      	movs	r0, #1
 800920c:	469e      	mov	lr, r3
 800920e:	2d00      	cmp	r5, #0
 8009210:	d0e0      	beq.n	80091d4 <__udivmoddi4+0xa4>
 8009212:	e9c5 4e00 	strd	r4, lr, [r5]
 8009216:	e7dd      	b.n	80091d4 <__udivmoddi4+0xa4>
 8009218:	b902      	cbnz	r2, 800921c <__udivmoddi4+0xec>
 800921a:	deff      	udf	#255	; 0xff
 800921c:	fab2 f282 	clz	r2, r2
 8009220:	2a00      	cmp	r2, #0
 8009222:	f040 8092 	bne.w	800934a <__udivmoddi4+0x21a>
 8009226:	eba1 010c 	sub.w	r1, r1, ip
 800922a:	ea4f 471c 	mov.w	r7, ip, lsr #16
 800922e:	fa1f fe8c 	uxth.w	lr, ip
 8009232:	2601      	movs	r6, #1
 8009234:	0c20      	lsrs	r0, r4, #16
 8009236:	fbb1 f3f7 	udiv	r3, r1, r7
 800923a:	fb07 1113 	mls	r1, r7, r3, r1
 800923e:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 8009242:	fb0e f003 	mul.w	r0, lr, r3
 8009246:	4288      	cmp	r0, r1
 8009248:	d908      	bls.n	800925c <__udivmoddi4+0x12c>
 800924a:	eb1c 0101 	adds.w	r1, ip, r1
 800924e:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 8009252:	d202      	bcs.n	800925a <__udivmoddi4+0x12a>
 8009254:	4288      	cmp	r0, r1
 8009256:	f200 80cb 	bhi.w	80093f0 <__udivmoddi4+0x2c0>
 800925a:	4643      	mov	r3, r8
 800925c:	1a09      	subs	r1, r1, r0
 800925e:	b2a4      	uxth	r4, r4
 8009260:	fbb1 f0f7 	udiv	r0, r1, r7
 8009264:	fb07 1110 	mls	r1, r7, r0, r1
 8009268:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 800926c:	fb0e fe00 	mul.w	lr, lr, r0
 8009270:	45a6      	cmp	lr, r4
 8009272:	d908      	bls.n	8009286 <__udivmoddi4+0x156>
 8009274:	eb1c 0404 	adds.w	r4, ip, r4
 8009278:	f100 31ff 	add.w	r1, r0, #4294967295	; 0xffffffff
 800927c:	d202      	bcs.n	8009284 <__udivmoddi4+0x154>
 800927e:	45a6      	cmp	lr, r4
 8009280:	f200 80bb 	bhi.w	80093fa <__udivmoddi4+0x2ca>
 8009284:	4608      	mov	r0, r1
 8009286:	eba4 040e 	sub.w	r4, r4, lr
 800928a:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 800928e:	e79c      	b.n	80091ca <__udivmoddi4+0x9a>
 8009290:	f1c6 0720 	rsb	r7, r6, #32
 8009294:	40b3      	lsls	r3, r6
 8009296:	fa22 fc07 	lsr.w	ip, r2, r7
 800929a:	ea4c 0c03 	orr.w	ip, ip, r3
 800929e:	fa20 f407 	lsr.w	r4, r0, r7
 80092a2:	fa01 f306 	lsl.w	r3, r1, r6
 80092a6:	431c      	orrs	r4, r3
 80092a8:	40f9      	lsrs	r1, r7
 80092aa:	ea4f 491c 	mov.w	r9, ip, lsr #16
 80092ae:	fa00 f306 	lsl.w	r3, r0, r6
 80092b2:	fbb1 f8f9 	udiv	r8, r1, r9
 80092b6:	0c20      	lsrs	r0, r4, #16
 80092b8:	fa1f fe8c 	uxth.w	lr, ip
 80092bc:	fb09 1118 	mls	r1, r9, r8, r1
 80092c0:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 80092c4:	fb08 f00e 	mul.w	r0, r8, lr
 80092c8:	4288      	cmp	r0, r1
 80092ca:	fa02 f206 	lsl.w	r2, r2, r6
 80092ce:	d90b      	bls.n	80092e8 <__udivmoddi4+0x1b8>
 80092d0:	eb1c 0101 	adds.w	r1, ip, r1
 80092d4:	f108 3aff 	add.w	sl, r8, #4294967295	; 0xffffffff
 80092d8:	f080 8088 	bcs.w	80093ec <__udivmoddi4+0x2bc>
 80092dc:	4288      	cmp	r0, r1
 80092de:	f240 8085 	bls.w	80093ec <__udivmoddi4+0x2bc>
 80092e2:	f1a8 0802 	sub.w	r8, r8, #2
 80092e6:	4461      	add	r1, ip
 80092e8:	1a09      	subs	r1, r1, r0
 80092ea:	b2a4      	uxth	r4, r4
 80092ec:	fbb1 f0f9 	udiv	r0, r1, r9
 80092f0:	fb09 1110 	mls	r1, r9, r0, r1
 80092f4:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
 80092f8:	fb00 fe0e 	mul.w	lr, r0, lr
 80092fc:	458e      	cmp	lr, r1
 80092fe:	d908      	bls.n	8009312 <__udivmoddi4+0x1e2>
 8009300:	eb1c 0101 	adds.w	r1, ip, r1
 8009304:	f100 34ff 	add.w	r4, r0, #4294967295	; 0xffffffff
 8009308:	d26c      	bcs.n	80093e4 <__udivmoddi4+0x2b4>
 800930a:	458e      	cmp	lr, r1
 800930c:	d96a      	bls.n	80093e4 <__udivmoddi4+0x2b4>
 800930e:	3802      	subs	r0, #2
 8009310:	4461      	add	r1, ip
 8009312:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8009316:	fba0 9402 	umull	r9, r4, r0, r2
 800931a:	eba1 010e 	sub.w	r1, r1, lr
 800931e:	42a1      	cmp	r1, r4
 8009320:	46c8      	mov	r8, r9
 8009322:	46a6      	mov	lr, r4
 8009324:	d356      	bcc.n	80093d4 <__udivmoddi4+0x2a4>
 8009326:	d053      	beq.n	80093d0 <__udivmoddi4+0x2a0>
 8009328:	b15d      	cbz	r5, 8009342 <__udivmoddi4+0x212>
 800932a:	ebb3 0208 	subs.w	r2, r3, r8
 800932e:	eb61 010e 	sbc.w	r1, r1, lr
 8009332:	fa01 f707 	lsl.w	r7, r1, r7
 8009336:	fa22 f306 	lsr.w	r3, r2, r6
 800933a:	40f1      	lsrs	r1, r6
 800933c:	431f      	orrs	r7, r3
 800933e:	e9c5 7100 	strd	r7, r1, [r5]
 8009342:	2600      	movs	r6, #0
 8009344:	4631      	mov	r1, r6
 8009346:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800934a:	f1c2 0320 	rsb	r3, r2, #32
 800934e:	40d8      	lsrs	r0, r3
 8009350:	fa0c fc02 	lsl.w	ip, ip, r2
 8009354:	fa21 f303 	lsr.w	r3, r1, r3
 8009358:	4091      	lsls	r1, r2
 800935a:	4301      	orrs	r1, r0
 800935c:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8009360:	fa1f fe8c 	uxth.w	lr, ip
 8009364:	fbb3 f0f7 	udiv	r0, r3, r7
 8009368:	fb07 3610 	mls	r6, r7, r0, r3
 800936c:	0c0b      	lsrs	r3, r1, #16
 800936e:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 8009372:	fb00 f60e 	mul.w	r6, r0, lr
 8009376:	429e      	cmp	r6, r3
 8009378:	fa04 f402 	lsl.w	r4, r4, r2
 800937c:	d908      	bls.n	8009390 <__udivmoddi4+0x260>
 800937e:	eb1c 0303 	adds.w	r3, ip, r3
 8009382:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
 8009386:	d22f      	bcs.n	80093e8 <__udivmoddi4+0x2b8>
 8009388:	429e      	cmp	r6, r3
 800938a:	d92d      	bls.n	80093e8 <__udivmoddi4+0x2b8>
 800938c:	3802      	subs	r0, #2
 800938e:	4463      	add	r3, ip
 8009390:	1b9b      	subs	r3, r3, r6
 8009392:	b289      	uxth	r1, r1
 8009394:	fbb3 f6f7 	udiv	r6, r3, r7
 8009398:	fb07 3316 	mls	r3, r7, r6, r3
 800939c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80093a0:	fb06 f30e 	mul.w	r3, r6, lr
 80093a4:	428b      	cmp	r3, r1
 80093a6:	d908      	bls.n	80093ba <__udivmoddi4+0x28a>
 80093a8:	eb1c 0101 	adds.w	r1, ip, r1
 80093ac:	f106 38ff 	add.w	r8, r6, #4294967295	; 0xffffffff
 80093b0:	d216      	bcs.n	80093e0 <__udivmoddi4+0x2b0>
 80093b2:	428b      	cmp	r3, r1
 80093b4:	d914      	bls.n	80093e0 <__udivmoddi4+0x2b0>
 80093b6:	3e02      	subs	r6, #2
 80093b8:	4461      	add	r1, ip
 80093ba:	1ac9      	subs	r1, r1, r3
 80093bc:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
 80093c0:	e738      	b.n	8009234 <__udivmoddi4+0x104>
 80093c2:	462e      	mov	r6, r5
 80093c4:	4628      	mov	r0, r5
 80093c6:	e705      	b.n	80091d4 <__udivmoddi4+0xa4>
 80093c8:	4606      	mov	r6, r0
 80093ca:	e6e3      	b.n	8009194 <__udivmoddi4+0x64>
 80093cc:	4618      	mov	r0, r3
 80093ce:	e6f8      	b.n	80091c2 <__udivmoddi4+0x92>
 80093d0:	454b      	cmp	r3, r9
 80093d2:	d2a9      	bcs.n	8009328 <__udivmoddi4+0x1f8>
 80093d4:	ebb9 0802 	subs.w	r8, r9, r2
 80093d8:	eb64 0e0c 	sbc.w	lr, r4, ip
 80093dc:	3801      	subs	r0, #1
 80093de:	e7a3      	b.n	8009328 <__udivmoddi4+0x1f8>
 80093e0:	4646      	mov	r6, r8
 80093e2:	e7ea      	b.n	80093ba <__udivmoddi4+0x28a>
 80093e4:	4620      	mov	r0, r4
 80093e6:	e794      	b.n	8009312 <__udivmoddi4+0x1e2>
 80093e8:	4640      	mov	r0, r8
 80093ea:	e7d1      	b.n	8009390 <__udivmoddi4+0x260>
 80093ec:	46d0      	mov	r8, sl
 80093ee:	e77b      	b.n	80092e8 <__udivmoddi4+0x1b8>
 80093f0:	3b02      	subs	r3, #2
 80093f2:	4461      	add	r1, ip
 80093f4:	e732      	b.n	800925c <__udivmoddi4+0x12c>
 80093f6:	4630      	mov	r0, r6
 80093f8:	e709      	b.n	800920e <__udivmoddi4+0xde>
 80093fa:	4464      	add	r4, ip
 80093fc:	3802      	subs	r0, #2
 80093fe:	e742      	b.n	8009286 <__udivmoddi4+0x156>

08009400 <__aeabi_idiv0>:
 8009400:	4770      	bx	lr
 8009402:	bf00      	nop

08009404 <SystemInit>:
  */
void SystemInit (void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8009404:	4b2f      	ldr	r3, [pc, #188]	; (80094c4 <SystemInit+0xc0>)
 SCB->SCR |= SCB_SCR_SEVONPEND_Msk;

#ifdef CORE_CM7
  /* Reset the RCC clock configuration to the default reset state ------------*/
   /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 8009406:	4930      	ldr	r1, [pc, #192]	; (80094c8 <SystemInit+0xc4>)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8009408:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800940c:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
{
 8009410:	b410      	push	{r4}
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8009412:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 SCB->SCR |= SCB_SCR_SEVONPEND_Msk;
 8009416:	691a      	ldr	r2, [r3, #16]
 8009418:	f042 0210 	orr.w	r2, r2, #16
 800941c:	611a      	str	r2, [r3, #16]
  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 800941e:	680b      	ldr	r3, [r1, #0]
 8009420:	f003 030f 	and.w	r3, r3, #15
 8009424:	2b06      	cmp	r3, #6
 8009426:	d805      	bhi.n	8009434 <SystemInit+0x30>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
	MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
 8009428:	680b      	ldr	r3, [r1, #0]
 800942a:	f023 030f 	bic.w	r3, r3, #15
 800942e:	f043 0307 	orr.w	r3, r3, #7
 8009432:	600b      	str	r3, [r1, #0]
  }

  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
 8009434:	4b25      	ldr	r3, [pc, #148]	; (80094cc <SystemInit+0xc8>)

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8009436:	2400      	movs	r4, #0

  /* Reset HSEON, HSECSSON, CSION, RC48ON, CSIKERON, PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
 8009438:	4a25      	ldr	r2, [pc, #148]	; (80094d0 <SystemInit+0xcc>)
  RCC->CR |= RCC_CR_HSION;
 800943a:	6819      	ldr	r1, [r3, #0]

   /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 800943c:	4822      	ldr	r0, [pc, #136]	; (80094c8 <SystemInit+0xc4>)
  RCC->CR |= RCC_CR_HSION;
 800943e:	f041 0101 	orr.w	r1, r1, #1
 8009442:	6019      	str	r1, [r3, #0]
  RCC->CFGR = 0x00000000;
 8009444:	611c      	str	r4, [r3, #16]
  RCC->CR &= 0xEAF6ED7FU;
 8009446:	6819      	ldr	r1, [r3, #0]
 8009448:	400a      	ands	r2, r1
 800944a:	601a      	str	r2, [r3, #0]
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 800944c:	6803      	ldr	r3, [r0, #0]
 800944e:	071b      	lsls	r3, r3, #28
 8009450:	d505      	bpl.n	800945e <SystemInit+0x5a>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
	MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
 8009452:	6803      	ldr	r3, [r0, #0]
 8009454:	f023 030f 	bic.w	r3, r3, #15
 8009458:	f043 0307 	orr.w	r3, r3, #7
 800945c:	6003      	str	r3, [r0, #0]
  }

  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
 800945e:	4b1b      	ldr	r3, [pc, #108]	; (80094cc <SystemInit+0xc8>)
 8009460:	2200      	movs	r2, #0
  RCC->PLLCKSELR = 0x02020200;

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x01FF0000;
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x01010280;
 8009462:	491c      	ldr	r1, [pc, #112]	; (80094d4 <SystemInit+0xd0>)
  RCC->PLLCFGR = 0x01FF0000;
 8009464:	481c      	ldr	r0, [pc, #112]	; (80094d8 <SystemInit+0xd4>)
  RCC->PLLCKSELR = 0x02020200;
 8009466:	4c1d      	ldr	r4, [pc, #116]	; (80094dc <SystemInit+0xd8>)
  RCC->D1CFGR = 0x00000000;
 8009468:	619a      	str	r2, [r3, #24]
  RCC->D2CFGR = 0x00000000;
 800946a:	61da      	str	r2, [r3, #28]
  RCC->D3CFGR = 0x00000000;
 800946c:	621a      	str	r2, [r3, #32]
  RCC->PLLCKSELR = 0x02020200;
 800946e:	629c      	str	r4, [r3, #40]	; 0x28
  RCC->PLLCFGR = 0x01FF0000;
 8009470:	62d8      	str	r0, [r3, #44]	; 0x2c

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;

  /* Enable CortexM7 HSEM EXTI line (line 78)*/
  EXTI_D2->EMR3 |= 0x4000UL;
 8009472:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
  RCC->PLL1DIVR = 0x01010280;
 8009476:	6319      	str	r1, [r3, #48]	; 0x30
  RCC->PLL1FRACR = 0x00000000;
 8009478:	635a      	str	r2, [r3, #52]	; 0x34
  RCC->PLL2DIVR = 0x01010280;
 800947a:	6399      	str	r1, [r3, #56]	; 0x38
  RCC->PLL2FRACR = 0x00000000;
 800947c:	63da      	str	r2, [r3, #60]	; 0x3c
  RCC->PLL3DIVR = 0x01010280;
 800947e:	6419      	str	r1, [r3, #64]	; 0x40
  RCC->PLL3FRACR = 0x00000000;
 8009480:	645a      	str	r2, [r3, #68]	; 0x44
  RCC->CR &= 0xFFFBFFFFU;
 8009482:	6819      	ldr	r1, [r3, #0]
 8009484:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 8009488:	6019      	str	r1, [r3, #0]
  RCC->CIER = 0x00000000;
 800948a:	661a      	str	r2, [r3, #96]	; 0x60
  EXTI_D2->EMR3 |= 0x4000UL;
 800948c:	f8d0 20e4 	ldr.w	r2, [r0, #228]	; 0xe4


  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 8009490:	4913      	ldr	r1, [pc, #76]	; (80094e0 <SystemInit+0xdc>)
  EXTI_D2->EMR3 |= 0x4000UL;
 8009492:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 8009496:	4b13      	ldr	r3, [pc, #76]	; (80094e4 <SystemInit+0xe0>)
  EXTI_D2->EMR3 |= 0x4000UL;
 8009498:	f8c0 20e4 	str.w	r2, [r0, #228]	; 0xe4
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 800949c:	680a      	ldr	r2, [r1, #0]
 800949e:	4013      	ands	r3, r2
 80094a0:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80094a4:	d203      	bcs.n	80094ae <SystemInit+0xaa>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
 80094a6:	4b10      	ldr	r3, [pc, #64]	; (80094e8 <SystemInit+0xe4>)
 80094a8:	2201      	movs	r2, #1
 80094aa:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
  /*
   * Disable the FMC bank1 (enabled after reset).
   * This, prevents CPU speculation access on this bank which blocks the use of FMC during
   * 24us. During this time the others FMC master (such as LTDC) cannot use it!
   */
  FMC_Bank1_R->BTCR[0] = 0x000030D2;
 80094ae:	490f      	ldr	r1, [pc, #60]	; (80094ec <SystemInit+0xe8>)
 80094b0:	f243 00d2 	movw	r0, #12498	; 0x30d2

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = D1_AXISRAM_BASE  | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM */
#else
  SCB->VTOR = FLASH_BANK1_BASE | VECT_TAB_OFFSET;       /* Vector Table Relocation in Internal FLASH */
 80094b4:	4b03      	ldr	r3, [pc, #12]	; (80094c4 <SystemInit+0xc0>)
 80094b6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
  FMC_Bank1_R->BTCR[0] = 0x000030D2;
 80094ba:	6008      	str	r0, [r1, #0]
#else
#error Please #define CORE_CM4 or CORE_CM7
#endif
#endif

}
 80094bc:	f85d 4b04 	ldr.w	r4, [sp], #4
  SCB->VTOR = FLASH_BANK1_BASE | VECT_TAB_OFFSET;       /* Vector Table Relocation in Internal FLASH */
 80094c0:	609a      	str	r2, [r3, #8]
}
 80094c2:	4770      	bx	lr
 80094c4:	e000ed00 	.word	0xe000ed00
 80094c8:	52002000 	.word	0x52002000
 80094cc:	58024400 	.word	0x58024400
 80094d0:	eaf6ed7f 	.word	0xeaf6ed7f
 80094d4:	01010280 	.word	0x01010280
 80094d8:	01ff0000 	.word	0x01ff0000
 80094dc:	02020200 	.word	0x02020200
 80094e0:	5c001000 	.word	0x5c001000
 80094e4:	ffff0000 	.word	0xffff0000
 80094e8:	51008000 	.word	0x51008000
 80094ec:	52004000 	.word	0x52004000

080094f0 <FreeRTOSReportFailure>:
}


#endif
static void FreeRTOSReportFailure(type_exception_t  tEX)
{
 80094f0:	b530      	push	{r4, r5, lr}
 80094f2:	b083      	sub	sp, #12
 80094f4:	4604      	mov	r4, r0


	  Fuzzer_t *pAFLfuzzer = (Fuzzer_t *)AFLfuzzerRegion;


	  if(xTaskGetCurrentTaskHandle() == AFLfuzzer.xTaskTarget )
 80094f6:	f7fe fffd 	bl	80084f4 <MPU_xTaskGetCurrentTaskHandle>
 80094fa:	4909      	ldr	r1, [pc, #36]	; (8009520 <FreeRTOSReportFailure+0x30>)
 80094fc:	f8d1 3870 	ldr.w	r3, [r1, #2160]	; 0x870
 8009500:	4283      	cmp	r3, r0
 8009502:	d000      	beq.n	8009506 <FreeRTOSReportFailure+0x16>
		  // port yield should be called and nothing else should be executed
	  }
	  else
	  {
		  //printf("Fuzzer crashed");
		  for( ; ; )
 8009504:	e7fe      	b.n	8009504 <FreeRTOSReportFailure+0x14>
		  xTaskNotifyIndexed(AFLfuzzer.xTaskFuzzer,0,FAULT_ASAN,eSetValueWithOverwrite);
 8009506:	2500      	movs	r5, #0
		  AFLfuzzer.xTypeEx = tEX;
 8009508:	f881 4874 	strb.w	r4, [r1, #2164]	; 0x874
		  xTaskNotifyIndexed(AFLfuzzer.xTaskFuzzer,0,FAULT_ASAN,eSetValueWithOverwrite);
 800950c:	f8d1 086c 	ldr.w	r0, [r1, #2156]	; 0x86c
 8009510:	2303      	movs	r3, #3
 8009512:	2209      	movs	r2, #9
 8009514:	4629      	mov	r1, r5
 8009516:	9500      	str	r5, [sp, #0]
 8009518:	f7fe ff60 	bl	80083dc <MPU_xTaskGenericNotify>
		  taskYIELD();
 800951c:	df01      	svc	1
		  while(1);
 800951e:	e7fe      	b.n	800951e <FreeRTOSReportFailure+0x2e>
 8009520:	24026000 	.word	0x24026000

08009524 <__asan_ReportGenericError>:
  FreeRTOSReportFailure(EX_ASAN_RW_OVERFLOW);
 8009524:	2004      	movs	r0, #4
{
 8009526:	b508      	push	{r3, lr}
  FreeRTOSReportFailure(EX_ASAN_RW_OVERFLOW);
 8009528:	f7ff ffe2 	bl	80094f0 <FreeRTOSReportFailure>

0800952c <SytemCall_3_code>:
 800952c:	4770      	bx	lr
 800952e:	bf00      	nop

08009530 <SytemCall_4_code>:
}
 8009530:	4770      	bx	lr
 8009532:	bf00      	nop

08009534 <SytemCall_5_code>:
 8009534:	4770      	bx	lr
 8009536:	bf00      	nop

08009538 <__asan_report_store1>:
{
 8009538:	b508      	push	{r3, lr}
	__asm volatile("push {r0-r3}");
 800953a:	b40f      	push	{r0, r1, r2, r3}
	__asan_ReportGenericError();
 800953c:	f7ff fff2 	bl	8009524 <__asan_ReportGenericError>

08009540 <__asan_report_store2>:
 8009540:	b508      	push	{r3, lr}
 8009542:	b40f      	push	{r0, r1, r2, r3}
 8009544:	f7ff ffee 	bl	8009524 <__asan_ReportGenericError>

08009548 <__asan_report_load1>:
 8009548:	b508      	push	{r3, lr}
 800954a:	b40f      	push	{r0, r1, r2, r3}
 800954c:	f7ff ffea 	bl	8009524 <__asan_ReportGenericError>

08009550 <__asan_report_load2>:
 8009550:	b508      	push	{r3, lr}
 8009552:	b40f      	push	{r0, r1, r2, r3}
 8009554:	f7ff ffe6 	bl	8009524 <__asan_ReportGenericError>

08009558 <__asan_report_load_n>:
 8009558:	b508      	push	{r3, lr}
 800955a:	b40f      	push	{r0, r1, r2, r3}
 800955c:	f7ff ffe2 	bl	8009524 <__asan_ReportGenericError>

08009560 <__asan_init>:
void __asan_init(void) {
 8009560:	b510      	push	{r4, lr}
	   if(!asan_inited)
 8009562:	4c07      	ldr	r4, [pc, #28]	; (8009580 <__asan_init+0x20>)
 8009564:	7821      	ldrb	r1, [r4, #0]
 8009566:	b101      	cbz	r1, 800956a <__asan_init+0xa>
}
 8009568:	bd10      	pop	{r4, pc}
		   __asan_option_detect_stack_use_after_return  = McuASAN_FLAG_DETECT_STACK_USE_AFTER_RETURN;
 800956a:	4b06      	ldr	r3, [pc, #24]	; (8009584 <__asan_init+0x24>)
		   memset((uint8_t *)( (uint32_t)(McuASAN_CONFIG_APP_MEM_START>>3) + McuASAN_CONFIG_APP_MEM_OFFSET),
 800956c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8009570:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
		   __asan_option_detect_stack_use_after_return  = McuASAN_FLAG_DETECT_STACK_USE_AFTER_RETURN;
 8009574:	6019      	str	r1, [r3, #0]
		   memset((uint8_t *)( (uint32_t)(McuASAN_CONFIG_APP_MEM_START>>3) + McuASAN_CONFIG_APP_MEM_OFFSET),
 8009576:	f00a fecb 	bl	8014310 <memset>
		   asan_inited = true;
 800957a:	2301      	movs	r3, #1
 800957c:	7023      	strb	r3, [r4, #0]
}
 800957e:	bd10      	pop	{r4, pc}
 8009580:	2401001c 	.word	0x2401001c
 8009584:	24037400 	.word	0x24037400

08009588 <__asan_version_mismatch_check_v8>:
void __asan_version_mismatch_check_v8(void) {  }
 8009588:	4770      	bx	lr
 800958a:	bf00      	nop

0800958c <__asan_unregister_globals>:
 800958c:	4770      	bx	lr
 800958e:	bf00      	nop

08009590 <__asan_register_globals>:
   for(i=0; i<n ; i++)
 8009590:	2900      	cmp	r1, #0
 8009592:	d052      	beq.n	800963a <__asan_register_globals+0xaa>
{
 8009594:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009598:	4604      	mov	r4, r0
  return (size + boundary - 1) & ~(boundary - 1);
 800959a:	f8df b0a4 	ldr.w	fp, [pc, #164]	; 8009640 <__asan_register_globals+0xb0>
 800959e:	eb00 1841 	add.w	r8, r0, r1, lsl #5
 80095a2:	e002      	b.n	80095aa <__asan_register_globals+0x1a>
   for(i=0; i<n ; i++)
 80095a4:	3420      	adds	r4, #32
 80095a6:	45a0      	cmp	r8, r4
 80095a8:	d03d      	beq.n	8009626 <__asan_register_globals+0x96>
	   if( (globals[i].beg >= McuASAN_CONFIG_APP_MEM_START) &&
 80095aa:	6826      	ldr	r6, [r4, #0]
 80095ac:	f106 435c 	add.w	r3, r6, #3690987520	; 0xdc000000
 80095b0:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 80095b4:	d2f6      	bcs.n	80095a4 <__asan_register_globals+0x14>
  uptr shadow_end = MEM_TO_SHADOW(
 80095b6:	4b21      	ldr	r3, [pc, #132]	; (800963c <__asan_register_globals+0xac>)
      aligned_beg + aligned_size - SHADOW_GRANULARITY) + 1;
 80095b8:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
  return (size + boundary - 1) & ~(boundary - 1);
 80095bc:	f107 0907 	add.w	r9, r7, #7
      aligned_beg + aligned_size - SHADOW_GRANULARITY) + 1;
 80095c0:	4435      	add	r5, r6
  return (size + boundary - 1) & ~(boundary - 1);
 80095c2:	f029 0907 	bic.w	r9, r9, #7
  uptr shadow_end = MEM_TO_SHADOW(
 80095c6:	3d08      	subs	r5, #8
  FastPoisonShadow(g.beg + aligned_size, g.size_with_redzone - aligned_size,
 80095c8:	eb06 0209 	add.w	r2, r6, r9
  uptr shadow_end = MEM_TO_SHADOW(
 80095cc:	eb03 05d5 	add.w	r5, r3, r5, lsr #3
  return   ((((uint32_t)address)>>3 ) + McuASAN_CONFIG_APP_MEM_OFFSET); /* divided by 8: every byte has a shadow bit */
 80095d0:	08d2      	lsrs	r2, r2, #3
  return x & ~(boundary - 1);
 80095d2:	ea05 0a0b 	and.w	sl, r5, fp
  return   ((((uint32_t)address)>>3 ) + McuASAN_CONFIG_APP_MEM_OFFSET); /* divided by 8: every byte has a shadow bit */
 80095d6:	f102 50dc 	add.w	r0, r2, #461373440	; 0x1b800000
  return (size + boundary - 1) & ~(boundary - 1);
 80095da:	f102 52dc 	add.w	r2, r2, #461373440	; 0x1b800000
 80095de:	f202 32ff 	addw	r2, r2, #1023	; 0x3ff
 80095e2:	ea02 020b 	and.w	r2, r2, fp
    if (page_beg >= page_end) {
 80095e6:	4552      	cmp	r2, sl
 80095e8:	d21f      	bcs.n	800962a <__asan_register_globals+0x9a>
      if (page_beg != shadow_beg) {
 80095ea:	4290      	cmp	r0, r2
 80095ec:	d003      	beq.n	80095f6 <__asan_register_globals+0x66>
        memset((void *)shadow_beg, value, page_beg - shadow_beg);
 80095ee:	1a12      	subs	r2, r2, r0
 80095f0:	21f9      	movs	r1, #249	; 0xf9
 80095f2:	f00a fe8d 	bl	8014310 <memset>
      if (page_end != shadow_end) {
 80095f6:	4555      	cmp	r5, sl
 80095f8:	d005      	beq.n	8009606 <__asan_register_globals+0x76>
        memset((void *)page_end, value, shadow_end - page_end);
 80095fa:	eba5 020a 	sub.w	r2, r5, sl
 80095fe:	4650      	mov	r0, sl
 8009600:	21f9      	movs	r1, #249	; 0xf9
 8009602:	f00a fe85 	bl	8014310 <memset>
  if (g.size != aligned_size) {
 8009606:	454f      	cmp	r7, r9
 8009608:	d0cc      	beq.n	80095a4 <__asan_register_globals+0x14>
  return x & ~(boundary - 1);
 800960a:	f027 0307 	bic.w	r3, r7, #7
    } else if (i >= size) {
 800960e:	f017 0707 	ands.w	r7, r7, #7
    FastPoisonShadowPartialRightRedzone(
 8009612:	441e      	add	r6, r3
  return   ((((uint32_t)address)>>3 ) + McuASAN_CONFIG_APP_MEM_OFFSET); /* divided by 8: every byte has a shadow bit */
 8009614:	ea4f 06d6 	mov.w	r6, r6, lsr #3
 8009618:	f106 56dc 	add.w	r6, r6, #461373440	; 0x1b800000
    } else if (i >= size) {
 800961c:	d00a      	beq.n	8009634 <__asan_register_globals+0xa4>
   for(i=0; i<n ; i++)
 800961e:	3420      	adds	r4, #32
      *shadow = poison_partial ?(uint8_t)(size - i) : 0;
 8009620:	7037      	strb	r7, [r6, #0]
   for(i=0; i<n ; i++)
 8009622:	45a0      	cmp	r8, r4
 8009624:	d1c1      	bne.n	80095aa <__asan_register_globals+0x1a>
}
 8009626:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      memset((void *)shadow_beg, value, shadow_end - shadow_beg);
 800962a:	1a2a      	subs	r2, r5, r0
 800962c:	21f9      	movs	r1, #249	; 0xf9
 800962e:	f00a fe6f 	bl	8014310 <memset>
 8009632:	e7e8      	b.n	8009606 <__asan_register_globals+0x76>
      *shadow = (SHADOW_GRANULARITY == 128) ? 0xff : value;  // unaddressable
 8009634:	23f9      	movs	r3, #249	; 0xf9
 8009636:	7033      	strb	r3, [r6, #0]
 8009638:	e7b4      	b.n	80095a4 <__asan_register_globals+0x14>
 800963a:	4770      	bx	lr
 800963c:	1b800001 	.word	0x1b800001
 8009640:	fffffc00 	.word	0xfffffc00

08009644 <Allocate>:
                 AllocType alloc_type, bool can_fill) {
 8009644:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (user_requested_alignment < 8)
 8009648:	2907      	cmp	r1, #7
                 AllocType alloc_type, bool can_fill) {
 800964a:	b085      	sub	sp, #20
 800964c:	4606      	mov	r6, r0
 800964e:	4691      	mov	r9, r2
 8009650:	9300      	str	r3, [sp, #0]
    if (user_requested_alignment < 8)
 8009652:	f240 80f3 	bls.w	800983c <Allocate+0x1f8>
  return (uptr) ffs(x);
 8009656:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 800965a:	460b      	mov	r3, r1
 800965c:	bf28      	it	cs
 800965e:	f44f 7300 	movcs.w	r3, #512	; 0x200
 8009662:	2b00      	cmp	r3, #0
 8009664:	fa93 f3a3 	rbit	r3, r3
 8009668:	fab3 f383 	clz	r3, r3
 800966c:	bf08      	it	eq
 800966e:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
    return Log2(user_requested_alignment) - 2;
 8009672:	3b01      	subs	r3, #1
 8009674:	9301      	str	r3, [sp, #4]
    if (alignment < min_alignment)
 8009676:	2908      	cmp	r1, #8
 8009678:	460f      	mov	r7, r1
 800967a:	bf38      	it	cc
 800967c:	2708      	movcc	r7, #8
    if (size == 0) {
 800967e:	b1e6      	cbz	r6, 80096ba <Allocate+0x76>
    user_requested_size <= 64        - 16   ? 0 :
 8009680:	2e30      	cmp	r6, #48	; 0x30
 8009682:	f240 80d1 	bls.w	8009828 <Allocate+0x1e4>
 8009686:	2e60      	cmp	r6, #96	; 0x60
 8009688:	f240 8138 	bls.w	80098fc <Allocate+0x2b8>
 800968c:	f5b6 7fe0 	cmp.w	r6, #448	; 0x1c0
 8009690:	f240 8145 	bls.w	800991e <Allocate+0x2da>
 8009694:	f5b6 6f78 	cmp.w	r6, #3968	; 0xf80
 8009698:	f240 8147 	bls.w	800992a <Allocate+0x2e6>
 800969c:	f5b6 5f7c 	cmp.w	r6, #16128	; 0x3f00
 80096a0:	f200 80ae 	bhi.w	8009800 <Allocate+0x1bc>
    if (size > kMaxAllowedMallocSize || needed_size > kMaxAllowedMallocSize ||
 80096a4:	f5b6 5f80 	cmp.w	r6, #4096	; 0x1000
 80096a8:	4633      	mov	r3, r6
 80096aa:	f04f 0b03 	mov.w	fp, #3
 80096ae:	f04f 0480 	mov.w	r4, #128	; 0x80
 80096b2:	bf94      	ite	ls
 80096b4:	2500      	movls	r5, #0
 80096b6:	2501      	movhi	r5, #1
 80096b8:	e005      	b.n	80096c6 <Allocate+0x82>
 80096ba:	f04f 0b01 	mov.w	fp, #1
 80096be:	4635      	mov	r5, r6
 80096c0:	2420      	movs	r4, #32
 80096c2:	2304      	movs	r3, #4
      size = 1;
 80096c4:	465e      	mov	r6, fp
  return (size + boundary - 1) & ~(boundary - 1);
 80096c6:	1e78      	subs	r0, r7, #1
 80096c8:	f1c7 0a00 	rsb	sl, r7, #0
    if (alignment > min_alignment)
 80096cc:	2908      	cmp	r1, #8
  return (size + boundary - 1) & ~(boundary - 1);
 80096ce:	4418      	add	r0, r3
 80096d0:	ea00 000a 	and.w	r0, r0, sl
    uptr needed_size = rounded_size + rz_size;
 80096d4:	4420      	add	r0, r4
    if (alignment > min_alignment)
 80096d6:	f200 80a0 	bhi.w	800981a <Allocate+0x1d6>
    needed_size += rz_size; // manually adding the right red zone
 80096da:	1903      	adds	r3, r0, r4
    if (size > kMaxAllowedMallocSize || needed_size > kMaxAllowedMallocSize ||
 80096dc:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80096e0:	bf88      	it	hi
 80096e2:	f045 0501 	orrhi.w	r5, r5, #1
 80096e6:	2d00      	cmp	r5, #0
 80096e8:	f040 8099 	bne.w	800981e <Allocate+0x1da>
    allocated = malloc(needed_size);
 80096ec:	4618      	mov	r0, r3
 80096ee:	9302      	str	r3, [sp, #8]
 80096f0:	f00a fdf0 	bl	80142d4 <malloc>
  	if(ptr)
 80096f4:	4680      	mov	r8, r0
 80096f6:	2800      	cmp	r0, #0
 80096f8:	f000 8091 	beq.w	800981e <Allocate+0x1da>
  		    if(pAFLfuzzer->allocs[i]==0)
 80096fc:	4a9c      	ldr	r2, [pc, #624]	; (8009970 <Allocate+0x32c>)
 80096fe:	9b02      	ldr	r3, [sp, #8]
 8009700:	f8d2 1830 	ldr.w	r1, [r2, #2096]	; 0x830
 8009704:	2900      	cmp	r1, #0
 8009706:	f000 8116 	beq.w	8009936 <Allocate+0x2f2>
 800970a:	f8d2 1834 	ldr.w	r1, [r2, #2100]	; 0x834
 800970e:	2900      	cmp	r1, #0
 8009710:	f000 8119 	beq.w	8009946 <Allocate+0x302>
 8009714:	f8d2 1838 	ldr.w	r1, [r2, #2104]	; 0x838
 8009718:	2900      	cmp	r1, #0
 800971a:	f000 8116 	beq.w	800994a <Allocate+0x306>
 800971e:	f8d2 183c 	ldr.w	r1, [r2, #2108]	; 0x83c
 8009722:	2900      	cmp	r1, #0
 8009724:	f000 8113 	beq.w	800994e <Allocate+0x30a>
 8009728:	f8d2 1840 	ldr.w	r1, [r2, #2112]	; 0x840
 800972c:	2900      	cmp	r1, #0
 800972e:	f000 8110 	beq.w	8009952 <Allocate+0x30e>
 8009732:	f8d2 1844 	ldr.w	r1, [r2, #2116]	; 0x844
 8009736:	2900      	cmp	r1, #0
 8009738:	f000 810d 	beq.w	8009956 <Allocate+0x312>
 800973c:	f8d2 1848 	ldr.w	r1, [r2, #2120]	; 0x848
 8009740:	2900      	cmp	r1, #0
 8009742:	f000 810a 	beq.w	800995a <Allocate+0x316>
 8009746:	f8d2 184c 	ldr.w	r1, [r2, #2124]	; 0x84c
 800974a:	2900      	cmp	r1, #0
 800974c:	f000 8107 	beq.w	800995e <Allocate+0x31a>
 8009750:	f8d2 1850 	ldr.w	r1, [r2, #2128]	; 0x850
 8009754:	2900      	cmp	r1, #0
 8009756:	f000 8104 	beq.w	8009962 <Allocate+0x31e>
 800975a:	f8d2 2854 	ldr.w	r2, [r2, #2132]	; 0x854
 800975e:	2a00      	cmp	r2, #0
 8009760:	f000 8101 	beq.w	8009966 <Allocate+0x322>
  return   ((((uint32_t)address)>>3 ) + McuASAN_CONFIG_APP_MEM_OFFSET); /* divided by 8: every byte has a shadow bit */
 8009764:	ea4f 02d8 	mov.w	r2, r8, lsr #3
 8009768:	f102 50dc 	add.w	r0, r2, #461373440	; 0x1b800000
    if (*(uint8_t *)MEM_TO_SHADOW((uptr)allocated) == 0 ) {
 800976c:	7801      	ldrb	r1, [r0, #0]
 800976e:	2900      	cmp	r1, #0
 8009770:	d067      	beq.n	8009842 <Allocate+0x1fe>
    uptr beg_plus_redzone = alloc_beg + rz_size;
 8009772:	4444      	add	r4, r8
  return (a & (alignment - 1)) == 0;
 8009774:	3f01      	subs	r7, #1
    if (!IsAligned(user_beg, alignment))
 8009776:	423c      	tst	r4, r7
 8009778:	d007      	beq.n	800978a <Allocate+0x146>
  return (size + boundary - 1) & ~(boundary - 1);
 800977a:	4427      	add	r7, r4
 800977c:	ea07 0a0a 	and.w	sl, r7, sl
    m->from_memalign = user_beg != beg_plus_redzone;
 8009780:	ebb4 050a 	subs.w	r5, r4, sl
      user_beg = RoundUpTo(user_beg, alignment);
 8009784:	4654      	mov	r4, sl
    m->from_memalign = user_beg != beg_plus_redzone;
 8009786:	bf18      	it	ne
 8009788:	2501      	movne	r5, #1
    m->free_tid = kInvalidTid;
 800978a:	062b      	lsls	r3, r5, #24
 800978c:	f009 0203 	and.w	r2, r9, #3
    uptr chunk_beg = user_beg - kChunkHeaderSize;
 8009790:	f1a4 0710 	sub.w	r7, r4, #16
    m->free_tid = kInvalidTid;
 8009794:	f063 437f 	orn	r3, r3, #4278190080	; 0xff000000
    if (alloc_beg != chunk_beg) {
 8009798:	45b8      	cmp	r8, r7
    m->free_tid = kInvalidTid;
 800979a:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
    m->alloc_tid = alloc_tid;
 800979e:	f854 2c10 	ldr.w	r2, [r4, #-16]
 80097a2:	f36f 221f 	bfc	r2, #8, #24
    m->free_tid = kInvalidTid;
 80097a6:	ea43 63cb 	orr.w	r3, r3, fp, lsl #27
    m->alloc_tid = alloc_tid;
 80097aa:	f844 2c10 	str.w	r2, [r4, #-16]
    m->free_tid = kInvalidTid;
 80097ae:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
 80097b2:	f854 2c0c 	ldr.w	r2, [r4, #-12]
 80097b6:	f002 4240 	and.w	r2, r2, #3221225472	; 0xc0000000
 80097ba:	ea43 0302 	orr.w	r3, r3, r2
 80097be:	f844 3c0c 	str.w	r3, [r4, #-12]
    if (alloc_beg != chunk_beg) {
 80097c2:	d004      	beq.n	80097ce <Allocate+0x18a>
      ((uptr *)alloc_beg)[0] = kAllocBegMagic;
 80097c4:	4b6b      	ldr	r3, [pc, #428]	; (8009974 <Allocate+0x330>)
      ((uptr *)alloc_beg)[1] = chunk_beg;
 80097c6:	f8c8 7004 	str.w	r7, [r8, #4]
      ((uptr *)alloc_beg)[0] = kAllocBegMagic;
 80097ca:	f8c8 3000 	str.w	r3, [r8]
      m->user_requested_size = size;   // SizeClassMap::kMaxSize;
 80097ce:	f026 4360 	bic.w	r3, r6, #3758096384	; 0xe0000000
 80097d2:	9a01      	ldr	r2, [sp, #4]
    if (size_rounded_down_to_granularity)
 80097d4:	f036 0507 	bics.w	r5, r6, #7
      m->user_requested_size = size;   // SizeClassMap::kMaxSize;
 80097d8:	ea43 7342 	orr.w	r3, r3, r2, lsl #29
 80097dc:	60bb      	str	r3, [r7, #8]
    if (size_rounded_down_to_granularity)
 80097de:	d163      	bne.n	80098a8 <Allocate+0x264>
          (uint8_t *)MEM_TO_SHADOW(user_beg + size_rounded_down_to_granularity);
 80097e0:	4425      	add	r5, r4
      *shadow = McuASAN_FLAG_POISON_PARTIAL ? (size & (SHADOW_GRANULARITY - 1)) : 0;
 80097e2:	f006 0307 	and.w	r3, r6, #7
  return   ((((uint32_t)address)>>3 ) + McuASAN_CONFIG_APP_MEM_OFFSET); /* divided by 8: every byte has a shadow bit */
 80097e6:	08ed      	lsrs	r5, r5, #3
      *shadow = McuASAN_FLAG_POISON_PARTIAL ? (size & (SHADOW_GRANULARITY - 1)) : 0;
 80097e8:	f105 55dc 	add.w	r5, r5, #461373440	; 0x1b800000
 80097ec:	702b      	strb	r3, [r5, #0]
    if (can_fill && McuASAN_FLAG_MAX_MALLOC_FILL_SIZE) {
 80097ee:	9b00      	ldr	r3, [sp, #0]
 80097f0:	2b00      	cmp	r3, #0
 80097f2:	d14d      	bne.n	8009890 <Allocate+0x24c>
    *(uint8_t *)m = CHUNK_ALLOCATED;
 80097f4:	2302      	movs	r3, #2
  }
 80097f6:	4620      	mov	r0, r4
    *(uint8_t *)m = CHUNK_ALLOCATED;
 80097f8:	703b      	strb	r3, [r7, #0]
  }
 80097fa:	b005      	add	sp, #20
 80097fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (alignment > min_alignment)
 8009800:	2908      	cmp	r1, #8
 8009802:	d90c      	bls.n	800981e <Allocate+0x1da>
  return (size + boundary - 1) & ~(boundary - 1);
 8009804:	1e70      	subs	r0, r6, #1
 8009806:	f1c7 0a00 	rsb	sl, r7, #0
    uptr needed_size = rounded_size + rz_size;
 800980a:	2501      	movs	r5, #1
  return Min(Max(rz_log, RZSize2Log(min_rz)), RZSize2Log(max_rz));
 800980c:	f04f 0b03 	mov.w	fp, #3
  return (size + boundary - 1) & ~(boundary - 1);
 8009810:	4438      	add	r0, r7
  return 16 << rz_log;
 8009812:	2480      	movs	r4, #128	; 0x80
  return (size + boundary - 1) & ~(boundary - 1);
 8009814:	ea00 000a 	and.w	r0, r0, sl
    uptr needed_size = rounded_size + rz_size;
 8009818:	3080      	adds	r0, #128	; 0x80
      needed_size += alignment;
 800981a:	4438      	add	r0, r7
 800981c:	e75d      	b.n	80096da <Allocate+0x96>
        return NULL;
 800981e:	2400      	movs	r4, #0
  }
 8009820:	4620      	mov	r0, r4
 8009822:	b005      	add	sp, #20
 8009824:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    uptr rounded_size = RoundUpTo(Max(size, kChunkHeader2Size), alignment);
 8009828:	2e04      	cmp	r6, #4
 800982a:	4633      	mov	r3, r6
 800982c:	f04f 0500 	mov.w	r5, #0
 8009830:	f04f 0b01 	mov.w	fp, #1
 8009834:	bf38      	it	cc
 8009836:	2304      	movcc	r3, #4
 8009838:	2420      	movs	r4, #32
 800983a:	e744      	b.n	80096c6 <Allocate+0x82>
      return 0;
 800983c:	2300      	movs	r3, #0
 800983e:	9301      	str	r3, [sp, #4]
 8009840:	e719      	b.n	8009676 <Allocate+0x32>
   if( (addr>= McuASAN_CONFIG_APP_MEM_START) &&
 8009842:	f108 415c 	add.w	r1, r8, #3690987520	; 0xdc000000
 8009846:	f5b1 2f00 	cmp.w	r1, #524288	; 0x80000
 800984a:	f080 808e 	bcs.w	800996a <Allocate+0x326>
  uptr shadow_end = MEM_TO_SHADOW(
 800984e:	3b08      	subs	r3, #8
 8009850:	4949      	ldr	r1, [pc, #292]	; (8009978 <Allocate+0x334>)
 8009852:	4443      	add	r3, r8
 8009854:	eb01 03d3 	add.w	r3, r1, r3, lsr #3
  return (size + boundary - 1) & ~(boundary - 1);
 8009858:	f201 31fe 	addw	r1, r1, #1022	; 0x3fe
  uptr shadow_end = MEM_TO_SHADOW(
 800985c:	9302      	str	r3, [sp, #8]
  return (size + boundary - 1) & ~(boundary - 1);
 800985e:	4411      	add	r1, r2
 8009860:	4b46      	ldr	r3, [pc, #280]	; (800997c <Allocate+0x338>)
  return x & ~(boundary - 1);
 8009862:	9a02      	ldr	r2, [sp, #8]
  return (size + boundary - 1) & ~(boundary - 1);
 8009864:	4019      	ands	r1, r3
  return x & ~(boundary - 1);
 8009866:	4013      	ands	r3, r2
    if (page_beg >= page_end) {
 8009868:	4299      	cmp	r1, r3
 800986a:	d253      	bcs.n	8009914 <Allocate+0x2d0>
      if (page_beg != shadow_beg) {
 800986c:	4288      	cmp	r0, r1
 800986e:	d005      	beq.n	800987c <Allocate+0x238>
        memset((void *)shadow_beg, value, page_beg - shadow_beg);
 8009870:	1a0a      	subs	r2, r1, r0
 8009872:	21fa      	movs	r1, #250	; 0xfa
 8009874:	9303      	str	r3, [sp, #12]
 8009876:	f00a fd4b 	bl	8014310 <memset>
 800987a:	9b03      	ldr	r3, [sp, #12]
      if (page_end != shadow_end) {
 800987c:	9a02      	ldr	r2, [sp, #8]
 800987e:	429a      	cmp	r2, r3
 8009880:	f43f af77 	beq.w	8009772 <Allocate+0x12e>
        memset((void *)page_end, value, shadow_end - page_end);
 8009884:	1ad2      	subs	r2, r2, r3
 8009886:	4618      	mov	r0, r3
 8009888:	21fa      	movs	r1, #250	; 0xfa
 800988a:	f00a fd41 	bl	8014310 <memset>
 800988e:	e770      	b.n	8009772 <Allocate+0x12e>
      memset(res, McuASAN_FLAG_MALLOC_FILL_BYTE, fill_size);
 8009890:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8009894:	4632      	mov	r2, r6
 8009896:	f04f 01be 	mov.w	r1, #190	; 0xbe
 800989a:	4620      	mov	r0, r4
 800989c:	bf28      	it	cs
 800989e:	f44f 7200 	movcs.w	r2, #512	; 0x200
 80098a2:	f00a fd35 	bl	8014310 <memset>
 80098a6:	e7a5      	b.n	80097f4 <Allocate+0x1b0>
   if( (addr>= McuASAN_CONFIG_APP_MEM_START) &&
 80098a8:	f104 435c 	add.w	r3, r4, #3690987520	; 0xdc000000
 80098ac:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 80098b0:	d25b      	bcs.n	800996a <Allocate+0x326>
  uptr shadow_end = MEM_TO_SHADOW(
 80098b2:	f1a5 0808 	sub.w	r8, r5, #8
 80098b6:	4a30      	ldr	r2, [pc, #192]	; (8009978 <Allocate+0x334>)
  return   ((((uint32_t)address)>>3 ) + McuASAN_CONFIG_APP_MEM_OFFSET); /* divided by 8: every byte has a shadow bit */
 80098b8:	08e0      	lsrs	r0, r4, #3
  uptr shadow_end = MEM_TO_SHADOW(
 80098ba:	eb08 0304 	add.w	r3, r8, r4
 80098be:	eb02 08d3 	add.w	r8, r2, r3, lsr #3
  return (size + boundary - 1) & ~(boundary - 1);
 80098c2:	f202 32fe 	addw	r2, r2, #1022	; 0x3fe
 80098c6:	4b2d      	ldr	r3, [pc, #180]	; (800997c <Allocate+0x338>)
 80098c8:	4402      	add	r2, r0
  return   ((((uint32_t)address)>>3 ) + McuASAN_CONFIG_APP_MEM_OFFSET); /* divided by 8: every byte has a shadow bit */
 80098ca:	f100 50dc 	add.w	r0, r0, #461373440	; 0x1b800000
  return x & ~(boundary - 1);
 80098ce:	ea08 0a03 	and.w	sl, r8, r3
  return (size + boundary - 1) & ~(boundary - 1);
 80098d2:	401a      	ands	r2, r3
    if (page_beg >= page_end) {
 80098d4:	4552      	cmp	r2, sl
 80098d6:	d217      	bcs.n	8009908 <Allocate+0x2c4>
      if (page_beg != shadow_beg) {
 80098d8:	4290      	cmp	r0, r2
 80098da:	d003      	beq.n	80098e4 <Allocate+0x2a0>
        memset((void *)shadow_beg, value, page_beg - shadow_beg);
 80098dc:	1a12      	subs	r2, r2, r0
 80098de:	2100      	movs	r1, #0
 80098e0:	f00a fd16 	bl	8014310 <memset>
      if (page_end != shadow_end) {
 80098e4:	45d0      	cmp	r8, sl
 80098e6:	d005      	beq.n	80098f4 <Allocate+0x2b0>
        memset((void *)page_end, value, shadow_end - page_end);
 80098e8:	eba8 020a 	sub.w	r2, r8, sl
 80098ec:	4650      	mov	r0, sl
 80098ee:	2100      	movs	r1, #0
 80098f0:	f00a fd0e 	bl	8014310 <memset>
    if (size != size_rounded_down_to_granularity ) {
 80098f4:	42b5      	cmp	r5, r6
 80098f6:	f43f af7a 	beq.w	80097ee <Allocate+0x1aa>
 80098fa:	e771      	b.n	80097e0 <Allocate+0x19c>
 80098fc:	4633      	mov	r3, r6
 80098fe:	2500      	movs	r5, #0
 8009900:	f04f 0b01 	mov.w	fp, #1
 8009904:	2420      	movs	r4, #32
 8009906:	e6de      	b.n	80096c6 <Allocate+0x82>
      memset((void *)shadow_beg, value, shadow_end - shadow_beg);
 8009908:	eba8 0200 	sub.w	r2, r8, r0
 800990c:	2100      	movs	r1, #0
 800990e:	f00a fcff 	bl	8014310 <memset>
 8009912:	e7ef      	b.n	80098f4 <Allocate+0x2b0>
 8009914:	1a12      	subs	r2, r2, r0
 8009916:	21fa      	movs	r1, #250	; 0xfa
 8009918:	f00a fcfa 	bl	8014310 <memset>
 800991c:	e729      	b.n	8009772 <Allocate+0x12e>
 800991e:	4633      	mov	r3, r6
 8009920:	2500      	movs	r5, #0
 8009922:	f04f 0b02 	mov.w	fp, #2
 8009926:	2440      	movs	r4, #64	; 0x40
 8009928:	e6cd      	b.n	80096c6 <Allocate+0x82>
 800992a:	4633      	mov	r3, r6
 800992c:	2500      	movs	r5, #0
 800992e:	f04f 0b03 	mov.w	fp, #3
 8009932:	2480      	movs	r4, #128	; 0x80
 8009934:	e6c7      	b.n	80096c6 <Allocate+0x82>
	int i=0;
 8009936:	4629      	mov	r1, r5
  		    	pAFLfuzzer->allocs[i] = ptr;
 8009938:	f641 220c 	movw	r2, #6668	; 0x1a0c
 800993c:	440a      	add	r2, r1
 800993e:	4910      	ldr	r1, [pc, #64]	; (8009980 <Allocate+0x33c>)
 8009940:	f841 8022 	str.w	r8, [r1, r2, lsl #2]
  			    break;
 8009944:	e70e      	b.n	8009764 <Allocate+0x120>
  		    i++;
 8009946:	2101      	movs	r1, #1
 8009948:	e7f6      	b.n	8009938 <Allocate+0x2f4>
 800994a:	2102      	movs	r1, #2
 800994c:	e7f4      	b.n	8009938 <Allocate+0x2f4>
 800994e:	2103      	movs	r1, #3
 8009950:	e7f2      	b.n	8009938 <Allocate+0x2f4>
 8009952:	2104      	movs	r1, #4
 8009954:	e7f0      	b.n	8009938 <Allocate+0x2f4>
 8009956:	2105      	movs	r1, #5
 8009958:	e7ee      	b.n	8009938 <Allocate+0x2f4>
 800995a:	2106      	movs	r1, #6
 800995c:	e7ec      	b.n	8009938 <Allocate+0x2f4>
 800995e:	2107      	movs	r1, #7
 8009960:	e7ea      	b.n	8009938 <Allocate+0x2f4>
 8009962:	2108      	movs	r1, #8
 8009964:	e7e8      	b.n	8009938 <Allocate+0x2f4>
 8009966:	2109      	movs	r1, #9
 8009968:	e7e6      	b.n	8009938 <Allocate+0x2f4>
  FreeRTOSReportFailure(EX_ASAN_FAIL_POISON);
 800996a:	2007      	movs	r0, #7
 800996c:	f7ff fdc0 	bl	80094f0 <FreeRTOSReportFailure>
 8009970:	24026000 	.word	0x24026000
 8009974:	cc6e96b9 	.word	0xcc6e96b9
 8009978:	1b800001 	.word	0x1b800001
 800997c:	fffffc00 	.word	0xfffffc00
 8009980:	24020000 	.word	0x24020000

08009984 <ReportDoubleFree>:
void ReportDoubleFree(uptr addr) {
 8009984:	b508      	push	{r3, lr}
	__asm volatile("push {r0-r3}");
 8009986:	b40f      	push	{r0, r1, r2, r3}
  FreeRTOSReportFailure(EX_ASAN_DOUBLE_FREE);
 8009988:	2001      	movs	r0, #1
 800998a:	f7ff fdb1 	bl	80094f0 <FreeRTOSReportFailure>
 800998e:	bf00      	nop

08009990 <ReportFreeNotMalloced>:
void ReportFreeNotMalloced(uptr addr) {
 8009990:	b508      	push	{r3, lr}
	__asm volatile("push {r0-r3}");
 8009992:	b40f      	push	{r0, r1, r2, r3}
  FreeRTOSReportFailure(EX_ASAN_INVALID_FREE);
 8009994:	2003      	movs	r0, #3
 8009996:	f7ff fdab 	bl	80094f0 <FreeRTOSReportFailure>
 800999a:	bf00      	nop

0800999c <ReportInvalidFree>:
    if (chunk_state == CHUNK_QUARANTINE)
 800999c:	2903      	cmp	r1, #3
void ReportInvalidFree(void *ptr, uint8_t chunk_state) {
 800999e:	b508      	push	{r3, lr}
    if (chunk_state == CHUNK_QUARANTINE)
 80099a0:	d001      	beq.n	80099a6 <ReportInvalidFree+0xa>
      ReportFreeNotMalloced((uptr)ptr);
 80099a2:	f7ff fff5 	bl	8009990 <ReportFreeNotMalloced>
      ReportDoubleFree((uptr)ptr);
 80099a6:	f7ff ffed 	bl	8009984 <ReportDoubleFree>
 80099aa:	bf00      	nop

080099ac <Recycle>:
   if( (addr>= McuASAN_CONFIG_APP_MEM_START) &&
 80099ac:	4a4b      	ldr	r2, [pc, #300]	; (8009adc <Recycle+0x130>)
void Recycle(AsanChunk *m) {
 80099ae:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   if( (addr>= McuASAN_CONFIG_APP_MEM_START) &&
 80099b0:	4402      	add	r2, r0
  *(uint8_t*)m = CHUNK_AVAILABLE;
 80099b2:	2300      	movs	r3, #0
 80099b4:	4606      	mov	r6, r0
   if( (addr>= McuASAN_CONFIG_APP_MEM_START) &&
 80099b6:	f5b2 2f00 	cmp.w	r2, #524288	; 0x80000
  *(uint8_t*)m = CHUNK_AVAILABLE;
 80099ba:	f806 3b10 	strb.w	r3, [r6], #16
               RoundUpTo(m->user_requested_size, SHADOW_GRANULARITY),
 80099be:	6883      	ldr	r3, [r0, #8]
 80099c0:	f3c3 031c 	ubfx	r3, r3, #0, #29
   if( (addr>= McuASAN_CONFIG_APP_MEM_START) &&
 80099c4:	f080 8087 	bcs.w	8009ad6 <Recycle+0x12a>
	   FastPoisonShadow(addr, size, value);
 80099c8:	4604      	mov	r4, r0
 80099ca:	3307      	adds	r3, #7
  return   ((((uint32_t)address)>>3 ) + McuASAN_CONFIG_APP_MEM_OFFSET); /* divided by 8: every byte has a shadow bit */
 80099cc:	08f1      	lsrs	r1, r6, #3
  return (size + boundary - 1) & ~(boundary - 1);
 80099ce:	4a44      	ldr	r2, [pc, #272]	; (8009ae0 <Recycle+0x134>)
  uptr shadow_end = MEM_TO_SHADOW(
 80099d0:	f104 0708 	add.w	r7, r4, #8
 80099d4:	f023 0307 	bic.w	r3, r3, #7
  return (size + boundary - 1) & ~(boundary - 1);
 80099d8:	4d42      	ldr	r5, [pc, #264]	; (8009ae4 <Recycle+0x138>)
 80099da:	440a      	add	r2, r1
  uptr shadow_end = MEM_TO_SHADOW(
 80099dc:	443b      	add	r3, r7
 80099de:	4f42      	ldr	r7, [pc, #264]	; (8009ae8 <Recycle+0x13c>)
  return (size + boundary - 1) & ~(boundary - 1);
 80099e0:	402a      	ands	r2, r5
  return   ((((uint32_t)address)>>3 ) + McuASAN_CONFIG_APP_MEM_OFFSET); /* divided by 8: every byte has a shadow bit */
 80099e2:	f101 50dc 	add.w	r0, r1, #461373440	; 0x1b800000
  uptr shadow_end = MEM_TO_SHADOW(
 80099e6:	eb07 07d3 	add.w	r7, r7, r3, lsr #3
  return x & ~(boundary - 1);
 80099ea:	403d      	ands	r5, r7
    if (page_beg >= page_end) {
 80099ec:	42aa      	cmp	r2, r5
 80099ee:	d24d      	bcs.n	8009a8c <Recycle+0xe0>
      if (page_beg != shadow_beg) {
 80099f0:	4290      	cmp	r0, r2
 80099f2:	d144      	bne.n	8009a7e <Recycle+0xd2>
      if (page_end != shadow_end) {
 80099f4:	42af      	cmp	r7, r5
 80099f6:	d138      	bne.n	8009a6a <Recycle+0xbe>
	if (m->from_memalign)
 80099f8:	79e3      	ldrb	r3, [r4, #7]
 80099fa:	f013 0201 	ands.w	r2, r3, #1
 80099fe:	d133      	bne.n	8009a68 <Recycle+0xbc>
  return 16 << rz_log;
 8009a00:	2010      	movs	r0, #16
	return (Beg(m) - RZLog2Size(m->rz_log));
 8009a02:	f3c3 03c2 	ubfx	r3, r3, #3, #3
  return 16 << rz_log;
 8009a06:	fa00 f303 	lsl.w	r3, r0, r3
  	if(ptr)
 8009a0a:	1af0      	subs	r0, r6, r3
 8009a0c:	d028      	beq.n	8009a60 <Recycle+0xb4>
  		    if(pAFLfuzzer->allocs[i]==ptr)
 8009a0e:	4b37      	ldr	r3, [pc, #220]	; (8009aec <Recycle+0x140>)
 8009a10:	f8d3 1830 	ldr.w	r1, [r3, #2096]	; 0x830
 8009a14:	4281      	cmp	r1, r0
 8009a16:	d043      	beq.n	8009aa0 <Recycle+0xf4>
 8009a18:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8009a1c:	4290      	cmp	r0, r2
 8009a1e:	d03e      	beq.n	8009a9e <Recycle+0xf2>
 8009a20:	f8d3 2838 	ldr.w	r2, [r3, #2104]	; 0x838
 8009a24:	4290      	cmp	r0, r2
 8009a26:	d048      	beq.n	8009aba <Recycle+0x10e>
 8009a28:	f8d3 283c 	ldr.w	r2, [r3, #2108]	; 0x83c
 8009a2c:	4290      	cmp	r0, r2
 8009a2e:	d04a      	beq.n	8009ac6 <Recycle+0x11a>
 8009a30:	f8d3 2840 	ldr.w	r2, [r3, #2112]	; 0x840
 8009a34:	4290      	cmp	r0, r2
 8009a36:	d048      	beq.n	8009aca <Recycle+0x11e>
 8009a38:	f8d3 2844 	ldr.w	r2, [r3, #2116]	; 0x844
 8009a3c:	4290      	cmp	r0, r2
 8009a3e:	d046      	beq.n	8009ace <Recycle+0x122>
 8009a40:	f8d3 2848 	ldr.w	r2, [r3, #2120]	; 0x848
 8009a44:	4290      	cmp	r0, r2
 8009a46:	d03a      	beq.n	8009abe <Recycle+0x112>
 8009a48:	f8d3 284c 	ldr.w	r2, [r3, #2124]	; 0x84c
 8009a4c:	4290      	cmp	r0, r2
 8009a4e:	d038      	beq.n	8009ac2 <Recycle+0x116>
 8009a50:	f8d3 2850 	ldr.w	r2, [r3, #2128]	; 0x850
 8009a54:	4290      	cmp	r0, r2
 8009a56:	d03c      	beq.n	8009ad2 <Recycle+0x126>
 8009a58:	f8d3 3854 	ldr.w	r3, [r3, #2132]	; 0x854
 8009a5c:	4298      	cmp	r0, r3
 8009a5e:	d02a      	beq.n	8009ab6 <Recycle+0x10a>
}
 8009a60:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  free(p);
 8009a64:	f00a bc3e 	b.w	80142e4 <free>
		while(1); // this is a special case that we do not support since we do not control the allocator, the code should not reach this point
 8009a68:	e7fe      	b.n	8009a68 <Recycle+0xbc>
        memset((void *)page_end, value, shadow_end - page_end);
 8009a6a:	1b7a      	subs	r2, r7, r5
 8009a6c:	21fa      	movs	r1, #250	; 0xfa
 8009a6e:	4628      	mov	r0, r5
 8009a70:	f00a fc4e 	bl	8014310 <memset>
	if (m->from_memalign)
 8009a74:	79e3      	ldrb	r3, [r4, #7]
 8009a76:	f013 0201 	ands.w	r2, r3, #1
 8009a7a:	d0c1      	beq.n	8009a00 <Recycle+0x54>
 8009a7c:	e7f4      	b.n	8009a68 <Recycle+0xbc>
        memset((void *)shadow_beg, value, page_beg - shadow_beg);
 8009a7e:	1a12      	subs	r2, r2, r0
 8009a80:	21fa      	movs	r1, #250	; 0xfa
 8009a82:	f00a fc45 	bl	8014310 <memset>
      if (page_end != shadow_end) {
 8009a86:	42af      	cmp	r7, r5
 8009a88:	d0b6      	beq.n	80099f8 <Recycle+0x4c>
 8009a8a:	e7ee      	b.n	8009a6a <Recycle+0xbe>
      memset((void *)shadow_beg, value, shadow_end - shadow_beg);
 8009a8c:	1a3a      	subs	r2, r7, r0
 8009a8e:	21fa      	movs	r1, #250	; 0xfa
 8009a90:	f00a fc3e 	bl	8014310 <memset>
	if (m->from_memalign)
 8009a94:	79e3      	ldrb	r3, [r4, #7]
 8009a96:	f013 0201 	ands.w	r2, r3, #1
 8009a9a:	d0b1      	beq.n	8009a00 <Recycle+0x54>
 8009a9c:	e7e4      	b.n	8009a68 <Recycle+0xbc>
  		    i++;
 8009a9e:	2201      	movs	r2, #1
  		    	pAFLfuzzer->allocs[i]= NULL;
 8009aa0:	f641 230c 	movw	r3, #6668	; 0x1a0c
 8009aa4:	2400      	movs	r4, #0
 8009aa6:	4912      	ldr	r1, [pc, #72]	; (8009af0 <Recycle+0x144>)
 8009aa8:	4413      	add	r3, r2
 8009aaa:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
}
 8009aae:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  free(p);
 8009ab2:	f00a bc17 	b.w	80142e4 <free>
  		    i++;
 8009ab6:	2209      	movs	r2, #9
 8009ab8:	e7f2      	b.n	8009aa0 <Recycle+0xf4>
 8009aba:	2202      	movs	r2, #2
 8009abc:	e7f0      	b.n	8009aa0 <Recycle+0xf4>
 8009abe:	2206      	movs	r2, #6
 8009ac0:	e7ee      	b.n	8009aa0 <Recycle+0xf4>
 8009ac2:	2207      	movs	r2, #7
 8009ac4:	e7ec      	b.n	8009aa0 <Recycle+0xf4>
 8009ac6:	2203      	movs	r2, #3
 8009ac8:	e7ea      	b.n	8009aa0 <Recycle+0xf4>
 8009aca:	2204      	movs	r2, #4
 8009acc:	e7e8      	b.n	8009aa0 <Recycle+0xf4>
 8009ace:	2205      	movs	r2, #5
 8009ad0:	e7e6      	b.n	8009aa0 <Recycle+0xf4>
 8009ad2:	2208      	movs	r2, #8
 8009ad4:	e7e4      	b.n	8009aa0 <Recycle+0xf4>
  FreeRTOSReportFailure(EX_ASAN_FAIL_POISON);
 8009ad6:	2007      	movs	r0, #7
 8009ad8:	f7ff fd0a 	bl	80094f0 <FreeRTOSReportFailure>
 8009adc:	dc000010 	.word	0xdc000010
 8009ae0:	1b8003ff 	.word	0x1b8003ff
 8009ae4:	fffffc00 	.word	0xfffffc00
 8009ae8:	1b800001 	.word	0x1b800001
 8009aec:	24026000 	.word	0x24026000
 8009af0:	24020000 	.word	0x24020000

08009af4 <Deallocate>:
    if (p == 0) return;
 8009af4:	2800      	cmp	r0, #0
 8009af6:	d05d      	beq.n	8009bb4 <Deallocate+0xc0>
{
 8009af8:	b570      	push	{r4, r5, r6, lr}
  if(*state == CHUNK_ALLOCATED)
 8009afa:	f810 1c10 	ldrb.w	r1, [r0, #-16]
 8009afe:	4604      	mov	r4, r0
    uptr chunk_beg = p - kChunkHeaderSize;
 8009b00:	f1a0 0510 	sub.w	r5, r0, #16
  if(*state == CHUNK_ALLOCATED)
 8009b04:	2902      	cmp	r1, #2
 8009b06:	d15a      	bne.n	8009bbe <Deallocate+0xca>
	  *state = CHUNK_QUARANTINE;
 8009b08:	2203      	movs	r2, #3
 8009b0a:	f800 2c10 	strb.w	r2, [r0, #-16]
    if (m->alloc_type != alloc_type) {
 8009b0e:	79ea      	ldrb	r2, [r5, #7]
 8009b10:	f3c2 0241 	ubfx	r2, r2, #1, #2
 8009b14:	429a      	cmp	r2, r3
 8009b16:	d003      	beq.n	8009b20 <Deallocate+0x2c>
      if (alloc_dealloc_mismatch) {
 8009b18:	4b2b      	ldr	r3, [pc, #172]	; (8009bc8 <Deallocate+0xd4>)
 8009b1a:	781b      	ldrb	r3, [r3, #0]
 8009b1c:	2b00      	cmp	r3, #0
 8009b1e:	d14a      	bne.n	8009bb6 <Deallocate+0xc2>
      uptr size_to_fill = m->user_requested_size;
 8009b20:	68aa      	ldr	r2, [r5, #8]
      memset(ptr, McuASAN_FLAG_FREE_FILL_BYTE, size_to_fill);
 8009b22:	2155      	movs	r1, #85	; 0x55
      size_to_fill = Min((size_to_fill), max_free_fill_size);
 8009b24:	4b29      	ldr	r3, [pc, #164]	; (8009bcc <Deallocate+0xd8>)
      memset(ptr, McuASAN_FLAG_FREE_FILL_BYTE, size_to_fill);
 8009b26:	4620      	mov	r0, r4
      uptr size_to_fill = m->user_requested_size;
 8009b28:	f3c2 021c 	ubfx	r2, r2, #0, #29
      size_to_fill = Min((size_to_fill), max_free_fill_size);
 8009b2c:	681b      	ldr	r3, [r3, #0]
      memset(ptr, McuASAN_FLAG_FREE_FILL_BYTE, size_to_fill);
 8009b2e:	429a      	cmp	r2, r3
 8009b30:	bf28      	it	cs
 8009b32:	461a      	movcs	r2, r3
 8009b34:	f00a fbec 	bl	8014310 <memset>
                 RoundUpTo(m->user_requested_size, SHADOW_GRANULARITY),
 8009b38:	68ab      	ldr	r3, [r5, #8]
   if( (addr>= McuASAN_CONFIG_APP_MEM_START) &&
 8009b3a:	f104 425c 	add.w	r2, r4, #3690987520	; 0xdc000000
                 RoundUpTo(m->user_requested_size, SHADOW_GRANULARITY),
 8009b3e:	f3c3 031c 	ubfx	r3, r3, #0, #29
   if( (addr>= McuASAN_CONFIG_APP_MEM_START) &&
 8009b42:	f5b2 2f00 	cmp.w	r2, #524288	; 0x80000
  return (size + boundary - 1) & ~(boundary - 1);
 8009b46:	f103 0307 	add.w	r3, r3, #7
 8009b4a:	f023 0307 	bic.w	r3, r3, #7
   if( (addr>= McuASAN_CONFIG_APP_MEM_START) &&
 8009b4e:	d238      	bcs.n	8009bc2 <Deallocate+0xce>
  return   ((((uint32_t)address)>>3 ) + McuASAN_CONFIG_APP_MEM_OFFSET); /* divided by 8: every byte has a shadow bit */
 8009b50:	08e1      	lsrs	r1, r4, #3
  uptr shadow_end = MEM_TO_SHADOW(
 8009b52:	3c08      	subs	r4, #8
  return (size + boundary - 1) & ~(boundary - 1);
 8009b54:	4a1e      	ldr	r2, [pc, #120]	; (8009bd0 <Deallocate+0xdc>)
  uptr shadow_end = MEM_TO_SHADOW(
 8009b56:	441c      	add	r4, r3
 8009b58:	4b1e      	ldr	r3, [pc, #120]	; (8009bd4 <Deallocate+0xe0>)
  return (size + boundary - 1) & ~(boundary - 1);
 8009b5a:	4e1f      	ldr	r6, [pc, #124]	; (8009bd8 <Deallocate+0xe4>)
 8009b5c:	440a      	add	r2, r1
  uptr shadow_end = MEM_TO_SHADOW(
 8009b5e:	eb03 04d4 	add.w	r4, r3, r4, lsr #3
  return   ((((uint32_t)address)>>3 ) + McuASAN_CONFIG_APP_MEM_OFFSET); /* divided by 8: every byte has a shadow bit */
 8009b62:	f101 50dc 	add.w	r0, r1, #461373440	; 0x1b800000
  return (size + boundary - 1) & ~(boundary - 1);
 8009b66:	4032      	ands	r2, r6
  return x & ~(boundary - 1);
 8009b68:	4026      	ands	r6, r4
    if (page_beg >= page_end) {
 8009b6a:	42b2      	cmp	r2, r6
 8009b6c:	d219      	bcs.n	8009ba2 <Deallocate+0xae>
      if (page_beg != shadow_beg) {
 8009b6e:	4290      	cmp	r0, r2
 8009b70:	d110      	bne.n	8009b94 <Deallocate+0xa0>
      if (page_end != shadow_end) {
 8009b72:	42b4      	cmp	r4, r6
 8009b74:	d104      	bne.n	8009b80 <Deallocate+0x8c>
    Recycle(m);
 8009b76:	4628      	mov	r0, r5
 }
 8009b78:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Recycle(m);
 8009b7c:	f7ff bf16 	b.w	80099ac <Recycle>
        memset((void *)page_end, value, shadow_end - page_end);
 8009b80:	1ba2      	subs	r2, r4, r6
 8009b82:	4630      	mov	r0, r6
 8009b84:	21fd      	movs	r1, #253	; 0xfd
 8009b86:	f00a fbc3 	bl	8014310 <memset>
    Recycle(m);
 8009b8a:	4628      	mov	r0, r5
 }
 8009b8c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Recycle(m);
 8009b90:	f7ff bf0c 	b.w	80099ac <Recycle>
        memset((void *)shadow_beg, value, page_beg - shadow_beg);
 8009b94:	1a12      	subs	r2, r2, r0
 8009b96:	21fd      	movs	r1, #253	; 0xfd
 8009b98:	f00a fbba 	bl	8014310 <memset>
      if (page_end != shadow_end) {
 8009b9c:	42b4      	cmp	r4, r6
 8009b9e:	d0ea      	beq.n	8009b76 <Deallocate+0x82>
 8009ba0:	e7ee      	b.n	8009b80 <Deallocate+0x8c>
      memset((void *)shadow_beg, value, shadow_end - shadow_beg);
 8009ba2:	1a22      	subs	r2, r4, r0
 8009ba4:	21fd      	movs	r1, #253	; 0xfd
 8009ba6:	f00a fbb3 	bl	8014310 <memset>
    Recycle(m);
 8009baa:	4628      	mov	r0, r5
 }
 8009bac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Recycle(m);
 8009bb0:	f7ff befc 	b.w	80099ac <Recycle>
 8009bb4:	4770      	bx	lr
  __asm volatile("push {r0-r3}");
 8009bb6:	b40f      	push	{r0, r1, r2, r3}
  FreeRTOSReportFailure(EX_ASAN_REALLOC_MISMATCH);
 8009bb8:	2006      	movs	r0, #6
 8009bba:	f7ff fc99 	bl	80094f0 <FreeRTOSReportFailure>
	  ReportInvalidFree(ptr, *state);
 8009bbe:	f7ff feed 	bl	800999c <ReportInvalidFree>
  FreeRTOSReportFailure(EX_ASAN_FAIL_POISON);
 8009bc2:	2007      	movs	r0, #7
 8009bc4:	f7ff fc94 	bl	80094f0 <FreeRTOSReportFailure>
 8009bc8:	24008008 	.word	0x24008008
 8009bcc:	2400800c 	.word	0x2400800c
 8009bd0:	1b8003ff 	.word	0x1b8003ff
 8009bd4:	1b800001 	.word	0x1b800001
 8009bd8:	fffffc00 	.word	0xfffffc00

08009bdc <vPortResetPrivilege>:
    if( xRunningPrivileged == pdFALSE )
 8009bdc:	b100      	cbz	r0, 8009be0 <vPortResetPrivilege+0x4>
}
 8009bde:	4770      	bx	lr
        portRESET_PRIVILEGE();
 8009be0:	f000 b856 	b.w	8009c90 <vResetPrivilege>

08009be4 <vPortEnableVFP>:
    __asm volatile
 8009be4:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8009bf4 <vPortEnableVFP+0x10>
 8009be8:	6801      	ldr	r1, [r0, #0]
 8009bea:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8009bee:	6001      	str	r1, [r0, #0]
 8009bf0:	4770      	bx	lr
 8009bf2:	0000      	.short	0x0000
 8009bf4:	e000ed88 	.word	0xe000ed88

08009bf8 <vPortEnterCritical>:
{
 8009bf8:	b508      	push	{r3, lr}
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
 8009bfa:	f7ff fa0b 	bl	8009014 <xPortRaisePrivilege>
 8009bfe:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009c02:	f383 8811 	msr	BASEPRI, r3
 8009c06:	f3bf 8f6f 	isb	sy
 8009c0a:	f3bf 8f4f 	dsb	sy
    uxCriticalNesting++;
 8009c0e:	4a04      	ldr	r2, [pc, #16]	; (8009c20 <vPortEnterCritical+0x28>)
 8009c10:	6813      	ldr	r3, [r2, #0]
 8009c12:	3301      	adds	r3, #1
 8009c14:	6013      	str	r3, [r2, #0]
}
 8009c16:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    vPortResetPrivilege( xRunningPrivileged );
 8009c1a:	f7ff bfdf 	b.w	8009bdc <vPortResetPrivilege>
 8009c1e:	bf00      	nop
 8009c20:	24008014 	.word	0x24008014

08009c24 <vPortExitCritical>:
{
 8009c24:	b508      	push	{r3, lr}
    BaseType_t xRunningPrivileged = xPortRaisePrivilege();
 8009c26:	f7ff f9f5 	bl	8009014 <xPortRaisePrivilege>
    configASSERT( uxCriticalNesting );
 8009c2a:	4a0a      	ldr	r2, [pc, #40]	; (8009c54 <vPortExitCritical+0x30>)
 8009c2c:	6813      	ldr	r3, [r2, #0]
 8009c2e:	b943      	cbnz	r3, 8009c42 <vPortExitCritical+0x1e>
 8009c30:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009c34:	f383 8811 	msr	BASEPRI, r3
 8009c38:	f3bf 8f6f 	isb	sy
 8009c3c:	f3bf 8f4f 	dsb	sy
 8009c40:	e7fe      	b.n	8009c40 <vPortExitCritical+0x1c>
    uxCriticalNesting--;
 8009c42:	3b01      	subs	r3, #1
 8009c44:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
 8009c46:	b90b      	cbnz	r3, 8009c4c <vPortExitCritical+0x28>
    __asm volatile
 8009c48:	f383 8811 	msr	BASEPRI, r3
}
 8009c4c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    vPortResetPrivilege( xRunningPrivileged );
 8009c50:	f7ff bfc4 	b.w	8009bdc <vPortResetPrivilege>
 8009c54:	24008014 	.word	0x24008014

08009c58 <vPortSetupTimerInterrupt>:
    portNVIC_SYSTICK_CTRL_REG = 0UL;
 8009c58:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
 8009c5c:	2100      	movs	r1, #0
    portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8009c5e:	4b06      	ldr	r3, [pc, #24]	; (8009c78 <vPortSetupTimerInterrupt+0x20>)
    portNVIC_SYSTICK_CTRL_REG = 0UL;
 8009c60:	6111      	str	r1, [r2, #16]
    portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8009c62:	4806      	ldr	r0, [pc, #24]	; (8009c7c <vPortSetupTimerInterrupt+0x24>)
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8009c64:	6191      	str	r1, [r2, #24]
    portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE );
 8009c66:	2107      	movs	r1, #7
    portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8009c68:	681b      	ldr	r3, [r3, #0]
 8009c6a:	fba0 0303 	umull	r0, r3, r0, r3
 8009c6e:	099b      	lsrs	r3, r3, #6
 8009c70:	3b01      	subs	r3, #1
 8009c72:	6153      	str	r3, [r2, #20]
    portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE );
 8009c74:	6111      	str	r1, [r2, #16]
}
 8009c76:	4770      	bx	lr
 8009c78:	24008000 	.word	0x24008000
 8009c7c:	10624dd3 	.word	0x10624dd3

08009c80 <xIsPrivileged>:
    __asm volatile
 8009c80:	f3ef 8014 	mrs	r0, CONTROL
 8009c84:	f010 0f01 	tst.w	r0, #1
 8009c88:	bf14      	ite	ne
 8009c8a:	2000      	movne	r0, #0
 8009c8c:	2001      	moveq	r0, #1
 8009c8e:	4770      	bx	lr

08009c90 <vResetPrivilege>:
    __asm volatile
 8009c90:	f3ef 8014 	mrs	r0, CONTROL
 8009c94:	f040 0001 	orr.w	r0, r0, #1
 8009c98:	f380 8814 	msr	CONTROL, r0
 8009c9c:	4770      	bx	lr
 8009c9e:	bf00      	nop

08009ca0 <vPortValidateInterruptPriority>:
    {
        uint32_t ulCurrentInterrupt;
        uint8_t ucCurrentPriority;

        /* Obtain the number of the currently executing interrupt. */
        __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 8009ca0:	f3ef 8305 	mrs	r3, IPSR

        /* Is the interrupt number a user defined interrupt? */
        if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8009ca4:	2b0f      	cmp	r3, #15
 8009ca6:	d90e      	bls.n	8009cc6 <vPortValidateInterruptPriority+0x26>
        {
            /* Look up the interrupt's priority. */
            ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8009ca8:	4911      	ldr	r1, [pc, #68]	; (8009cf0 <vPortValidateInterruptPriority+0x50>)
             * interrupt entry is as fast and simple as possible.
             *
             * The following links provide detailed information:
             * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html
             * https://www.FreeRTOS.org/FAQHelp.html */
            configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8009caa:	4a12      	ldr	r2, [pc, #72]	; (8009cf4 <vPortValidateInterruptPriority+0x54>)
            ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8009cac:	5c5b      	ldrb	r3, [r3, r1]
            configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8009cae:	7812      	ldrb	r2, [r2, #0]
 8009cb0:	429a      	cmp	r2, r3
 8009cb2:	d908      	bls.n	8009cc6 <vPortValidateInterruptPriority+0x26>
    __asm volatile
 8009cb4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009cb8:	f383 8811 	msr	BASEPRI, r3
 8009cbc:	f3bf 8f6f 	isb	sy
 8009cc0:	f3bf 8f4f 	dsb	sy
 8009cc4:	e7fe      	b.n	8009cc4 <vPortValidateInterruptPriority+0x24>
         * configuration then the correct setting can be achieved on all Cortex-M
         * devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
         * scheduler.  Note however that some vendor specific peripheral libraries
         * assume a non-zero priority group setting, in which cases using a value
         * of zero will result in unpredicable behaviour. */
        configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8009cc6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8009cca:	4a0b      	ldr	r2, [pc, #44]	; (8009cf8 <vPortValidateInterruptPriority+0x58>)
 8009ccc:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	; 0xd0c
 8009cd0:	6812      	ldr	r2, [r2, #0]
 8009cd2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8009cd6:	4293      	cmp	r3, r2
 8009cd8:	d908      	bls.n	8009cec <vPortValidateInterruptPriority+0x4c>
 8009cda:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009cde:	f383 8811 	msr	BASEPRI, r3
 8009ce2:	f3bf 8f6f 	isb	sy
 8009ce6:	f3bf 8f4f 	dsb	sy
 8009cea:	e7fe      	b.n	8009cea <vPortValidateInterruptPriority+0x4a>
    }
 8009cec:	4770      	bx	lr
 8009cee:	bf00      	nop
 8009cf0:	e000e3f0 	.word	0xe000e3f0
 8009cf4:	2401001d 	.word	0x2401001d
 8009cf8:	24010020 	.word	0x24010020

08009cfc <__sanitizer_cov_trace_pc>:

	uint16_t guard;

	guard =  (uint16_t) (R14 & AFL_BITMAP_MASK);

	uint16_t bitmapindex = (uint16_t)( guard^AFLfuzzer.previousGuard);
 8009cfc:	4b15      	ldr	r3, [pc, #84]	; (8009d54 <__sanitizer_cov_trace_pc+0x58>)
 8009cfe:	f503 40c0 	add.w	r0, r3, #24576	; 0x6000
{
 8009d02:	b500      	push	{lr}
	uint16_t bitmapindex = (uint16_t)( guard^AFLfuzzer.previousGuard);
 8009d04:	f8b0 2858 	ldrh.w	r2, [r0, #2136]	; 0x858
	guard =  (uint16_t) (R14 & AFL_BITMAP_MASK);
 8009d08:	f3ce 0e0c 	ubfx	lr, lr, #0, #13
	uint16_t bitmapindex = (uint16_t)( guard^AFLfuzzer.previousGuard);
 8009d0c:	ea8e 0202 	eor.w	r2, lr, r2
	bitmapindex &=AFL_BITMAP_MASK;
 8009d10:	f3c2 020c 	ubfx	r2, r2, #0, #13

	if(!paflbitmap[bitmapindex])
 8009d14:	f833 1012 	ldrh.w	r1, [r3, r2, lsl #1]
 8009d18:	b969      	cbnz	r1, 8009d36 <__sanitizer_cov_trace_pc+0x3a>
	{
		  AFLfuzzer.indexdif++; // since we need to start the index in 1 the first tuple is empty,
 8009d1a:	f8b0 1862 	ldrh.w	r1, [r0, #2146]	; 0x862
 8009d1e:	3101      	adds	r1, #1
 8009d20:	b289      	uxth	r1, r1
 8009d22:	f8a0 1862 	strh.w	r1, [r0, #2146]	; 0x862
		              // we will correct the pointer
		  	  	  	  // when sending the data to the PC
		  paflbitmap[bitmapindex] =  AFLfuzzer.indexdif;
 8009d26:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
		  AFLfuzzer.afldiff[AFLfuzzer.indexdif].index = bitmapindex;
 8009d2a:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
 8009d2e:	f823 2021 	strh.w	r2, [r3, r1, lsl #2]

	 }
	 AFLfuzzer.afldiff[paflbitmap[bitmapindex]].val = (AFLfuzzer.afldiff[paflbitmap[bitmapindex]].val + 1) & 0xff;
 8009d32:	f833 1012 	ldrh.w	r1, [r3, r2, lsl #1]
 8009d36:	f501 5180 	add.w	r1, r1, #4096	; 0x1000

	 AFLfuzzer.previousGuard = guard>>1;
 8009d3a:	ea4f 0e5e 	mov.w	lr, lr, lsr #1
	 AFLfuzzer.afldiff[paflbitmap[bitmapindex]].val = (AFLfuzzer.afldiff[paflbitmap[bitmapindex]].val + 1) & 0xff;
 8009d3e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	 AFLfuzzer.previousGuard = guard>>1;
 8009d42:	f8a0 e858 	strh.w	lr, [r0, #2136]	; 0x858
	 AFLfuzzer.afldiff[paflbitmap[bitmapindex]].val = (AFLfuzzer.afldiff[paflbitmap[bitmapindex]].val + 1) & 0xff;
 8009d46:	885a      	ldrh	r2, [r3, #2]
 8009d48:	3201      	adds	r2, #1
 8009d4a:	b2d2      	uxtb	r2, r2
 8009d4c:	805a      	strh	r2, [r3, #2]



}
 8009d4e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009d52:	bf00      	nop
 8009d54:	24020000 	.word	0x24020000

08009d58 <app_main>:

/* Demo includes. */
#include "mpu_demo.h"

void app_main( void )
{
 8009d58:	b508      	push	{r3, lr}
	/* Start the MPU demo. */
	vStartMPUDemo();
 8009d5a:	f008 fef1 	bl	8012b40 <vStartMPUDemo>


	/* Start the scheduler. */
	vTaskStartScheduler();
 8009d5e:	f7f9 fb75 	bl	800344c <vTaskStartScheduler>

	/* Should not get here. */
	for( ;; );
 8009d62:	e7fe      	b.n	8009d62 <app_main+0xa>

08009d64 <vApplicationStackOverflowHook>:
{
	/* If configCHECK_FOR_STACK_OVERFLOW is set to either 1 or 2 then this
	function will automatically get called if a task overflows its stack. */
	( void ) pxTask;
	( void ) pcTaskName;
	for( ;; );
 8009d64:	e7fe      	b.n	8009d64 <vApplicationStackOverflowHook>
 8009d66:	bf00      	nop

08009d68 <vApplicationMallocFailedHook>:
void vApplicationMallocFailedHook( void )
{
	/* If configUSE_MALLOC_FAILED_HOOK is set to 1 then this function will
	be called automatically if a call to pvPortMalloc() fails.  pvPortMalloc()
	is called automatically when a task, queue or semaphore is created. */
	for( ;; );
 8009d68:	e7fe      	b.n	8009d68 <vApplicationMallocFailedHook>
 8009d6a:	bf00      	nop

08009d6c <vApplicationGetIdleTaskMemory>:
static StaticTask_t xIdleTaskTCB;
static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

	/* Pass out a pointer to the StaticTask_t structure in which the Idle task's
	state will be stored. */
	*ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
 8009d6c:	4b05      	ldr	r3, [pc, #20]	; (8009d84 <vApplicationGetIdleTaskMemory+0x18>)
{
 8009d6e:	b410      	push	{r4}
	*ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
 8009d70:	6003      	str	r3, [r0, #0]
	*ppxIdleTaskStackBuffer = uxIdleTaskStack;

	/* Pass out the size of the array pointed to by *ppxIdleTaskStackBuffer.
	Note that, as the array is necessarily of type StackType_t,
	configMINIMAL_STACK_SIZE is specified in words, not bytes. */
	*pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
 8009d72:	f44f 6380 	mov.w	r3, #1024	; 0x400
	*ppxIdleTaskStackBuffer = uxIdleTaskStack;
 8009d76:	4c04      	ldr	r4, [pc, #16]	; (8009d88 <vApplicationGetIdleTaskMemory+0x1c>)
 8009d78:	600c      	str	r4, [r1, #0]
}
 8009d7a:	f85d 4b04 	ldr.w	r4, [sp], #4
	*pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
 8009d7e:	6013      	str	r3, [r2, #0]
}
 8009d80:	4770      	bx	lr
 8009d82:	bf00      	nop
 8009d84:	24011424 	.word	0x24011424
 8009d88:	24010024 	.word	0x24010024

08009d8c <vApplicationGetTimerTaskMemory>:
static StaticTask_t xTimerTaskTCB;
static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

	/* Pass out a pointer to the StaticTask_t structure in which the Timer
	task's state will be stored. */
	*ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
 8009d8c:	4b05      	ldr	r3, [pc, #20]	; (8009da4 <vApplicationGetTimerTaskMemory+0x18>)
{
 8009d8e:	b410      	push	{r4}
	*ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
 8009d90:	6003      	str	r3, [r0, #0]
	*ppxTimerTaskStackBuffer = uxTimerTaskStack;

	/* Pass out the size of the array pointed to by *ppxTimerTaskStackBuffer.
	Note that, as the array is necessarily of type StackType_t,
	configMINIMAL_STACK_SIZE is specified in words, not bytes. */
	*pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
 8009d92:	f44f 7380 	mov.w	r3, #256	; 0x100
	*ppxTimerTaskStackBuffer = uxTimerTaskStack;
 8009d96:	4c04      	ldr	r4, [pc, #16]	; (8009da8 <vApplicationGetTimerTaskMemory+0x1c>)
 8009d98:	600c      	str	r4, [r1, #0]
}
 8009d9a:	f85d 4b04 	ldr.w	r4, [sp], #4
	*pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
 8009d9e:	6013      	str	r3, [r2, #0]
}
 8009da0:	4770      	bx	lr
 8009da2:	bf00      	nop
 8009da4:	24011568 	.word	0x24011568
 8009da8:	24011024 	.word	0x24011024

08009dac <vHandleMemoryFault>:

}


portDONT_DISCARD void vHandleMemoryFault( uint32_t * pulFaultStackAddress )
{
 8009dac:	b570      	push	{r4, r5, r6, lr}

Fuzzer_t *pAFLfuzzer = (Fuzzer_t *)AFLfuzzerRegion;


  if(xTaskGetCurrentTaskHandle() == AFLfuzzer.xTaskTarget )
 8009dae:	4d13      	ldr	r5, [pc, #76]	; (8009dfc <vHandleMemoryFault+0x50>)
{
 8009db0:	b084      	sub	sp, #16
 8009db2:	4604      	mov	r4, r0
  if(xTaskGetCurrentTaskHandle() == AFLfuzzer.xTaskTarget )
 8009db4:	f7fe fb9e 	bl	80084f4 <MPU_xTaskGetCurrentTaskHandle>
 8009db8:	f8d5 3870 	ldr.w	r3, [r5, #2160]	; 0x870
 8009dbc:	4283      	cmp	r3, r0
 8009dbe:	d000      	beq.n	8009dc2 <vHandleMemoryFault+0x16>

  }
  else
  {
	  //printf("Fuzzer crashed at PC: %x\n", (unsigned int)pulFaultStackAddress[ 6 ]);
	  for( ; ; )
 8009dc0:	e7fe      	b.n	8009dc0 <vHandleMemoryFault+0x14>
	  AFLfuzzer.PCcrash = pulFaultStackAddress[ 6 ] ;
 8009dc2:	69a1      	ldr	r1, [r4, #24]
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 8009dc4:	2600      	movs	r6, #0
    xTaskNotifyFromISR(AFLfuzzer.xTaskFuzzer,FAULT_CRASH,eSetValueWithOverwrite, &xHigherPriorityTaskWoken);
 8009dc6:	ab03      	add	r3, sp, #12
	  AFLfuzzer.xTypeEx = EX_MPU_VIOLATION;
 8009dc8:	2208      	movs	r2, #8
	  AFLfuzzer.PCcrash = pulFaultStackAddress[ 6 ] ;
 8009dca:	f8c5 1868 	str.w	r1, [r5, #2152]	; 0x868
    xTaskNotifyFromISR(AFLfuzzer.xTaskFuzzer,FAULT_CRASH,eSetValueWithOverwrite, &xHigherPriorityTaskWoken);
 8009dce:	4631      	mov	r1, r6
 8009dd0:	9301      	str	r3, [sp, #4]
 8009dd2:	2303      	movs	r3, #3
	  AFLfuzzer.xTypeEx = EX_MPU_VIOLATION;
 8009dd4:	f885 2874 	strb.w	r2, [r5, #2164]	; 0x874
    xTaskNotifyFromISR(AFLfuzzer.xTaskFuzzer,FAULT_CRASH,eSetValueWithOverwrite, &xHigherPriorityTaskWoken);
 8009dd8:	2202      	movs	r2, #2
 8009dda:	f8d5 086c 	ldr.w	r0, [r5, #2156]	; 0x86c
 8009dde:	9600      	str	r6, [sp, #0]
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 8009de0:	9603      	str	r6, [sp, #12]
    xTaskNotifyFromISR(AFLfuzzer.xTaskFuzzer,FAULT_CRASH,eSetValueWithOverwrite, &xHigherPriorityTaskWoken);
 8009de2:	f7f9 fcb9 	bl	8003758 <xTaskGenericNotifyFromISR>
	HAL_GPIO_WritePin(LD1_GPIO_Port, LD1_Pin, GPIO_PIN_RESET);
 8009de6:	4632      	mov	r2, r6
 8009de8:	2101      	movs	r1, #1
 8009dea:	4805      	ldr	r0, [pc, #20]	; (8009e00 <vHandleMemoryFault+0x54>)
 8009dec:	f002 ff0e 	bl	800cc0c <HAL_GPIO_WritePin>
	vTaskDelete(AFLfuzzer.xTaskTarget);
 8009df0:	f8d5 0870 	ldr.w	r0, [r5, #2160]	; 0x870
 8009df4:	f7fe f9a0 	bl	8008138 <MPU_vTaskDelete>
	  }

  }


}
 8009df8:	b004      	add	sp, #16
 8009dfa:	bd70      	pop	{r4, r5, r6, pc}
 8009dfc:	24026000 	.word	0x24026000
 8009e00:	58020400 	.word	0x58020400

08009e04 <vNMI_Handler>:
 8009e04:	b570      	push	{r4, r5, r6, lr}
 8009e06:	4d13      	ldr	r5, [pc, #76]	; (8009e54 <vNMI_Handler+0x50>)
 8009e08:	b084      	sub	sp, #16
 8009e0a:	4604      	mov	r4, r0
 8009e0c:	f7fe fb72 	bl	80084f4 <MPU_xTaskGetCurrentTaskHandle>
 8009e10:	f8d5 3870 	ldr.w	r3, [r5, #2160]	; 0x870
 8009e14:	4283      	cmp	r3, r0
 8009e16:	d000      	beq.n	8009e1a <vNMI_Handler+0x16>
 8009e18:	e7fe      	b.n	8009e18 <vNMI_Handler+0x14>
 8009e1a:	69a1      	ldr	r1, [r4, #24]
 8009e1c:	2600      	movs	r6, #0
 8009e1e:	ab03      	add	r3, sp, #12
 8009e20:	2208      	movs	r2, #8
 8009e22:	f8c5 1868 	str.w	r1, [r5, #2152]	; 0x868
 8009e26:	4631      	mov	r1, r6
 8009e28:	9301      	str	r3, [sp, #4]
 8009e2a:	2303      	movs	r3, #3
 8009e2c:	f885 2874 	strb.w	r2, [r5, #2164]	; 0x874
 8009e30:	2202      	movs	r2, #2
 8009e32:	f8d5 086c 	ldr.w	r0, [r5, #2156]	; 0x86c
 8009e36:	9600      	str	r6, [sp, #0]
 8009e38:	9603      	str	r6, [sp, #12]
 8009e3a:	f7f9 fc8d 	bl	8003758 <xTaskGenericNotifyFromISR>
 8009e3e:	4632      	mov	r2, r6
 8009e40:	2101      	movs	r1, #1
 8009e42:	4805      	ldr	r0, [pc, #20]	; (8009e58 <vNMI_Handler+0x54>)
 8009e44:	f002 fee2 	bl	800cc0c <HAL_GPIO_WritePin>
 8009e48:	f8d5 0870 	ldr.w	r0, [r5, #2160]	; 0x870
 8009e4c:	f7fe f974 	bl	8008138 <MPU_vTaskDelete>
 8009e50:	b004      	add	sp, #16
 8009e52:	bd70      	pop	{r4, r5, r6, pc}
 8009e54:	24026000 	.word	0x24026000
 8009e58:	58020400 	.word	0x58020400

08009e5c <vHardFault_Handler>:

}


portDONT_DISCARD void vHardFault_Handler( uint32_t * pulFaultStackAddress )
{
 8009e5c:	b508      	push	{r3, lr}

Fuzzer_t *pAFLfuzzer = (Fuzzer_t *)AFLfuzzerRegion;

  //this exception is not recoverable
  if(xTaskGetCurrentTaskHandle() == AFLfuzzer.xTaskTarget )
 8009e5e:	f7fe fb49 	bl	80084f4 <MPU_xTaskGetCurrentTaskHandle>
 8009e62:	4b03      	ldr	r3, [pc, #12]	; (8009e70 <vHardFault_Handler+0x14>)
 8009e64:	f8d3 3870 	ldr.w	r3, [r3, #2160]	; 0x870
 8009e68:	4283      	cmp	r3, r0
 8009e6a:	d000      	beq.n	8009e6e <vHardFault_Handler+0x12>
	  }

  }


}
 8009e6c:	bd08      	pop	{r3, pc}
	  for( ; ; )
 8009e6e:	e7fe      	b.n	8009e6e <vHardFault_Handler+0x12>
 8009e70:	24026000 	.word	0x24026000

08009e74 <vBusFault_Handler>:


portDONT_DISCARD void vBusFault_Handler( uint32_t * pulFaultStackAddress )
{
 8009e74:	b570      	push	{r4, r5, r6, lr}

Fuzzer_t *pAFLfuzzer = (Fuzzer_t *)AFLfuzzerRegion;



  if(xTaskGetCurrentTaskHandle() == AFLfuzzer.xTaskTarget )
 8009e76:	4d13      	ldr	r5, [pc, #76]	; (8009ec4 <vBusFault_Handler+0x50>)
{
 8009e78:	b084      	sub	sp, #16
 8009e7a:	4604      	mov	r4, r0
  if(xTaskGetCurrentTaskHandle() == AFLfuzzer.xTaskTarget )
 8009e7c:	f7fe fb3a 	bl	80084f4 <MPU_xTaskGetCurrentTaskHandle>
 8009e80:	f8d5 3870 	ldr.w	r3, [r5, #2160]	; 0x870
 8009e84:	4283      	cmp	r3, r0
 8009e86:	d000      	beq.n	8009e8a <vBusFault_Handler+0x16>
	  deleteTask();
  }
  else
  {
	  //printf("Fuzzer crashed at PC: %x\n", (unsigned int)pulFaultStackAddress[ 6 ]);
	  for( ; ; )
 8009e88:	e7fe      	b.n	8009e88 <vBusFault_Handler+0x14>
	  AFLfuzzer.PCcrash = pulFaultStackAddress[ 6 ] ;
 8009e8a:	69a1      	ldr	r1, [r4, #24]
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 8009e8c:	2600      	movs	r6, #0
    xTaskNotifyFromISR(AFLfuzzer.xTaskFuzzer,FAULT_CRASH,eSetValueWithOverwrite, &xHigherPriorityTaskWoken);
 8009e8e:	ab03      	add	r3, sp, #12
	  AFLfuzzer.xTypeEx = EX_CORTEX_BUS_FAULT;
 8009e90:	220b      	movs	r2, #11
	  AFLfuzzer.PCcrash = pulFaultStackAddress[ 6 ] ;
 8009e92:	f8c5 1868 	str.w	r1, [r5, #2152]	; 0x868
    xTaskNotifyFromISR(AFLfuzzer.xTaskFuzzer,FAULT_CRASH,eSetValueWithOverwrite, &xHigherPriorityTaskWoken);
 8009e96:	4631      	mov	r1, r6
 8009e98:	9301      	str	r3, [sp, #4]
 8009e9a:	2303      	movs	r3, #3
	  AFLfuzzer.xTypeEx = EX_CORTEX_BUS_FAULT;
 8009e9c:	f885 2874 	strb.w	r2, [r5, #2164]	; 0x874
    xTaskNotifyFromISR(AFLfuzzer.xTaskFuzzer,FAULT_CRASH,eSetValueWithOverwrite, &xHigherPriorityTaskWoken);
 8009ea0:	2202      	movs	r2, #2
 8009ea2:	f8d5 086c 	ldr.w	r0, [r5, #2156]	; 0x86c
 8009ea6:	9600      	str	r6, [sp, #0]
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 8009ea8:	9603      	str	r6, [sp, #12]
    xTaskNotifyFromISR(AFLfuzzer.xTaskFuzzer,FAULT_CRASH,eSetValueWithOverwrite, &xHigherPriorityTaskWoken);
 8009eaa:	f7f9 fc55 	bl	8003758 <xTaskGenericNotifyFromISR>
	HAL_GPIO_WritePin(LD1_GPIO_Port, LD1_Pin, GPIO_PIN_RESET);
 8009eae:	4632      	mov	r2, r6
 8009eb0:	2101      	movs	r1, #1
 8009eb2:	4805      	ldr	r0, [pc, #20]	; (8009ec8 <vBusFault_Handler+0x54>)
 8009eb4:	f002 feaa 	bl	800cc0c <HAL_GPIO_WritePin>
	vTaskDelete(AFLfuzzer.xTaskTarget);
 8009eb8:	f8d5 0870 	ldr.w	r0, [r5, #2160]	; 0x870
 8009ebc:	f7fe f93c 	bl	8008138 <MPU_vTaskDelete>
	  }

  }


}
 8009ec0:	b004      	add	sp, #16
 8009ec2:	bd70      	pop	{r4, r5, r6, pc}
 8009ec4:	24026000 	.word	0x24026000
 8009ec8:	58020400 	.word	0x58020400

08009ecc <vUsageFault_Handler>:

portDONT_DISCARD void vUsageFault_Handler( uint32_t * pulFaultStackAddress )
{
 8009ecc:	b530      	push	{r4, r5, lr}

Fuzzer_t *pAFLfuzzer = (Fuzzer_t *)AFLfuzzerRegion;


  if(xTaskGetCurrentTaskHandle() == AFLfuzzer.xTaskTarget )
 8009ece:	4c22      	ldr	r4, [pc, #136]	; (8009f58 <vUsageFault_Handler+0x8c>)
{
 8009ed0:	b085      	sub	sp, #20
 8009ed2:	4605      	mov	r5, r0
  if(xTaskGetCurrentTaskHandle() == AFLfuzzer.xTaskTarget )
 8009ed4:	f7fe fb0e 	bl	80084f4 <MPU_xTaskGetCurrentTaskHandle>
 8009ed8:	f8d4 3870 	ldr.w	r3, [r4, #2160]	; 0x870
 8009edc:	4283      	cmp	r3, r0
 8009ede:	d000      	beq.n	8009ee2 <vUsageFault_Handler+0x16>

  }
  else
  {
	  //printf("Fuzzer crashed at PC: %x\n", (unsigned int)pulFaultStackAddress[ 6 ]);
	  for( ; ; )
 8009ee0:	e7fe      	b.n	8009ee0 <vUsageFault_Handler+0x14>
	  if(SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk)
 8009ee2:	4b1e      	ldr	r3, [pc, #120]	; (8009f5c <vUsageFault_Handler+0x90>)
	  AFLfuzzer.PCcrash = pulFaultStackAddress[ 6 ] ;
 8009ee4:	69a9      	ldr	r1, [r5, #24]
	  if(SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk)
 8009ee6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	  AFLfuzzer.PCcrash = pulFaultStackAddress[ 6 ] ;
 8009ee8:	f8c4 1868 	str.w	r1, [r4, #2152]	; 0x868
	  if(SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk)
 8009eec:	0190      	lsls	r0, r2, #6
 8009eee:	d506      	bpl.n	8009efe <vUsageFault_Handler+0x32>
		  SCB->CFSR |= SCB_CFSR_DIVBYZERO_Msk; //to clean the bit we need to write 1
 8009ef0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	      AFLfuzzer.xTypeEx = EX_CORTEX_DIV0;
 8009ef2:	2109      	movs	r1, #9
		  SCB->CFSR |= SCB_CFSR_DIVBYZERO_Msk; //to clean the bit we need to write 1
 8009ef4:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
	      AFLfuzzer.xTypeEx = EX_CORTEX_DIV0;
 8009ef8:	f884 1874 	strb.w	r1, [r4, #2164]	; 0x874
		  SCB->CFSR |= SCB_CFSR_DIVBYZERO_Msk; //to clean the bit we need to write 1
 8009efc:	629a      	str	r2, [r3, #40]	; 0x28
	  if(SCB->CFSR & SCB_CFSR_UNALIGNED_Msk)
 8009efe:	4b17      	ldr	r3, [pc, #92]	; (8009f5c <vUsageFault_Handler+0x90>)
 8009f00:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8009f02:	01d1      	lsls	r1, r2, #7
 8009f04:	d506      	bpl.n	8009f14 <vUsageFault_Handler+0x48>
          SCB->CFSR |= SCB_CFSR_UNALIGNED_Msk;
 8009f06:	6a9a      	ldr	r2, [r3, #40]	; 0x28
          AFLfuzzer.xTypeEx = EX_CORTEX_UNA_ACCESS;
 8009f08:	210a      	movs	r1, #10
          SCB->CFSR |= SCB_CFSR_UNALIGNED_Msk;
 8009f0a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
          AFLfuzzer.xTypeEx = EX_CORTEX_UNA_ACCESS;
 8009f0e:	f884 1874 	strb.w	r1, [r4, #2164]	; 0x874
          SCB->CFSR |= SCB_CFSR_UNALIGNED_Msk;
 8009f12:	629a      	str	r2, [r3, #40]	; 0x28
	  if(SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk)
 8009f14:	4b11      	ldr	r3, [pc, #68]	; (8009f5c <vUsageFault_Handler+0x90>)
 8009f16:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8009f18:	03d2      	lsls	r2, r2, #15
 8009f1a:	d506      	bpl.n	8009f2a <vUsageFault_Handler+0x5e>
		  SCB->CFSR |= SCB_CFSR_UNDEFINSTR_Msk;
 8009f1c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		  AFLfuzzer.xTypeEx = EX_CORTEX_UNDEF_INST;
 8009f1e:	210c      	movs	r1, #12
		  SCB->CFSR |= SCB_CFSR_UNDEFINSTR_Msk;
 8009f20:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
		  AFLfuzzer.xTypeEx = EX_CORTEX_UNDEF_INST;
 8009f24:	f884 1874 	strb.w	r1, [r4, #2164]	; 0x874
		  SCB->CFSR |= SCB_CFSR_UNDEFINSTR_Msk;
 8009f28:	629a      	str	r2, [r3, #40]	; 0x28
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 8009f2a:	2500      	movs	r5, #0
    xTaskNotifyFromISR(AFLfuzzer.xTaskFuzzer,FAULT_CRASH,eSetValueWithOverwrite, &xHigherPriorityTaskWoken);
 8009f2c:	a903      	add	r1, sp, #12
 8009f2e:	2303      	movs	r3, #3
 8009f30:	2202      	movs	r2, #2
 8009f32:	f8d4 086c 	ldr.w	r0, [r4, #2156]	; 0x86c
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 8009f36:	9503      	str	r5, [sp, #12]
    xTaskNotifyFromISR(AFLfuzzer.xTaskFuzzer,FAULT_CRASH,eSetValueWithOverwrite, &xHigherPriorityTaskWoken);
 8009f38:	e9cd 5100 	strd	r5, r1, [sp]
 8009f3c:	4629      	mov	r1, r5
 8009f3e:	f7f9 fc0b 	bl	8003758 <xTaskGenericNotifyFromISR>
	HAL_GPIO_WritePin(LD1_GPIO_Port, LD1_Pin, GPIO_PIN_RESET);
 8009f42:	462a      	mov	r2, r5
 8009f44:	2101      	movs	r1, #1
 8009f46:	4806      	ldr	r0, [pc, #24]	; (8009f60 <vUsageFault_Handler+0x94>)
 8009f48:	f002 fe60 	bl	800cc0c <HAL_GPIO_WritePin>
	vTaskDelete(AFLfuzzer.xTaskTarget);
 8009f4c:	f8d4 0870 	ldr.w	r0, [r4, #2160]	; 0x870
 8009f50:	f7fe f8f2 	bl	8008138 <MPU_vTaskDelete>
	  }

  }


}
 8009f54:	b005      	add	sp, #20
 8009f56:	bd30      	pop	{r4, r5, pc}
 8009f58:	24026000 	.word	0x24026000
 8009f5c:	e000ed00 	.word	0xe000ed00
 8009f60:	58020400 	.word	0x58020400

08009f64 <MemManage_Handler>:
void MemManage_Handler( void ) __attribute__ (( naked ));
/*-----------------------------------------------------------*/

void MemManage_Handler( void )
{
	__asm volatile
 8009f64:	f01e 0f04 	tst.w	lr, #4
 8009f68:	bf0c      	ite	eq
 8009f6a:	f3ef 8008 	mrseq	r0, MSP
 8009f6e:	f3ef 8009 	mrsne	r0, PSP
 8009f72:	f04f 0200 	mov.w	r2, #0
 8009f76:	f382 8814 	msr	CONTROL, r2
 8009f7a:	f8df 1004 	ldr.w	r1, [pc, #4]	; 8009f80 <handler_address_const>
 8009f7e:	4708      	bx	r1

08009f80 <handler_address_const>:
 8009f80:	08009dad 	.word	0x08009dad

08009f84 <NMI_Handler>:
  */
void NMI_Handler( void ) __attribute__ (( naked ));
void NMI_Handler(void)
{

		__asm volatile
 8009f84:	f01e 0f04 	tst.w	lr, #4
 8009f88:	bf0c      	ite	eq
 8009f8a:	f3ef 8008 	mrseq	r0, MSP
 8009f8e:	f3ef 8009 	mrsne	r0, PSP
 8009f92:	f04f 0200 	mov.w	r2, #0
 8009f96:	f382 8814 	msr	CONTROL, r2
 8009f9a:	f8df 1004 	ldr.w	r1, [pc, #4]	; 8009fa0 <handler_address_const1>
 8009f9e:	4708      	bx	r1

08009fa0 <handler_address_const1>:
 8009fa0:	08009e05 	.word	0x08009e05

08009fa4 <HardFault_Handler>:
  */
void HardFault_Handler( void ) __attribute__ (( naked ));
void HardFault_Handler(void)
{

		__asm volatile
 8009fa4:	f01e 0f04 	tst.w	lr, #4
 8009fa8:	bf0c      	ite	eq
 8009faa:	f3ef 8008 	mrseq	r0, MSP
 8009fae:	f3ef 8009 	mrsne	r0, PSP
 8009fb2:	f04f 0200 	mov.w	r2, #0
 8009fb6:	f382 8814 	msr	CONTROL, r2
 8009fba:	f8df 1004 	ldr.w	r1, [pc, #4]	; 8009fc0 <handler_address_const2>
 8009fbe:	4708      	bx	r1

08009fc0 <handler_address_const2>:
 8009fc0:	08009e5d 	.word	0x08009e5d

08009fc4 <BusFault_Handler>:
  */
void BusFault_Handler( void ) __attribute__ (( naked ));
void BusFault_Handler(void)
{

		__asm volatile
 8009fc4:	f01e 0f04 	tst.w	lr, #4
 8009fc8:	bf0c      	ite	eq
 8009fca:	f3ef 8008 	mrseq	r0, MSP
 8009fce:	f3ef 8009 	mrsne	r0, PSP
 8009fd2:	f04f 0200 	mov.w	r2, #0
 8009fd6:	f382 8814 	msr	CONTROL, r2
 8009fda:	f8df 1004 	ldr.w	r1, [pc, #4]	; 8009fe0 <handler_address_const3>
 8009fde:	4708      	bx	r1

08009fe0 <handler_address_const3>:
 8009fe0:	08009e75 	.word	0x08009e75

08009fe4 <UsageFault_Handler>:
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler( void ) __attribute__ (( naked ));
void UsageFault_Handler(void)
{
		__asm volatile
 8009fe4:	f01e 0f04 	tst.w	lr, #4
 8009fe8:	bf0c      	ite	eq
 8009fea:	f3ef 8008 	mrseq	r0, MSP
 8009fee:	f3ef 8009 	mrsne	r0, PSP
 8009ff2:	f04f 0200 	mov.w	r2, #0
 8009ff6:	f382 8814 	msr	CONTROL, r2
 8009ffa:	f8df 1004 	ldr.w	r1, [pc, #4]	; 800a000 <handler_address_const5>
 8009ffe:	4708      	bx	r1

0800a000 <handler_address_const5>:
 800a000:	08009ecd 	.word	0x08009ecd

0800a004 <FuzzingInputHandler>:
}



void FuzzingInputHandler(uint8_t* Buf, uint32_t *Len)
{
 800a004:	b530      	push	{r4, r5, lr}
	  uint8_t error;


	  error = 0;

	  if( (AFLfuzzer.inputLength != 0 && AFLfuzzer.inputLengthpadded == 0) ||
 800a006:	4c4b      	ldr	r4, [pc, #300]	; (800a134 <FuzzingInputHandler+0x130>)
	  xHigherPriorityTaskWoken = pdFALSE;
 800a008:	2300      	movs	r3, #0
{
 800a00a:	b085      	sub	sp, #20
	  if( (AFLfuzzer.inputLength != 0 && AFLfuzzer.inputLengthpadded == 0) ||
 800a00c:	f8d4 2824 	ldr.w	r2, [r4, #2084]	; 0x824
	  xHigherPriorityTaskWoken = pdFALSE;
 800a010:	9303      	str	r3, [sp, #12]
	  if( (AFLfuzzer.inputLength != 0 && AFLfuzzer.inputLengthpadded == 0) ||
 800a012:	f8d4 3828 	ldr.w	r3, [r4, #2088]	; 0x828
 800a016:	2a00      	cmp	r2, #0
 800a018:	d165      	bne.n	800a0e6 <FuzzingInputHandler+0xe2>
	   	   AFLfuzzer.inputLength > MAX_BUFFER_INPUT || 	AFLfuzzer.inputLengthpadded> MAX_BUFFER_INPUT )
 800a01a:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800a01e:	d92d      	bls.n	800a07c <FuzzingInputHandler+0x78>
	RingClear(&AFLfuzzer.inputAFL);
 800a020:	4844      	ldr	r0, [pc, #272]	; (800a134 <FuzzingInputHandler+0x130>)
	AFLfuzzer.inputLength = 0;
 800a022:	2500      	movs	r5, #0
	RingClear(&AFLfuzzer.inputAFL);
 800a024:	f000 f8c6 	bl	800a1b4 <RingClear>
	AFLfuzzer.aflheader[0] = faultcode;
 800a028:	2107      	movs	r1, #7
	AFLfuzzer.aflheader[1] = 4; // 4 bytes for CRC and no payload
 800a02a:	2304      	movs	r3, #4
	uint32_t uwCRCValue = HAL_CRC_Calculate(&hcrc, (uint32_t *)AFLfuzzer.aflheader, 2);
 800a02c:	2202      	movs	r2, #2
	AFLfuzzer.aflheader[0] = faultcode;
 800a02e:	f8c4 1814 	str.w	r1, [r4, #2068]	; 0x814
	uint32_t uwCRCValue = HAL_CRC_Calculate(&hcrc, (uint32_t *)AFLfuzzer.aflheader, 2);
 800a032:	4841      	ldr	r0, [pc, #260]	; (800a138 <FuzzingInputHandler+0x134>)
 800a034:	4941      	ldr	r1, [pc, #260]	; (800a13c <FuzzingInputHandler+0x138>)
	AFLfuzzer.aflheader[1] = 4; // 4 bytes for CRC and no payload
 800a036:	f8c4 3818 	str.w	r3, [r4, #2072]	; 0x818
	AFLfuzzer.inputLength = 0;
 800a03a:	f8c4 5824 	str.w	r5, [r4, #2084]	; 0x824
	AFLfuzzer.inputLengthpadded = 0;
 800a03e:	f8c4 5828 	str.w	r5, [r4, #2088]	; 0x828
	uint32_t uwCRCValue = HAL_CRC_Calculate(&hcrc, (uint32_t *)AFLfuzzer.aflheader, 2);
 800a042:	f000 ffd5 	bl	800aff0 <HAL_CRC_Calculate>
 800a046:	4603      	mov	r3, r0
	RingZeroes(&AFLfuzzer.inputAFL);
 800a048:	483a      	ldr	r0, [pc, #232]	; (800a134 <FuzzingInputHandler+0x130>)
	AFLfuzzer.bRXcomplete = false;
 800a04a:	f884 5864 	strb.w	r5, [r4, #2148]	; 0x864
	AFLfuzzer.aflheader[2] = ~uwCRCValue;
 800a04e:	43db      	mvns	r3, r3
	AFLfuzzer.inputLength = 0;
 800a050:	f8c4 5824 	str.w	r5, [r4, #2084]	; 0x824
	AFLfuzzer.previousGuard = 0;
 800a054:	f8a4 5858 	strh.w	r5, [r4, #2136]	; 0x858
	AFLfuzzer.aflheader[2] = ~uwCRCValue;
 800a058:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
	RingZeroes(&AFLfuzzer.inputAFL);
 800a05c:	f000 f8b6 	bl	800a1cc <RingZeroes>
    CDC_Transmit_FS((uint8_t *)AFLfuzzer.aflheader, 12);
 800a060:	210c      	movs	r1, #12
 800a062:	4836      	ldr	r0, [pc, #216]	; (800a13c <FuzzingInputHandler+0x138>)
 800a064:	f009 fd78 	bl	8013b58 <CDC_Transmit_FS>

	  	     }


      }
      portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 800a068:	9b03      	ldr	r3, [sp, #12]
 800a06a:	b12b      	cbz	r3, 800a078 <FuzzingInputHandler+0x74>
 800a06c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800a070:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800a074:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04

}
 800a078:	b005      	add	sp, #20
 800a07a:	bd30      	pop	{r4, r5, pc}
	      auxbytes.vbytes[0]=Buf[0];
 800a07c:	6803      	ldr	r3, [r0, #0]
	      if(AFLfuzzer.inputLength % 4)
 800a07e:	079a      	lsls	r2, r3, #30
	      AFLfuzzer.inputLength = auxbytes.vint32;
 800a080:	f8c4 3824 	str.w	r3, [r4, #2084]	; 0x824
	      if(AFLfuzzer.inputLength % 4)
 800a084:	d002      	beq.n	800a08c <FuzzingInputHandler+0x88>
	      	  AFLfuzzer.inputLengthpadded = AFLfuzzer.inputLength + 4 - AFLfuzzer.inputLength % 4;
 800a086:	f023 0303 	bic.w	r3, r3, #3
 800a08a:	3304      	adds	r3, #4
	      if((AFLfuzzer.inputLengthpadded + 4 )> MAX_BUFFER_INPUT)
 800a08c:	1d1a      	adds	r2, r3, #4
 800a08e:	f8c4 3828 	str.w	r3, [r4, #2088]	; 0x828
 800a092:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 800a096:	d8c3      	bhi.n	800a020 <FuzzingInputHandler+0x1c>
      if(AFLfuzzer.inputLengthpadded && (error == 0) )
 800a098:	2b00      	cmp	r3, #0
 800a09a:	d0ed      	beq.n	800a078 <FuzzingInputHandler+0x74>
	    	 u32Tocopy = (AFLfuzzer.inputLengthpadded + 4) - AFLfuzzer.inputAFL.u32available;
 800a09c:	f8d4 5808 	ldr.w	r5, [r4, #2056]	; 0x808
	    	 RingCopy(&AFLfuzzer.inputAFL, Buf, u32Tocopy);
 800a0a0:	680a      	ldr	r2, [r1, #0]
 800a0a2:	4601      	mov	r1, r0
	    	 u32Tocopy = (AFLfuzzer.inputLengthpadded + 4) - AFLfuzzer.inputAFL.u32available;
 800a0a4:	f1c5 0504 	rsb	r5, r5, #4
	    	 RingCopy(&AFLfuzzer.inputAFL, Buf, u32Tocopy);
 800a0a8:	4822      	ldr	r0, [pc, #136]	; (800a134 <FuzzingInputHandler+0x130>)
	    	 u32Tocopy = (AFLfuzzer.inputLengthpadded + 4) - AFLfuzzer.inputAFL.u32available;
 800a0aa:	442b      	add	r3, r5
	    	 RingCopy(&AFLfuzzer.inputAFL, Buf, u32Tocopy);
 800a0ac:	429a      	cmp	r2, r3
 800a0ae:	bf28      	it	cs
 800a0b0:	461a      	movcs	r2, r3
 800a0b2:	f000 f853 	bl	800a15c <RingCopy>
	  	     if( (AFLfuzzer.inputLengthpadded + 4) == AFLfuzzer.inputAFL.u32available)
 800a0b6:	f8d4 5828 	ldr.w	r5, [r4, #2088]	; 0x828
 800a0ba:	f8d4 3808 	ldr.w	r3, [r4, #2056]	; 0x808
 800a0be:	1d2a      	adds	r2, r5, #4
 800a0c0:	429a      	cmp	r2, r3
 800a0c2:	d1d1      	bne.n	800a068 <FuzzingInputHandler+0x64>
	uint32_t uwCRCValue = HAL_CRC_Calculate(&hcrc, (uint32_t *)input->uxBuffer, numberwords );
 800a0c4:	08aa      	lsrs	r2, r5, #2
	if (crcreceived[numberwords] == uwCRCValue)
 800a0c6:	f025 0503 	bic.w	r5, r5, #3
	uint32_t uwCRCValue = HAL_CRC_Calculate(&hcrc, (uint32_t *)input->uxBuffer, numberwords );
 800a0ca:	491a      	ldr	r1, [pc, #104]	; (800a134 <FuzzingInputHandler+0x130>)
 800a0cc:	481a      	ldr	r0, [pc, #104]	; (800a138 <FuzzingInputHandler+0x134>)
 800a0ce:	f000 ff8f 	bl	800aff0 <HAL_CRC_Calculate>
	if (crcreceived[numberwords] == uwCRCValue)
 800a0d2:	5963      	ldr	r3, [r4, r5]
	uwCRCValue = ~uwCRCValue;
 800a0d4:	43c0      	mvns	r0, r0
	if (crcreceived[numberwords] == uwCRCValue)
 800a0d6:	4298      	cmp	r0, r3
 800a0d8:	d00e      	beq.n	800a0f8 <FuzzingInputHandler+0xf4>
	RingClear(&AFLfuzzer.inputAFL);
 800a0da:	4816      	ldr	r0, [pc, #88]	; (800a134 <FuzzingInputHandler+0x130>)
	AFLfuzzer.inputLength = 0;
 800a0dc:	2500      	movs	r5, #0
	RingClear(&AFLfuzzer.inputAFL);
 800a0de:	f000 f869 	bl	800a1b4 <RingClear>
	AFLfuzzer.aflheader[0] = faultcode;
 800a0e2:	2106      	movs	r1, #6
 800a0e4:	e7a1      	b.n	800a02a <FuzzingInputHandler+0x26>
	  if( (AFLfuzzer.inputLength != 0 && AFLfuzzer.inputLengthpadded == 0) ||
 800a0e6:	2b00      	cmp	r3, #0
 800a0e8:	d09a      	beq.n	800a020 <FuzzingInputHandler+0x1c>
 800a0ea:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 800a0ee:	d897      	bhi.n	800a020 <FuzzingInputHandler+0x1c>
	   	   AFLfuzzer.inputLength > MAX_BUFFER_INPUT || 	AFLfuzzer.inputLengthpadded> MAX_BUFFER_INPUT )
 800a0f0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800a0f4:	d894      	bhi.n	800a020 <FuzzingInputHandler+0x1c>
 800a0f6:	e7d1      	b.n	800a09c <FuzzingInputHandler+0x98>
	  	    		AFLfuzzer.bRXcomplete = 1;
 800a0f8:	2301      	movs	r3, #1
	  	    		AFLfuzzer.inputAFL.u32availablenopad = AFLfuzzer.inputLength;
 800a0fa:	f8d4 2824 	ldr.w	r2, [r4, #2084]	; 0x824
	  	    		AFLfuzzer.bRXcomplete = 1;
 800a0fe:	f884 3864 	strb.w	r3, [r4, #2148]	; 0x864
	  	    		AFLfuzzer.inputAFL.u32availablenopad = AFLfuzzer.inputLength;
 800a102:	f8c4 280c 	str.w	r2, [r4, #2060]	; 0x80c
	  	    		AFLfuzzer.timespan = HAL_GetTick();
 800a106:	f000 fe01 	bl	800ad0c <HAL_GetTick>
	  	    		if(AFLfuzzer.inputAFL.u32availablenopad ==0)printf("Zero USB \n");
 800a10a:	f8d4 380c 	ldr.w	r3, [r4, #2060]	; 0x80c
	  	    		AFLfuzzer.timespan = HAL_GetTick();
 800a10e:	f8c4 082c 	str.w	r0, [r4, #2092]	; 0x82c
	  	    		if(AFLfuzzer.inputAFL.u32availablenopad ==0)printf("Zero USB \n");
 800a112:	b15b      	cbz	r3, 800a12c <FuzzingInputHandler+0x128>
	  	    		xTaskNotifyIndexedFromISR(AFLfuzzer.xTaskFuzzer,
 800a114:	2301      	movs	r3, #1
 800a116:	ad03      	add	r5, sp, #12
 800a118:	2100      	movs	r1, #0
 800a11a:	f8d4 086c 	ldr.w	r0, [r4, #2156]	; 0x86c
 800a11e:	461a      	mov	r2, r3
 800a120:	e9cd 1500 	strd	r1, r5, [sp]
 800a124:	4619      	mov	r1, r3
 800a126:	f7f9 fb17 	bl	8003758 <xTaskGenericNotifyFromISR>
 800a12a:	e79d      	b.n	800a068 <FuzzingInputHandler+0x64>
	  	    		if(AFLfuzzer.inputAFL.u32availablenopad ==0)printf("Zero USB \n");
 800a12c:	4804      	ldr	r0, [pc, #16]	; (800a140 <FuzzingInputHandler+0x13c>)
 800a12e:	f00a fa5d 	bl	80145ec <puts>
 800a132:	e7ef      	b.n	800a114 <FuzzingInputHandler+0x110>
 800a134:	24026000 	.word	0x24026000
 800a138:	240116ac 	.word	0x240116ac
 800a13c:	24026814 	.word	0x24026814
 800a140:	24008268 	.word	0x24008268

0800a144 <activateCortexMtraps>:


void activateCortexMtraps()
{
	 SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk
 800a144:	4b04      	ldr	r3, [pc, #16]	; (800a158 <activateCortexMtraps+0x14>)
 800a146:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a148:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
 800a14c:	625a      	str	r2, [r3, #36]	; 0x24
	  | SCB_SHCSR_BUSFAULTENA_Msk
	  | SCB_SHCSR_MEMFAULTENA_Msk; // enable Usage-/Bus-/MPU Fault

	  SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;// | // enable div by zero trap
 800a14e:	695a      	ldr	r2, [r3, #20]
 800a150:	f042 0210 	orr.w	r2, r2, #16
 800a154:	615a      	str	r2, [r3, #20]
			  //SCB_CCR_UNALIGN_TRP_Msk;    // enable unaligned access trap

}
 800a156:	4770      	bx	lr
 800a158:	e000ed00 	.word	0xe000ed00

0800a15c <RingCopy>:


/* Ring Buffer functions */

void RingCopy(RingBuffer_t *xRingBuffer, uint8_t* u8Buff, uint32_t len)
{
 800a15c:	b570      	push	{r4, r5, r6, lr}
 800a15e:	4604      	mov	r4, r0
	uint32_t u32Free=0;


	u32Free = MAX_BUFFER_INPUT - xRingBuffer->u32end;
 800a160:	f8d0 0804 	ldr.w	r0, [r0, #2052]	; 0x804
 800a164:	f5c0 6600 	rsb	r6, r0, #2048	; 0x800

	if(u32Free > len)
 800a168:	4296      	cmp	r6, r2
 800a16a:	d911      	bls.n	800a190 <RingCopy+0x34>
	{
		memcpy( &xRingBuffer->uxBuffer[xRingBuffer->u32end], u8Buff, len );
 800a16c:	4420      	add	r0, r4
 800a16e:	4615      	mov	r5, r2
 800a170:	f00a f8c0 	bl	80142f4 <memcpy>
		xRingBuffer->u32end = (xRingBuffer->u32end + len);
 800a174:	f8d4 3804 	ldr.w	r3, [r4, #2052]	; 0x804
		xRingBuffer->u32available += len;
 800a178:	f8d4 2808 	ldr.w	r2, [r4, #2056]	; 0x808
		xRingBuffer->u32end = (xRingBuffer->u32end + len);
 800a17c:	442b      	add	r3, r5
		xRingBuffer->u32available += len;
 800a17e:	442a      	add	r2, r5
		xRingBuffer->u32end = (xRingBuffer->u32end + len);
 800a180:	f8c4 3804 	str.w	r3, [r4, #2052]	; 0x804
		memcpy( &xRingBuffer->uxBuffer[xRingBuffer->u32end], u8Buff, u32Free);
		xRingBuffer->u32end = (xRingBuffer->u32end + u32Free);
		xRingBuffer->u32available += u32Free;
	}

	xRingBuffer->overflow = false;
 800a184:	2300      	movs	r3, #0
		xRingBuffer->u32available += len;
 800a186:	f8c4 2808 	str.w	r2, [r4, #2056]	; 0x808
	xRingBuffer->overflow = false;
 800a18a:	f884 3810 	strb.w	r3, [r4, #2064]	; 0x810

}
 800a18e:	bd70      	pop	{r4, r5, r6, pc}
		memcpy( &xRingBuffer->uxBuffer[xRingBuffer->u32end], u8Buff, u32Free);
 800a190:	4632      	mov	r2, r6
 800a192:	4420      	add	r0, r4
 800a194:	f00a f8ae 	bl	80142f4 <memcpy>
		xRingBuffer->u32available += u32Free;
 800a198:	f8d4 3808 	ldr.w	r3, [r4, #2056]	; 0x808
		xRingBuffer->u32end = (xRingBuffer->u32end + u32Free);
 800a19c:	f8d4 2804 	ldr.w	r2, [r4, #2052]	; 0x804
		xRingBuffer->u32available += u32Free;
 800a1a0:	4433      	add	r3, r6
		xRingBuffer->u32end = (xRingBuffer->u32end + u32Free);
 800a1a2:	4432      	add	r2, r6
		xRingBuffer->u32available += u32Free;
 800a1a4:	f8c4 3808 	str.w	r3, [r4, #2056]	; 0x808
	xRingBuffer->overflow = false;
 800a1a8:	2300      	movs	r3, #0
		xRingBuffer->u32end = (xRingBuffer->u32end + u32Free);
 800a1aa:	f8c4 2804 	str.w	r2, [r4, #2052]	; 0x804
	xRingBuffer->overflow = false;
 800a1ae:	f884 3810 	strb.w	r3, [r4, #2064]	; 0x810
}
 800a1b2:	bd70      	pop	{r4, r5, r6, pc}

0800a1b4 <RingClear>:
return xRingBuffer->u32available;
}

void RingClear(RingBuffer_t *xRingBuffer)
{
xRingBuffer->u32start = 0;
 800a1b4:	2300      	movs	r3, #0
 800a1b6:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
xRingBuffer->u32end = 0;
 800a1ba:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
xRingBuffer->u32available = 0;
 800a1be:	f8c0 3808 	str.w	r3, [r0, #2056]	; 0x808
xRingBuffer->u32availablenopad = 0;
 800a1c2:	f8c0 380c 	str.w	r3, [r0, #2060]	; 0x80c
xRingBuffer->overflow = false;
 800a1c6:	f880 3810 	strb.w	r3, [r0, #2064]	; 0x810
}
 800a1ca:	4770      	bx	lr

0800a1cc <RingZeroes>:
 800a1cc:	2300      	movs	r3, #0
 800a1ce:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
 800a1d2:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
 800a1d6:	f8c0 3808 	str.w	r3, [r0, #2056]	; 0x808
 800a1da:	f8c0 380c 	str.w	r3, [r0, #2060]	; 0x80c
 800a1de:	f880 3810 	strb.w	r3, [r0, #2064]	; 0x810
 800a1e2:	4770      	bx	lr

0800a1e4 <__io_putchar>:
static void MX_DMA_Init(void);
static void MX_CRC_Init(void);
static void MX_UART4_Init(void);
static void MX_USART2_UART_Init(void);
/* USER CODE BEGIN PFP */
void __io_putchar(uint8_t ch) {
 800a1e4:	b500      	push	{lr}
HAL_UART_Transmit(&huart3, &ch, 1, 1);
 800a1e6:	2301      	movs	r3, #1
void __io_putchar(uint8_t ch) {
 800a1e8:	b083      	sub	sp, #12
 800a1ea:	4684      	mov	ip, r0
HAL_UART_Transmit(&huart3, &ch, 1, 1);
 800a1ec:	4805      	ldr	r0, [pc, #20]	; (800a204 <__io_putchar+0x20>)
 800a1ee:	f10d 0107 	add.w	r1, sp, #7
 800a1f2:	461a      	mov	r2, r3
void __io_putchar(uint8_t ch) {
 800a1f4:	f88d c007 	strb.w	ip, [sp, #7]
HAL_UART_Transmit(&huart3, &ch, 1, 1);
 800a1f8:	f006 fcbe 	bl	8010b78 <HAL_UART_Transmit>
}
 800a1fc:	b003      	add	sp, #12
 800a1fe:	f85d fb04 	ldr.w	pc, [sp], #4
 800a202:	bf00      	nop
 800a204:	240118dc 	.word	0x240118dc

0800a208 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 800a208:	b500      	push	{lr}
 800a20a:	b09f      	sub	sp, #124	; 0x7c
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800a20c:	224c      	movs	r2, #76	; 0x4c
 800a20e:	2100      	movs	r1, #0
 800a210:	a80a      	add	r0, sp, #40	; 0x28
 800a212:	f00a f87d 	bl	8014310 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800a216:	2220      	movs	r2, #32
 800a218:	2100      	movs	r1, #0
 800a21a:	a802      	add	r0, sp, #8
 800a21c:	f00a f878 	bl	8014310 <memset>

  /** Supply configuration update enable
  */
  HAL_PWREx_ConfigSupply(PWR_DIRECT_SMPS_SUPPLY);
 800a220:	2004      	movs	r0, #4
 800a222:	f003 fd17 	bl	800dc54 <HAL_PWREx_ConfigSupply>

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
 800a226:	4a30      	ldr	r2, [pc, #192]	; (800a2e8 <SystemClock_Config+0xe0>)
 800a228:	2100      	movs	r1, #0
 800a22a:	4b30      	ldr	r3, [pc, #192]	; (800a2ec <SystemClock_Config+0xe4>)
 800a22c:	9101      	str	r1, [sp, #4]
 800a22e:	6991      	ldr	r1, [r2, #24]
 800a230:	f441 4140 	orr.w	r1, r1, #49152	; 0xc000
 800a234:	6191      	str	r1, [r2, #24]
 800a236:	6991      	ldr	r1, [r2, #24]
 800a238:	f401 4140 	and.w	r1, r1, #49152	; 0xc000
 800a23c:	9101      	str	r1, [sp, #4]
 800a23e:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 800a240:	f041 0101 	orr.w	r1, r1, #1
 800a244:	62d9      	str	r1, [r3, #44]	; 0x2c
 800a246:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a248:	f003 0301 	and.w	r3, r3, #1
 800a24c:	9301      	str	r3, [sp, #4]
 800a24e:	9b01      	ldr	r3, [sp, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
 800a250:	6993      	ldr	r3, [r2, #24]
 800a252:	049b      	lsls	r3, r3, #18
 800a254:	d5fc      	bpl.n	800a250 <SystemClock_Config+0x48>

  /** Macro to configure the PLL clock source
  */
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
 800a256:	4a26      	ldr	r2, [pc, #152]	; (800a2f0 <SystemClock_Config+0xe8>)
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 800a258:	2101      	movs	r1, #1
  RCC_OscInitStruct.PLL.PLLQ = 2;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3;
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800a25a:	a80a      	add	r0, sp, #40	; 0x28
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
 800a25c:	6a93      	ldr	r3, [r2, #40]	; 0x28
 800a25e:	f023 0303 	bic.w	r3, r3, #3
 800a262:	f043 0302 	orr.w	r3, r3, #2
 800a266:	6293      	str	r3, [r2, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800a268:	2302      	movs	r3, #2
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 800a26a:	9110      	str	r1, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
 800a26c:	2200      	movs	r2, #0
  RCC_OscInitStruct.PLL.PLLM = 1;
 800a26e:	9115      	str	r1, [sp, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLN = 120;
 800a270:	2178      	movs	r1, #120	; 0x78
  RCC_OscInitStruct.PLL.PLLR = 2;
 800a272:	9319      	str	r3, [sp, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLN = 120;
 800a274:	9116      	str	r1, [sp, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3;
 800a276:	210c      	movs	r1, #12
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
 800a278:	921c      	str	r2, [sp, #112]	; 0x70
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE;
 800a27a:	ed9f 7b15 	vldr	d7, [pc, #84]	; 800a2d0 <SystemClock_Config+0xc8>
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800a27e:	e9cd 3313 	strd	r3, r3, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLQ = 2;
 800a282:	e9cd 3317 	strd	r3, r3, [sp, #92]	; 0x5c
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE;
 800a286:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3;
 800a28a:	e9cd 121a 	strd	r1, r2, [sp, #104]	; 0x68
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800a28e:	f003 fdab 	bl	800dde8 <HAL_RCC_OscConfig>
 800a292:	b108      	cbz	r0, 800a298 <SystemClock_Config+0x90>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800a294:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 800a296:	e7fe      	b.n	800a296 <SystemClock_Config+0x8e>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800a298:	ed9f 7b0f 	vldr	d7, [pc, #60]	; 800a2d8 <SystemClock_Config+0xd0>
 800a29c:	2200      	movs	r2, #0
 800a29e:	2308      	movs	r3, #8
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 800a2a0:	a802      	add	r0, sp, #8
 800a2a2:	2104      	movs	r1, #4
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800a2a4:	ed8d 7b02 	vstr	d7, [sp, #8]
 800a2a8:	ed9f 7b0d 	vldr	d7, [pc, #52]	; 800a2e0 <SystemClock_Config+0xd8>
 800a2ac:	e9cd 2304 	strd	r2, r3, [sp, #16]
 800a2b0:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800a2b4:	2340      	movs	r3, #64	; 0x40
 800a2b6:	ed8d 7b06 	vstr	d7, [sp, #24]
 800a2ba:	e9cd 2308 	strd	r2, r3, [sp, #32]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 800a2be:	f004 f907 	bl	800e4d0 <HAL_RCC_ClockConfig>
 800a2c2:	b108      	cbz	r0, 800a2c8 <SystemClock_Config+0xc0>
 800a2c4:	b672      	cpsid	i
  while (1)
 800a2c6:	e7fe      	b.n	800a2c6 <SystemClock_Config+0xbe>
}
 800a2c8:	b01f      	add	sp, #124	; 0x7c
 800a2ca:	f85d fb04 	ldr.w	pc, [sp], #4
 800a2ce:	bf00      	nop
 800a2d0:	00000021 	.word	0x00000021
 800a2d4:	00050000 	.word	0x00050000
 800a2d8:	0000003f 	.word	0x0000003f
 800a2dc:	00000003 	.word	0x00000003
 800a2e0:	00000040 	.word	0x00000040
 800a2e4:	00000040 	.word	0x00000040
 800a2e8:	58024800 	.word	0x58024800
 800a2ec:	58000400 	.word	0x58000400
 800a2f0:	58024400 	.word	0x58024400
 800a2f4:	00000000 	.word	0x00000000

0800a2f8 <led_init>:
	__HAL_RCC_GPIOB_CLK_ENABLE();
 800a2f8:	4b17      	ldr	r3, [pc, #92]	; (800a358 <led_init+0x60>)
    GPIO_InitTypeDef GPIO_InitStruct = {0};
 800a2fa:	2100      	movs	r1, #0
    HAL_GPIO_Init(LD1_GPIO_PORT, &GPIO_InitStruct);
 800a2fc:	4817      	ldr	r0, [pc, #92]	; (800a35c <led_init+0x64>)
	__HAL_RCC_GPIOB_CLK_ENABLE();
 800a2fe:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 800a302:	f042 0202 	orr.w	r2, r2, #2
void led_init(void) {
 800a306:	b500      	push	{lr}
	__HAL_RCC_GPIOB_CLK_ENABLE();
 800a308:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
void led_init(void) {
 800a30c:	b089      	sub	sp, #36	; 0x24
	__HAL_RCC_GPIOB_CLK_ENABLE();
 800a30e:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    GPIO_InitTypeDef GPIO_InitStruct = {0};
 800a312:	9106      	str	r1, [sp, #24]
	__HAL_RCC_GPIOB_CLK_ENABLE();
 800a314:	f002 0202 	and.w	r2, r2, #2
 800a318:	9200      	str	r2, [sp, #0]
 800a31a:	9a00      	ldr	r2, [sp, #0]
    GPIO_InitTypeDef GPIO_InitStruct = {0};
 800a31c:	e9cd 1104 	strd	r1, r1, [sp, #16]
    LD1_GPIO_CLK_EN();
 800a320:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
    HAL_GPIO_Init(LD1_GPIO_PORT, &GPIO_InitStruct);
 800a324:	a902      	add	r1, sp, #8
    LD1_GPIO_CLK_EN();
 800a326:	f042 0202 	orr.w	r2, r2, #2
 800a32a:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 800a32e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800a332:	f003 0302 	and.w	r3, r3, #2
    GPIO_InitStruct.Pin = LD1_GPIO_PIN;
 800a336:	ed9f 7b06 	vldr	d7, [pc, #24]	; 800a350 <led_init+0x58>
    LD1_GPIO_CLK_EN();
 800a33a:	9301      	str	r3, [sp, #4]
 800a33c:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = LD1_GPIO_PIN;
 800a33e:	ed8d 7b02 	vstr	d7, [sp, #8]
    HAL_GPIO_Init(LD1_GPIO_PORT, &GPIO_InitStruct);
 800a342:	f002 fa61 	bl	800c808 <HAL_GPIO_Init>
}
 800a346:	b009      	add	sp, #36	; 0x24
 800a348:	f85d fb04 	ldr.w	pc, [sp], #4
 800a34c:	f3af 8000 	nop.w
 800a350:	00000001 	.word	0x00000001
 800a354:	00000001 	.word	0x00000001
 800a358:	58024400 	.word	0x58024400
 800a35c:	58020400 	.word	0x58020400

0800a360 <main>:
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
 800a360:	4ab7      	ldr	r2, [pc, #732]	; (800a640 <main+0x2e0>)
 800a362:	6953      	ldr	r3, [r2, #20]
 800a364:	f413 3300 	ands.w	r3, r3, #131072	; 0x20000
{
 800a368:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a36a:	b08f      	sub	sp, #60	; 0x3c
 800a36c:	d111      	bne.n	800a392 <main+0x32>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800a36e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800a372:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 800a376:	f8c2 3250 	str.w	r3, [r2, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 800a37a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800a37e:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 800a382:	6953      	ldr	r3, [r2, #20]
 800a384:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800a388:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 800a38a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800a38e:	f3bf 8f6f 	isb	sy
  HAL_MPU_Disable();
 800a392:	f000 fd4b 	bl	800ae2c <HAL_MPU_Disable>
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
 800a396:	2004      	movs	r0, #4
 800a398:	f000 fd56 	bl	800ae48 <HAL_MPU_Enable>
  while((__HAL_RCC_GET_FLAG(RCC_FLAG_D2CKRDY) != RESET) && (timeout-- > 0));
 800a39c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a3a0:	49a8      	ldr	r1, [pc, #672]	; (800a644 <main+0x2e4>)
 800a3a2:	e001      	b.n	800a3a8 <main+0x48>
 800a3a4:	3b01      	subs	r3, #1
 800a3a6:	d002      	beq.n	800a3ae <main+0x4e>
 800a3a8:	680a      	ldr	r2, [r1, #0]
 800a3aa:	0410      	lsls	r0, r2, #16
 800a3ac:	d4fa      	bmi.n	800a3a4 <main+0x44>
__HAL_RCC_HSEM_CLK_ENABLE();
 800a3ae:	4ca5      	ldr	r4, [pc, #660]	; (800a644 <main+0x2e4>)
  HAL_Init();
 800a3b0:	f000 fc70 	bl	800ac94 <HAL_Init>
  activateCortexMtraps();
 800a3b4:	f7ff fec6 	bl	800a144 <activateCortexMtraps>
  SystemClock_Config();
 800a3b8:	f7ff ff26 	bl	800a208 <SystemClock_Config>
__HAL_RCC_HSEM_CLK_ENABLE();
 800a3bc:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
HAL_HSEM_FastTake(HSEM_ID_0);
 800a3c0:	2000      	movs	r0, #0
__HAL_RCC_HSEM_CLK_ENABLE();
 800a3c2:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800a3c6:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 800a3ca:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800a3ce:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800a3d2:	9301      	str	r3, [sp, #4]
 800a3d4:	9b01      	ldr	r3, [sp, #4]
HAL_HSEM_FastTake(HSEM_ID_0);
 800a3d6:	f002 fc1d 	bl	800cc14 <HAL_HSEM_FastTake>
HAL_HSEM_Release(HSEM_ID_0,0);
 800a3da:	2100      	movs	r1, #0
 800a3dc:	4608      	mov	r0, r1
 800a3de:	f002 fc27 	bl	800cc30 <HAL_HSEM_Release>
while((__HAL_RCC_GET_FLAG(RCC_FLAG_D2CKRDY) == RESET) && (timeout-- > 0));
 800a3e2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800a3e6:	e001      	b.n	800a3ec <main+0x8c>
 800a3e8:	3b01      	subs	r3, #1
 800a3ea:	d002      	beq.n	800a3f2 <main+0x92>
 800a3ec:	6822      	ldr	r2, [r4, #0]
 800a3ee:	0412      	lsls	r2, r2, #16
 800a3f0:	d5fa      	bpl.n	800a3e8 <main+0x88>
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800a3f2:	4c94      	ldr	r4, [pc, #592]	; (800a644 <main+0x2e4>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800a3f4:	2500      	movs	r5, #0
  HAL_GPIO_WritePin(GPIOB, LD1_Pin|LD3_Pin, GPIO_PIN_RESET);
 800a3f6:	f244 0101 	movw	r1, #16385	; 0x4001
 800a3fa:	4893      	ldr	r0, [pc, #588]	; (800a648 <main+0x2e8>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800a3fc:	950c      	str	r5, [sp, #48]	; 0x30
  HAL_GPIO_WritePin(GPIOB, LD1_Pin|LD3_Pin, GPIO_PIN_RESET);
 800a3fe:	462a      	mov	r2, r5
  GPIO_InitStruct.Pin = LD1_Pin|LD3_Pin;
 800a400:	2600      	movs	r6, #0
 800a402:	2700      	movs	r7, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800a404:	e9cd 5508 	strd	r5, r5, [sp, #32]
 800a408:	e9cd 550a 	strd	r5, r5, [sp, #40]	; 0x28
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800a40c:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800a410:	f043 0304 	orr.w	r3, r3, #4
 800a414:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 800a418:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800a41c:	f003 0304 	and.w	r3, r3, #4
 800a420:	9302      	str	r3, [sp, #8]
 800a422:	9b02      	ldr	r3, [sp, #8]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800a424:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800a428:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a42c:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 800a430:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800a434:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800a438:	9303      	str	r3, [sp, #12]
 800a43a:	9b03      	ldr	r3, [sp, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800a43c:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800a440:	f043 0301 	orr.w	r3, r3, #1
 800a444:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 800a448:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800a44c:	f003 0301 	and.w	r3, r3, #1
 800a450:	9304      	str	r3, [sp, #16]
 800a452:	9b04      	ldr	r3, [sp, #16]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800a454:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800a458:	f043 0302 	orr.w	r3, r3, #2
 800a45c:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 800a460:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800a464:	f003 0302 	and.w	r3, r3, #2
 800a468:	9305      	str	r3, [sp, #20]
 800a46a:	9b05      	ldr	r3, [sp, #20]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 800a46c:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800a470:	f043 0308 	orr.w	r3, r3, #8
 800a474:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 800a478:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800a47c:	f003 0308 	and.w	r3, r3, #8
 800a480:	9306      	str	r3, [sp, #24]
 800a482:	9b06      	ldr	r3, [sp, #24]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 800a484:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800a488:	f043 0310 	orr.w	r3, r3, #16
 800a48c:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 800a490:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800a494:	f003 0310 	and.w	r3, r3, #16
 800a498:	9307      	str	r3, [sp, #28]
 800a49a:	9b07      	ldr	r3, [sp, #28]
  HAL_GPIO_WritePin(GPIOB, LD1_Pin|LD3_Pin, GPIO_PIN_RESET);
 800a49c:	f002 fbb6 	bl	800cc0c <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
 800a4a0:	462a      	mov	r2, r5
 800a4a2:	2102      	movs	r1, #2
 800a4a4:	4869      	ldr	r0, [pc, #420]	; (800a64c <main+0x2ec>)
 800a4a6:	f002 fbb1 	bl	800cc0c <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = LD1_Pin|LD3_Pin;
 800a4aa:	f244 0201 	movw	r2, #16385	; 0x4001
 800a4ae:	2301      	movs	r3, #1
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800a4b0:	a908      	add	r1, sp, #32
 800a4b2:	4865      	ldr	r0, [pc, #404]	; (800a648 <main+0x2e8>)
  GPIO_InitStruct.Pin = LD1_Pin|LD3_Pin;
 800a4b4:	e9cd 2308 	strd	r2, r3, [sp, #32]
 800a4b8:	e9cd 670a 	strd	r6, r7, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800a4bc:	f002 f9a4 	bl	800c808 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = LD2_Pin;
 800a4c0:	2301      	movs	r3, #1
 800a4c2:	2202      	movs	r2, #2
  HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
 800a4c4:	4861      	ldr	r0, [pc, #388]	; (800a64c <main+0x2ec>)
 800a4c6:	a908      	add	r1, sp, #32
  GPIO_InitStruct.Pin = LD2_Pin;
 800a4c8:	e9cd 670a 	strd	r6, r7, [sp, #40]	; 0x28
 800a4cc:	e9cd 2308 	strd	r2, r3, [sp, #32]
  huart3.Instance = USART3;
 800a4d0:	4e5f      	ldr	r6, [pc, #380]	; (800a650 <main+0x2f0>)
  HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
 800a4d2:	f002 f999 	bl	800c808 <HAL_GPIO_Init>
  huart3.Instance = USART3;
 800a4d6:	4b5f      	ldr	r3, [pc, #380]	; (800a654 <main+0x2f4>)
  huart3.Init.Mode = UART_MODE_TX_RX;
 800a4d8:	270c      	movs	r7, #12
  if (HAL_UART_Init(&huart3) != HAL_OK)
 800a4da:	4630      	mov	r0, r6
  huart3.Init.Parity = UART_PARITY_NONE;
 800a4dc:	6135      	str	r5, [r6, #16]
  huart3.Instance = USART3;
 800a4de:	6033      	str	r3, [r6, #0]
  huart3.Init.BaudRate = 5000000;
 800a4e0:	4b5d      	ldr	r3, [pc, #372]	; (800a658 <main+0x2f8>)
  huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800a4e2:	62b5      	str	r5, [r6, #40]	; 0x28
  huart3.Init.BaudRate = 5000000;
 800a4e4:	6073      	str	r3, [r6, #4]
  huart3.Init.OverSampling = UART_OVERSAMPLING_8;
 800a4e6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  huart3.Init.StopBits = UART_STOPBITS_1;
 800a4ea:	e9c6 5502 	strd	r5, r5, [r6, #8]
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800a4ee:	e9c6 7505 	strd	r7, r5, [r6, #20]
  huart3.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 800a4f2:	e9c6 5508 	strd	r5, r5, [r6, #32]
  huart3.Init.OverSampling = UART_OVERSAMPLING_8;
 800a4f6:	61f3      	str	r3, [r6, #28]
  if (HAL_UART_Init(&huart3) != HAL_OK)
 800a4f8:	f006 fc0a 	bl	8010d10 <HAL_UART_Init>
 800a4fc:	b108      	cbz	r0, 800a502 <main+0x1a2>
  __ASM volatile ("cpsid i" : : : "memory");
 800a4fe:	b672      	cpsid	i
  while (1)
 800a500:	e7fe      	b.n	800a500 <main+0x1a0>
  if (HAL_UARTEx_SetTxFifoThreshold(&huart3, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 800a502:	4601      	mov	r1, r0
 800a504:	4630      	mov	r0, r6
 800a506:	f006 fd21 	bl	8010f4c <HAL_UARTEx_SetTxFifoThreshold>
 800a50a:	b108      	cbz	r0, 800a510 <main+0x1b0>
 800a50c:	b672      	cpsid	i
  while (1)
 800a50e:	e7fe      	b.n	800a50e <main+0x1ae>
  if (HAL_UARTEx_SetRxFifoThreshold(&huart3, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 800a510:	4601      	mov	r1, r0
 800a512:	4630      	mov	r0, r6
 800a514:	f006 fd5c 	bl	8010fd0 <HAL_UARTEx_SetRxFifoThreshold>
 800a518:	b108      	cbz	r0, 800a51e <main+0x1be>
 800a51a:	b672      	cpsid	i
  while (1)
 800a51c:	e7fe      	b.n	800a51c <main+0x1bc>
  if (HAL_UARTEx_DisableFifoMode(&huart3) != HAL_OK)
 800a51e:	4630      	mov	r0, r6
 800a520:	f006 fcf6 	bl	8010f10 <HAL_UARTEx_DisableFifoMode>
 800a524:	b108      	cbz	r0, 800a52a <main+0x1ca>
 800a526:	b672      	cpsid	i
  while (1)
 800a528:	e7fe      	b.n	800a528 <main+0x1c8>
  hrng.Instance = RNG;
 800a52a:	4b4c      	ldr	r3, [pc, #304]	; (800a65c <main+0x2fc>)
 800a52c:	4a4c      	ldr	r2, [pc, #304]	; (800a660 <main+0x300>)
  hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
 800a52e:	6058      	str	r0, [r3, #4]
  if (HAL_RNG_Init(&hrng) != HAL_OK)
 800a530:	4618      	mov	r0, r3
  hrng.Instance = RNG;
 800a532:	601a      	str	r2, [r3, #0]
  if (HAL_RNG_Init(&hrng) != HAL_OK)
 800a534:	f005 f996 	bl	800f864 <HAL_RNG_Init>
 800a538:	4605      	mov	r5, r0
 800a53a:	b108      	cbz	r0, 800a540 <main+0x1e0>
 800a53c:	b672      	cpsid	i
  while (1)
 800a53e:	e7fe      	b.n	800a53e <main+0x1de>
  __HAL_RCC_DMA1_CLK_ENABLE();
 800a540:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
  HAL_NVIC_SetPriority(DMA1_Stream0_IRQn, 0, 0);
 800a544:	4602      	mov	r2, r0
 800a546:	4601      	mov	r1, r0
 800a548:	200b      	movs	r0, #11
  __HAL_RCC_DMA1_CLK_ENABLE();
 800a54a:	f043 0301 	orr.w	r3, r3, #1
 800a54e:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
 800a552:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
 800a556:	f003 0301 	and.w	r3, r3, #1
 800a55a:	9308      	str	r3, [sp, #32]
 800a55c:	9b08      	ldr	r3, [sp, #32]
  HAL_NVIC_SetPriority(DMA1_Stream0_IRQn, 0, 0);
 800a55e:	f000 fc05 	bl	800ad6c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream0_IRQn);
 800a562:	200b      	movs	r0, #11
 800a564:	f000 fc40 	bl	800ade8 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 0, 0);
 800a568:	462a      	mov	r2, r5
 800a56a:	4629      	mov	r1, r5
 800a56c:	4638      	mov	r0, r7
 800a56e:	f000 fbfd 	bl	800ad6c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
 800a572:	4638      	mov	r0, r7
 800a574:	f000 fc38 	bl	800ade8 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA1_Stream2_IRQn, 0, 0);
 800a578:	462a      	mov	r2, r5
 800a57a:	4629      	mov	r1, r5
 800a57c:	200d      	movs	r0, #13
 800a57e:	f000 fbf5 	bl	800ad6c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream2_IRQn);
 800a582:	200d      	movs	r0, #13
 800a584:	f000 fc30 	bl	800ade8 <HAL_NVIC_EnableIRQ>
  hcrc.Instance = CRC;
 800a588:	4836      	ldr	r0, [pc, #216]	; (800a664 <main+0x304>)
  hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_WORD;
 800a58a:	2360      	movs	r3, #96	; 0x60
  hcrc.Instance = CRC;
 800a58c:	4936      	ldr	r1, [pc, #216]	; (800a668 <main+0x308>)
  hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_ENABLE;
 800a58e:	2280      	movs	r2, #128	; 0x80
  hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
 800a590:	8085      	strh	r5, [r0, #4]
  hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_WORD;
 800a592:	6143      	str	r3, [r0, #20]
  hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_WORDS;
 800a594:	2303      	movs	r3, #3
  hcrc.Instance = CRC;
 800a596:	6001      	str	r1, [r0, #0]
  hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_WORDS;
 800a598:	6203      	str	r3, [r0, #32]
  hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_ENABLE;
 800a59a:	6182      	str	r2, [r0, #24]
  if (HAL_CRC_Init(&hcrc) != HAL_OK)
 800a59c:	f000 fca8 	bl	800aef0 <HAL_CRC_Init>
 800a5a0:	4603      	mov	r3, r0
 800a5a2:	b108      	cbz	r0, 800a5a8 <main+0x248>
 800a5a4:	b672      	cpsid	i
  while (1)
 800a5a6:	e7fe      	b.n	800a5a6 <main+0x246>
  huart4.Instance = UART4;
 800a5a8:	4c30      	ldr	r4, [pc, #192]	; (800a66c <main+0x30c>)
  huart4.Init.Mode = UART_MODE_RX;
 800a5aa:	2204      	movs	r2, #4
  huart4.Init.BaudRate = 1000000;
 800a5ac:	4930      	ldr	r1, [pc, #192]	; (800a670 <main+0x310>)
  huart4.Instance = UART4;
 800a5ae:	4831      	ldr	r0, [pc, #196]	; (800a674 <main+0x314>)
  huart4.Init.BaudRate = 1000000;
 800a5b0:	e884 000b 	stmia.w	r4, {r0, r1, r3}
  if (HAL_UART_Init(&huart4) != HAL_OK)
 800a5b4:	4620      	mov	r0, r4
  huart4.Init.Parity = UART_PARITY_NONE;
 800a5b6:	e9c4 3303 	strd	r3, r3, [r4, #12]
  huart4.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800a5ba:	e9c4 2305 	strd	r2, r3, [r4, #20]
  huart4.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800a5be:	e9c4 3307 	strd	r3, r3, [r4, #28]
  huart4.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800a5c2:	e9c4 3309 	strd	r3, r3, [r4, #36]	; 0x24
  if (HAL_UART_Init(&huart4) != HAL_OK)
 800a5c6:	f006 fba3 	bl	8010d10 <HAL_UART_Init>
 800a5ca:	4601      	mov	r1, r0
 800a5cc:	b108      	cbz	r0, 800a5d2 <main+0x272>
 800a5ce:	b672      	cpsid	i
  while (1)
 800a5d0:	e7fe      	b.n	800a5d0 <main+0x270>
  if (HAL_UARTEx_SetTxFifoThreshold(&huart4, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 800a5d2:	4620      	mov	r0, r4
 800a5d4:	f006 fcba 	bl	8010f4c <HAL_UARTEx_SetTxFifoThreshold>
 800a5d8:	4601      	mov	r1, r0
 800a5da:	b108      	cbz	r0, 800a5e0 <main+0x280>
 800a5dc:	b672      	cpsid	i
  while (1)
 800a5de:	e7fe      	b.n	800a5de <main+0x27e>
  if (HAL_UARTEx_SetRxFifoThreshold(&huart4, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 800a5e0:	4620      	mov	r0, r4
 800a5e2:	f006 fcf5 	bl	8010fd0 <HAL_UARTEx_SetRxFifoThreshold>
 800a5e6:	b108      	cbz	r0, 800a5ec <main+0x28c>
 800a5e8:	b672      	cpsid	i
  while (1)
 800a5ea:	e7fe      	b.n	800a5ea <main+0x28a>
  if (HAL_UARTEx_EnableFifoMode(&huart4) != HAL_OK)
 800a5ec:	4620      	mov	r0, r4
 800a5ee:	f006 fc55 	bl	8010e9c <HAL_UARTEx_EnableFifoMode>
 800a5f2:	b108      	cbz	r0, 800a5f8 <main+0x298>
 800a5f4:	b672      	cpsid	i
  while (1)
 800a5f6:	e7fe      	b.n	800a5f6 <main+0x296>
  huart2.Instance = USART2;
 800a5f8:	4c1f      	ldr	r4, [pc, #124]	; (800a678 <main+0x318>)
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 800a5fa:	2300      	movs	r3, #0
  huart2.Init.BaudRate = 115200;
 800a5fc:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
  huart2.Instance = USART2;
 800a600:	481e      	ldr	r0, [pc, #120]	; (800a67c <main+0x31c>)
  huart2.Init.Mode = UART_MODE_TX_RX;
 800a602:	220c      	movs	r2, #12
  huart2.Init.BaudRate = 115200;
 800a604:	e884 000b 	stmia.w	r4, {r0, r1, r3}
  if (HAL_UART_Init(&huart2) != HAL_OK)
 800a608:	4620      	mov	r0, r4
  huart2.Init.Parity = UART_PARITY_NONE;
 800a60a:	e9c4 3303 	strd	r3, r3, [r4, #12]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800a60e:	e9c4 2305 	strd	r2, r3, [r4, #20]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800a612:	e9c4 3307 	strd	r3, r3, [r4, #28]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800a616:	e9c4 3309 	strd	r3, r3, [r4, #36]	; 0x24
  if (HAL_UART_Init(&huart2) != HAL_OK)
 800a61a:	f006 fb79 	bl	8010d10 <HAL_UART_Init>
 800a61e:	4601      	mov	r1, r0
 800a620:	b108      	cbz	r0, 800a626 <main+0x2c6>
 800a622:	b672      	cpsid	i
  while (1)
 800a624:	e7fe      	b.n	800a624 <main+0x2c4>
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 800a626:	4620      	mov	r0, r4
 800a628:	f006 fc90 	bl	8010f4c <HAL_UARTEx_SetTxFifoThreshold>
 800a62c:	4601      	mov	r1, r0
 800a62e:	b108      	cbz	r0, 800a634 <main+0x2d4>
 800a630:	b672      	cpsid	i
  while (1)
 800a632:	e7fe      	b.n	800a632 <main+0x2d2>
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 800a634:	4620      	mov	r0, r4
 800a636:	f006 fccb 	bl	8010fd0 <HAL_UARTEx_SetRxFifoThreshold>
 800a63a:	b308      	cbz	r0, 800a680 <main+0x320>
 800a63c:	b672      	cpsid	i
  while (1)
 800a63e:	e7fe      	b.n	800a63e <main+0x2de>
 800a640:	e000ed00 	.word	0xe000ed00
 800a644:	58024400 	.word	0x58024400
 800a648:	58020400 	.word	0x58020400
 800a64c:	58021000 	.word	0x58021000
 800a650:	240118dc 	.word	0x240118dc
 800a654:	40004800 	.word	0x40004800
 800a658:	004c4b40 	.word	0x004c4b40
 800a65c:	24011838 	.word	0x24011838
 800a660:	48021800 	.word	0x48021800
 800a664:	240116ac 	.word	0x240116ac
 800a668:	58024c00 	.word	0x58024c00
 800a66c:	2401196c 	.word	0x2401196c
 800a670:	000f4240 	.word	0x000f4240
 800a674:	40004c00 	.word	0x40004c00
 800a678:	2401184c 	.word	0x2401184c
 800a67c:	40004400 	.word	0x40004400
  if (HAL_UARTEx_DisableFifoMode(&huart2) != HAL_OK)
 800a680:	4620      	mov	r0, r4
 800a682:	f006 fc45 	bl	8010f10 <HAL_UARTEx_DisableFifoMode>
 800a686:	b108      	cbz	r0, 800a68c <main+0x32c>
 800a688:	b672      	cpsid	i
  while (1)
 800a68a:	e7fe      	b.n	800a68a <main+0x32a>
  led_init();
 800a68c:	f7ff fe34 	bl	800a2f8 <led_init>
  testextern = (uint32_t)__user_heap_start__;
 800a690:	4a02      	ldr	r2, [pc, #8]	; (800a69c <main+0x33c>)
 800a692:	4b03      	ldr	r3, [pc, #12]	; (800a6a0 <main+0x340>)
 800a694:	601a      	str	r2, [r3, #0]
  app_main();
 800a696:	f7ff fb5f 	bl	8009d58 <app_main>
  while (1)
 800a69a:	e7fe      	b.n	800a69a <main+0x33a>
 800a69c:	24036000 	.word	0x24036000
 800a6a0:	240119fc 	.word	0x240119fc

0800a6a4 <HAL_TIM_PeriodElapsedCallback>:
  if (htim->Instance == TIM16) {
 800a6a4:	4b03      	ldr	r3, [pc, #12]	; (800a6b4 <HAL_TIM_PeriodElapsedCallback+0x10>)
 800a6a6:	6802      	ldr	r2, [r0, #0]
 800a6a8:	429a      	cmp	r2, r3
 800a6aa:	d000      	beq.n	800a6ae <HAL_TIM_PeriodElapsedCallback+0xa>
}
 800a6ac:	4770      	bx	lr
    HAL_IncTick();
 800a6ae:	f000 bb21 	b.w	800acf4 <HAL_IncTick>
 800a6b2:	bf00      	nop
 800a6b4:	40014400 	.word	0x40014400

0800a6b8 <Error_Handler>:
 800a6b8:	b672      	cpsid	i
  while (1)
 800a6ba:	e7fe      	b.n	800a6ba <Error_Handler+0x2>

0800a6bc <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800a6bc:	4b07      	ldr	r3, [pc, #28]	; (800a6dc <HAL_MspInit+0x20>)
{
 800a6be:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800a6c0:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
 800a6c4:	f042 0202 	orr.w	r2, r2, #2
 800a6c8:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
 800a6cc:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 800a6d0:	f003 0302 	and.w	r3, r3, #2
 800a6d4:	9301      	str	r3, [sp, #4]
 800a6d6:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800a6d8:	b002      	add	sp, #8
 800a6da:	4770      	bx	lr
 800a6dc:	58024400 	.word	0x58024400

0800a6e0 <HAL_CRC_MspInit>:
* @param hcrc: CRC handle pointer
* @retval None
*/
void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc)
{
  if(hcrc->Instance==CRC)
 800a6e0:	4b0a      	ldr	r3, [pc, #40]	; (800a70c <HAL_CRC_MspInit+0x2c>)
 800a6e2:	6802      	ldr	r2, [r0, #0]
 800a6e4:	429a      	cmp	r2, r3
 800a6e6:	d000      	beq.n	800a6ea <HAL_CRC_MspInit+0xa>
 800a6e8:	4770      	bx	lr
  {
  /* USER CODE BEGIN CRC_MspInit 0 */

  /* USER CODE END CRC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CRC_CLK_ENABLE();
 800a6ea:	f5a3 6300 	sub.w	r3, r3, #2048	; 0x800
{
 800a6ee:	b082      	sub	sp, #8
    __HAL_RCC_CRC_CLK_ENABLE();
 800a6f0:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 800a6f4:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 800a6f8:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 800a6fc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800a700:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800a704:	9301      	str	r3, [sp, #4]
 800a706:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN CRC_MspInit 1 */

  /* USER CODE END CRC_MspInit 1 */
  }

}
 800a708:	b002      	add	sp, #8
 800a70a:	4770      	bx	lr
 800a70c:	58024c00 	.word	0x58024c00

0800a710 <HAL_RNG_MspInit>:
* This function configures the hardware resources used in this example
* @param hrng: RNG handle pointer
* @retval None
*/
void HAL_RNG_MspInit(RNG_HandleTypeDef* hrng)
{
 800a710:	b510      	push	{r4, lr}
 800a712:	b0b0      	sub	sp, #192	; 0xc0
 800a714:	4604      	mov	r4, r0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800a716:	22bc      	movs	r2, #188	; 0xbc
 800a718:	2100      	movs	r1, #0
 800a71a:	a801      	add	r0, sp, #4
 800a71c:	f009 fdf8 	bl	8014310 <memset>
  if(hrng->Instance==RNG)
 800a720:	4b13      	ldr	r3, [pc, #76]	; (800a770 <HAL_RNG_MspInit+0x60>)
 800a722:	6822      	ldr	r2, [r4, #0]
 800a724:	429a      	cmp	r2, r3
 800a726:	d001      	beq.n	800a72c <HAL_RNG_MspInit+0x1c>
  /* USER CODE BEGIN RNG_MspInit 1 */

  /* USER CODE END RNG_MspInit 1 */
  }

}
 800a728:	b030      	add	sp, #192	; 0xc0
 800a72a:	bd10      	pop	{r4, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RNG;
 800a72c:	f44f 3300 	mov.w	r3, #131072	; 0x20000
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800a730:	a801      	add	r0, sp, #4
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RNG;
 800a732:	9301      	str	r3, [sp, #4]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800a734:	f004 f9e4 	bl	800eb00 <HAL_RCCEx_PeriphCLKConfig>
 800a738:	b9b0      	cbnz	r0, 800a768 <HAL_RNG_MspInit+0x58>
    __HAL_RCC_RNG_CLK_ENABLE();
 800a73a:	4b0e      	ldr	r3, [pc, #56]	; (800a774 <HAL_RNG_MspInit+0x64>)
    HAL_NVIC_SetPriority(HASH_RNG_IRQn, 0, 0);
 800a73c:	2200      	movs	r2, #0
 800a73e:	2050      	movs	r0, #80	; 0x50
    __HAL_RCC_RNG_CLK_ENABLE();
 800a740:	f8d3 40dc 	ldr.w	r4, [r3, #220]	; 0xdc
    HAL_NVIC_SetPriority(HASH_RNG_IRQn, 0, 0);
 800a744:	4611      	mov	r1, r2
    __HAL_RCC_RNG_CLK_ENABLE();
 800a746:	f044 0440 	orr.w	r4, r4, #64	; 0x40
 800a74a:	f8c3 40dc 	str.w	r4, [r3, #220]	; 0xdc
 800a74e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 800a752:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a756:	9300      	str	r3, [sp, #0]
 800a758:	9b00      	ldr	r3, [sp, #0]
    HAL_NVIC_SetPriority(HASH_RNG_IRQn, 0, 0);
 800a75a:	f000 fb07 	bl	800ad6c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(HASH_RNG_IRQn);
 800a75e:	2050      	movs	r0, #80	; 0x50
 800a760:	f000 fb42 	bl	800ade8 <HAL_NVIC_EnableIRQ>
}
 800a764:	b030      	add	sp, #192	; 0xc0
 800a766:	bd10      	pop	{r4, pc}
      Error_Handler();
 800a768:	f7ff ffa6 	bl	800a6b8 <Error_Handler>
 800a76c:	e7e5      	b.n	800a73a <HAL_RNG_MspInit+0x2a>
 800a76e:	bf00      	nop
 800a770:	48021800 	.word	0x48021800
 800a774:	58024400 	.word	0x58024400

0800a778 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 800a778:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 800a77c:	b0bc      	sub	sp, #240	; 0xf0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800a77e:	2100      	movs	r1, #0
{
 800a780:	4604      	mov	r4, r0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800a782:	22bc      	movs	r2, #188	; 0xbc
 800a784:	a80d      	add	r0, sp, #52	; 0x34
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800a786:	910c      	str	r1, [sp, #48]	; 0x30
 800a788:	e9cd 1108 	strd	r1, r1, [sp, #32]
 800a78c:	e9cd 110a 	strd	r1, r1, [sp, #40]	; 0x28
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800a790:	f009 fdbe 	bl	8014310 <memset>
  if(huart->Instance==UART4)
 800a794:	6823      	ldr	r3, [r4, #0]
 800a796:	4a91      	ldr	r2, [pc, #580]	; (800a9dc <HAL_UART_MspInit+0x264>)
 800a798:	4293      	cmp	r3, r2
 800a79a:	d009      	beq.n	800a7b0 <HAL_UART_MspInit+0x38>

  /* USER CODE BEGIN UART4_MspInit 1 */

  /* USER CODE END UART4_MspInit 1 */
  }
  else if(huart->Instance==USART2)
 800a79c:	4a90      	ldr	r2, [pc, #576]	; (800a9e0 <HAL_UART_MspInit+0x268>)
 800a79e:	4293      	cmp	r3, r2
 800a7a0:	d069      	beq.n	800a876 <HAL_UART_MspInit+0xfe>

  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
  else if(huart->Instance==USART3)
 800a7a2:	4a90      	ldr	r2, [pc, #576]	; (800a9e4 <HAL_UART_MspInit+0x26c>)
 800a7a4:	4293      	cmp	r3, r2
 800a7a6:	f000 809c 	beq.w	800a8e2 <HAL_UART_MspInit+0x16a>
  /* USER CODE BEGIN USART3_MspInit 1 */

  /* USER CODE END USART3_MspInit 1 */
  }

}
 800a7aa:	b03c      	add	sp, #240	; 0xf0
 800a7ac:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_UART4;
 800a7b0:	2302      	movs	r3, #2
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800a7b2:	a80d      	add	r0, sp, #52	; 0x34
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_UART4;
 800a7b4:	930d      	str	r3, [sp, #52]	; 0x34
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800a7b6:	f004 f9a3 	bl	800eb00 <HAL_RCCEx_PeriphCLKConfig>
 800a7ba:	2800      	cmp	r0, #0
 800a7bc:	f040 80fe 	bne.w	800a9bc <HAL_UART_MspInit+0x244>
    __HAL_RCC_UART4_CLK_ENABLE();
 800a7c0:	4b89      	ldr	r3, [pc, #548]	; (800a9e8 <HAL_UART_MspInit+0x270>)
    GPIO_InitStruct.Alternate = GPIO_AF8_UART4;
 800a7c2:	2608      	movs	r6, #8
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 800a7c4:	f04f 0800 	mov.w	r8, #0
 800a7c8:	f04f 0900 	mov.w	r9, #0
    __HAL_RCC_UART4_CLK_ENABLE();
 800a7cc:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a7d0:	4886      	ldr	r0, [pc, #536]	; (800a9ec <HAL_UART_MspInit+0x274>)
    __HAL_RCC_UART4_CLK_ENABLE();
 800a7d2:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
    hdma_uart4_rx.Instance = DMA1_Stream2;
 800a7d6:	4d86      	ldr	r5, [pc, #536]	; (800a9f0 <HAL_UART_MspInit+0x278>)
    __HAL_RCC_UART4_CLK_ENABLE();
 800a7d8:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
 800a7dc:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 800a7e0:	f402 2200 	and.w	r2, r2, #524288	; 0x80000
 800a7e4:	9201      	str	r2, [sp, #4]
 800a7e6:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800a7e8:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 800a7ec:	f042 0201 	orr.w	r2, r2, #1
 800a7f0:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 800a7f4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 800a7f8:	f002 0201 	and.w	r2, r2, #1
 800a7fc:	9202      	str	r2, [sp, #8]
 800a7fe:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800a800:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 800a804:	f042 0204 	orr.w	r2, r2, #4
 800a808:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 800a80c:	2201      	movs	r2, #1
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800a80e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF8_UART4;
 800a812:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800a814:	f003 0304 	and.w	r3, r3, #4
 800a818:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 800a81a:	2302      	movs	r3, #2
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800a81c:	9903      	ldr	r1, [sp, #12]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a81e:	a908      	add	r1, sp, #32
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 800a820:	e9cd 2308 	strd	r2, r3, [sp, #32]
 800a824:	e9cd 890a 	strd	r8, r9, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a828:	f001 ffee 	bl	800c808 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_11;
 800a82c:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800a830:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800a832:	a908      	add	r1, sp, #32
 800a834:	486f      	ldr	r0, [pc, #444]	; (800a9f4 <HAL_UART_MspInit+0x27c>)
    GPIO_InitStruct.Alternate = GPIO_AF8_UART4;
 800a836:	960c      	str	r6, [sp, #48]	; 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_11;
 800a838:	e9cd 2308 	strd	r2, r3, [sp, #32]
 800a83c:	e9cd 890a 	strd	r8, r9, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800a840:	f001 ffe2 	bl	800c808 <HAL_GPIO_Init>
    hdma_uart4_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 800a844:	2300      	movs	r3, #0
    hdma_uart4_rx.Init.Request = DMA_REQUEST_UART4_RX;
 800a846:	223f      	movs	r2, #63	; 0x3f
    hdma_uart4_rx.Instance = DMA1_Stream2;
 800a848:	496b      	ldr	r1, [pc, #428]	; (800a9f8 <HAL_UART_MspInit+0x280>)
    if (HAL_DMA_Init(&hdma_uart4_rx) != HAL_OK)
 800a84a:	4628      	mov	r0, r5
    hdma_uart4_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 800a84c:	626b      	str	r3, [r5, #36]	; 0x24
    hdma_uart4_rx.Init.Request = DMA_REQUEST_UART4_RX;
 800a84e:	e885 000e 	stmia.w	r5, {r1, r2, r3}
    hdma_uart4_rx.Init.MemInc = DMA_MINC_ENABLE;
 800a852:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hdma_uart4_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 800a856:	e9c5 3305 	strd	r3, r3, [r5, #20]
    hdma_uart4_rx.Init.MemInc = DMA_MINC_ENABLE;
 800a85a:	e9c5 3203 	strd	r3, r2, [r5, #12]
    hdma_uart4_rx.Init.Priority = DMA_PRIORITY_LOW;
 800a85e:	e9c5 3307 	strd	r3, r3, [r5, #28]
    if (HAL_DMA_Init(&hdma_uart4_rx) != HAL_OK)
 800a862:	f000 fd1f 	bl	800b2a4 <HAL_DMA_Init>
 800a866:	2800      	cmp	r0, #0
 800a868:	f040 80a5 	bne.w	800a9b6 <HAL_UART_MspInit+0x23e>
    __HAL_LINKDMA(huart,hdmarx,hdma_uart4_rx);
 800a86c:	67e5      	str	r5, [r4, #124]	; 0x7c
 800a86e:	63ac      	str	r4, [r5, #56]	; 0x38
}
 800a870:	b03c      	add	sp, #240	; 0xf0
 800a872:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 800a876:	2302      	movs	r3, #2
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800a878:	a80d      	add	r0, sp, #52	; 0x34
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 800a87a:	930d      	str	r3, [sp, #52]	; 0x34
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800a87c:	f004 f940 	bl	800eb00 <HAL_RCCEx_PeriphCLKConfig>
 800a880:	2800      	cmp	r0, #0
 800a882:	f040 809e 	bne.w	800a9c2 <HAL_UART_MspInit+0x24a>
    __HAL_RCC_USART2_CLK_ENABLE();
 800a886:	4b58      	ldr	r3, [pc, #352]	; (800a9e8 <HAL_UART_MspInit+0x270>)
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
 800a888:	f04f 0860 	mov.w	r8, #96	; 0x60
 800a88c:	f04f 0902 	mov.w	r9, #2
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 800a890:	2407      	movs	r4, #7
    __HAL_RCC_USART2_CLK_ENABLE();
 800a892:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800a896:	a908      	add	r1, sp, #32
 800a898:	4858      	ldr	r0, [pc, #352]	; (800a9fc <HAL_UART_MspInit+0x284>)
    __HAL_RCC_USART2_CLK_ENABLE();
 800a89a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800a89e:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
 800a8a2:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 800a8a6:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 800a8aa:	9204      	str	r2, [sp, #16]
 800a8ac:	9a04      	ldr	r2, [sp, #16]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800a8ae:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 800a8b2:	f042 0208 	orr.w	r2, r2, #8
 800a8b6:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 800a8ba:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 800a8be:	940c      	str	r4, [sp, #48]	; 0x30
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800a8c0:	f003 0308 	and.w	r3, r3, #8
 800a8c4:	9305      	str	r3, [sp, #20]
 800a8c6:	9b05      	ldr	r3, [sp, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
 800a8c8:	e9cd 8908 	strd	r8, r9, [sp, #32]
 800a8cc:	f04f 0800 	mov.w	r8, #0
 800a8d0:	f04f 0900 	mov.w	r9, #0
 800a8d4:	e9cd 890a 	strd	r8, r9, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800a8d8:	f001 ff96 	bl	800c808 <HAL_GPIO_Init>
}
 800a8dc:	b03c      	add	sp, #240	; 0xf0
 800a8de:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3;
 800a8e2:	2302      	movs	r3, #2
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800a8e4:	a80d      	add	r0, sp, #52	; 0x34
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3;
 800a8e6:	930d      	str	r3, [sp, #52]	; 0x34
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800a8e8:	f004 f90a 	bl	800eb00 <HAL_RCCEx_PeriphCLKConfig>
 800a8ec:	2800      	cmp	r0, #0
 800a8ee:	d171      	bne.n	800a9d4 <HAL_UART_MspInit+0x25c>
    __HAL_RCC_USART3_CLK_ENABLE();
 800a8f0:	4b3d      	ldr	r3, [pc, #244]	; (800a9e8 <HAL_UART_MspInit+0x270>)
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 800a8f2:	2007      	movs	r0, #7
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800a8f4:	a908      	add	r1, sp, #32
    hdma_usart3_tx.Instance = DMA1_Stream0;
 800a8f6:	4e42      	ldr	r6, [pc, #264]	; (800aa00 <HAL_UART_MspInit+0x288>)
    __HAL_RCC_USART3_CLK_ENABLE();
 800a8f8:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 800a8fc:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800a900:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
 800a904:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 800a908:	f402 2280 	and.w	r2, r2, #262144	; 0x40000
 800a90c:	9206      	str	r2, [sp, #24]
 800a90e:	9a06      	ldr	r2, [sp, #24]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800a910:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 800a914:	f042 0208 	orr.w	r2, r2, #8
 800a918:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = STLINK_RX_Pin|STLINK_TX_Pin;
 800a91c:	f44f 7240 	mov.w	r2, #768	; 0x300
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800a920:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 800a924:	900c      	str	r0, [sp, #48]	; 0x30
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800a926:	f003 0308 	and.w	r3, r3, #8
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800a92a:	4834      	ldr	r0, [pc, #208]	; (800a9fc <HAL_UART_MspInit+0x284>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800a92c:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Pin = STLINK_RX_Pin|STLINK_TX_Pin;
 800a92e:	2302      	movs	r3, #2
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800a930:	9d07      	ldr	r5, [sp, #28]
    GPIO_InitStruct.Pin = STLINK_RX_Pin|STLINK_TX_Pin;
 800a932:	e9cd 2308 	strd	r2, r3, [sp, #32]
 800a936:	2200      	movs	r2, #0
 800a938:	2300      	movs	r3, #0
 800a93a:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800a93e:	f001 ff63 	bl	800c808 <HAL_GPIO_Init>
    hdma_usart3_tx.Instance = DMA1_Stream0;
 800a942:	4930      	ldr	r1, [pc, #192]	; (800aa04 <HAL_UART_MspInit+0x28c>)
    hdma_usart3_tx.Init.Request = DMA_REQUEST_USART3_TX;
 800a944:	222e      	movs	r2, #46	; 0x2e
    hdma_usart3_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 800a946:	2300      	movs	r3, #0
    if (HAL_DMA_Init(&hdma_usart3_tx) != HAL_OK)
 800a948:	4630      	mov	r0, r6
    hdma_usart3_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 800a94a:	60f3      	str	r3, [r6, #12]
    hdma_usart3_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 800a94c:	6173      	str	r3, [r6, #20]
    hdma_usart3_tx.Init.Request = DMA_REQUEST_USART3_TX;
 800a94e:	e9c6 1200 	strd	r1, r2, [r6]
    hdma_usart3_tx.Init.MemInc = DMA_MINC_ENABLE;
 800a952:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hdma_usart3_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 800a956:	2140      	movs	r1, #64	; 0x40
    hdma_usart3_tx.Init.MemInc = DMA_MINC_ENABLE;
 800a958:	6132      	str	r2, [r6, #16]
    hdma_usart3_tx.Init.Priority = DMA_PRIORITY_HIGH;
 800a95a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    hdma_usart3_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 800a95e:	60b1      	str	r1, [r6, #8]
    hdma_usart3_tx.Init.Mode = DMA_NORMAL;
 800a960:	e9c6 3306 	strd	r3, r3, [r6, #24]
    hdma_usart3_tx.Init.Priority = DMA_PRIORITY_HIGH;
 800a964:	e9c6 2308 	strd	r2, r3, [r6, #32]
    if (HAL_DMA_Init(&hdma_usart3_tx) != HAL_OK)
 800a968:	f000 fc9c 	bl	800b2a4 <HAL_DMA_Init>
 800a96c:	bb78      	cbnz	r0, 800a9ce <HAL_UART_MspInit+0x256>
    hdma_usart3_rx.Instance = DMA1_Stream1;
 800a96e:	4d26      	ldr	r5, [pc, #152]	; (800aa08 <HAL_UART_MspInit+0x290>)
    hdma_usart3_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 800a970:	2300      	movs	r3, #0
    hdma_usart3_rx.Instance = DMA1_Stream1;
 800a972:	4926      	ldr	r1, [pc, #152]	; (800aa0c <HAL_UART_MspInit+0x294>)
    hdma_usart3_rx.Init.Request = DMA_REQUEST_USART3_RX;
 800a974:	222d      	movs	r2, #45	; 0x2d
    if (HAL_DMA_Init(&hdma_usart3_rx) != HAL_OK)
 800a976:	4628      	mov	r0, r5
    __HAL_LINKDMA(huart,hdmatx,hdma_usart3_tx);
 800a978:	67a6      	str	r6, [r4, #120]	; 0x78
 800a97a:	63b4      	str	r4, [r6, #56]	; 0x38
    hdma_usart3_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 800a97c:	626b      	str	r3, [r5, #36]	; 0x24
    hdma_usart3_rx.Init.Request = DMA_REQUEST_USART3_RX;
 800a97e:	e885 000e 	stmia.w	r5, {r1, r2, r3}
    hdma_usart3_rx.Init.MemInc = DMA_MINC_ENABLE;
 800a982:	f44f 6180 	mov.w	r1, #1024	; 0x400
    hdma_usart3_rx.Init.Priority = DMA_PRIORITY_HIGH;
 800a986:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    hdma_usart3_rx.Init.MemInc = DMA_MINC_ENABLE;
 800a98a:	e9c5 3103 	strd	r3, r1, [r5, #12]
    hdma_usart3_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 800a98e:	e9c5 3305 	strd	r3, r3, [r5, #20]
    hdma_usart3_rx.Init.Priority = DMA_PRIORITY_HIGH;
 800a992:	e9c5 3207 	strd	r3, r2, [r5, #28]
    if (HAL_DMA_Init(&hdma_usart3_rx) != HAL_OK)
 800a996:	f000 fc85 	bl	800b2a4 <HAL_DMA_Init>
 800a99a:	b9a8      	cbnz	r0, 800a9c8 <HAL_UART_MspInit+0x250>
    HAL_NVIC_SetPriority(USART3_IRQn, 5, 0);
 800a99c:	2200      	movs	r2, #0
 800a99e:	2105      	movs	r1, #5
 800a9a0:	2027      	movs	r0, #39	; 0x27
    __HAL_LINKDMA(huart,hdmarx,hdma_usart3_rx);
 800a9a2:	67e5      	str	r5, [r4, #124]	; 0x7c
 800a9a4:	63ac      	str	r4, [r5, #56]	; 0x38
    HAL_NVIC_SetPriority(USART3_IRQn, 5, 0);
 800a9a6:	f000 f9e1 	bl	800ad6c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART3_IRQn);
 800a9aa:	2027      	movs	r0, #39	; 0x27
 800a9ac:	f000 fa1c 	bl	800ade8 <HAL_NVIC_EnableIRQ>
}
 800a9b0:	b03c      	add	sp, #240	; 0xf0
 800a9b2:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
      Error_Handler();
 800a9b6:	f7ff fe7f 	bl	800a6b8 <Error_Handler>
 800a9ba:	e757      	b.n	800a86c <HAL_UART_MspInit+0xf4>
      Error_Handler();
 800a9bc:	f7ff fe7c 	bl	800a6b8 <Error_Handler>
 800a9c0:	e6fe      	b.n	800a7c0 <HAL_UART_MspInit+0x48>
      Error_Handler();
 800a9c2:	f7ff fe79 	bl	800a6b8 <Error_Handler>
 800a9c6:	e75e      	b.n	800a886 <HAL_UART_MspInit+0x10e>
      Error_Handler();
 800a9c8:	f7ff fe76 	bl	800a6b8 <Error_Handler>
 800a9cc:	e7e6      	b.n	800a99c <HAL_UART_MspInit+0x224>
      Error_Handler();
 800a9ce:	f7ff fe73 	bl	800a6b8 <Error_Handler>
 800a9d2:	e7cc      	b.n	800a96e <HAL_UART_MspInit+0x1f6>
      Error_Handler();
 800a9d4:	f7ff fe70 	bl	800a6b8 <Error_Handler>
 800a9d8:	e78a      	b.n	800a8f0 <HAL_UART_MspInit+0x178>
 800a9da:	bf00      	nop
 800a9dc:	40004c00 	.word	0x40004c00
 800a9e0:	40004400 	.word	0x40004400
 800a9e4:	40004800 	.word	0x40004800
 800a9e8:	58024400 	.word	0x58024400
 800a9ec:	58020000 	.word	0x58020000
 800a9f0:	240116d0 	.word	0x240116d0
 800a9f4:	58020800 	.word	0x58020800
 800a9f8:	40020040 	.word	0x40020040
 800a9fc:	58020c00 	.word	0x58020c00
 800aa00:	240117c0 	.word	0x240117c0
 800aa04:	40020010 	.word	0x40020010
 800aa08:	24011748 	.word	0x24011748
 800aa0c:	40020028 	.word	0x40020028

0800aa10 <HAL_UART_MspDeInit>:
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspDeInit(UART_HandleTypeDef* huart)
{
  if(huart->Instance==UART4)
 800aa10:	4a22      	ldr	r2, [pc, #136]	; (800aa9c <HAL_UART_MspDeInit+0x8c>)
 800aa12:	6803      	ldr	r3, [r0, #0]
 800aa14:	4293      	cmp	r3, r2
{
 800aa16:	b510      	push	{r4, lr}
 800aa18:	4604      	mov	r4, r0
  if(huart->Instance==UART4)
 800aa1a:	d006      	beq.n	800aa2a <HAL_UART_MspDeInit+0x1a>
    HAL_DMA_DeInit(huart->hdmarx);
  /* USER CODE BEGIN UART4_MspDeInit 1 */

  /* USER CODE END UART4_MspDeInit 1 */
  }
  else if(huart->Instance==USART2)
 800aa1c:	4a20      	ldr	r2, [pc, #128]	; (800aaa0 <HAL_UART_MspDeInit+0x90>)
 800aa1e:	4293      	cmp	r3, r2
 800aa20:	d018      	beq.n	800aa54 <HAL_UART_MspDeInit+0x44>

  /* USER CODE BEGIN USART2_MspDeInit 1 */

  /* USER CODE END USART2_MspDeInit 1 */
  }
  else if(huart->Instance==USART3)
 800aa22:	4a20      	ldr	r2, [pc, #128]	; (800aaa4 <HAL_UART_MspDeInit+0x94>)
 800aa24:	4293      	cmp	r3, r2
 800aa26:	d022      	beq.n	800aa6e <HAL_UART_MspDeInit+0x5e>
  /* USER CODE BEGIN USART3_MspDeInit 1 */

  /* USER CODE END USART3_MspDeInit 1 */
  }

}
 800aa28:	bd10      	pop	{r4, pc}
    __HAL_RCC_UART4_CLK_DISABLE();
 800aa2a:	4a1f      	ldr	r2, [pc, #124]	; (800aaa8 <HAL_UART_MspDeInit+0x98>)
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_0);
 800aa2c:	2101      	movs	r1, #1
 800aa2e:	481f      	ldr	r0, [pc, #124]	; (800aaac <HAL_UART_MspDeInit+0x9c>)
    __HAL_RCC_UART4_CLK_DISABLE();
 800aa30:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
 800aa34:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 800aa38:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_0);
 800aa3c:	f002 f81e 	bl	800ca7c <HAL_GPIO_DeInit>
    HAL_GPIO_DeInit(GPIOC, GPIO_PIN_11);
 800aa40:	481b      	ldr	r0, [pc, #108]	; (800aab0 <HAL_UART_MspDeInit+0xa0>)
 800aa42:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800aa46:	f002 f819 	bl	800ca7c <HAL_GPIO_DeInit>
    HAL_DMA_DeInit(huart->hdmarx);
 800aa4a:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
}
 800aa4c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_DMA_DeInit(huart->hdmarx);
 800aa50:	f000 be96 	b.w	800b780 <HAL_DMA_DeInit>
    __HAL_RCC_USART2_CLK_DISABLE();
 800aa54:	4a14      	ldr	r2, [pc, #80]	; (800aaa8 <HAL_UART_MspDeInit+0x98>)
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_5|GPIO_PIN_6);
 800aa56:	2160      	movs	r1, #96	; 0x60
 800aa58:	4816      	ldr	r0, [pc, #88]	; (800aab4 <HAL_UART_MspDeInit+0xa4>)
    __HAL_RCC_USART2_CLK_DISABLE();
 800aa5a:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
 800aa5e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
}
 800aa62:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    __HAL_RCC_USART2_CLK_DISABLE();
 800aa66:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_5|GPIO_PIN_6);
 800aa6a:	f002 b807 	b.w	800ca7c <HAL_GPIO_DeInit>
    __HAL_RCC_USART3_CLK_DISABLE();
 800aa6e:	4a0e      	ldr	r2, [pc, #56]	; (800aaa8 <HAL_UART_MspDeInit+0x98>)
    HAL_GPIO_DeInit(GPIOD, STLINK_RX_Pin|STLINK_TX_Pin);
 800aa70:	f44f 7140 	mov.w	r1, #768	; 0x300
 800aa74:	480f      	ldr	r0, [pc, #60]	; (800aab4 <HAL_UART_MspDeInit+0xa4>)
    __HAL_RCC_USART3_CLK_DISABLE();
 800aa76:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
 800aa7a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800aa7e:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
    HAL_GPIO_DeInit(GPIOD, STLINK_RX_Pin|STLINK_TX_Pin);
 800aa82:	f001 fffb 	bl	800ca7c <HAL_GPIO_DeInit>
    HAL_DMA_DeInit(huart->hdmatx);
 800aa86:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 800aa88:	f000 fe7a 	bl	800b780 <HAL_DMA_DeInit>
    HAL_DMA_DeInit(huart->hdmarx);
 800aa8c:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 800aa8e:	f000 fe77 	bl	800b780 <HAL_DMA_DeInit>
    HAL_NVIC_DisableIRQ(USART3_IRQn);
 800aa92:	2027      	movs	r0, #39	; 0x27
}
 800aa94:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_DisableIRQ(USART3_IRQn);
 800aa98:	f000 b9b4 	b.w	800ae04 <HAL_NVIC_DisableIRQ>
 800aa9c:	40004c00 	.word	0x40004c00
 800aaa0:	40004400 	.word	0x40004400
 800aaa4:	40004800 	.word	0x40004800
 800aaa8:	58024400 	.word	0x58024400
 800aaac:	58020000 	.word	0x58020000
 800aab0:	58020800 	.word	0x58020800
 800aab4:	58020c00 	.word	0x58020c00

0800aab8 <HAL_InitTick>:
  uint32_t              uwTimclock;

  uint32_t              uwPrescalerValue;
  uint32_t              pFLatency;
/*Configure the TIM16 IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800aab8:	280f      	cmp	r0, #15
 800aaba:	d901      	bls.n	800aac0 <HAL_InitTick+0x8>
  HAL_NVIC_EnableIRQ(TIM16_IRQn);
    uwTickPrio = TickPriority;
    }
  else
  {
    return HAL_ERROR;
 800aabc:	2001      	movs	r0, #1
    return HAL_TIM_Base_Start_IT(&htim16);
  }

  /* Return function status */
  return HAL_ERROR;
}
 800aabe:	4770      	bx	lr
{
 800aac0:	b530      	push	{r4, r5, lr}
  HAL_NVIC_SetPriority(TIM16_IRQn, TickPriority ,0U);
 800aac2:	4601      	mov	r1, r0
{
 800aac4:	b08b      	sub	sp, #44	; 0x2c
 800aac6:	4604      	mov	r4, r0
  HAL_NVIC_SetPriority(TIM16_IRQn, TickPriority ,0U);
 800aac8:	2200      	movs	r2, #0
 800aaca:	2075      	movs	r0, #117	; 0x75
  htim16.Instance = TIM16;
 800aacc:	4d1a      	ldr	r5, [pc, #104]	; (800ab38 <HAL_InitTick+0x80>)
  HAL_NVIC_SetPriority(TIM16_IRQn, TickPriority ,0U);
 800aace:	f000 f94d 	bl	800ad6c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM16_IRQn);
 800aad2:	2075      	movs	r0, #117	; 0x75
 800aad4:	f000 f988 	bl	800ade8 <HAL_NVIC_EnableIRQ>
  __HAL_RCC_TIM16_CLK_ENABLE();
 800aad8:	4b18      	ldr	r3, [pc, #96]	; (800ab3c <HAL_InitTick+0x84>)
    uwTickPrio = TickPriority;
 800aada:	4a19      	ldr	r2, [pc, #100]	; (800ab40 <HAL_InitTick+0x88>)
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800aadc:	4669      	mov	r1, sp
 800aade:	a802      	add	r0, sp, #8
    uwTickPrio = TickPriority;
 800aae0:	6014      	str	r4, [r2, #0]
  __HAL_RCC_TIM16_CLK_ENABLE();
 800aae2:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 800aae6:	4c17      	ldr	r4, [pc, #92]	; (800ab44 <HAL_InitTick+0x8c>)
  __HAL_RCC_TIM16_CLK_ENABLE();
 800aae8:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800aaec:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
 800aaf0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 800aaf4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800aaf8:	9301      	str	r3, [sp, #4]
 800aafa:	9b01      	ldr	r3, [sp, #4]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800aafc:	f003 fee0 	bl	800e8c0 <HAL_RCC_GetClockConfig>
  uwTimclock = 2*HAL_RCC_GetPCLK2Freq();
 800ab00:	f003 fe96 	bl	800e830 <HAL_RCC_GetPCLK2Freq>
  htim16.Init.ClockDivision = 0;
 800ab04:	2200      	movs	r2, #0
  uwTimclock = 2*HAL_RCC_GetPCLK2Freq();
 800ab06:	0043      	lsls	r3, r0, #1
  htim16.Instance = TIM16;
 800ab08:	490f      	ldr	r1, [pc, #60]	; (800ab48 <HAL_InitTick+0x90>)
  htim16.Init.ClockDivision = 0;
 800ab0a:	612a      	str	r2, [r5, #16]
  if(HAL_TIM_Base_Init(&htim16) == HAL_OK)
 800ab0c:	4628      	mov	r0, r5
  htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
 800ab0e:	60aa      	str	r2, [r5, #8]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 800ab10:	fba4 2303 	umull	r2, r3, r4, r3
  htim16.Init.Period = (1000000U / 1000U) - 1U;
 800ab14:	f240 32e7 	movw	r2, #999	; 0x3e7
  htim16.Instance = TIM16;
 800ab18:	6029      	str	r1, [r5, #0]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 800ab1a:	0c9b      	lsrs	r3, r3, #18
  htim16.Init.Period = (1000000U / 1000U) - 1U;
 800ab1c:	60ea      	str	r2, [r5, #12]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 800ab1e:	3b01      	subs	r3, #1
  htim16.Init.Prescaler = uwPrescalerValue;
 800ab20:	606b      	str	r3, [r5, #4]
  if(HAL_TIM_Base_Init(&htim16) == HAL_OK)
 800ab22:	f004 ff1b 	bl	800f95c <HAL_TIM_Base_Init>
 800ab26:	b110      	cbz	r0, 800ab2e <HAL_InitTick+0x76>
    return HAL_ERROR;
 800ab28:	2001      	movs	r0, #1
}
 800ab2a:	b00b      	add	sp, #44	; 0x2c
 800ab2c:	bd30      	pop	{r4, r5, pc}
    return HAL_TIM_Base_Start_IT(&htim16);
 800ab2e:	4628      	mov	r0, r5
 800ab30:	f004 ffca 	bl	800fac8 <HAL_TIM_Base_Start_IT>
 800ab34:	e7f9      	b.n	800ab2a <HAL_InitTick+0x72>
 800ab36:	bf00      	nop
 800ab38:	24011a00 	.word	0x24011a00
 800ab3c:	58024400 	.word	0x58024400
 800ab40:	2400801c 	.word	0x2400801c
 800ab44:	431bde83 	.word	0x431bde83
 800ab48:	40014400 	.word	0x40014400

0800ab4c <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800ab4c:	4770      	bx	lr
 800ab4e:	bf00      	nop

0800ab50 <DMA1_Stream0_IRQHandler>:
void DMA1_Stream0_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream0_IRQn 0 */

  /* USER CODE END DMA1_Stream0_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart3_tx);
 800ab50:	4801      	ldr	r0, [pc, #4]	; (800ab58 <DMA1_Stream0_IRQHandler+0x8>)
 800ab52:	f001 bb07 	b.w	800c164 <HAL_DMA_IRQHandler>
 800ab56:	bf00      	nop
 800ab58:	240117c0 	.word	0x240117c0

0800ab5c <DMA1_Stream1_IRQHandler>:
void DMA1_Stream1_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream1_IRQn 0 */

  /* USER CODE END DMA1_Stream1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart3_rx);
 800ab5c:	4801      	ldr	r0, [pc, #4]	; (800ab64 <DMA1_Stream1_IRQHandler+0x8>)
 800ab5e:	f001 bb01 	b.w	800c164 <HAL_DMA_IRQHandler>
 800ab62:	bf00      	nop
 800ab64:	24011748 	.word	0x24011748

0800ab68 <DMA1_Stream2_IRQHandler>:
void DMA1_Stream2_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream2_IRQn 0 */

  /* USER CODE END DMA1_Stream2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_uart4_rx);
 800ab68:	4801      	ldr	r0, [pc, #4]	; (800ab70 <DMA1_Stream2_IRQHandler+0x8>)
 800ab6a:	f001 bafb 	b.w	800c164 <HAL_DMA_IRQHandler>
 800ab6e:	bf00      	nop
 800ab70:	240116d0 	.word	0x240116d0

0800ab74 <USART3_IRQHandler>:
void USART3_IRQHandler(void)
{
  /* USER CODE BEGIN USART3_IRQn 0 */

  /* USER CODE END USART3_IRQn 0 */
  HAL_UART_IRQHandler(&huart3);
 800ab74:	4801      	ldr	r0, [pc, #4]	; (800ab7c <USART3_IRQHandler+0x8>)
 800ab76:	f005 ba83 	b.w	8010080 <HAL_UART_IRQHandler>
 800ab7a:	bf00      	nop
 800ab7c:	240118dc 	.word	0x240118dc

0800ab80 <RNG_IRQHandler>:
void HASH_RNG_IRQHandler(void)
{
  /* USER CODE BEGIN HASH_RNG_IRQn 0 */

  /* USER CODE END HASH_RNG_IRQn 0 */
  HAL_RNG_IRQHandler(&hrng);
 800ab80:	4801      	ldr	r0, [pc, #4]	; (800ab88 <RNG_IRQHandler+0x8>)
 800ab82:	f004 beb1 	b.w	800f8e8 <HAL_RNG_IRQHandler>
 800ab86:	bf00      	nop
 800ab88:	24011838 	.word	0x24011838

0800ab8c <OTG_FS_IRQHandler>:
void OTG_FS_IRQHandler(void)
{
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 800ab8c:	4801      	ldr	r0, [pc, #4]	; (800ab94 <OTG_FS_IRQHandler+0x8>)
 800ab8e:	f002 b90f 	b.w	800cdb0 <HAL_PCD_IRQHandler>
 800ab92:	bf00      	nop
 800ab94:	240344e0 	.word	0x240344e0

0800ab98 <TIM16_IRQHandler>:
void TIM16_IRQHandler(void)
{
  /* USER CODE BEGIN TIM16_IRQn 0 */

  /* USER CODE END TIM16_IRQn 0 */
  HAL_TIM_IRQHandler(&htim16);
 800ab98:	4801      	ldr	r0, [pc, #4]	; (800aba0 <TIM16_IRQHandler+0x8>)
 800ab9a:	f004 bff9 	b.w	800fb90 <HAL_TIM_IRQHandler>
 800ab9e:	bf00      	nop
 800aba0:	24011a00 	.word	0x24011a00

0800aba4 <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 800aba4:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800aba6:	1e16      	subs	r6, r2, #0
 800aba8:	dd07      	ble.n	800abba <_read+0x16>
 800abaa:	460c      	mov	r4, r1
 800abac:	198d      	adds	r5, r1, r6
	{
		*ptr++ = __io_getchar();
 800abae:	f3af 8000 	nop.w
 800abb2:	f804 0b01 	strb.w	r0, [r4], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800abb6:	42a5      	cmp	r5, r4
 800abb8:	d1f9      	bne.n	800abae <_read+0xa>
	}

return len;
}
 800abba:	4630      	mov	r0, r6
 800abbc:	bd70      	pop	{r4, r5, r6, pc}
 800abbe:	bf00      	nop

0800abc0 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 800abc0:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800abc2:	1e16      	subs	r6, r2, #0
 800abc4:	dd07      	ble.n	800abd6 <_write+0x16>
 800abc6:	460c      	mov	r4, r1
 800abc8:	198d      	adds	r5, r1, r6
	{
		__io_putchar(*ptr++);
 800abca:	f814 0b01 	ldrb.w	r0, [r4], #1
 800abce:	f7ff fb09 	bl	800a1e4 <__io_putchar>
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800abd2:	42ac      	cmp	r4, r5
 800abd4:	d1f9      	bne.n	800abca <_write+0xa>
	}
	return len;
}
 800abd6:	4630      	mov	r0, r6
 800abd8:	bd70      	pop	{r4, r5, r6, pc}
 800abda:	bf00      	nop

0800abdc <_close>:

int _close(int file)
{
	return -1;
}
 800abdc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800abe0:	4770      	bx	lr
 800abe2:	bf00      	nop

0800abe4 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 800abe4:	f44f 5300 	mov.w	r3, #8192	; 0x2000
	return 0;
}
 800abe8:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
 800abea:	604b      	str	r3, [r1, #4]
}
 800abec:	4770      	bx	lr
 800abee:	bf00      	nop

0800abf0 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 800abf0:	2001      	movs	r0, #1
 800abf2:	4770      	bx	lr

0800abf4 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 800abf4:	2000      	movs	r0, #0
 800abf6:	4770      	bx	lr

0800abf8 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 800abf8:	b538      	push	{r3, r4, r5, lr}
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 800abfa:	4c0d      	ldr	r4, [pc, #52]	; (800ac30 <_sbrk+0x38>)
{
 800abfc:	4603      	mov	r3, r0
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 800abfe:	490d      	ldr	r1, [pc, #52]	; (800ac34 <_sbrk+0x3c>)
 800ac00:	4d0d      	ldr	r5, [pc, #52]	; (800ac38 <_sbrk+0x40>)
  if (NULL == __sbrk_heap_end)
 800ac02:	6822      	ldr	r2, [r4, #0]
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 800ac04:	1b49      	subs	r1, r1, r5
  if (NULL == __sbrk_heap_end)
 800ac06:	b12a      	cbz	r2, 800ac14 <_sbrk+0x1c>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 800ac08:	4413      	add	r3, r2
 800ac0a:	428b      	cmp	r3, r1
 800ac0c:	d808      	bhi.n	800ac20 <_sbrk+0x28>

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;

  return (void *)prev_heap_end;
}
 800ac0e:	4610      	mov	r0, r2
  __sbrk_heap_end += incr;
 800ac10:	6023      	str	r3, [r4, #0]
}
 800ac12:	bd38      	pop	{r3, r4, r5, pc}
    __sbrk_heap_end = &_end;
 800ac14:	4809      	ldr	r0, [pc, #36]	; (800ac3c <_sbrk+0x44>)
 800ac16:	4602      	mov	r2, r0
 800ac18:	6020      	str	r0, [r4, #0]
  if (__sbrk_heap_end + incr > max_heap)
 800ac1a:	4413      	add	r3, r2
 800ac1c:	428b      	cmp	r3, r1
 800ac1e:	d9f6      	bls.n	800ac0e <_sbrk+0x16>
    errno = ENOMEM;
 800ac20:	f009 fa34 	bl	801408c <__errno>
 800ac24:	230c      	movs	r3, #12
    return (void *)-1;
 800ac26:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    errno = ENOMEM;
 800ac2a:	6003      	str	r3, [r0, #0]
}
 800ac2c:	4610      	mov	r0, r2
 800ac2e:	bd38      	pop	{r3, r4, r5, pc}
 800ac30:	24011a4c 	.word	0x24011a4c
 800ac34:	24080000 	.word	0x24080000
 800ac38:	00000400 	.word	0x00000400
 800ac3c:	24036000 	.word	0x24036000

0800ac40 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack      /* set stack pointer */
 800ac40:	f8df d034 	ldr.w	sp, [pc, #52]	; 800ac78 <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit
 800ac44:	f7fe fbde 	bl	8009404 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 800ac48:	480c      	ldr	r0, [pc, #48]	; (800ac7c <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 800ac4a:	490d      	ldr	r1, [pc, #52]	; (800ac80 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 800ac4c:	4a0d      	ldr	r2, [pc, #52]	; (800ac84 <LoopFillZerobss+0x1a>)
  movs r3, #0
 800ac4e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 800ac50:	e002      	b.n	800ac58 <LoopCopyDataInit>

0800ac52 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800ac52:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800ac54:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800ac56:	3304      	adds	r3, #4

0800ac58 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800ac58:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800ac5a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800ac5c:	d3f9      	bcc.n	800ac52 <CopyDataInit>
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800ac5e:	4a0a      	ldr	r2, [pc, #40]	; (800ac88 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 800ac60:	4c0a      	ldr	r4, [pc, #40]	; (800ac8c <LoopFillZerobss+0x22>)
  movs r3, #0
 800ac62:	2300      	movs	r3, #0
  b LoopFillZerobss
 800ac64:	e001      	b.n	800ac6a <LoopFillZerobss>

0800ac66 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800ac66:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800ac68:	3204      	adds	r2, #4

0800ac6a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800ac6a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800ac6c:	d3fb      	bcc.n	800ac66 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 800ac6e:	f009 fb09 	bl	8014284 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800ac72:	f7ff fb75 	bl	800a360 <main>
  bx  lr
 800ac76:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 800ac78:	24080000 	.word	0x24080000
  ldr r0, =_sdata
 800ac7c:	24000000 	.word	0x24000000
  ldr r1, =_edata
 800ac80:	240085b4 	.word	0x240085b4
  ldr r2, =_sidata
 800ac84:	0801523c 	.word	0x0801523c
  ldr r2, =_sbss
 800ac88:	24010000 	.word	0x24010000
  ldr r4, =_ebss
 800ac8c:	24034c1c 	.word	0x24034c1c

0800ac90 <ADC3_IRQHandler>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800ac90:	e7fe      	b.n	800ac90 <ADC3_IRQHandler>
	...

0800ac94 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800ac94:	b510      	push	{r4, lr}
   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */
   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */
#endif /* DUAL_CORE &&  CORE_CM4 */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800ac96:	2003      	movs	r0, #3
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800ac98:	4c12      	ldr	r4, [pc, #72]	; (800ace4 <HAL_Init+0x50>)
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800ac9a:	f000 f855 	bl	800ad48 <HAL_NVIC_SetPriorityGrouping>
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800ac9e:	f003 fb77 	bl	800e390 <HAL_RCC_GetSysClockFreq>
 800aca2:	4b11      	ldr	r3, [pc, #68]	; (800ace8 <HAL_Init+0x54>)
 800aca4:	4911      	ldr	r1, [pc, #68]	; (800acec <HAL_Init+0x58>)
 800aca6:	699a      	ldr	r2, [r3, #24]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800aca8:	699b      	ldr	r3, [r3, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800acaa:	f3c2 2203 	ubfx	r2, r2, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800acae:	f003 030f 	and.w	r3, r3, #15
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800acb2:	5c8a      	ldrb	r2, [r1, r2]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800acb4:	5ccb      	ldrb	r3, [r1, r3]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800acb6:	f002 021f 	and.w	r2, r2, #31
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 800acba:	490d      	ldr	r1, [pc, #52]	; (800acf0 <HAL_Init+0x5c>)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800acbc:	f003 031f 	and.w	r3, r3, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800acc0:	40d0      	lsrs	r0, r2
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800acc2:	fa20 f303 	lsr.w	r3, r0, r3
  SystemCoreClock = common_system_clock;
 800acc6:	6008      	str	r0, [r1, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 800acc8:	2000      	movs	r0, #0
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800acca:	6023      	str	r3, [r4, #0]
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 800accc:	f7ff fef4 	bl	800aab8 <HAL_InitTick>
 800acd0:	b110      	cbz	r0, 800acd8 <HAL_Init+0x44>
  {
    return HAL_ERROR;
 800acd2:	2401      	movs	r4, #1
  /* Init the low level hardware */
  HAL_MspInit();

  /* Return function status */
  return HAL_OK;
}
 800acd4:	4620      	mov	r0, r4
 800acd6:	bd10      	pop	{r4, pc}
 800acd8:	4604      	mov	r4, r0
  HAL_MspInit();
 800acda:	f7ff fcef 	bl	800a6bc <HAL_MspInit>
}
 800acde:	4620      	mov	r0, r4
 800ace0:	bd10      	pop	{r4, pc}
 800ace2:	bf00      	nop
 800ace4:	24008004 	.word	0x24008004
 800ace8:	58024400 	.word	0x58024400
 800acec:	24008240 	.word	0x24008240
 800acf0:	24008000 	.word	0x24008000

0800acf4 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 800acf4:	4a03      	ldr	r2, [pc, #12]	; (800ad04 <HAL_IncTick+0x10>)
 800acf6:	4b04      	ldr	r3, [pc, #16]	; (800ad08 <HAL_IncTick+0x14>)
 800acf8:	6811      	ldr	r1, [r2, #0]
 800acfa:	781b      	ldrb	r3, [r3, #0]
 800acfc:	440b      	add	r3, r1
 800acfe:	6013      	str	r3, [r2, #0]
}
 800ad00:	4770      	bx	lr
 800ad02:	bf00      	nop
 800ad04:	24011a50 	.word	0x24011a50
 800ad08:	24008018 	.word	0x24008018

0800ad0c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 800ad0c:	4b01      	ldr	r3, [pc, #4]	; (800ad14 <HAL_GetTick+0x8>)
 800ad0e:	6818      	ldr	r0, [r3, #0]
}
 800ad10:	4770      	bx	lr
 800ad12:	bf00      	nop
 800ad14:	24011a50 	.word	0x24011a50

0800ad18 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800ad18:	b538      	push	{r3, r4, r5, lr}
 800ad1a:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 800ad1c:	f7ff fff6 	bl	800ad0c <HAL_GetTick>
 800ad20:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800ad22:	1c63      	adds	r3, r4, #1
 800ad24:	d002      	beq.n	800ad2c <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 800ad26:	4b04      	ldr	r3, [pc, #16]	; (800ad38 <HAL_Delay+0x20>)
 800ad28:	781b      	ldrb	r3, [r3, #0]
 800ad2a:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 800ad2c:	f7ff ffee 	bl	800ad0c <HAL_GetTick>
 800ad30:	1b43      	subs	r3, r0, r5
 800ad32:	42a3      	cmp	r3, r4
 800ad34:	d3fa      	bcc.n	800ad2c <HAL_Delay+0x14>
  {
  }
}
 800ad36:	bd38      	pop	{r3, r4, r5, pc}
 800ad38:	24008018 	.word	0x24008018

0800ad3c <HAL_GetREVID>:
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
   return((DBGMCU->IDCODE) >> 16);
 800ad3c:	4b01      	ldr	r3, [pc, #4]	; (800ad44 <HAL_GetREVID+0x8>)
 800ad3e:	6818      	ldr	r0, [r3, #0]
}
 800ad40:	0c00      	lsrs	r0, r0, #16
 800ad42:	4770      	bx	lr
 800ad44:	5c001000 	.word	0x5c001000

0800ad48 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800ad48:	4906      	ldr	r1, [pc, #24]	; (800ad64 <HAL_NVIC_SetPriorityGrouping+0x1c>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800ad4a:	f64f 0cff 	movw	ip, #63743	; 0xf8ff
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800ad4e:	0200      	lsls	r0, r0, #8
  reg_value  =  (reg_value                                   |
 800ad50:	4b05      	ldr	r3, [pc, #20]	; (800ad68 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800ad52:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800ad54:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800ad58:	ea02 020c 	and.w	r2, r2, ip
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800ad5c:	4310      	orrs	r0, r2
  reg_value  =  (reg_value                                   |
 800ad5e:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 800ad60:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800ad62:	4770      	bx	lr
 800ad64:	e000ed00 	.word	0xe000ed00
 800ad68:	05fa0000 	.word	0x05fa0000

0800ad6c <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800ad6c:	4b1b      	ldr	r3, [pc, #108]	; (800addc <HAL_NVIC_SetPriority+0x70>)
 800ad6e:	68db      	ldr	r3, [r3, #12]
 800ad70:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800ad74:	b500      	push	{lr}
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800ad76:	f1c3 0e07 	rsb	lr, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800ad7a:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800ad7e:	f1be 0f04 	cmp.w	lr, #4
 800ad82:	bf28      	it	cs
 800ad84:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800ad88:	f1bc 0f06 	cmp.w	ip, #6
 800ad8c:	d91a      	bls.n	800adc4 <HAL_NVIC_SetPriority+0x58>
 800ad8e:	3b03      	subs	r3, #3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800ad90:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 800ad94:	fa0c fc03 	lsl.w	ip, ip, r3
 800ad98:	ea22 020c 	bic.w	r2, r2, ip
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800ad9c:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
  if ((int32_t)(IRQn) >= 0)
 800ada0:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800ada2:	fa0c fc0e 	lsl.w	ip, ip, lr
 800ada6:	ea21 010c 	bic.w	r1, r1, ip
 800adaa:	fa01 f103 	lsl.w	r1, r1, r3
 800adae:	ea41 0102 	orr.w	r1, r1, r2
  if ((int32_t)(IRQn) >= 0)
 800adb2:	db0a      	blt.n	800adca <HAL_NVIC_SetPriority+0x5e>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800adb4:	0109      	lsls	r1, r1, #4
 800adb6:	4b0a      	ldr	r3, [pc, #40]	; (800ade0 <HAL_NVIC_SetPriority+0x74>)
 800adb8:	b2c9      	uxtb	r1, r1
 800adba:	4403      	add	r3, r0
 800adbc:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800adc0:	f85d fb04 	ldr.w	pc, [sp], #4
 800adc4:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800adc6:	4613      	mov	r3, r2
 800adc8:	e7e8      	b.n	800ad9c <HAL_NVIC_SetPriority+0x30>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800adca:	f000 000f 	and.w	r0, r0, #15
 800adce:	0109      	lsls	r1, r1, #4
 800add0:	4b04      	ldr	r3, [pc, #16]	; (800ade4 <HAL_NVIC_SetPriority+0x78>)
 800add2:	b2c9      	uxtb	r1, r1
 800add4:	4403      	add	r3, r0
 800add6:	7619      	strb	r1, [r3, #24]
 800add8:	f85d fb04 	ldr.w	pc, [sp], #4
 800addc:	e000ed00 	.word	0xe000ed00
 800ade0:	e000e100 	.word	0xe000e100
 800ade4:	e000ecfc 	.word	0xe000ecfc

0800ade8 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 800ade8:	2800      	cmp	r0, #0
 800adea:	db07      	blt.n	800adfc <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800adec:	2301      	movs	r3, #1
 800adee:	f000 011f 	and.w	r1, r0, #31
 800adf2:	4a03      	ldr	r2, [pc, #12]	; (800ae00 <HAL_NVIC_EnableIRQ+0x18>)
 800adf4:	0940      	lsrs	r0, r0, #5
 800adf6:	408b      	lsls	r3, r1
 800adf8:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 800adfc:	4770      	bx	lr
 800adfe:	bf00      	nop
 800ae00:	e000e100 	.word	0xe000e100

0800ae04 <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 800ae04:	2800      	cmp	r0, #0
 800ae06:	db0d      	blt.n	800ae24 <HAL_NVIC_DisableIRQ+0x20>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800ae08:	0943      	lsrs	r3, r0, #5
 800ae0a:	2201      	movs	r2, #1
 800ae0c:	f000 001f 	and.w	r0, r0, #31
 800ae10:	4905      	ldr	r1, [pc, #20]	; (800ae28 <HAL_NVIC_DisableIRQ+0x24>)
 800ae12:	3320      	adds	r3, #32
 800ae14:	fa02 f000 	lsl.w	r0, r2, r0
 800ae18:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 800ae1c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800ae20:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 800ae24:	4770      	bx	lr
 800ae26:	bf00      	nop
 800ae28:	e000e100 	.word	0xe000e100

0800ae2c <HAL_MPU_Disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
 800ae2c:	f3bf 8f5f 	dmb	sy
{
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 800ae30:	4b04      	ldr	r3, [pc, #16]	; (800ae44 <HAL_MPU_Disable+0x18>)

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
 800ae32:	2100      	movs	r1, #0
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 800ae34:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ae36:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800ae3a:	625a      	str	r2, [r3, #36]	; 0x24
  MPU->CTRL = 0;
 800ae3c:	f8c3 1094 	str.w	r1, [r3, #148]	; 0x94
}
 800ae40:	4770      	bx	lr
 800ae42:	bf00      	nop
 800ae44:	e000ed00 	.word	0xe000ed00

0800ae48 <HAL_MPU_Enable>:
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
 800ae48:	4b06      	ldr	r3, [pc, #24]	; (800ae64 <HAL_MPU_Enable+0x1c>)
 800ae4a:	f040 0001 	orr.w	r0, r0, #1
 800ae4e:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 800ae52:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ae54:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800ae58:	625a      	str	r2, [r3, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
 800ae5a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800ae5e:	f3bf 8f6f 	isb	sy

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
 800ae62:	4770      	bx	lr
 800ae64:	e000ed00 	.word	0xe000ed00

0800ae68 <CRC_Handle_8>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 800ae68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __IO uint16_t *pReg;

  /* Processing time optimization: 4 bytes are entered in a row with a single word write,
   * last bytes must be carefully fed to the CRC calculator to ensure a correct type
   * handling by the peripheral */
  for (i = 0U; i < (BufferLength / 4U); i++)
 800ae6c:	0897      	lsrs	r7, r2, #2
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800ae6e:	6805      	ldr	r5, [r0, #0]
  for (i = 0U; i < (BufferLength / 4U); i++)
 800ae70:	d016      	beq.n	800aea0 <CRC_Handle_8+0x38>
 800ae72:	468c      	mov	ip, r1
 800ae74:	eb01 0687 	add.w	r6, r1, r7, lsl #2
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 800ae78:	f89c 3001 	ldrb.w	r3, [ip, #1]
  for (i = 0U; i < (BufferLength / 4U); i++)
 800ae7c:	f10c 0c04 	add.w	ip, ip, #4
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800ae80:	f81c 8c04 	ldrb.w	r8, [ip, #-4]
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 800ae84:	041b      	lsls	r3, r3, #16
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
                         (uint32_t)pBuffer[(4U * i) + 3U];
 800ae86:	f81c 4c01 	ldrb.w	r4, [ip, #-1]
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 800ae8a:	f81c ec02 	ldrb.w	lr, [ip, #-2]
  for (i = 0U; i < (BufferLength / 4U); i++)
 800ae8e:	4566      	cmp	r6, ip
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 800ae90:	ea43 6308 	orr.w	r3, r3, r8, lsl #24
 800ae94:	ea43 0304 	orr.w	r3, r3, r4
 800ae98:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 800ae9c:	602b      	str	r3, [r5, #0]
  for (i = 0U; i < (BufferLength / 4U); i++)
 800ae9e:	d1eb      	bne.n	800ae78 <CRC_Handle_8+0x10>
  }
  /* last bytes specific handling */
  if ((BufferLength % 4U) != 0U)
 800aea0:	f012 0203 	ands.w	r2, r2, #3
 800aea4:	d00b      	beq.n	800aebe <CRC_Handle_8+0x56>
  {
    if ((BufferLength % 4U) == 1U)
 800aea6:	2a01      	cmp	r2, #1
 800aea8:	d00c      	beq.n	800aec4 <CRC_Handle_8+0x5c>
    {
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[4U * i];         /* Derogation MisraC2012 R.11.5 */
    }
    if ((BufferLength % 4U) == 2U)
 800aeaa:	2a02      	cmp	r2, #2
 800aeac:	d111      	bne.n	800aed2 <CRC_Handle_8+0x6a>
    {
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 800aeae:	eb01 0387 	add.w	r3, r1, r7, lsl #2
 800aeb2:	f811 2027 	ldrb.w	r2, [r1, r7, lsl #2]
 800aeb6:	785b      	ldrb	r3, [r3, #1]
 800aeb8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
      pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                    /* Derogation MisraC2012 R.11.5 */
      *pReg = data;
 800aebc:	802b      	strh	r3, [r5, #0]
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
    }
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 800aebe:	6828      	ldr	r0, [r5, #0]
}
 800aec0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[4U * i];         /* Derogation MisraC2012 R.11.5 */
 800aec4:	f811 3027 	ldrb.w	r3, [r1, r7, lsl #2]
 800aec8:	702b      	strb	r3, [r5, #0]
      pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                    /* Derogation MisraC2012 R.11.5 */
 800aeca:	6805      	ldr	r5, [r0, #0]
  return hcrc->Instance->DR;
 800aecc:	6828      	ldr	r0, [r5, #0]
}
 800aece:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 800aed2:	f811 2027 	ldrb.w	r2, [r1, r7, lsl #2]
 800aed6:	eb01 0187 	add.w	r1, r1, r7, lsl #2
 800aeda:	784b      	ldrb	r3, [r1, #1]
 800aedc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
      *pReg = data;
 800aee0:	802b      	strh	r3, [r5, #0]
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
 800aee2:	788b      	ldrb	r3, [r1, #2]
 800aee4:	702b      	strb	r3, [r5, #0]
  return hcrc->Instance->DR;
 800aee6:	6805      	ldr	r5, [r0, #0]
 800aee8:	6828      	ldr	r0, [r5, #0]
}
 800aeea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800aeee:	bf00      	nop

0800aef0 <HAL_CRC_Init>:
  if (hcrc == NULL)
 800aef0:	2800      	cmp	r0, #0
 800aef2:	d036      	beq.n	800af62 <HAL_CRC_Init+0x72>
{
 800aef4:	b510      	push	{r4, lr}
  if (hcrc->State == HAL_CRC_STATE_RESET)
 800aef6:	7f43      	ldrb	r3, [r0, #29]
 800aef8:	4604      	mov	r4, r0
 800aefa:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800aefe:	b363      	cbz	r3, 800af5a <HAL_CRC_Init+0x6a>
  hcrc->State = HAL_CRC_STATE_BUSY;
 800af00:	2202      	movs	r2, #2
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 800af02:	7923      	ldrb	r3, [r4, #4]
  hcrc->State = HAL_CRC_STATE_BUSY;
 800af04:	7762      	strb	r2, [r4, #29]
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 800af06:	b9f3      	cbnz	r3, 800af46 <HAL_CRC_Init+0x56>
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 800af08:	6823      	ldr	r3, [r4, #0]
 800af0a:	4a17      	ldr	r2, [pc, #92]	; (800af68 <HAL_CRC_Init+0x78>)
 800af0c:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 800af0e:	689a      	ldr	r2, [r3, #8]
 800af10:	f022 0218 	bic.w	r2, r2, #24
 800af14:	609a      	str	r2, [r3, #8]
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 800af16:	7962      	ldrb	r2, [r4, #5]
 800af18:	b18a      	cbz	r2, 800af3e <HAL_CRC_Init+0x4e>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 800af1a:	6922      	ldr	r2, [r4, #16]
 800af1c:	611a      	str	r2, [r3, #16]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 800af1e:	6899      	ldr	r1, [r3, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 800af20:	e9d4 2005 	ldrd	r2, r0, [r4, #20]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 800af24:	f021 0160 	bic.w	r1, r1, #96	; 0x60
 800af28:	4311      	orrs	r1, r2
 800af2a:	6099      	str	r1, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 800af2c:	2101      	movs	r1, #1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 800af2e:	689a      	ldr	r2, [r3, #8]
 800af30:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800af34:	4302      	orrs	r2, r0
  return HAL_OK;
 800af36:	2000      	movs	r0, #0
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 800af38:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 800af3a:	7761      	strb	r1, [r4, #29]
}
 800af3c:	bd10      	pop	{r4, pc}
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 800af3e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800af42:	611a      	str	r2, [r3, #16]
 800af44:	e7eb      	b.n	800af1e <HAL_CRC_Init+0x2e>
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 800af46:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 800af4a:	4620      	mov	r0, r4
 800af4c:	f000 f890 	bl	800b070 <HAL_CRCEx_Polynomial_Set>
 800af50:	b908      	cbnz	r0, 800af56 <HAL_CRC_Init+0x66>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 800af52:	6823      	ldr	r3, [r4, #0]
 800af54:	e7df      	b.n	800af16 <HAL_CRC_Init+0x26>
    return HAL_ERROR;
 800af56:	2001      	movs	r0, #1
}
 800af58:	bd10      	pop	{r4, pc}
    hcrc->Lock = HAL_UNLOCKED;
 800af5a:	7702      	strb	r2, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 800af5c:	f7ff fbc0 	bl	800a6e0 <HAL_CRC_MspInit>
 800af60:	e7ce      	b.n	800af00 <HAL_CRC_Init+0x10>
    return HAL_ERROR;
 800af62:	2001      	movs	r0, #1
}
 800af64:	4770      	bx	lr
 800af66:	bf00      	nop
 800af68:	04c11db7 	.word	0x04c11db7

0800af6c <HAL_CRC_Accumulate>:
  hcrc->State = HAL_CRC_STATE_BUSY;
 800af6c:	2302      	movs	r3, #2
{
 800af6e:	468c      	mov	ip, r1
 800af70:	b570      	push	{r4, r5, r6, lr}
  hcrc->State = HAL_CRC_STATE_BUSY;
 800af72:	7743      	strb	r3, [r0, #29]
{
 800af74:	4605      	mov	r5, r0
  switch (hcrc->InputDataFormat)
 800af76:	6a03      	ldr	r3, [r0, #32]
{
 800af78:	4616      	mov	r6, r2
  switch (hcrc->InputDataFormat)
 800af7a:	2b02      	cmp	r3, #2
 800af7c:	d007      	beq.n	800af8e <HAL_CRC_Accumulate+0x22>
 800af7e:	2b03      	cmp	r3, #3
 800af80:	d023      	beq.n	800afca <HAL_CRC_Accumulate+0x5e>
 800af82:	2b01      	cmp	r3, #1
 800af84:	d01c      	beq.n	800afc0 <HAL_CRC_Accumulate+0x54>
  hcrc->State = HAL_CRC_STATE_READY;
 800af86:	2301      	movs	r3, #1
  switch (hcrc->InputDataFormat)
 800af88:	2000      	movs	r0, #0
  hcrc->State = HAL_CRC_STATE_READY;
 800af8a:	776b      	strb	r3, [r5, #29]
}
 800af8c:	bd70      	pop	{r4, r5, r6, pc}
  __IO uint16_t *pReg;

  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure
   * a correct type handling by the peripheral */
  for (i = 0U; i < (BufferLength / 2U); i++)
 800af8e:	0850      	lsrs	r0, r2, #1
 800af90:	d029      	beq.n	800afe6 <HAL_CRC_Accumulate+0x7a>
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800af92:	6829      	ldr	r1, [r5, #0]
  for (i = 0U; i < (BufferLength / 2U); i++)
 800af94:	2300      	movs	r3, #0
 800af96:	f10c 0e02 	add.w	lr, ip, #2
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800af9a:	f83c 2023 	ldrh.w	r2, [ip, r3, lsl #2]
 800af9e:	f83e 4023 	ldrh.w	r4, [lr, r3, lsl #2]
  for (i = 0U; i < (BufferLength / 2U); i++)
 800afa2:	3301      	adds	r3, #1
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800afa4:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
  for (i = 0U; i < (BufferLength / 2U); i++)
 800afa8:	4283      	cmp	r3, r0
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800afaa:	600c      	str	r4, [r1, #0]
  for (i = 0U; i < (BufferLength / 2U); i++)
 800afac:	d1f5      	bne.n	800af9a <HAL_CRC_Accumulate+0x2e>
  }
  if ((BufferLength % 2U) != 0U)
 800afae:	07f3      	lsls	r3, r6, #31
 800afb0:	d502      	bpl.n	800afb8 <HAL_CRC_Accumulate+0x4c>
  {
    pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                 /* Derogation MisraC2012 R.11.5 */
    *pReg = pBuffer[2U * i];
 800afb2:	f83c 3020 	ldrh.w	r3, [ip, r0, lsl #2]
 800afb6:	800b      	strh	r3, [r1, #0]
  hcrc->State = HAL_CRC_STATE_READY;
 800afb8:	2301      	movs	r3, #1
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 800afba:	6808      	ldr	r0, [r1, #0]
  hcrc->State = HAL_CRC_STATE_READY;
 800afbc:	776b      	strb	r3, [r5, #29]
}
 800afbe:	bd70      	pop	{r4, r5, r6, pc}
      temp = CRC_Handle_8(hcrc, (uint8_t *)pBuffer, BufferLength);
 800afc0:	f7ff ff52 	bl	800ae68 <CRC_Handle_8>
  hcrc->State = HAL_CRC_STATE_READY;
 800afc4:	2301      	movs	r3, #1
 800afc6:	776b      	strb	r3, [r5, #29]
}
 800afc8:	bd70      	pop	{r4, r5, r6, pc}
      for (index = 0U; index < BufferLength; index++)
 800afca:	b172      	cbz	r2, 800afea <HAL_CRC_Accumulate+0x7e>
 800afcc:	3904      	subs	r1, #4
        hcrc->Instance->DR = pBuffer[index];
 800afce:	6800      	ldr	r0, [r0, #0]
 800afd0:	eb01 0682 	add.w	r6, r1, r2, lsl #2
 800afd4:	f851 3f04 	ldr.w	r3, [r1, #4]!
      for (index = 0U; index < BufferLength; index++)
 800afd8:	428e      	cmp	r6, r1
        hcrc->Instance->DR = pBuffer[index];
 800afda:	6003      	str	r3, [r0, #0]
      for (index = 0U; index < BufferLength; index++)
 800afdc:	d1fa      	bne.n	800afd4 <HAL_CRC_Accumulate+0x68>
  hcrc->State = HAL_CRC_STATE_READY;
 800afde:	2301      	movs	r3, #1
      temp = hcrc->Instance->DR;
 800afe0:	6800      	ldr	r0, [r0, #0]
  hcrc->State = HAL_CRC_STATE_READY;
 800afe2:	776b      	strb	r3, [r5, #29]
}
 800afe4:	bd70      	pop	{r4, r5, r6, pc}
      temp = hcrc->Instance->DR;
 800afe6:	6829      	ldr	r1, [r5, #0]
 800afe8:	e7e1      	b.n	800afae <HAL_CRC_Accumulate+0x42>
 800afea:	6800      	ldr	r0, [r0, #0]
 800afec:	e7f7      	b.n	800afde <HAL_CRC_Accumulate+0x72>
 800afee:	bf00      	nop

0800aff0 <HAL_CRC_Calculate>:
{
 800aff0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  hcrc->State = HAL_CRC_STATE_BUSY;
 800aff2:	2302      	movs	r3, #2
  __HAL_CRC_DR_RESET(hcrc);
 800aff4:	6805      	ldr	r5, [r0, #0]
{
 800aff6:	4606      	mov	r6, r0
 800aff8:	468c      	mov	ip, r1
  hcrc->State = HAL_CRC_STATE_BUSY;
 800affa:	7743      	strb	r3, [r0, #29]
{
 800affc:	4617      	mov	r7, r2
  __HAL_CRC_DR_RESET(hcrc);
 800affe:	68ab      	ldr	r3, [r5, #8]
 800b000:	f043 0301 	orr.w	r3, r3, #1
 800b004:	60ab      	str	r3, [r5, #8]
  switch (hcrc->InputDataFormat)
 800b006:	6a03      	ldr	r3, [r0, #32]
 800b008:	2b02      	cmp	r3, #2
 800b00a:	d007      	beq.n	800b01c <HAL_CRC_Calculate+0x2c>
 800b00c:	2b03      	cmp	r3, #3
 800b00e:	d022      	beq.n	800b056 <HAL_CRC_Calculate+0x66>
 800b010:	2b01      	cmp	r3, #1
 800b012:	d01b      	beq.n	800b04c <HAL_CRC_Calculate+0x5c>
  hcrc->State = HAL_CRC_STATE_READY;
 800b014:	2301      	movs	r3, #1
  switch (hcrc->InputDataFormat)
 800b016:	2000      	movs	r0, #0
  hcrc->State = HAL_CRC_STATE_READY;
 800b018:	7773      	strb	r3, [r6, #29]
}
 800b01a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  for (i = 0U; i < (BufferLength / 2U); i++)
 800b01c:	0851      	lsrs	r1, r2, #1
 800b01e:	d00c      	beq.n	800b03a <HAL_CRC_Calculate+0x4a>
 800b020:	2300      	movs	r3, #0
 800b022:	f10c 0002 	add.w	r0, ip, #2
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800b026:	f83c 2023 	ldrh.w	r2, [ip, r3, lsl #2]
 800b02a:	f830 4023 	ldrh.w	r4, [r0, r3, lsl #2]
  for (i = 0U; i < (BufferLength / 2U); i++)
 800b02e:	3301      	adds	r3, #1
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800b030:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
  for (i = 0U; i < (BufferLength / 2U); i++)
 800b034:	428b      	cmp	r3, r1
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 800b036:	602c      	str	r4, [r5, #0]
  for (i = 0U; i < (BufferLength / 2U); i++)
 800b038:	d1f5      	bne.n	800b026 <HAL_CRC_Calculate+0x36>
  if ((BufferLength % 2U) != 0U)
 800b03a:	07fb      	lsls	r3, r7, #31
 800b03c:	d502      	bpl.n	800b044 <HAL_CRC_Calculate+0x54>
    *pReg = pBuffer[2U * i];
 800b03e:	f83c 3021 	ldrh.w	r3, [ip, r1, lsl #2]
 800b042:	802b      	strh	r3, [r5, #0]
  return hcrc->Instance->DR;
 800b044:	6828      	ldr	r0, [r5, #0]
  hcrc->State = HAL_CRC_STATE_READY;
 800b046:	2301      	movs	r3, #1
 800b048:	7773      	strb	r3, [r6, #29]
}
 800b04a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      temp = CRC_Handle_8(hcrc, (uint8_t *)pBuffer, BufferLength);
 800b04c:	f7ff ff0c 	bl	800ae68 <CRC_Handle_8>
  hcrc->State = HAL_CRC_STATE_READY;
 800b050:	2301      	movs	r3, #1
 800b052:	7773      	strb	r3, [r6, #29]
}
 800b054:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      for (index = 0U; index < BufferLength; index++)
 800b056:	2a00      	cmp	r2, #0
 800b058:	d0f4      	beq.n	800b044 <HAL_CRC_Calculate+0x54>
 800b05a:	3904      	subs	r1, #4
 800b05c:	eb01 0782 	add.w	r7, r1, r2, lsl #2
        hcrc->Instance->DR = pBuffer[index];
 800b060:	f851 3f04 	ldr.w	r3, [r1, #4]!
      for (index = 0U; index < BufferLength; index++)
 800b064:	428f      	cmp	r7, r1
        hcrc->Instance->DR = pBuffer[index];
 800b066:	602b      	str	r3, [r5, #0]
      for (index = 0U; index < BufferLength; index++)
 800b068:	d1fa      	bne.n	800b060 <HAL_CRC_Calculate+0x70>
  return hcrc->Instance->DR;
 800b06a:	6828      	ldr	r0, [r5, #0]
      break;
 800b06c:	e7eb      	b.n	800b046 <HAL_CRC_Calculate+0x56>
 800b06e:	bf00      	nop

0800b070 <HAL_CRCEx_Polynomial_Set>:
   * definition. HAL_ERROR is reported if Pol degree is
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 800b070:	231e      	movs	r3, #30
{
 800b072:	b410      	push	{r4}
 800b074:	e001      	b.n	800b07a <HAL_CRCEx_Polynomial_Set+0xa>
  while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 800b076:	3b01      	subs	r3, #1
 800b078:	d315      	bcc.n	800b0a6 <HAL_CRCEx_Polynomial_Set+0x36>
 800b07a:	fa21 fc03 	lsr.w	ip, r1, r3
 800b07e:	f01c 0f01 	tst.w	ip, #1
 800b082:	d0f8      	beq.n	800b076 <HAL_CRCEx_Polynomial_Set+0x6>
  {
  }

  switch (PolyLength)
 800b084:	2a18      	cmp	r2, #24
 800b086:	d80f      	bhi.n	800b0a8 <HAL_CRCEx_Polynomial_Set+0x38>
 800b088:	e8df f002 	tbb	[pc, r2]
 800b08c:	0e0e0e14 	.word	0x0e0e0e14
 800b090:	0e0e0e0e 	.word	0x0e0e0e0e
 800b094:	0e0e0e1f 	.word	0x0e0e0e1f
 800b098:	0e0e0e0e 	.word	0x0e0e0e0e
 800b09c:	0e0e0e22 	.word	0x0e0e0e22
 800b0a0:	0e0e0e0e 	.word	0x0e0e0e0e
 800b0a4:	12          	.byte	0x12
 800b0a5:	00          	.byte	0x00
 800b0a6:	b12a      	cbz	r2, 800b0b4 <HAL_CRCEx_Polynomial_Set+0x44>

    case CRC_POLYLENGTH_32B:
      /* no polynomial definition vs. polynomial length issue possible */
      break;
    default:
      status =  HAL_ERROR;
 800b0a8:	2001      	movs	r0, #1
    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
  }
  /* Return function status */
  return status;
}
 800b0aa:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b0ae:	4770      	bx	lr
      if (msb >= HAL_CRC_LENGTH_7B)
 800b0b0:	2b06      	cmp	r3, #6
 800b0b2:	d8f9      	bhi.n	800b0a8 <HAL_CRCEx_Polynomial_Set+0x38>
    WRITE_REG(hcrc->Instance->POL, Pol);
 800b0b4:	6804      	ldr	r4, [r0, #0]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 800b0b6:	2000      	movs	r0, #0
    WRITE_REG(hcrc->Instance->POL, Pol);
 800b0b8:	6161      	str	r1, [r4, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 800b0ba:	68a3      	ldr	r3, [r4, #8]
 800b0bc:	f023 0318 	bic.w	r3, r3, #24
 800b0c0:	431a      	orrs	r2, r3
 800b0c2:	60a2      	str	r2, [r4, #8]
}
 800b0c4:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b0c8:	4770      	bx	lr
      if (msb >= HAL_CRC_LENGTH_16B)
 800b0ca:	2b0f      	cmp	r3, #15
 800b0cc:	d9f2      	bls.n	800b0b4 <HAL_CRCEx_Polynomial_Set+0x44>
 800b0ce:	e7eb      	b.n	800b0a8 <HAL_CRCEx_Polynomial_Set+0x38>
      if (msb >= HAL_CRC_LENGTH_8B)
 800b0d0:	2b07      	cmp	r3, #7
 800b0d2:	d9ef      	bls.n	800b0b4 <HAL_CRCEx_Polynomial_Set+0x44>
 800b0d4:	e7e8      	b.n	800b0a8 <HAL_CRCEx_Polynomial_Set+0x38>
 800b0d6:	bf00      	nop

0800b0d8 <DMA_CalcBaseAndBitshift>:
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800b0d8:	6802      	ldr	r2, [r0, #0]
 800b0da:	4b34      	ldr	r3, [pc, #208]	; (800b1ac <DMA_CalcBaseAndBitshift+0xd4>)
 800b0dc:	4934      	ldr	r1, [pc, #208]	; (800b1b0 <DMA_CalcBaseAndBitshift+0xd8>)
{
 800b0de:	b430      	push	{r4, r5}
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800b0e0:	4d34      	ldr	r5, [pc, #208]	; (800b1b4 <DMA_CalcBaseAndBitshift+0xdc>)
 800b0e2:	4c35      	ldr	r4, [pc, #212]	; (800b1b8 <DMA_CalcBaseAndBitshift+0xe0>)
 800b0e4:	42aa      	cmp	r2, r5
 800b0e6:	bf18      	it	ne
 800b0e8:	429a      	cmpne	r2, r3
 800b0ea:	bf0c      	ite	eq
 800b0ec:	2301      	moveq	r3, #1
 800b0ee:	2300      	movne	r3, #0
 800b0f0:	428a      	cmp	r2, r1
 800b0f2:	bf08      	it	eq
 800b0f4:	f043 0301 	orreq.w	r3, r3, #1
 800b0f8:	3130      	adds	r1, #48	; 0x30
 800b0fa:	42a2      	cmp	r2, r4
 800b0fc:	bf08      	it	eq
 800b0fe:	f043 0301 	orreq.w	r3, r3, #1
 800b102:	3430      	adds	r4, #48	; 0x30
 800b104:	428a      	cmp	r2, r1
 800b106:	bf08      	it	eq
 800b108:	f043 0301 	orreq.w	r3, r3, #1
 800b10c:	3130      	adds	r1, #48	; 0x30
 800b10e:	42a2      	cmp	r2, r4
 800b110:	bf08      	it	eq
 800b112:	f043 0301 	orreq.w	r3, r3, #1
 800b116:	3430      	adds	r4, #48	; 0x30
 800b118:	428a      	cmp	r2, r1
 800b11a:	bf08      	it	eq
 800b11c:	f043 0301 	orreq.w	r3, r3, #1
 800b120:	f501 715c 	add.w	r1, r1, #880	; 0x370
 800b124:	42a2      	cmp	r2, r4
 800b126:	bf08      	it	eq
 800b128:	f043 0301 	orreq.w	r3, r3, #1
 800b12c:	f504 745c 	add.w	r4, r4, #880	; 0x370
 800b130:	428a      	cmp	r2, r1
 800b132:	bf08      	it	eq
 800b134:	f043 0301 	orreq.w	r3, r3, #1
 800b138:	3130      	adds	r1, #48	; 0x30
 800b13a:	42a2      	cmp	r2, r4
 800b13c:	bf08      	it	eq
 800b13e:	f043 0301 	orreq.w	r3, r3, #1
 800b142:	3430      	adds	r4, #48	; 0x30
 800b144:	428a      	cmp	r2, r1
 800b146:	bf08      	it	eq
 800b148:	f043 0301 	orreq.w	r3, r3, #1
 800b14c:	3130      	adds	r1, #48	; 0x30
 800b14e:	42a2      	cmp	r2, r4
 800b150:	bf08      	it	eq
 800b152:	f043 0301 	orreq.w	r3, r3, #1
 800b156:	3430      	adds	r4, #48	; 0x30
 800b158:	428a      	cmp	r2, r1
 800b15a:	bf08      	it	eq
 800b15c:	f043 0301 	orreq.w	r3, r3, #1
 800b160:	3130      	adds	r1, #48	; 0x30
 800b162:	42a2      	cmp	r2, r4
 800b164:	bf08      	it	eq
 800b166:	f043 0301 	orreq.w	r3, r3, #1
 800b16a:	428a      	cmp	r2, r1
 800b16c:	bf08      	it	eq
 800b16e:	f043 0301 	orreq.w	r3, r3, #1
 800b172:	b913      	cbnz	r3, 800b17a <DMA_CalcBaseAndBitshift+0xa2>
 800b174:	4b11      	ldr	r3, [pc, #68]	; (800b1bc <DMA_CalcBaseAndBitshift+0xe4>)
 800b176:	429a      	cmp	r2, r3
 800b178:	d113      	bne.n	800b1a2 <DMA_CalcBaseAndBitshift+0xca>
  {
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 800b17a:	b2d3      	uxtb	r3, r2
 800b17c:	4910      	ldr	r1, [pc, #64]	; (800b1c0 <DMA_CalcBaseAndBitshift+0xe8>)

    /* lookup table for necessary bitshift of flags within status registers */
    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 800b17e:	4c11      	ldr	r4, [pc, #68]	; (800b1c4 <DMA_CalcBaseAndBitshift+0xec>)
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 800b180:	3b10      	subs	r3, #16
 800b182:	fba1 5103 	umull	r5, r1, r1, r3

    if (stream_number > 3U)
 800b186:	2b5f      	cmp	r3, #95	; 0x5f
    {
      /* return pointer to HISR and HIFCR */
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
 800b188:	4b0f      	ldr	r3, [pc, #60]	; (800b1c8 <DMA_CalcBaseAndBitshift+0xf0>)
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 800b18a:	f3c1 1102 	ubfx	r1, r1, #4, #3
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
 800b18e:	ea03 0302 	and.w	r3, r3, r2
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 800b192:	5c61      	ldrb	r1, [r4, r1]
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
 800b194:	bf88      	it	hi
 800b196:	3304      	addhi	r3, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 800b198:	65c1      	str	r1, [r0, #92]	; 0x5c
    }
    else
    {
      /* return pointer to LISR and LIFCR */
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
 800b19a:	6583      	str	r3, [r0, #88]	; 0x58
    /* return pointer to ISR and IFCR */
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
  }

  return hdma->StreamBaseAddress;
}
 800b19c:	4618      	mov	r0, r3
 800b19e:	bc30      	pop	{r4, r5}
 800b1a0:	4770      	bx	lr
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
 800b1a2:	f022 03ff 	bic.w	r3, r2, #255	; 0xff
 800b1a6:	6583      	str	r3, [r0, #88]	; 0x58
 800b1a8:	e7f8      	b.n	800b19c <DMA_CalcBaseAndBitshift+0xc4>
 800b1aa:	bf00      	nop
 800b1ac:	40020010 	.word	0x40020010
 800b1b0:	40020040 	.word	0x40020040
 800b1b4:	40020028 	.word	0x40020028
 800b1b8:	40020058 	.word	0x40020058
 800b1bc:	400204b8 	.word	0x400204b8
 800b1c0:	aaaaaaab 	.word	0xaaaaaaab
 800b1c4:	24008274 	.word	0x24008274
 800b1c8:	fffffc00 	.word	0xfffffc00

0800b1cc <DMA_CalcDMAMUXChannelBaseAndMask>:
  * @retval HAL status
  */
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number;
  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);
 800b1cc:	6803      	ldr	r3, [r0, #0]

  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 800b1ce:	4a29      	ldr	r2, [pc, #164]	; (800b274 <DMA_CalcDMAMUXChannelBaseAndMask+0xa8>)
 800b1d0:	4929      	ldr	r1, [pc, #164]	; (800b278 <DMA_CalcDMAMUXChannelBaseAndMask+0xac>)
{
 800b1d2:	b430      	push	{r4, r5}
  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 800b1d4:	4d29      	ldr	r5, [pc, #164]	; (800b27c <DMA_CalcDMAMUXChannelBaseAndMask+0xb0>)
 800b1d6:	4c2a      	ldr	r4, [pc, #168]	; (800b280 <DMA_CalcDMAMUXChannelBaseAndMask+0xb4>)
 800b1d8:	42ab      	cmp	r3, r5
 800b1da:	bf18      	it	ne
 800b1dc:	4293      	cmpne	r3, r2
 800b1de:	bf0c      	ite	eq
 800b1e0:	2201      	moveq	r2, #1
 800b1e2:	2200      	movne	r2, #0
 800b1e4:	428b      	cmp	r3, r1
 800b1e6:	bf08      	it	eq
 800b1e8:	f042 0201 	orreq.w	r2, r2, #1
 800b1ec:	3128      	adds	r1, #40	; 0x28
 800b1ee:	42a3      	cmp	r3, r4
 800b1f0:	bf08      	it	eq
 800b1f2:	f042 0201 	orreq.w	r2, r2, #1
 800b1f6:	3428      	adds	r4, #40	; 0x28
 800b1f8:	428b      	cmp	r3, r1
 800b1fa:	bf08      	it	eq
 800b1fc:	f042 0201 	orreq.w	r2, r2, #1
 800b200:	3128      	adds	r1, #40	; 0x28
 800b202:	42a3      	cmp	r3, r4
 800b204:	bf08      	it	eq
 800b206:	f042 0201 	orreq.w	r2, r2, #1
 800b20a:	428b      	cmp	r3, r1
 800b20c:	bf08      	it	eq
 800b20e:	f042 0201 	orreq.w	r2, r2, #1
 800b212:	b912      	cbnz	r2, 800b21a <DMA_CalcDMAMUXChannelBaseAndMask+0x4e>
 800b214:	4a1b      	ldr	r2, [pc, #108]	; (800b284 <DMA_CalcDMAMUXChannelBaseAndMask+0xb8>)
 800b216:	4293      	cmp	r3, r2
 800b218:	d113      	bne.n	800b242 <DMA_CalcDMAMUXChannelBaseAndMask+0x76>
  {
    /* BDMA Channels are connected to DMAMUX2 channels */
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 800b21a:	b2db      	uxtb	r3, r3
 800b21c:	4c1a      	ldr	r4, [pc, #104]	; (800b288 <DMA_CalcDMAMUXChannelBaseAndMask+0xbc>)
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 800b21e:	4a1b      	ldr	r2, [pc, #108]	; (800b28c <DMA_CalcDMAMUXChannelBaseAndMask+0xc0>)
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 800b220:	2101      	movs	r1, #1
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 800b222:	3b08      	subs	r3, #8
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
 800b224:	4d1a      	ldr	r5, [pc, #104]	; (800b290 <DMA_CalcDMAMUXChannelBaseAndMask+0xc4>)
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 800b226:	fba4 4303 	umull	r4, r3, r4, r3
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
 800b22a:	6645      	str	r5, [r0, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 800b22c:	eb02 1213 	add.w	r2, r2, r3, lsr #4
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 800b230:	f3c3 1304 	ubfx	r3, r3, #4, #5
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 800b234:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 800b236:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 800b23a:	6602      	str	r2, [r0, #96]	; 0x60
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 800b23c:	6683      	str	r3, [r0, #104]	; 0x68
    }
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
  }
}
 800b23e:	bc30      	pop	{r4, r5}
 800b240:	4770      	bx	lr
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 800b242:	b2da      	uxtb	r2, r3
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 800b244:	4913      	ldr	r1, [pc, #76]	; (800b294 <DMA_CalcDMAMUXChannelBaseAndMask+0xc8>)
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 800b246:	4c14      	ldr	r4, [pc, #80]	; (800b298 <DMA_CalcDMAMUXChannelBaseAndMask+0xcc>)
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 800b248:	4419      	add	r1, r3
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 800b24a:	3a10      	subs	r2, #16
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 800b24c:	29a8      	cmp	r1, #168	; 0xa8
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 800b24e:	fba4 2302 	umull	r2, r3, r4, r2
 800b252:	ea4f 1313 	mov.w	r3, r3, lsr #4
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 800b256:	d800      	bhi.n	800b25a <DMA_CalcDMAMUXChannelBaseAndMask+0x8e>
      stream_number += 8U;
 800b258:	3308      	adds	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 800b25a:	4a10      	ldr	r2, [pc, #64]	; (800b29c <DMA_CalcDMAMUXChannelBaseAndMask+0xd0>)
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 800b25c:	f003 051f 	and.w	r5, r3, #31
 800b260:	2101      	movs	r1, #1
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 800b262:	4c0f      	ldr	r4, [pc, #60]	; (800b2a0 <DMA_CalcDMAMUXChannelBaseAndMask+0xd4>)
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 800b264:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 800b266:	40a9      	lsls	r1, r5
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 800b268:	6644      	str	r4, [r0, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 800b26a:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 800b26c:	6681      	str	r1, [r0, #104]	; 0x68
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 800b26e:	6602      	str	r2, [r0, #96]	; 0x60
}
 800b270:	e7e5      	b.n	800b23e <DMA_CalcDMAMUXChannelBaseAndMask+0x72>
 800b272:	bf00      	nop
 800b274:	58025408 	.word	0x58025408
 800b278:	58025430 	.word	0x58025430
 800b27c:	5802541c 	.word	0x5802541c
 800b280:	58025444 	.word	0x58025444
 800b284:	58025494 	.word	0x58025494
 800b288:	cccccccd 	.word	0xcccccccd
 800b28c:	16009600 	.word	0x16009600
 800b290:	58025880 	.word	0x58025880
 800b294:	bffdfbf0 	.word	0xbffdfbf0
 800b298:	aaaaaaab 	.word	0xaaaaaaab
 800b29c:	10008200 	.word	0x10008200
 800b2a0:	40020880 	.word	0x40020880

0800b2a4 <HAL_DMA_Init>:
{
 800b2a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b2a6:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 800b2a8:	f7ff fd30 	bl	800ad0c <HAL_GetTick>
  if(hdma == NULL)
 800b2ac:	2c00      	cmp	r4, #0
 800b2ae:	f000 8177 	beq.w	800b5a0 <HAL_DMA_Init+0x2fc>
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800b2b2:	6823      	ldr	r3, [r4, #0]
 800b2b4:	4605      	mov	r5, r0
 800b2b6:	4a92      	ldr	r2, [pc, #584]	; (800b500 <HAL_DMA_Init+0x25c>)
 800b2b8:	4293      	cmp	r3, r2
 800b2ba:	d048      	beq.n	800b34e <HAL_DMA_Init+0xaa>
 800b2bc:	3218      	adds	r2, #24
 800b2be:	4293      	cmp	r3, r2
 800b2c0:	d045      	beq.n	800b34e <HAL_DMA_Init+0xaa>
 800b2c2:	3230      	adds	r2, #48	; 0x30
 800b2c4:	498f      	ldr	r1, [pc, #572]	; (800b504 <HAL_DMA_Init+0x260>)
 800b2c6:	428b      	cmp	r3, r1
 800b2c8:	bf18      	it	ne
 800b2ca:	4293      	cmpne	r3, r2
 800b2cc:	f101 0130 	add.w	r1, r1, #48	; 0x30
 800b2d0:	bf0c      	ite	eq
 800b2d2:	2201      	moveq	r2, #1
 800b2d4:	2200      	movne	r2, #0
 800b2d6:	428b      	cmp	r3, r1
 800b2d8:	bf08      	it	eq
 800b2da:	f042 0201 	orreq.w	r2, r2, #1
 800b2de:	3118      	adds	r1, #24
 800b2e0:	428b      	cmp	r3, r1
 800b2e2:	bf08      	it	eq
 800b2e4:	f042 0201 	orreq.w	r2, r2, #1
 800b2e8:	3118      	adds	r1, #24
 800b2ea:	428b      	cmp	r3, r1
 800b2ec:	bf08      	it	eq
 800b2ee:	f042 0201 	orreq.w	r2, r2, #1
 800b2f2:	3118      	adds	r1, #24
 800b2f4:	428b      	cmp	r3, r1
 800b2f6:	bf08      	it	eq
 800b2f8:	f042 0201 	orreq.w	r2, r2, #1
 800b2fc:	f501 7156 	add.w	r1, r1, #856	; 0x358
 800b300:	428b      	cmp	r3, r1
 800b302:	bf08      	it	eq
 800b304:	f042 0201 	orreq.w	r2, r2, #1
 800b308:	3118      	adds	r1, #24
 800b30a:	428b      	cmp	r3, r1
 800b30c:	bf08      	it	eq
 800b30e:	f042 0201 	orreq.w	r2, r2, #1
 800b312:	3118      	adds	r1, #24
 800b314:	428b      	cmp	r3, r1
 800b316:	bf08      	it	eq
 800b318:	f042 0201 	orreq.w	r2, r2, #1
 800b31c:	3118      	adds	r1, #24
 800b31e:	428b      	cmp	r3, r1
 800b320:	bf08      	it	eq
 800b322:	f042 0201 	orreq.w	r2, r2, #1
 800b326:	3118      	adds	r1, #24
 800b328:	428b      	cmp	r3, r1
 800b32a:	bf08      	it	eq
 800b32c:	f042 0201 	orreq.w	r2, r2, #1
 800b330:	3118      	adds	r1, #24
 800b332:	428b      	cmp	r3, r1
 800b334:	bf08      	it	eq
 800b336:	f042 0201 	orreq.w	r2, r2, #1
 800b33a:	3118      	adds	r1, #24
 800b33c:	428b      	cmp	r3, r1
 800b33e:	bf08      	it	eq
 800b340:	f042 0201 	orreq.w	r2, r2, #1
 800b344:	b91a      	cbnz	r2, 800b34e <HAL_DMA_Init+0xaa>
 800b346:	4a70      	ldr	r2, [pc, #448]	; (800b508 <HAL_DMA_Init+0x264>)
 800b348:	4293      	cmp	r3, r2
 800b34a:	f040 8198 	bne.w	800b67e <HAL_DMA_Init+0x3da>
    __HAL_UNLOCK(hdma);
 800b34e:	2200      	movs	r2, #0
    hdma->State = HAL_DMA_STATE_BUSY;
 800b350:	2102      	movs	r1, #2
    __HAL_UNLOCK(hdma);
 800b352:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    hdma->State = HAL_DMA_STATE_BUSY;
 800b356:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
 800b35a:	681a      	ldr	r2, [r3, #0]
 800b35c:	f022 0201 	bic.w	r2, r2, #1
 800b360:	601a      	str	r2, [r3, #0]
 800b362:	e006      	b.n	800b372 <HAL_DMA_Init+0xce>
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 800b364:	f7ff fcd2 	bl	800ad0c <HAL_GetTick>
 800b368:	1b43      	subs	r3, r0, r5
 800b36a:	2b05      	cmp	r3, #5
 800b36c:	f200 80ff 	bhi.w	800b56e <HAL_DMA_Init+0x2ca>
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
 800b370:	6823      	ldr	r3, [r4, #0]
 800b372:	681a      	ldr	r2, [r3, #0]
 800b374:	07d6      	lsls	r6, r2, #31
 800b376:	d4f5      	bmi.n	800b364 <HAL_DMA_Init+0xc0>
    registerValue |=  hdma->Init.Direction           |
 800b378:	e9d4 2502 	ldrd	r2, r5, [r4, #8]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800b37c:	6920      	ldr	r0, [r4, #16]
    registerValue |=  hdma->Init.Direction           |
 800b37e:	432a      	orrs	r2, r5
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800b380:	69a1      	ldr	r1, [r4, #24]
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;
 800b382:	681d      	ldr	r5, [r3, #0]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800b384:	4302      	orrs	r2, r0
 800b386:	6960      	ldr	r0, [r4, #20]
 800b388:	4302      	orrs	r2, r0
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800b38a:	69e0      	ldr	r0, [r4, #28]
 800b38c:	430a      	orrs	r2, r1
 800b38e:	4302      	orrs	r2, r0
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 800b390:	485e      	ldr	r0, [pc, #376]	; (800b50c <HAL_DMA_Init+0x268>)
 800b392:	4028      	ands	r0, r5
            hdma->Init.Mode                | hdma->Init.Priority;
 800b394:	6a25      	ldr	r5, [r4, #32]
 800b396:	432a      	orrs	r2, r5
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
 800b398:	4d5d      	ldr	r5, [pc, #372]	; (800b510 <HAL_DMA_Init+0x26c>)
    registerValue |=  hdma->Init.Direction           |
 800b39a:	4302      	orrs	r2, r0
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800b39c:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b39e:	2804      	cmp	r0, #4
 800b3a0:	f000 8100 	beq.w	800b5a4 <HAL_DMA_Init+0x300>
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
 800b3a4:	682e      	ldr	r6, [r5, #0]
 800b3a6:	4d5b      	ldr	r5, [pc, #364]	; (800b514 <HAL_DMA_Init+0x270>)
 800b3a8:	4035      	ands	r5, r6
 800b3aa:	f1b5 5f00 	cmp.w	r5, #536870912	; 0x20000000
 800b3ae:	f080 80bb 	bcs.w	800b528 <HAL_DMA_Init+0x284>
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
 800b3b2:	601a      	str	r2, [r3, #0]
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
 800b3b4:	695a      	ldr	r2, [r3, #20]
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 800b3b6:	f022 0207 	bic.w	r2, r2, #7
    registerValue |= hdma->Init.FIFOMode;
 800b3ba:	4302      	orrs	r2, r0
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;
 800b3bc:	615a      	str	r2, [r3, #20]
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 800b3be:	4620      	mov	r0, r4
 800b3c0:	f7ff fe8a 	bl	800b0d8 <DMA_CalcBaseAndBitshift>
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 800b3c4:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 800b3c6:	233f      	movs	r3, #63	; 0x3f
 800b3c8:	f002 021f 	and.w	r2, r2, #31
 800b3cc:	4093      	lsls	r3, r2
 800b3ce:	6083      	str	r3, [r0, #8]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800b3d0:	6822      	ldr	r2, [r4, #0]
 800b3d2:	4b4b      	ldr	r3, [pc, #300]	; (800b500 <HAL_DMA_Init+0x25c>)
 800b3d4:	4850      	ldr	r0, [pc, #320]	; (800b518 <HAL_DMA_Init+0x274>)
 800b3d6:	494b      	ldr	r1, [pc, #300]	; (800b504 <HAL_DMA_Init+0x260>)
 800b3d8:	4282      	cmp	r2, r0
 800b3da:	bf18      	it	ne
 800b3dc:	429a      	cmpne	r2, r3
 800b3de:	f100 0030 	add.w	r0, r0, #48	; 0x30
 800b3e2:	bf0c      	ite	eq
 800b3e4:	2301      	moveq	r3, #1
 800b3e6:	2300      	movne	r3, #0
 800b3e8:	428a      	cmp	r2, r1
 800b3ea:	bf08      	it	eq
 800b3ec:	f043 0301 	orreq.w	r3, r3, #1
 800b3f0:	3130      	adds	r1, #48	; 0x30
 800b3f2:	4282      	cmp	r2, r0
 800b3f4:	bf08      	it	eq
 800b3f6:	f043 0301 	orreq.w	r3, r3, #1
 800b3fa:	3030      	adds	r0, #48	; 0x30
 800b3fc:	428a      	cmp	r2, r1
 800b3fe:	bf08      	it	eq
 800b400:	f043 0301 	orreq.w	r3, r3, #1
 800b404:	3130      	adds	r1, #48	; 0x30
 800b406:	4282      	cmp	r2, r0
 800b408:	bf08      	it	eq
 800b40a:	f043 0301 	orreq.w	r3, r3, #1
 800b40e:	3030      	adds	r0, #48	; 0x30
 800b410:	428a      	cmp	r2, r1
 800b412:	bf08      	it	eq
 800b414:	f043 0301 	orreq.w	r3, r3, #1
 800b418:	f501 715c 	add.w	r1, r1, #880	; 0x370
 800b41c:	4282      	cmp	r2, r0
 800b41e:	bf08      	it	eq
 800b420:	f043 0301 	orreq.w	r3, r3, #1
 800b424:	f500 705c 	add.w	r0, r0, #880	; 0x370
 800b428:	428a      	cmp	r2, r1
 800b42a:	bf08      	it	eq
 800b42c:	f043 0301 	orreq.w	r3, r3, #1
 800b430:	3130      	adds	r1, #48	; 0x30
 800b432:	4282      	cmp	r2, r0
 800b434:	bf08      	it	eq
 800b436:	f043 0301 	orreq.w	r3, r3, #1
 800b43a:	3030      	adds	r0, #48	; 0x30
 800b43c:	428a      	cmp	r2, r1
 800b43e:	bf08      	it	eq
 800b440:	f043 0301 	orreq.w	r3, r3, #1
 800b444:	3130      	adds	r1, #48	; 0x30
 800b446:	4282      	cmp	r2, r0
 800b448:	bf08      	it	eq
 800b44a:	f043 0301 	orreq.w	r3, r3, #1
 800b44e:	3030      	adds	r0, #48	; 0x30
 800b450:	428a      	cmp	r2, r1
 800b452:	bf08      	it	eq
 800b454:	f043 0301 	orreq.w	r3, r3, #1
 800b458:	3130      	adds	r1, #48	; 0x30
 800b45a:	4282      	cmp	r2, r0
 800b45c:	bf08      	it	eq
 800b45e:	f043 0301 	orreq.w	r3, r3, #1
 800b462:	3030      	adds	r0, #48	; 0x30
 800b464:	428a      	cmp	r2, r1
 800b466:	bf08      	it	eq
 800b468:	f043 0301 	orreq.w	r3, r3, #1
 800b46c:	492b      	ldr	r1, [pc, #172]	; (800b51c <HAL_DMA_Init+0x278>)
 800b46e:	4282      	cmp	r2, r0
 800b470:	bf08      	it	eq
 800b472:	f043 0301 	orreq.w	r3, r3, #1
 800b476:	482a      	ldr	r0, [pc, #168]	; (800b520 <HAL_DMA_Init+0x27c>)
 800b478:	428a      	cmp	r2, r1
 800b47a:	bf08      	it	eq
 800b47c:	f043 0301 	orreq.w	r3, r3, #1
 800b480:	3128      	adds	r1, #40	; 0x28
 800b482:	4282      	cmp	r2, r0
 800b484:	bf08      	it	eq
 800b486:	f043 0301 	orreq.w	r3, r3, #1
 800b48a:	3028      	adds	r0, #40	; 0x28
 800b48c:	428a      	cmp	r2, r1
 800b48e:	bf08      	it	eq
 800b490:	f043 0301 	orreq.w	r3, r3, #1
 800b494:	3128      	adds	r1, #40	; 0x28
 800b496:	4282      	cmp	r2, r0
 800b498:	bf08      	it	eq
 800b49a:	f043 0301 	orreq.w	r3, r3, #1
 800b49e:	3028      	adds	r0, #40	; 0x28
 800b4a0:	428a      	cmp	r2, r1
 800b4a2:	bf08      	it	eq
 800b4a4:	f043 0301 	orreq.w	r3, r3, #1
 800b4a8:	3128      	adds	r1, #40	; 0x28
 800b4aa:	4282      	cmp	r2, r0
 800b4ac:	bf08      	it	eq
 800b4ae:	f043 0301 	orreq.w	r3, r3, #1
 800b4b2:	428a      	cmp	r2, r1
 800b4b4:	bf08      	it	eq
 800b4b6:	f043 0301 	orreq.w	r3, r3, #1
 800b4ba:	b913      	cbnz	r3, 800b4c2 <HAL_DMA_Init+0x21e>
 800b4bc:	4b19      	ldr	r3, [pc, #100]	; (800b524 <HAL_DMA_Init+0x280>)
 800b4be:	429a      	cmp	r2, r3
 800b4c0:	d118      	bne.n	800b4f4 <HAL_DMA_Init+0x250>
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 800b4c2:	4620      	mov	r0, r4
 800b4c4:	f7ff fe82 	bl	800b1cc <DMA_CalcDMAMUXChannelBaseAndMask>
    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 800b4c8:	68a3      	ldr	r3, [r4, #8]
 800b4ca:	2b80      	cmp	r3, #128	; 0x80
 800b4cc:	d05c      	beq.n	800b588 <HAL_DMA_Init+0x2e4>
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 800b4ce:	6863      	ldr	r3, [r4, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800b4d0:	6ea0      	ldr	r0, [r4, #104]	; 0x68
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 800b4d2:	b2da      	uxtb	r2, r3
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
 800b4d4:	3b01      	subs	r3, #1
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800b4d6:	e9d4 5118 	ldrd	r5, r1, [r4, #96]	; 0x60
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
 800b4da:	2b07      	cmp	r3, #7
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 800b4dc:	602a      	str	r2, [r5, #0]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800b4de:	6048      	str	r0, [r1, #4]
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
 800b4e0:	d859      	bhi.n	800b596 <HAL_DMA_Init+0x2f2>
  */
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
 800b4e2:	1e50      	subs	r0, r2, #1
 800b4e4:	2807      	cmp	r0, #7
 800b4e6:	d96e      	bls.n	800b5c6 <HAL_DMA_Init+0x322>
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800b4e8:	6f62      	ldr	r2, [r4, #116]	; 0x74
 800b4ea:	e9d4 311b 	ldrd	r3, r1, [r4, #108]	; 0x6c
      hdma->DMAmuxRequestGen->RGCR = 0U;
 800b4ee:	2000      	movs	r0, #0
 800b4f0:	6018      	str	r0, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800b4f2:	604a      	str	r2, [r1, #4]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800b4f4:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
 800b4f6:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800b4f8:	6560      	str	r0, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 800b4fa:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 800b4fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b500:	40020010 	.word	0x40020010
 800b504:	40020040 	.word	0x40020040
 800b508:	400204b8 	.word	0x400204b8
 800b50c:	fe10803f 	.word	0xfe10803f
 800b510:	5c001000 	.word	0x5c001000
 800b514:	ffff0000 	.word	0xffff0000
 800b518:	40020028 	.word	0x40020028
 800b51c:	58025408 	.word	0x58025408
 800b520:	5802541c 	.word	0x5802541c
 800b524:	58025494 	.word	0x58025494
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
 800b528:	6865      	ldr	r5, [r4, #4]
 800b52a:	f1a5 0629 	sub.w	r6, r5, #41	; 0x29
 800b52e:	2e1f      	cmp	r6, #31
 800b530:	d924      	bls.n	800b57c <HAL_DMA_Init+0x2d8>
 800b532:	3d4f      	subs	r5, #79	; 0x4f
 800b534:	2d03      	cmp	r5, #3
 800b536:	d801      	bhi.n	800b53c <HAL_DMA_Init+0x298>
        registerValue |= DMA_SxCR_TRBUFF;
 800b538:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
 800b53c:	601a      	str	r2, [r3, #0]
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800b53e:	2804      	cmp	r0, #4
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
 800b540:	695a      	ldr	r2, [r3, #20]
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 800b542:	f022 0207 	bic.w	r2, r2, #7
    registerValue |= hdma->Init.FIFOMode;
 800b546:	ea42 0200 	orr.w	r2, r2, r0
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800b54a:	f47f af37 	bne.w	800b3bc <HAL_DMA_Init+0x118>
 800b54e:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
      registerValue |= hdma->Init.FIFOThreshold;
 800b550:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800b552:	4302      	orrs	r2, r0
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 800b554:	2d00      	cmp	r5, #0
 800b556:	f43f af31 	beq.w	800b3bc <HAL_DMA_Init+0x118>
  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 800b55a:	2900      	cmp	r1, #0
 800b55c:	d169      	bne.n	800b632 <HAL_DMA_Init+0x38e>
    switch (hdma->Init.FIFOThreshold)
 800b55e:	2801      	cmp	r0, #1
 800b560:	f000 8088 	beq.w	800b674 <HAL_DMA_Init+0x3d0>
 800b564:	f030 0102 	bics.w	r1, r0, #2
 800b568:	f47f af28 	bne.w	800b3bc <HAL_DMA_Init+0x118>
 800b56c:	e069      	b.n	800b642 <HAL_DMA_Init+0x39e>
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 800b56e:	2220      	movs	r2, #32
        hdma->State = HAL_DMA_STATE_ERROR;
 800b570:	2303      	movs	r3, #3
        return HAL_ERROR;
 800b572:	2001      	movs	r0, #1
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 800b574:	6562      	str	r2, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_ERROR;
 800b576:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 800b57a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
 800b57c:	4d73      	ldr	r5, [pc, #460]	; (800b74c <HAL_DMA_Init+0x4a8>)
 800b57e:	fa25 f606 	lsr.w	r6, r5, r6
 800b582:	07f5      	lsls	r5, r6, #31
 800b584:	d5da      	bpl.n	800b53c <HAL_DMA_Init+0x298>
 800b586:	e7d7      	b.n	800b538 <HAL_DMA_Init+0x294>
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 800b588:	2300      	movs	r3, #0
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800b58a:	6ea1      	ldr	r1, [r4, #104]	; 0x68
 800b58c:	e9d4 0218 	ldrd	r0, r2, [r4, #96]	; 0x60
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 800b590:	6063      	str	r3, [r4, #4]
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 800b592:	6003      	str	r3, [r0, #0]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800b594:	6051      	str	r1, [r2, #4]
      hdma->DMAmuxRequestGen = 0U;
 800b596:	2300      	movs	r3, #0
      hdma->DMAmuxRequestGenStatus = 0U;
 800b598:	e9c4 331b 	strd	r3, r3, [r4, #108]	; 0x6c
      hdma->DMAmuxRequestGenStatusMask = 0U;
 800b59c:	6763      	str	r3, [r4, #116]	; 0x74
 800b59e:	e7a9      	b.n	800b4f4 <HAL_DMA_Init+0x250>
    return HAL_ERROR;
 800b5a0:	2001      	movs	r0, #1
}
 800b5a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
 800b5a4:	682f      	ldr	r7, [r5, #0]
      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 800b5a6:	e9d4 560b 	ldrd	r5, r6, [r4, #44]	; 0x2c
 800b5aa:	432e      	orrs	r6, r5
 800b5ac:	4332      	orrs	r2, r6
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
 800b5ae:	4e68      	ldr	r6, [pc, #416]	; (800b750 <HAL_DMA_Init+0x4ac>)
 800b5b0:	403e      	ands	r6, r7
 800b5b2:	f1b6 5f00 	cmp.w	r6, #536870912	; 0x20000000
 800b5b6:	d2b7      	bcs.n	800b528 <HAL_DMA_Init+0x284>
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
 800b5b8:	601a      	str	r2, [r3, #0]
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
 800b5ba:	695a      	ldr	r2, [r3, #20]
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 800b5bc:	f022 0207 	bic.w	r2, r2, #7
    registerValue |= hdma->Init.FIFOMode;
 800b5c0:	f042 0204 	orr.w	r2, r2, #4
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800b5c4:	e7c4      	b.n	800b550 <HAL_DMA_Init+0x2ac>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 800b5c6:	6821      	ldr	r1, [r4, #0]
 800b5c8:	4b62      	ldr	r3, [pc, #392]	; (800b754 <HAL_DMA_Init+0x4b0>)
 800b5ca:	4d63      	ldr	r5, [pc, #396]	; (800b758 <HAL_DMA_Init+0x4b4>)
 800b5cc:	42a9      	cmp	r1, r5
 800b5ce:	bf18      	it	ne
 800b5d0:	4299      	cmpne	r1, r3
 800b5d2:	f105 0514 	add.w	r5, r5, #20
 800b5d6:	bf0c      	ite	eq
 800b5d8:	2301      	moveq	r3, #1
 800b5da:	2300      	movne	r3, #0
 800b5dc:	42a9      	cmp	r1, r5
 800b5de:	bf08      	it	eq
 800b5e0:	f043 0301 	orreq.w	r3, r3, #1
 800b5e4:	3514      	adds	r5, #20
 800b5e6:	42a9      	cmp	r1, r5
 800b5e8:	bf08      	it	eq
 800b5ea:	f043 0301 	orreq.w	r3, r3, #1
 800b5ee:	3514      	adds	r5, #20
 800b5f0:	42a9      	cmp	r1, r5
 800b5f2:	bf08      	it	eq
 800b5f4:	f043 0301 	orreq.w	r3, r3, #1
 800b5f8:	3514      	adds	r5, #20
 800b5fa:	42a9      	cmp	r1, r5
 800b5fc:	bf08      	it	eq
 800b5fe:	f043 0301 	orreq.w	r3, r3, #1
 800b602:	3514      	adds	r5, #20
 800b604:	42a9      	cmp	r1, r5
 800b606:	bf08      	it	eq
 800b608:	f043 0301 	orreq.w	r3, r3, #1
 800b60c:	b93b      	cbnz	r3, 800b61e <HAL_DMA_Init+0x37a>
 800b60e:	4b53      	ldr	r3, [pc, #332]	; (800b75c <HAL_DMA_Init+0x4b8>)
 800b610:	4299      	cmp	r1, r3
 800b612:	d004      	beq.n	800b61e <HAL_DMA_Init+0x37a>
      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
    }
    else
    {
      /* DMA1 and DMA2 Streams use DMAMUX1 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 800b614:	4b52      	ldr	r3, [pc, #328]	; (800b760 <HAL_DMA_Init+0x4bc>)

      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 800b616:	4953      	ldr	r1, [pc, #332]	; (800b764 <HAL_DMA_Init+0x4c0>)
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 800b618:	4413      	add	r3, r2
 800b61a:	009b      	lsls	r3, r3, #2
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 800b61c:	e003      	b.n	800b626 <HAL_DMA_Init+0x382>
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 800b61e:	4b52      	ldr	r3, [pc, #328]	; (800b768 <HAL_DMA_Init+0x4c4>)
      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
 800b620:	4952      	ldr	r1, [pc, #328]	; (800b76c <HAL_DMA_Init+0x4c8>)
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 800b622:	4413      	add	r3, r2
 800b624:	009b      	lsls	r3, r3, #2
    }

    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
 800b626:	2201      	movs	r2, #1
 800b628:	4082      	lsls	r2, r0
 800b62a:	e9c4 311b 	strd	r3, r1, [r4, #108]	; 0x6c
 800b62e:	6762      	str	r2, [r4, #116]	; 0x74
 800b630:	e75d      	b.n	800b4ee <HAL_DMA_Init+0x24a>
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 800b632:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
 800b636:	d00e      	beq.n	800b656 <HAL_DMA_Init+0x3b2>
    switch (hdma->Init.FIFOThreshold)
 800b638:	2802      	cmp	r0, #2
 800b63a:	d905      	bls.n	800b648 <HAL_DMA_Init+0x3a4>
 800b63c:	2803      	cmp	r0, #3
 800b63e:	f47f aebd 	bne.w	800b3bc <HAL_DMA_Init+0x118>
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 800b642:	01e9      	lsls	r1, r5, #7
 800b644:	f57f aeba 	bpl.w	800b3bc <HAL_DMA_Init+0x118>
          hdma->State = HAL_DMA_STATE_READY;
 800b648:	2301      	movs	r3, #1
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 800b64a:	2240      	movs	r2, #64	; 0x40
          return HAL_ERROR;
 800b64c:	4618      	mov	r0, r3
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 800b64e:	6562      	str	r2, [r4, #84]	; 0x54
          hdma->State = HAL_DMA_STATE_READY;
 800b650:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 800b654:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch (hdma->Init.FIFOThreshold)
 800b656:	2803      	cmp	r0, #3
 800b658:	f63f aeb0 	bhi.w	800b3bc <HAL_DMA_Init+0x118>
 800b65c:	a101      	add	r1, pc, #4	; (adr r1, 800b664 <HAL_DMA_Init+0x3c0>)
 800b65e:	f851 f020 	ldr.w	pc, [r1, r0, lsl #2]
 800b662:	bf00      	nop
 800b664:	0800b649 	.word	0x0800b649
 800b668:	0800b643 	.word	0x0800b643
 800b66c:	0800b649 	.word	0x0800b649
 800b670:	0800b675 	.word	0x0800b675
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 800b674:	f1b5 7fc0 	cmp.w	r5, #25165824	; 0x1800000
 800b678:	f47f aea0 	bne.w	800b3bc <HAL_DMA_Init+0x118>
 800b67c:	e7e4      	b.n	800b648 <HAL_DMA_Init+0x3a4>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 800b67e:	4a35      	ldr	r2, [pc, #212]	; (800b754 <HAL_DMA_Init+0x4b0>)
 800b680:	4835      	ldr	r0, [pc, #212]	; (800b758 <HAL_DMA_Init+0x4b4>)
 800b682:	493b      	ldr	r1, [pc, #236]	; (800b770 <HAL_DMA_Init+0x4cc>)
 800b684:	4283      	cmp	r3, r0
 800b686:	bf18      	it	ne
 800b688:	4293      	cmpne	r3, r2
 800b68a:	f100 0028 	add.w	r0, r0, #40	; 0x28
 800b68e:	bf0c      	ite	eq
 800b690:	2201      	moveq	r2, #1
 800b692:	2200      	movne	r2, #0
 800b694:	428b      	cmp	r3, r1
 800b696:	bf08      	it	eq
 800b698:	f042 0201 	orreq.w	r2, r2, #1
 800b69c:	3128      	adds	r1, #40	; 0x28
 800b69e:	4283      	cmp	r3, r0
 800b6a0:	bf08      	it	eq
 800b6a2:	f042 0201 	orreq.w	r2, r2, #1
 800b6a6:	3028      	adds	r0, #40	; 0x28
 800b6a8:	428b      	cmp	r3, r1
 800b6aa:	bf08      	it	eq
 800b6ac:	f042 0201 	orreq.w	r2, r2, #1
 800b6b0:	3128      	adds	r1, #40	; 0x28
 800b6b2:	4283      	cmp	r3, r0
 800b6b4:	bf08      	it	eq
 800b6b6:	f042 0201 	orreq.w	r2, r2, #1
 800b6ba:	428b      	cmp	r3, r1
 800b6bc:	bf08      	it	eq
 800b6be:	f042 0201 	orreq.w	r2, r2, #1
 800b6c2:	b912      	cbnz	r2, 800b6ca <HAL_DMA_Init+0x426>
 800b6c4:	4a25      	ldr	r2, [pc, #148]	; (800b75c <HAL_DMA_Init+0x4b8>)
 800b6c6:	4293      	cmp	r3, r2
 800b6c8:	d138      	bne.n	800b73c <HAL_DMA_Init+0x498>
    __HAL_UNLOCK(hdma);
 800b6ca:	2200      	movs	r2, #0
    hdma->State = HAL_DMA_STATE_BUSY;
 800b6cc:	2102      	movs	r1, #2
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
 800b6ce:	4d29      	ldr	r5, [pc, #164]	; (800b774 <HAL_DMA_Init+0x4d0>)
    hdma->State = HAL_DMA_STATE_BUSY;
 800b6d0:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
    __HAL_UNLOCK(hdma);
 800b6d4:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;
 800b6d8:	681a      	ldr	r2, [r3, #0]
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
 800b6da:	4015      	ands	r5, r2
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 800b6dc:	68a2      	ldr	r2, [r4, #8]
 800b6de:	2a40      	cmp	r2, #64	; 0x40
 800b6e0:	d02a      	beq.n	800b738 <HAL_DMA_Init+0x494>
 800b6e2:	2a80      	cmp	r2, #128	; 0x80
 800b6e4:	bf0c      	ite	eq
 800b6e6:	f44f 4080 	moveq.w	r0, #16384	; 0x4000
 800b6ea:	2000      	movne	r0, #0
                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);
 800b6ec:	6a26      	ldr	r6, [r4, #32]
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
 800b6ee:	e9d4 1203 	ldrd	r1, r2, [r4, #12]
 800b6f2:	08d2      	lsrs	r2, r2, #3
 800b6f4:	ea42 02d1 	orr.w	r2, r2, r1, lsr #3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
 800b6f8:	6961      	ldr	r1, [r4, #20]
 800b6fa:	ea42 02d1 	orr.w	r2, r2, r1, lsr #3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
 800b6fe:	69a1      	ldr	r1, [r4, #24]
 800b700:	ea42 02d1 	orr.w	r2, r2, r1, lsr #3
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
 800b704:	69e1      	ldr	r1, [r4, #28]
 800b706:	ea42 02d1 	orr.w	r2, r2, r1, lsr #3
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
 800b70a:	491b      	ldr	r1, [pc, #108]	; (800b778 <HAL_DMA_Init+0x4d4>)
 800b70c:	ea42 1216 	orr.w	r2, r2, r6, lsr #4
 800b710:	4419      	add	r1, r3
 800b712:	432a      	orrs	r2, r5
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 800b714:	4302      	orrs	r2, r0
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
 800b716:	4819      	ldr	r0, [pc, #100]	; (800b77c <HAL_DMA_Init+0x4d8>)
 800b718:	fba0 0101 	umull	r0, r1, r0, r1
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 800b71c:	4620      	mov	r0, r4
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;
 800b71e:	601a      	str	r2, [r3, #0]
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
 800b720:	090b      	lsrs	r3, r1, #4
 800b722:	009b      	lsls	r3, r3, #2
 800b724:	65e3      	str	r3, [r4, #92]	; 0x5c
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 800b726:	f7ff fcd7 	bl	800b0d8 <DMA_CalcBaseAndBitshift>
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 800b72a:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 800b72c:	2301      	movs	r3, #1
 800b72e:	f002 021f 	and.w	r2, r2, #31
 800b732:	4093      	lsls	r3, r2
 800b734:	6043      	str	r3, [r0, #4]
 800b736:	e64b      	b.n	800b3d0 <HAL_DMA_Init+0x12c>
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 800b738:	2010      	movs	r0, #16
 800b73a:	e7d7      	b.n	800b6ec <HAL_DMA_Init+0x448>
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 800b73c:	2240      	movs	r2, #64	; 0x40
    hdma->State     = HAL_DMA_STATE_ERROR;
 800b73e:	2303      	movs	r3, #3
    return HAL_ERROR;
 800b740:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 800b742:	6562      	str	r2, [r4, #84]	; 0x54
    hdma->State     = HAL_DMA_STATE_ERROR;
 800b744:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 800b748:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b74a:	bf00      	nop
 800b74c:	c3c0003f 	.word	0xc3c0003f
 800b750:	ffff0000 	.word	0xffff0000
 800b754:	58025408 	.word	0x58025408
 800b758:	5802541c 	.word	0x5802541c
 800b75c:	58025494 	.word	0x58025494
 800b760:	1000823f 	.word	0x1000823f
 800b764:	40020940 	.word	0x40020940
 800b768:	1600963f 	.word	0x1600963f
 800b76c:	58025940 	.word	0x58025940
 800b770:	58025430 	.word	0x58025430
 800b774:	fffe000f 	.word	0xfffe000f
 800b778:	a7fdabf8 	.word	0xa7fdabf8
 800b77c:	cccccccd 	.word	0xcccccccd

0800b780 <HAL_DMA_DeInit>:
  if(hdma == NULL)
 800b780:	2800      	cmp	r0, #0
 800b782:	f000 80f3 	beq.w	800b96c <HAL_DMA_DeInit+0x1ec>
  __HAL_DMA_DISABLE(hdma);
 800b786:	6802      	ldr	r2, [r0, #0]
 800b788:	497c      	ldr	r1, [pc, #496]	; (800b97c <HAL_DMA_DeInit+0x1fc>)
{
 800b78a:	b538      	push	{r3, r4, r5, lr}
  __HAL_DMA_DISABLE(hdma);
 800b78c:	4b7c      	ldr	r3, [pc, #496]	; (800b980 <HAL_DMA_DeInit+0x200>)
 800b78e:	4604      	mov	r4, r0
 800b790:	487c      	ldr	r0, [pc, #496]	; (800b984 <HAL_DMA_DeInit+0x204>)
 800b792:	4282      	cmp	r2, r0
 800b794:	bf18      	it	ne
 800b796:	429a      	cmpne	r2, r3
 800b798:	f100 0048 	add.w	r0, r0, #72	; 0x48
 800b79c:	bf0c      	ite	eq
 800b79e:	2301      	moveq	r3, #1
 800b7a0:	2300      	movne	r3, #0
 800b7a2:	428a      	cmp	r2, r1
 800b7a4:	bf08      	it	eq
 800b7a6:	f043 0301 	orreq.w	r3, r3, #1
 800b7aa:	3130      	adds	r1, #48	; 0x30
 800b7ac:	4282      	cmp	r2, r0
 800b7ae:	bf08      	it	eq
 800b7b0:	f043 0301 	orreq.w	r3, r3, #1
 800b7b4:	3030      	adds	r0, #48	; 0x30
 800b7b6:	428a      	cmp	r2, r1
 800b7b8:	bf08      	it	eq
 800b7ba:	f043 0301 	orreq.w	r3, r3, #1
 800b7be:	f501 715c 	add.w	r1, r1, #880	; 0x370
 800b7c2:	4282      	cmp	r2, r0
 800b7c4:	bf08      	it	eq
 800b7c6:	f043 0301 	orreq.w	r3, r3, #1
 800b7ca:	f500 705c 	add.w	r0, r0, #880	; 0x370
 800b7ce:	428a      	cmp	r2, r1
 800b7d0:	bf08      	it	eq
 800b7d2:	f043 0301 	orreq.w	r3, r3, #1
 800b7d6:	3130      	adds	r1, #48	; 0x30
 800b7d8:	4282      	cmp	r2, r0
 800b7da:	bf08      	it	eq
 800b7dc:	f043 0301 	orreq.w	r3, r3, #1
 800b7e0:	3030      	adds	r0, #48	; 0x30
 800b7e2:	428a      	cmp	r2, r1
 800b7e4:	bf08      	it	eq
 800b7e6:	f043 0301 	orreq.w	r3, r3, #1
 800b7ea:	3130      	adds	r1, #48	; 0x30
 800b7ec:	4282      	cmp	r2, r0
 800b7ee:	bf08      	it	eq
 800b7f0:	f043 0301 	orreq.w	r3, r3, #1
 800b7f4:	3030      	adds	r0, #48	; 0x30
 800b7f6:	428a      	cmp	r2, r1
 800b7f8:	bf08      	it	eq
 800b7fa:	f043 0301 	orreq.w	r3, r3, #1
 800b7fe:	3130      	adds	r1, #48	; 0x30
 800b800:	4282      	cmp	r2, r0
 800b802:	bf08      	it	eq
 800b804:	f043 0301 	orreq.w	r3, r3, #1
 800b808:	428a      	cmp	r2, r1
 800b80a:	bf08      	it	eq
 800b80c:	f043 0301 	orreq.w	r3, r3, #1
 800b810:	3118      	adds	r1, #24
 800b812:	428a      	cmp	r2, r1
 800b814:	bf08      	it	eq
 800b816:	f043 0301 	orreq.w	r3, r3, #1
 800b81a:	b933      	cbnz	r3, 800b82a <HAL_DMA_DeInit+0xaa>
 800b81c:	f5a1 6195 	sub.w	r1, r1, #1192	; 0x4a8
 800b820:	4b59      	ldr	r3, [pc, #356]	; (800b988 <HAL_DMA_DeInit+0x208>)
 800b822:	429a      	cmp	r2, r3
 800b824:	bf18      	it	ne
 800b826:	428a      	cmpne	r2, r1
 800b828:	d165      	bne.n	800b8f6 <HAL_DMA_DeInit+0x176>
 800b82a:	6811      	ldr	r1, [r2, #0]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
 800b82c:	2300      	movs	r3, #0
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
 800b82e:	2521      	movs	r5, #33	; 0x21
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 800b830:	4620      	mov	r0, r4
  __HAL_DMA_DISABLE(hdma);
 800b832:	f021 0101 	bic.w	r1, r1, #1
 800b836:	6011      	str	r1, [r2, #0]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
 800b838:	6013      	str	r3, [r2, #0]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
 800b83a:	6053      	str	r3, [r2, #4]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;
 800b83c:	6093      	str	r3, [r2, #8]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = 0U;
 800b83e:	60d3      	str	r3, [r2, #12]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = 0U;
 800b840:	6113      	str	r3, [r2, #16]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
 800b842:	6155      	str	r5, [r2, #20]
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 800b844:	f7ff fc48 	bl	800b0d8 <DMA_CalcBaseAndBitshift>
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 800b848:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 800b84a:	233f      	movs	r3, #63	; 0x3f
 800b84c:	f002 021f 	and.w	r2, r2, #31
 800b850:	4093      	lsls	r3, r2
 800b852:	6083      	str	r3, [r0, #8]
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 800b854:	4620      	mov	r0, r4
 800b856:	f7ff fcb9 	bl	800b1cc <DMA_CalcDMAMUXChannelBaseAndMask>
    if(hdma->DMAmuxChannel != 0U)
 800b85a:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800b85c:	b123      	cbz	r3, 800b868 <HAL_DMA_DeInit+0xe8>
      hdma->DMAmuxChannel->CCR = 0U;
 800b85e:	2000      	movs	r0, #0
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800b860:	e9d4 2119 	ldrd	r2, r1, [r4, #100]	; 0x64
      hdma->DMAmuxChannel->CCR = 0U;
 800b864:	6018      	str	r0, [r3, #0]
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800b866:	6051      	str	r1, [r2, #4]
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
 800b868:	6861      	ldr	r1, [r4, #4]
 800b86a:	1e4b      	subs	r3, r1, #1
 800b86c:	2b07      	cmp	r3, #7
 800b86e:	d910      	bls.n	800b892 <HAL_DMA_DeInit+0x112>
    hdma->DMAmuxRequestGen = 0U;
 800b870:	2300      	movs	r3, #0
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800b872:	6563      	str	r3, [r4, #84]	; 0x54
  return HAL_OK;
 800b874:	4618      	mov	r0, r3
    hdma->DMAmuxRequestGenStatusMask = 0U;
 800b876:	6763      	str	r3, [r4, #116]	; 0x74
  hdma->State = HAL_DMA_STATE_RESET;
 800b878:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  __HAL_UNLOCK(hdma);
 800b87c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    hdma->DMAmuxRequestGenStatus = 0U;
 800b880:	e9c4 331b 	strd	r3, r3, [r4, #108]	; 0x6c
  hdma->XferHalfCpltCallback   = NULL;
 800b884:	e9c4 330f 	strd	r3, r3, [r4, #60]	; 0x3c
  hdma->XferM1HalfCpltCallback = NULL;
 800b888:	e9c4 3311 	strd	r3, r3, [r4, #68]	; 0x44
  hdma->XferAbortCallback      = NULL;
 800b88c:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
}
 800b890:	bd38      	pop	{r3, r4, r5, pc}
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 800b892:	6820      	ldr	r0, [r4, #0]
 800b894:	4a3d      	ldr	r2, [pc, #244]	; (800b98c <HAL_DMA_DeInit+0x20c>)
 800b896:	4d3e      	ldr	r5, [pc, #248]	; (800b990 <HAL_DMA_DeInit+0x210>)
 800b898:	42a8      	cmp	r0, r5
 800b89a:	bf18      	it	ne
 800b89c:	4290      	cmpne	r0, r2
 800b89e:	f105 0514 	add.w	r5, r5, #20
 800b8a2:	bf0c      	ite	eq
 800b8a4:	2201      	moveq	r2, #1
 800b8a6:	2200      	movne	r2, #0
 800b8a8:	42a8      	cmp	r0, r5
 800b8aa:	bf08      	it	eq
 800b8ac:	f042 0201 	orreq.w	r2, r2, #1
 800b8b0:	3514      	adds	r5, #20
 800b8b2:	42a8      	cmp	r0, r5
 800b8b4:	bf08      	it	eq
 800b8b6:	f042 0201 	orreq.w	r2, r2, #1
 800b8ba:	3514      	adds	r5, #20
 800b8bc:	42a8      	cmp	r0, r5
 800b8be:	bf08      	it	eq
 800b8c0:	f042 0201 	orreq.w	r2, r2, #1
 800b8c4:	3514      	adds	r5, #20
 800b8c6:	42a8      	cmp	r0, r5
 800b8c8:	bf08      	it	eq
 800b8ca:	f042 0201 	orreq.w	r2, r2, #1
 800b8ce:	3514      	adds	r5, #20
 800b8d0:	42a8      	cmp	r0, r5
 800b8d2:	bf08      	it	eq
 800b8d4:	f042 0201 	orreq.w	r2, r2, #1
 800b8d8:	b912      	cbnz	r2, 800b8e0 <HAL_DMA_DeInit+0x160>
 800b8da:	4a2e      	ldr	r2, [pc, #184]	; (800b994 <HAL_DMA_DeInit+0x214>)
 800b8dc:	4290      	cmp	r0, r2
 800b8de:	d147      	bne.n	800b970 <HAL_DMA_DeInit+0x1f0>
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 800b8e0:	4a2d      	ldr	r2, [pc, #180]	; (800b998 <HAL_DMA_DeInit+0x218>)
      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
 800b8e2:	482e      	ldr	r0, [pc, #184]	; (800b99c <HAL_DMA_DeInit+0x21c>)
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 800b8e4:	440a      	add	r2, r1
 800b8e6:	0091      	lsls	r1, r2, #2
    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
 800b8e8:	2201      	movs	r2, #1
 800b8ea:	fa02 f303 	lsl.w	r3, r2, r3
      hdma->DMAmuxRequestGen->RGCR = 0U;
 800b8ee:	2200      	movs	r2, #0
 800b8f0:	600a      	str	r2, [r1, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800b8f2:	6043      	str	r3, [r0, #4]
 800b8f4:	e7bc      	b.n	800b870 <HAL_DMA_DeInit+0xf0>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 800b8f6:	4b25      	ldr	r3, [pc, #148]	; (800b98c <HAL_DMA_DeInit+0x20c>)
 800b8f8:	4d25      	ldr	r5, [pc, #148]	; (800b990 <HAL_DMA_DeInit+0x210>)
 800b8fa:	4829      	ldr	r0, [pc, #164]	; (800b9a0 <HAL_DMA_DeInit+0x220>)
 800b8fc:	42aa      	cmp	r2, r5
 800b8fe:	bf18      	it	ne
 800b900:	429a      	cmpne	r2, r3
  __HAL_DMA_DISABLE(hdma);
 800b902:	6811      	ldr	r1, [r2, #0]
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 800b904:	bf0c      	ite	eq
 800b906:	2301      	moveq	r3, #1
 800b908:	2300      	movne	r3, #0
  __HAL_DMA_DISABLE(hdma);
 800b90a:	f021 0101 	bic.w	r1, r1, #1
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 800b90e:	4282      	cmp	r2, r0
 800b910:	bf08      	it	eq
 800b912:	f043 0301 	orreq.w	r3, r3, #1
 800b916:	3014      	adds	r0, #20
  __HAL_DMA_DISABLE(hdma);
 800b918:	6011      	str	r1, [r2, #0]
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 800b91a:	4282      	cmp	r2, r0
 800b91c:	bf08      	it	eq
 800b91e:	f043 0301 	orreq.w	r3, r3, #1
 800b922:	4920      	ldr	r1, [pc, #128]	; (800b9a4 <HAL_DMA_DeInit+0x224>)
 800b924:	3028      	adds	r0, #40	; 0x28
 800b926:	428a      	cmp	r2, r1
 800b928:	bf08      	it	eq
 800b92a:	f043 0301 	orreq.w	r3, r3, #1
 800b92e:	3128      	adds	r1, #40	; 0x28
 800b930:	4282      	cmp	r2, r0
 800b932:	bf08      	it	eq
 800b934:	f043 0301 	orreq.w	r3, r3, #1
 800b938:	428a      	cmp	r2, r1
 800b93a:	bf08      	it	eq
 800b93c:	f043 0301 	orreq.w	r3, r3, #1
 800b940:	b913      	cbnz	r3, 800b948 <HAL_DMA_DeInit+0x1c8>
 800b942:	4b14      	ldr	r3, [pc, #80]	; (800b994 <HAL_DMA_DeInit+0x214>)
 800b944:	429a      	cmp	r2, r3
 800b946:	d10f      	bne.n	800b968 <HAL_DMA_DeInit+0x1e8>
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
 800b948:	2300      	movs	r3, #0
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 800b94a:	4620      	mov	r0, r4
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
 800b94c:	6013      	str	r3, [r2, #0]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = 0U;
 800b94e:	6053      	str	r3, [r2, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR  = 0U;
 800b950:	6093      	str	r3, [r2, #8]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = 0U;
 800b952:	60d3      	str	r3, [r2, #12]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM1AR = 0U;
 800b954:	6113      	str	r3, [r2, #16]
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 800b956:	f7ff fbbf 	bl	800b0d8 <DMA_CalcBaseAndBitshift>
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 800b95a:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 800b95c:	2301      	movs	r3, #1
 800b95e:	f002 021f 	and.w	r2, r2, #31
 800b962:	4093      	lsls	r3, r2
 800b964:	6043      	str	r3, [r0, #4]
 800b966:	e775      	b.n	800b854 <HAL_DMA_DeInit+0xd4>
    return HAL_ERROR;
 800b968:	2001      	movs	r0, #1
}
 800b96a:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 800b96c:	2001      	movs	r0, #1
}
 800b96e:	4770      	bx	lr
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 800b970:	4a0d      	ldr	r2, [pc, #52]	; (800b9a8 <HAL_DMA_DeInit+0x228>)
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 800b972:	480e      	ldr	r0, [pc, #56]	; (800b9ac <HAL_DMA_DeInit+0x22c>)
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 800b974:	440a      	add	r2, r1
 800b976:	0091      	lsls	r1, r2, #2
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 800b978:	e7b6      	b.n	800b8e8 <HAL_DMA_DeInit+0x168>
 800b97a:	bf00      	nop
 800b97c:	40020070 	.word	0x40020070
 800b980:	40020058 	.word	0x40020058
 800b984:	40020040 	.word	0x40020040
 800b988:	40020028 	.word	0x40020028
 800b98c:	58025408 	.word	0x58025408
 800b990:	5802541c 	.word	0x5802541c
 800b994:	58025494 	.word	0x58025494
 800b998:	1600963f 	.word	0x1600963f
 800b99c:	58025940 	.word	0x58025940
 800b9a0:	58025430 	.word	0x58025430
 800b9a4:	58025458 	.word	0x58025458
 800b9a8:	1000823f 	.word	0x1000823f
 800b9ac:	40020940 	.word	0x40020940

0800b9b0 <HAL_DMA_Start_IT>:
  if(hdma == NULL)
 800b9b0:	2800      	cmp	r0, #0
 800b9b2:	f000 8177 	beq.w	800bca4 <HAL_DMA_Start_IT+0x2f4>
 800b9b6:	4684      	mov	ip, r0
  __HAL_LOCK(hdma);
 800b9b8:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
 800b9bc:	2801      	cmp	r0, #1
 800b9be:	f000 8173 	beq.w	800bca8 <HAL_DMA_Start_IT+0x2f8>
 800b9c2:	2001      	movs	r0, #1
{
 800b9c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if(HAL_DMA_STATE_READY == hdma->State)
 800b9c8:	f89c 4035 	ldrb.w	r4, [ip, #53]	; 0x35
  __HAL_LOCK(hdma);
 800b9cc:	f88c 0034 	strb.w	r0, [ip, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 800b9d0:	4284      	cmp	r4, r0
 800b9d2:	d008      	beq.n	800b9e6 <HAL_DMA_Start_IT+0x36>
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 800b9d4:	f44f 6200 	mov.w	r2, #2048	; 0x800
    __HAL_UNLOCK(hdma);
 800b9d8:	2300      	movs	r3, #0
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 800b9da:	f8cc 2054 	str.w	r2, [ip, #84]	; 0x54
    __HAL_UNLOCK(hdma);
 800b9de:	f88c 3034 	strb.w	r3, [ip, #52]	; 0x34
}
 800b9e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    hdma->State = HAL_DMA_STATE_BUSY;
 800b9e6:	2002      	movs	r0, #2
    __HAL_DMA_DISABLE(hdma);
 800b9e8:	f8dc 4000 	ldr.w	r4, [ip]
 800b9ec:	4d53      	ldr	r5, [pc, #332]	; (800bb3c <HAL_DMA_Start_IT+0x18c>)
    hdma->State = HAL_DMA_STATE_BUSY;
 800b9ee:	f88c 0035 	strb.w	r0, [ip, #53]	; 0x35
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800b9f2:	2000      	movs	r0, #0
    __HAL_DMA_DISABLE(hdma);
 800b9f4:	4e52      	ldr	r6, [pc, #328]	; (800bb40 <HAL_DMA_Start_IT+0x190>)
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800b9f6:	f8cc 0054 	str.w	r0, [ip, #84]	; 0x54
    __HAL_DMA_DISABLE(hdma);
 800b9fa:	4852      	ldr	r0, [pc, #328]	; (800bb44 <HAL_DMA_Start_IT+0x194>)
 800b9fc:	42ac      	cmp	r4, r5
 800b9fe:	bf18      	it	ne
 800ba00:	4284      	cmpne	r4, r0
 800ba02:	f105 0518 	add.w	r5, r5, #24
 800ba06:	bf0c      	ite	eq
 800ba08:	2001      	moveq	r0, #1
 800ba0a:	2000      	movne	r0, #0
 800ba0c:	42ac      	cmp	r4, r5
 800ba0e:	bf08      	it	eq
 800ba10:	f040 0001 	orreq.w	r0, r0, #1
 800ba14:	3518      	adds	r5, #24
 800ba16:	42ac      	cmp	r4, r5
 800ba18:	bf08      	it	eq
 800ba1a:	f040 0001 	orreq.w	r0, r0, #1
 800ba1e:	3518      	adds	r5, #24
 800ba20:	42ac      	cmp	r4, r5
 800ba22:	bf08      	it	eq
 800ba24:	f040 0001 	orreq.w	r0, r0, #1
 800ba28:	3518      	adds	r5, #24
 800ba2a:	42ac      	cmp	r4, r5
 800ba2c:	bf08      	it	eq
 800ba2e:	f040 0001 	orreq.w	r0, r0, #1
 800ba32:	f505 7556 	add.w	r5, r5, #856	; 0x358
 800ba36:	42ac      	cmp	r4, r5
 800ba38:	bf08      	it	eq
 800ba3a:	f040 0001 	orreq.w	r0, r0, #1
 800ba3e:	3518      	adds	r5, #24
 800ba40:	42ac      	cmp	r4, r5
 800ba42:	bf08      	it	eq
 800ba44:	f040 0001 	orreq.w	r0, r0, #1
 800ba48:	3518      	adds	r5, #24
 800ba4a:	42ac      	cmp	r4, r5
 800ba4c:	bf08      	it	eq
 800ba4e:	f040 0001 	orreq.w	r0, r0, #1
 800ba52:	3518      	adds	r5, #24
 800ba54:	42ac      	cmp	r4, r5
 800ba56:	bf08      	it	eq
 800ba58:	f040 0001 	orreq.w	r0, r0, #1
 800ba5c:	3518      	adds	r5, #24
 800ba5e:	42ac      	cmp	r4, r5
 800ba60:	bf08      	it	eq
 800ba62:	f040 0001 	orreq.w	r0, r0, #1
 800ba66:	3518      	adds	r5, #24
 800ba68:	42ac      	cmp	r4, r5
 800ba6a:	bf08      	it	eq
 800ba6c:	f040 0001 	orreq.w	r0, r0, #1
 800ba70:	3518      	adds	r5, #24
 800ba72:	42ac      	cmp	r4, r5
 800ba74:	bf08      	it	eq
 800ba76:	f040 0001 	orreq.w	r0, r0, #1
 800ba7a:	3518      	adds	r5, #24
 800ba7c:	42ac      	cmp	r4, r5
 800ba7e:	bf14      	ite	ne
 800ba80:	4681      	movne	r9, r0
 800ba82:	f040 0901 	orreq.w	r9, r0, #1
 800ba86:	f5a5 6592 	sub.w	r5, r5, #1168	; 0x490
 800ba8a:	42ac      	cmp	r4, r5
 800ba8c:	bf18      	it	ne
 800ba8e:	42b4      	cmpne	r4, r6
 800ba90:	bf0c      	ite	eq
 800ba92:	2501      	moveq	r5, #1
 800ba94:	2500      	movne	r5, #0
 800ba96:	d002      	beq.n	800ba9e <HAL_DMA_Start_IT+0xee>
 800ba98:	f1b9 0f00 	cmp.w	r9, #0
 800ba9c:	d054      	beq.n	800bb48 <HAL_DMA_Start_IT+0x198>
 800ba9e:	6826      	ldr	r6, [r4, #0]
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 800baa0:	f8dc a058 	ldr.w	sl, [ip, #88]	; 0x58
    __HAL_DMA_DISABLE(hdma);
 800baa4:	f026 0601 	bic.w	r6, r6, #1
 800baa8:	6026      	str	r6, [r4, #0]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800baaa:	2d00      	cmp	r5, #0
 800baac:	d078      	beq.n	800bba0 <HAL_DMA_Start_IT+0x1f0>
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800baae:	e9dc 6719 	ldrd	r6, r7, [ip, #100]	; 0x64
 800bab2:	6077      	str	r7, [r6, #4]
    if(hdma->DMAmuxRequestGen != 0U)
 800bab4:	f8dc 706c 	ldr.w	r7, [ip, #108]	; 0x6c
 800bab8:	b117      	cbz	r7, 800bac0 <HAL_DMA_Start_IT+0x110>
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800baba:	e9dc 601c 	ldrd	r6, r0, [ip, #112]	; 0x70
 800babe:	6070      	str	r0, [r6, #4]
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 800bac0:	f8dc 605c 	ldr.w	r6, [ip, #92]	; 0x5c
 800bac4:	f04f 0e3f 	mov.w	lr, #63	; 0x3f
 800bac8:	f006 081f 	and.w	r8, r6, #31
 800bacc:	fa0e fe08 	lsl.w	lr, lr, r8
 800bad0:	f8ca e008 	str.w	lr, [sl, #8]
    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);
 800bad4:	6826      	ldr	r6, [r4, #0]
 800bad6:	f426 2680 	bic.w	r6, r6, #262144	; 0x40000
 800bada:	6026      	str	r6, [r4, #0]
    ((DMA_Stream_TypeDef *)hdma->Instance)->NDTR = DataLength;
 800badc:	6063      	str	r3, [r4, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 800bade:	f8dc 3008 	ldr.w	r3, [ip, #8]
 800bae2:	2b40      	cmp	r3, #64	; 0x40
 800bae4:	f000 80e2 	beq.w	800bcac <HAL_DMA_Start_IT+0x2fc>
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = SrcAddress;
 800bae8:	60a1      	str	r1, [r4, #8]
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = DstAddress;
 800baea:	60e2      	str	r2, [r4, #12]
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800baec:	b91d      	cbnz	r5, 800baf6 <HAL_DMA_Start_IT+0x146>
 800baee:	f1b9 0f00 	cmp.w	r9, #0
 800baf2:	f000 80e1 	beq.w	800bcb8 <HAL_DMA_Start_IT+0x308>
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
 800baf6:	6823      	ldr	r3, [r4, #0]
 800baf8:	f023 031e 	bic.w	r3, r3, #30
 800bafc:	f043 0316 	orr.w	r3, r3, #22
 800bb00:	6023      	str	r3, [r4, #0]
      if(hdma->XferHalfCpltCallback != NULL)
 800bb02:	f8dc 3040 	ldr.w	r3, [ip, #64]	; 0x40
 800bb06:	b11b      	cbz	r3, 800bb10 <HAL_DMA_Start_IT+0x160>
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
 800bb08:	6823      	ldr	r3, [r4, #0]
 800bb0a:	f043 0308 	orr.w	r3, r3, #8
 800bb0e:	6023      	str	r3, [r4, #0]
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
 800bb10:	f8dc 3060 	ldr.w	r3, [ip, #96]	; 0x60
 800bb14:	681a      	ldr	r2, [r3, #0]
 800bb16:	03d2      	lsls	r2, r2, #15
 800bb18:	d503      	bpl.n	800bb22 <HAL_DMA_Start_IT+0x172>
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
 800bb1a:	681a      	ldr	r2, [r3, #0]
 800bb1c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800bb20:	601a      	str	r2, [r3, #0]
      if(hdma->DMAmuxRequestGen != 0U)
 800bb22:	b11f      	cbz	r7, 800bb2c <HAL_DMA_Start_IT+0x17c>
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
 800bb24:	683b      	ldr	r3, [r7, #0]
 800bb26:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800bb2a:	603b      	str	r3, [r7, #0]
    __HAL_DMA_ENABLE(hdma);
 800bb2c:	6823      	ldr	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
 800bb2e:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
 800bb30:	f043 0301 	orr.w	r3, r3, #1
 800bb34:	6023      	str	r3, [r4, #0]
}
 800bb36:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800bb3a:	bf00      	nop
 800bb3c:	40020058 	.word	0x40020058
 800bb40:	40020010 	.word	0x40020010
 800bb44:	40020040 	.word	0x40020040
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800bb48:	4f61      	ldr	r7, [pc, #388]	; (800bcd0 <HAL_DMA_Start_IT+0x320>)
 800bb4a:	4e62      	ldr	r6, [pc, #392]	; (800bcd4 <HAL_DMA_Start_IT+0x324>)
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 800bb4c:	f8dc a058 	ldr.w	sl, [ip, #88]	; 0x58
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800bb50:	42b4      	cmp	r4, r6
 800bb52:	bf18      	it	ne
 800bb54:	42bc      	cmpne	r4, r7
 800bb56:	f106 0628 	add.w	r6, r6, #40	; 0x28
 800bb5a:	bf0c      	ite	eq
 800bb5c:	2701      	moveq	r7, #1
 800bb5e:	2700      	movne	r7, #0
 800bb60:	42b4      	cmp	r4, r6
 800bb62:	bf08      	it	eq
 800bb64:	f047 0701 	orreq.w	r7, r7, #1
 800bb68:	3614      	adds	r6, #20
 800bb6a:	42b4      	cmp	r4, r6
 800bb6c:	bf08      	it	eq
 800bb6e:	f047 0701 	orreq.w	r7, r7, #1
 800bb72:	3614      	adds	r6, #20
 800bb74:	42b4      	cmp	r4, r6
 800bb76:	bf08      	it	eq
 800bb78:	f047 0701 	orreq.w	r7, r7, #1
 800bb7c:	3614      	adds	r6, #20
 800bb7e:	42b4      	cmp	r4, r6
 800bb80:	bf08      	it	eq
 800bb82:	f047 0701 	orreq.w	r7, r7, #1
    __HAL_DMA_DISABLE(hdma);
 800bb86:	6826      	ldr	r6, [r4, #0]
 800bb88:	f026 0601 	bic.w	r6, r6, #1
 800bb8c:	6026      	str	r6, [r4, #0]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800bb8e:	4e52      	ldr	r6, [pc, #328]	; (800bcd8 <HAL_DMA_Start_IT+0x328>)
 800bb90:	42b4      	cmp	r4, r6
 800bb92:	bf08      	it	eq
 800bb94:	f047 0701 	orreq.w	r7, r7, #1
 800bb98:	b917      	cbnz	r7, 800bba0 <HAL_DMA_Start_IT+0x1f0>
 800bb9a:	4f50      	ldr	r7, [pc, #320]	; (800bcdc <HAL_DMA_Start_IT+0x32c>)
 800bb9c:	42bc      	cmp	r4, r7
 800bb9e:	d10b      	bne.n	800bbb8 <HAL_DMA_Start_IT+0x208>
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800bba0:	e9dc 6719 	ldrd	r6, r7, [ip, #100]	; 0x64
 800bba4:	6077      	str	r7, [r6, #4]
    if(hdma->DMAmuxRequestGen != 0U)
 800bba6:	f8dc 706c 	ldr.w	r7, [ip, #108]	; 0x6c
 800bbaa:	b117      	cbz	r7, 800bbb2 <HAL_DMA_Start_IT+0x202>
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800bbac:	e9dc 061c 	ldrd	r0, r6, [ip, #112]	; 0x70
 800bbb0:	6046      	str	r6, [r0, #4]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800bbb2:	f1b9 0f00 	cmp.w	r9, #0
 800bbb6:	d183      	bne.n	800bac0 <HAL_DMA_Start_IT+0x110>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 800bbb8:	4f46      	ldr	r7, [pc, #280]	; (800bcd4 <HAL_DMA_Start_IT+0x324>)
 800bbba:	f8df e114 	ldr.w	lr, [pc, #276]	; 800bcd0 <HAL_DMA_Start_IT+0x320>
 800bbbe:	4574      	cmp	r4, lr
 800bbc0:	bf18      	it	ne
 800bbc2:	42bc      	cmpne	r4, r7
 800bbc4:	f10e 0e14 	add.w	lr, lr, #20
 800bbc8:	bf0c      	ite	eq
 800bbca:	2701      	moveq	r7, #1
 800bbcc:	2700      	movne	r7, #0
 800bbce:	4574      	cmp	r4, lr
 800bbd0:	bf08      	it	eq
 800bbd2:	f047 0701 	orreq.w	r7, r7, #1
 800bbd6:	f10e 0e14 	add.w	lr, lr, #20
 800bbda:	4574      	cmp	r4, lr
 800bbdc:	bf08      	it	eq
 800bbde:	f047 0701 	orreq.w	r7, r7, #1
 800bbe2:	f10e 0e14 	add.w	lr, lr, #20
 800bbe6:	4574      	cmp	r4, lr
 800bbe8:	bf08      	it	eq
 800bbea:	f047 0701 	orreq.w	r7, r7, #1
 800bbee:	f10e 0e14 	add.w	lr, lr, #20
 800bbf2:	4574      	cmp	r4, lr
 800bbf4:	bf08      	it	eq
 800bbf6:	f047 0701 	orreq.w	r7, r7, #1
 800bbfa:	f10e 0e14 	add.w	lr, lr, #20
 800bbfe:	4574      	cmp	r4, lr
 800bc00:	bf08      	it	eq
 800bc02:	f047 0701 	orreq.w	r7, r7, #1
 800bc06:	b917      	cbnz	r7, 800bc0e <HAL_DMA_Start_IT+0x25e>
 800bc08:	4f34      	ldr	r7, [pc, #208]	; (800bcdc <HAL_DMA_Start_IT+0x32c>)
 800bc0a:	42bc      	cmp	r4, r7
 800bc0c:	d154      	bne.n	800bcb8 <HAL_DMA_Start_IT+0x308>
    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
 800bc0e:	f8dc 005c 	ldr.w	r0, [ip, #92]	; 0x5c
 800bc12:	2701      	movs	r7, #1
 800bc14:	f000 0e1f 	and.w	lr, r0, #31
 800bc18:	fa07 f70e 	lsl.w	r7, r7, lr
 800bc1c:	f8ca 7004 	str.w	r7, [sl, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;
 800bc20:	6063      	str	r3, [r4, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 800bc22:	f8dc 3008 	ldr.w	r3, [ip, #8]
 800bc26:	2b40      	cmp	r3, #64	; 0x40
 800bc28:	d043      	beq.n	800bcb2 <HAL_DMA_Start_IT+0x302>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;
 800bc2a:	60a1      	str	r1, [r4, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;
 800bc2c:	60e2      	str	r2, [r4, #12]
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
 800bc2e:	6823      	ldr	r3, [r4, #0]
 800bc30:	f023 030e 	bic.w	r3, r3, #14
 800bc34:	f043 030a 	orr.w	r3, r3, #10
 800bc38:	6023      	str	r3, [r4, #0]
      if(hdma->XferHalfCpltCallback != NULL)
 800bc3a:	f8dc 3040 	ldr.w	r3, [ip, #64]	; 0x40
 800bc3e:	2b00      	cmp	r3, #0
 800bc40:	d02d      	beq.n	800bc9e <HAL_DMA_Start_IT+0x2ee>
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
 800bc42:	6823      	ldr	r3, [r4, #0]
 800bc44:	f043 0304 	orr.w	r3, r3, #4
 800bc48:	6023      	str	r3, [r4, #0]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800bc4a:	4b21      	ldr	r3, [pc, #132]	; (800bcd0 <HAL_DMA_Start_IT+0x320>)
 800bc4c:	4a21      	ldr	r2, [pc, #132]	; (800bcd4 <HAL_DMA_Start_IT+0x324>)
 800bc4e:	4294      	cmp	r4, r2
 800bc50:	bf18      	it	ne
 800bc52:	429c      	cmpne	r4, r3
 800bc54:	f102 0228 	add.w	r2, r2, #40	; 0x28
 800bc58:	bf0c      	ite	eq
 800bc5a:	2301      	moveq	r3, #1
 800bc5c:	2300      	movne	r3, #0
 800bc5e:	4294      	cmp	r4, r2
 800bc60:	bf08      	it	eq
 800bc62:	f043 0301 	orreq.w	r3, r3, #1
 800bc66:	3214      	adds	r2, #20
 800bc68:	4294      	cmp	r4, r2
 800bc6a:	bf08      	it	eq
 800bc6c:	f043 0301 	orreq.w	r3, r3, #1
 800bc70:	3214      	adds	r2, #20
 800bc72:	4294      	cmp	r4, r2
 800bc74:	bf08      	it	eq
 800bc76:	f043 0301 	orreq.w	r3, r3, #1
 800bc7a:	3214      	adds	r2, #20
 800bc7c:	4294      	cmp	r4, r2
 800bc7e:	bf08      	it	eq
 800bc80:	f043 0301 	orreq.w	r3, r3, #1
 800bc84:	3214      	adds	r2, #20
 800bc86:	4294      	cmp	r4, r2
 800bc88:	bf08      	it	eq
 800bc8a:	f043 0301 	orreq.w	r3, r3, #1
 800bc8e:	3214      	adds	r2, #20
 800bc90:	4294      	cmp	r4, r2
 800bc92:	bf08      	it	eq
 800bc94:	f043 0301 	orreq.w	r3, r3, #1
 800bc98:	2b00      	cmp	r3, #0
 800bc9a:	f43f af47 	beq.w	800bb2c <HAL_DMA_Start_IT+0x17c>
 800bc9e:	f8dc 706c 	ldr.w	r7, [ip, #108]	; 0x6c
 800bca2:	e735      	b.n	800bb10 <HAL_DMA_Start_IT+0x160>
    return HAL_ERROR;
 800bca4:	2001      	movs	r0, #1
 800bca6:	4770      	bx	lr
  __HAL_LOCK(hdma);
 800bca8:	2002      	movs	r0, #2
}
 800bcaa:	4770      	bx	lr
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = DstAddress;
 800bcac:	60a2      	str	r2, [r4, #8]
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = SrcAddress;
 800bcae:	60e1      	str	r1, [r4, #12]
 800bcb0:	e71c      	b.n	800baec <HAL_DMA_Start_IT+0x13c>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
 800bcb2:	60a2      	str	r2, [r4, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;
 800bcb4:	60e1      	str	r1, [r4, #12]
 800bcb6:	e7ba      	b.n	800bc2e <HAL_DMA_Start_IT+0x27e>
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
 800bcb8:	6823      	ldr	r3, [r4, #0]
 800bcba:	f023 030e 	bic.w	r3, r3, #14
 800bcbe:	f043 030a 	orr.w	r3, r3, #10
 800bcc2:	6023      	str	r3, [r4, #0]
      if(hdma->XferHalfCpltCallback != NULL)
 800bcc4:	f8dc 3040 	ldr.w	r3, [ip, #64]	; 0x40
 800bcc8:	2b00      	cmp	r3, #0
 800bcca:	d1ba      	bne.n	800bc42 <HAL_DMA_Start_IT+0x292>
 800bccc:	e7bd      	b.n	800bc4a <HAL_DMA_Start_IT+0x29a>
 800bcce:	bf00      	nop
 800bcd0:	5802541c 	.word	0x5802541c
 800bcd4:	58025408 	.word	0x58025408
 800bcd8:	58025480 	.word	0x58025480
 800bcdc:	58025494 	.word	0x58025494

0800bce0 <HAL_DMA_Abort>:
{
 800bce0:	b570      	push	{r4, r5, r6, lr}
 800bce2:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
 800bce4:	f7ff f812 	bl	800ad0c <HAL_GetTick>
  if(hdma == NULL)
 800bce8:	2d00      	cmp	r5, #0
 800bcea:	f000 8124 	beq.w	800bf36 <HAL_DMA_Abort+0x256>
  if(hdma->State != HAL_DMA_STATE_BUSY)
 800bcee:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
 800bcf2:	2b02      	cmp	r3, #2
 800bcf4:	f040 80dd 	bne.w	800beb2 <HAL_DMA_Abort+0x1d2>
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800bcf8:	682c      	ldr	r4, [r5, #0]
 800bcfa:	4606      	mov	r6, r0
 800bcfc:	4b8f      	ldr	r3, [pc, #572]	; (800bf3c <HAL_DMA_Abort+0x25c>)
 800bcfe:	4890      	ldr	r0, [pc, #576]	; (800bf40 <HAL_DMA_Abort+0x260>)
 800bd00:	4a90      	ldr	r2, [pc, #576]	; (800bf44 <HAL_DMA_Abort+0x264>)
 800bd02:	4284      	cmp	r4, r0
 800bd04:	bf18      	it	ne
 800bd06:	429c      	cmpne	r4, r3
 800bd08:	f100 0030 	add.w	r0, r0, #48	; 0x30
 800bd0c:	498e      	ldr	r1, [pc, #568]	; (800bf48 <HAL_DMA_Abort+0x268>)
 800bd0e:	bf0c      	ite	eq
 800bd10:	2301      	moveq	r3, #1
 800bd12:	2300      	movne	r3, #0
 800bd14:	4284      	cmp	r4, r0
 800bd16:	bf08      	it	eq
 800bd18:	f043 0301 	orreq.w	r3, r3, #1
 800bd1c:	3018      	adds	r0, #24
 800bd1e:	4284      	cmp	r4, r0
 800bd20:	bf08      	it	eq
 800bd22:	f043 0301 	orreq.w	r3, r3, #1
 800bd26:	3018      	adds	r0, #24
 800bd28:	4284      	cmp	r4, r0
 800bd2a:	bf08      	it	eq
 800bd2c:	f043 0301 	orreq.w	r3, r3, #1
 800bd30:	3018      	adds	r0, #24
 800bd32:	4284      	cmp	r4, r0
 800bd34:	bf08      	it	eq
 800bd36:	f043 0301 	orreq.w	r3, r3, #1
 800bd3a:	f500 7056 	add.w	r0, r0, #856	; 0x358
 800bd3e:	4284      	cmp	r4, r0
 800bd40:	bf08      	it	eq
 800bd42:	f043 0301 	orreq.w	r3, r3, #1
 800bd46:	3018      	adds	r0, #24
 800bd48:	4284      	cmp	r4, r0
 800bd4a:	bf08      	it	eq
 800bd4c:	f043 0301 	orreq.w	r3, r3, #1
 800bd50:	3018      	adds	r0, #24
 800bd52:	4284      	cmp	r4, r0
 800bd54:	bf08      	it	eq
 800bd56:	f043 0301 	orreq.w	r3, r3, #1
 800bd5a:	3018      	adds	r0, #24
 800bd5c:	4284      	cmp	r4, r0
 800bd5e:	bf08      	it	eq
 800bd60:	f043 0301 	orreq.w	r3, r3, #1
 800bd64:	3018      	adds	r0, #24
 800bd66:	4284      	cmp	r4, r0
 800bd68:	bf08      	it	eq
 800bd6a:	f043 0301 	orreq.w	r3, r3, #1
 800bd6e:	3018      	adds	r0, #24
 800bd70:	4284      	cmp	r4, r0
 800bd72:	bf08      	it	eq
 800bd74:	f043 0301 	orreq.w	r3, r3, #1
 800bd78:	3018      	adds	r0, #24
 800bd7a:	4284      	cmp	r4, r0
 800bd7c:	bf08      	it	eq
 800bd7e:	f043 0301 	orreq.w	r3, r3, #1
 800bd82:	3018      	adds	r0, #24
 800bd84:	4284      	cmp	r4, r0
 800bd86:	bf08      	it	eq
 800bd88:	f043 0301 	orreq.w	r3, r3, #1
 800bd8c:	428c      	cmp	r4, r1
 800bd8e:	bf18      	it	ne
 800bd90:	4294      	cmpne	r4, r2
 800bd92:	bf0c      	ite	eq
 800bd94:	2201      	moveq	r2, #1
 800bd96:	2200      	movne	r2, #0
 800bd98:	d002      	beq.n	800bda0 <HAL_DMA_Abort+0xc0>
 800bd9a:	2b00      	cmp	r3, #0
 800bd9c:	f000 8090 	beq.w	800bec0 <HAL_DMA_Abort+0x1e0>
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT);
 800bda0:	6821      	ldr	r1, [r4, #0]
 800bda2:	f021 011e 	bic.w	r1, r1, #30
 800bda6:	6021      	str	r1, [r4, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
 800bda8:	6961      	ldr	r1, [r4, #20]
 800bdaa:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 800bdae:	6161      	str	r1, [r4, #20]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800bdb0:	2a00      	cmp	r2, #0
 800bdb2:	f000 80b0 	beq.w	800bf16 <HAL_DMA_Abort+0x236>
      hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 800bdb6:	6e2a      	ldr	r2, [r5, #96]	; 0x60
 800bdb8:	6813      	ldr	r3, [r2, #0]
 800bdba:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800bdbe:	6013      	str	r3, [r2, #0]
    __HAL_DMA_DISABLE(hdma);
 800bdc0:	6823      	ldr	r3, [r4, #0]
 800bdc2:	f023 0301 	bic.w	r3, r3, #1
 800bdc6:	6023      	str	r3, [r4, #0]
 800bdc8:	e005      	b.n	800bdd6 <HAL_DMA_Abort+0xf6>
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 800bdca:	f7fe ff9f 	bl	800ad0c <HAL_GetTick>
 800bdce:	1b83      	subs	r3, r0, r6
 800bdd0:	2b05      	cmp	r3, #5
 800bdd2:	f200 80a6 	bhi.w	800bf22 <HAL_DMA_Abort+0x242>
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
 800bdd6:	6823      	ldr	r3, [r4, #0]
 800bdd8:	07db      	lsls	r3, r3, #31
 800bdda:	d4f6      	bmi.n	800bdca <HAL_DMA_Abort+0xea>
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800bddc:	682a      	ldr	r2, [r5, #0]
 800bdde:	4b57      	ldr	r3, [pc, #348]	; (800bf3c <HAL_DMA_Abort+0x25c>)
 800bde0:	4857      	ldr	r0, [pc, #348]	; (800bf40 <HAL_DMA_Abort+0x260>)
 800bde2:	495a      	ldr	r1, [pc, #360]	; (800bf4c <HAL_DMA_Abort+0x26c>)
 800bde4:	4282      	cmp	r2, r0
 800bde6:	bf18      	it	ne
 800bde8:	429a      	cmpne	r2, r3
 800bdea:	f100 0048 	add.w	r0, r0, #72	; 0x48
 800bdee:	bf0c      	ite	eq
 800bdf0:	2301      	moveq	r3, #1
 800bdf2:	2300      	movne	r3, #0
 800bdf4:	428a      	cmp	r2, r1
 800bdf6:	bf08      	it	eq
 800bdf8:	f043 0301 	orreq.w	r3, r3, #1
 800bdfc:	3130      	adds	r1, #48	; 0x30
 800bdfe:	4282      	cmp	r2, r0
 800be00:	bf08      	it	eq
 800be02:	f043 0301 	orreq.w	r3, r3, #1
 800be06:	3030      	adds	r0, #48	; 0x30
 800be08:	428a      	cmp	r2, r1
 800be0a:	bf08      	it	eq
 800be0c:	f043 0301 	orreq.w	r3, r3, #1
 800be10:	f501 715c 	add.w	r1, r1, #880	; 0x370
 800be14:	4282      	cmp	r2, r0
 800be16:	bf08      	it	eq
 800be18:	f043 0301 	orreq.w	r3, r3, #1
 800be1c:	f500 705c 	add.w	r0, r0, #880	; 0x370
 800be20:	428a      	cmp	r2, r1
 800be22:	bf08      	it	eq
 800be24:	f043 0301 	orreq.w	r3, r3, #1
 800be28:	3130      	adds	r1, #48	; 0x30
 800be2a:	4282      	cmp	r2, r0
 800be2c:	bf08      	it	eq
 800be2e:	f043 0301 	orreq.w	r3, r3, #1
 800be32:	3030      	adds	r0, #48	; 0x30
 800be34:	428a      	cmp	r2, r1
 800be36:	bf08      	it	eq
 800be38:	f043 0301 	orreq.w	r3, r3, #1
 800be3c:	3130      	adds	r1, #48	; 0x30
 800be3e:	4282      	cmp	r2, r0
 800be40:	bf08      	it	eq
 800be42:	f043 0301 	orreq.w	r3, r3, #1
 800be46:	3030      	adds	r0, #48	; 0x30
 800be48:	428a      	cmp	r2, r1
 800be4a:	bf08      	it	eq
 800be4c:	f043 0301 	orreq.w	r3, r3, #1
 800be50:	3130      	adds	r1, #48	; 0x30
 800be52:	4282      	cmp	r2, r0
 800be54:	bf08      	it	eq
 800be56:	f043 0301 	orreq.w	r3, r3, #1
 800be5a:	428a      	cmp	r2, r1
 800be5c:	bf08      	it	eq
 800be5e:	f043 0301 	orreq.w	r3, r3, #1
 800be62:	3118      	adds	r1, #24
 800be64:	428a      	cmp	r2, r1
 800be66:	bf08      	it	eq
 800be68:	f043 0301 	orreq.w	r3, r3, #1
 800be6c:	b933      	cbnz	r3, 800be7c <HAL_DMA_Abort+0x19c>
 800be6e:	f5a1 6195 	sub.w	r1, r1, #1192	; 0x4a8
 800be72:	4b35      	ldr	r3, [pc, #212]	; (800bf48 <HAL_DMA_Abort+0x268>)
 800be74:	429a      	cmp	r2, r3
 800be76:	bf18      	it	ne
 800be78:	428a      	cmpne	r2, r1
 800be7a:	d16f      	bne.n	800bf5c <HAL_DMA_Abort+0x27c>
      regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 800be7c:	6dea      	ldr	r2, [r5, #92]	; 0x5c
 800be7e:	233f      	movs	r3, #63	; 0x3f
      regs_dma = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 800be80:	6da9      	ldr	r1, [r5, #88]	; 0x58
      regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 800be82:	f002 021f 	and.w	r2, r2, #31
 800be86:	4093      	lsls	r3, r2
 800be88:	608b      	str	r3, [r1, #8]
      if(hdma->DMAmuxRequestGen != 0U)
 800be8a:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800be8c:	e9d5 2119 	ldrd	r2, r1, [r5, #100]	; 0x64
 800be90:	6051      	str	r1, [r2, #4]
      if(hdma->DMAmuxRequestGen != 0U)
 800be92:	b133      	cbz	r3, 800bea2 <HAL_DMA_Abort+0x1c2>
        hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 800be94:	681a      	ldr	r2, [r3, #0]
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800be96:	e9d5 101c 	ldrd	r1, r0, [r5, #112]	; 0x70
        hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 800be9a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800be9e:	601a      	str	r2, [r3, #0]
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800bea0:	6048      	str	r0, [r1, #4]
    __HAL_UNLOCK(hdma);
 800bea2:	2300      	movs	r3, #0
    hdma->State = HAL_DMA_STATE_READY;
 800bea4:	2201      	movs	r2, #1
  return HAL_OK;
 800bea6:	4618      	mov	r0, r3
    hdma->State = HAL_DMA_STATE_READY;
 800bea8:	f885 2035 	strb.w	r2, [r5, #53]	; 0x35
    __HAL_UNLOCK(hdma);
 800beac:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
}
 800beb0:	bd70      	pop	{r4, r5, r6, pc}
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800beb2:	2280      	movs	r2, #128	; 0x80
    __HAL_UNLOCK(hdma);
 800beb4:	2300      	movs	r3, #0
    return HAL_ERROR;
 800beb6:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800beb8:	656a      	str	r2, [r5, #84]	; 0x54
    __HAL_UNLOCK(hdma);
 800beba:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
}
 800bebe:	bd70      	pop	{r4, r5, r6, pc}
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
 800bec0:	6822      	ldr	r2, [r4, #0]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800bec2:	4923      	ldr	r1, [pc, #140]	; (800bf50 <HAL_DMA_Abort+0x270>)
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
 800bec4:	f022 020e 	bic.w	r2, r2, #14
 800bec8:	6022      	str	r2, [r4, #0]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800beca:	4a22      	ldr	r2, [pc, #136]	; (800bf54 <HAL_DMA_Abort+0x274>)
 800becc:	428c      	cmp	r4, r1
 800bece:	bf18      	it	ne
 800bed0:	4294      	cmpne	r4, r2
 800bed2:	f101 0128 	add.w	r1, r1, #40	; 0x28
 800bed6:	bf0c      	ite	eq
 800bed8:	2201      	moveq	r2, #1
 800beda:	2200      	movne	r2, #0
 800bedc:	428c      	cmp	r4, r1
 800bede:	bf08      	it	eq
 800bee0:	f042 0201 	orreq.w	r2, r2, #1
 800bee4:	3114      	adds	r1, #20
 800bee6:	428c      	cmp	r4, r1
 800bee8:	bf08      	it	eq
 800beea:	f042 0201 	orreq.w	r2, r2, #1
 800beee:	3114      	adds	r1, #20
 800bef0:	428c      	cmp	r4, r1
 800bef2:	bf08      	it	eq
 800bef4:	f042 0201 	orreq.w	r2, r2, #1
 800bef8:	3114      	adds	r1, #20
 800befa:	428c      	cmp	r4, r1
 800befc:	bf08      	it	eq
 800befe:	f042 0201 	orreq.w	r2, r2, #1
 800bf02:	3114      	adds	r1, #20
 800bf04:	428c      	cmp	r4, r1
 800bf06:	bf08      	it	eq
 800bf08:	f042 0201 	orreq.w	r2, r2, #1
 800bf0c:	b91a      	cbnz	r2, 800bf16 <HAL_DMA_Abort+0x236>
 800bf0e:	4a12      	ldr	r2, [pc, #72]	; (800bf58 <HAL_DMA_Abort+0x278>)
 800bf10:	4294      	cmp	r4, r2
 800bf12:	f47f af55 	bne.w	800bdc0 <HAL_DMA_Abort+0xe0>
      hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 800bf16:	6e29      	ldr	r1, [r5, #96]	; 0x60
 800bf18:	680a      	ldr	r2, [r1, #0]
 800bf1a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800bf1e:	600a      	str	r2, [r1, #0]
    __HAL_DMA_DISABLE(hdma);
 800bf20:	e74e      	b.n	800bdc0 <HAL_DMA_Abort+0xe0>
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 800bf22:	2120      	movs	r1, #32
        hdma->State = HAL_DMA_STATE_ERROR;
 800bf24:	2203      	movs	r2, #3
        __HAL_UNLOCK(hdma);
 800bf26:	2300      	movs	r3, #0
        return HAL_ERROR;
 800bf28:	2001      	movs	r0, #1
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 800bf2a:	6569      	str	r1, [r5, #84]	; 0x54
        __HAL_UNLOCK(hdma);
 800bf2c:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
        hdma->State = HAL_DMA_STATE_ERROR;
 800bf30:	f885 2035 	strb.w	r2, [r5, #53]	; 0x35
}
 800bf34:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 800bf36:	2001      	movs	r0, #1
}
 800bf38:	bd70      	pop	{r4, r5, r6, pc}
 800bf3a:	bf00      	nop
 800bf3c:	40020058 	.word	0x40020058
 800bf40:	40020040 	.word	0x40020040
 800bf44:	40020010 	.word	0x40020010
 800bf48:	40020028 	.word	0x40020028
 800bf4c:	40020070 	.word	0x40020070
 800bf50:	58025408 	.word	0x58025408
 800bf54:	5802541c 	.word	0x5802541c
 800bf58:	58025494 	.word	0x58025494
      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 800bf5c:	6de8      	ldr	r0, [r5, #92]	; 0x5c
 800bf5e:	2101      	movs	r1, #1
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800bf60:	4b16      	ldr	r3, [pc, #88]	; (800bfbc <HAL_DMA_Abort+0x2dc>)
      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 800bf62:	f000 001f 	and.w	r0, r0, #31
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800bf66:	4c16      	ldr	r4, [pc, #88]	; (800bfc0 <HAL_DMA_Abort+0x2e0>)
      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 800bf68:	4081      	lsls	r1, r0
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800bf6a:	42a2      	cmp	r2, r4
 800bf6c:	bf18      	it	ne
 800bf6e:	429a      	cmpne	r2, r3
      regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
 800bf70:	6da8      	ldr	r0, [r5, #88]	; 0x58
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800bf72:	bf0c      	ite	eq
 800bf74:	2301      	moveq	r3, #1
 800bf76:	2300      	movne	r3, #0
      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 800bf78:	6041      	str	r1, [r0, #4]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800bf7a:	4812      	ldr	r0, [pc, #72]	; (800bfc4 <HAL_DMA_Abort+0x2e4>)
 800bf7c:	4912      	ldr	r1, [pc, #72]	; (800bfc8 <HAL_DMA_Abort+0x2e8>)
 800bf7e:	4282      	cmp	r2, r0
 800bf80:	bf08      	it	eq
 800bf82:	f043 0301 	orreq.w	r3, r3, #1
 800bf86:	3028      	adds	r0, #40	; 0x28
 800bf88:	428a      	cmp	r2, r1
 800bf8a:	bf08      	it	eq
 800bf8c:	f043 0301 	orreq.w	r3, r3, #1
 800bf90:	3128      	adds	r1, #40	; 0x28
 800bf92:	4282      	cmp	r2, r0
 800bf94:	bf08      	it	eq
 800bf96:	f043 0301 	orreq.w	r3, r3, #1
 800bf9a:	428a      	cmp	r2, r1
 800bf9c:	bf08      	it	eq
 800bf9e:	f043 0301 	orreq.w	r3, r3, #1
 800bfa2:	3114      	adds	r1, #20
 800bfa4:	428a      	cmp	r2, r1
 800bfa6:	bf08      	it	eq
 800bfa8:	f043 0301 	orreq.w	r3, r3, #1
 800bfac:	2b00      	cmp	r3, #0
 800bfae:	f47f af6c 	bne.w	800be8a <HAL_DMA_Abort+0x1aa>
 800bfb2:	4b06      	ldr	r3, [pc, #24]	; (800bfcc <HAL_DMA_Abort+0x2ec>)
 800bfb4:	429a      	cmp	r2, r3
 800bfb6:	f43f af68 	beq.w	800be8a <HAL_DMA_Abort+0x1aa>
 800bfba:	e772      	b.n	800bea2 <HAL_DMA_Abort+0x1c2>
 800bfbc:	5802541c 	.word	0x5802541c
 800bfc0:	58025408 	.word	0x58025408
 800bfc4:	58025430 	.word	0x58025430
 800bfc8:	58025444 	.word	0x58025444
 800bfcc:	58025494 	.word	0x58025494

0800bfd0 <HAL_DMA_Abort_IT>:
  if(hdma == NULL)
 800bfd0:	2800      	cmp	r0, #0
 800bfd2:	d05f      	beq.n	800c094 <HAL_DMA_Abort_IT+0xc4>
{
 800bfd4:	b538      	push	{r3, r4, r5, lr}
  if(hdma->State != HAL_DMA_STATE_BUSY)
 800bfd6:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
 800bfda:	4603      	mov	r3, r0
 800bfdc:	2a02      	cmp	r2, #2
 800bfde:	d155      	bne.n	800c08c <HAL_DMA_Abort_IT+0xbc>
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800bfe0:	6801      	ldr	r1, [r0, #0]
 800bfe2:	4a57      	ldr	r2, [pc, #348]	; (800c140 <HAL_DMA_Abort_IT+0x170>)
 800bfe4:	4291      	cmp	r1, r2
 800bfe6:	d048      	beq.n	800c07a <HAL_DMA_Abort_IT+0xaa>
 800bfe8:	3218      	adds	r2, #24
 800bfea:	4291      	cmp	r1, r2
 800bfec:	d045      	beq.n	800c07a <HAL_DMA_Abort_IT+0xaa>
 800bfee:	3230      	adds	r2, #48	; 0x30
 800bff0:	4c54      	ldr	r4, [pc, #336]	; (800c144 <HAL_DMA_Abort_IT+0x174>)
 800bff2:	4855      	ldr	r0, [pc, #340]	; (800c148 <HAL_DMA_Abort_IT+0x178>)
 800bff4:	42a1      	cmp	r1, r4
 800bff6:	bf18      	it	ne
 800bff8:	4291      	cmpne	r1, r2
 800bffa:	f104 0448 	add.w	r4, r4, #72	; 0x48
 800bffe:	bf0c      	ite	eq
 800c000:	2201      	moveq	r2, #1
 800c002:	2200      	movne	r2, #0
 800c004:	4281      	cmp	r1, r0
 800c006:	bf08      	it	eq
 800c008:	f042 0201 	orreq.w	r2, r2, #1
 800c00c:	3030      	adds	r0, #48	; 0x30
 800c00e:	42a1      	cmp	r1, r4
 800c010:	bf08      	it	eq
 800c012:	f042 0201 	orreq.w	r2, r2, #1
 800c016:	3430      	adds	r4, #48	; 0x30
 800c018:	4281      	cmp	r1, r0
 800c01a:	bf08      	it	eq
 800c01c:	f042 0201 	orreq.w	r2, r2, #1
 800c020:	f500 705c 	add.w	r0, r0, #880	; 0x370
 800c024:	42a1      	cmp	r1, r4
 800c026:	bf08      	it	eq
 800c028:	f042 0201 	orreq.w	r2, r2, #1
 800c02c:	f504 745c 	add.w	r4, r4, #880	; 0x370
 800c030:	4281      	cmp	r1, r0
 800c032:	bf08      	it	eq
 800c034:	f042 0201 	orreq.w	r2, r2, #1
 800c038:	3030      	adds	r0, #48	; 0x30
 800c03a:	42a1      	cmp	r1, r4
 800c03c:	bf08      	it	eq
 800c03e:	f042 0201 	orreq.w	r2, r2, #1
 800c042:	3430      	adds	r4, #48	; 0x30
 800c044:	4281      	cmp	r1, r0
 800c046:	bf08      	it	eq
 800c048:	f042 0201 	orreq.w	r2, r2, #1
 800c04c:	3030      	adds	r0, #48	; 0x30
 800c04e:	42a1      	cmp	r1, r4
 800c050:	bf08      	it	eq
 800c052:	f042 0201 	orreq.w	r2, r2, #1
 800c056:	3430      	adds	r4, #48	; 0x30
 800c058:	4281      	cmp	r1, r0
 800c05a:	bf08      	it	eq
 800c05c:	f042 0201 	orreq.w	r2, r2, #1
 800c060:	3030      	adds	r0, #48	; 0x30
 800c062:	42a1      	cmp	r1, r4
 800c064:	bf08      	it	eq
 800c066:	f042 0201 	orreq.w	r2, r2, #1
 800c06a:	4281      	cmp	r1, r0
 800c06c:	bf08      	it	eq
 800c06e:	f042 0201 	orreq.w	r2, r2, #1
 800c072:	b912      	cbnz	r2, 800c07a <HAL_DMA_Abort_IT+0xaa>
 800c074:	4a35      	ldr	r2, [pc, #212]	; (800c14c <HAL_DMA_Abort_IT+0x17c>)
 800c076:	4291      	cmp	r1, r2
 800c078:	d10e      	bne.n	800c098 <HAL_DMA_Abort_IT+0xc8>
      hdma->State = HAL_DMA_STATE_ABORT;
 800c07a:	2204      	movs	r2, #4
  return HAL_OK;
 800c07c:	2000      	movs	r0, #0
      hdma->State = HAL_DMA_STATE_ABORT;
 800c07e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      __HAL_DMA_DISABLE(hdma);
 800c082:	680b      	ldr	r3, [r1, #0]
 800c084:	f023 0301 	bic.w	r3, r3, #1
 800c088:	600b      	str	r3, [r1, #0]
}
 800c08a:	bd38      	pop	{r3, r4, r5, pc}
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800c08c:	2280      	movs	r2, #128	; 0x80
    return HAL_ERROR;
 800c08e:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800c090:	655a      	str	r2, [r3, #84]	; 0x54
}
 800c092:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 800c094:	2001      	movs	r0, #1
}
 800c096:	4770      	bx	lr
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800c098:	4a2d      	ldr	r2, [pc, #180]	; (800c150 <HAL_DMA_Abort_IT+0x180>)
 800c09a:	4d2e      	ldr	r5, [pc, #184]	; (800c154 <HAL_DMA_Abort_IT+0x184>)
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
 800c09c:	6808      	ldr	r0, [r1, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800c09e:	42a9      	cmp	r1, r5
 800c0a0:	bf18      	it	ne
 800c0a2:	4291      	cmpne	r1, r2
 800c0a4:	4c2c      	ldr	r4, [pc, #176]	; (800c158 <HAL_DMA_Abort_IT+0x188>)
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
 800c0a6:	f020 000e 	bic.w	r0, r0, #14
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800c0aa:	f105 053c 	add.w	r5, r5, #60	; 0x3c
 800c0ae:	bf0c      	ite	eq
 800c0b0:	2201      	moveq	r2, #1
 800c0b2:	2200      	movne	r2, #0
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
 800c0b4:	6008      	str	r0, [r1, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800c0b6:	42a1      	cmp	r1, r4
 800c0b8:	bf08      	it	eq
 800c0ba:	f042 0201 	orreq.w	r2, r2, #1
      __HAL_DMA_DISABLE(hdma);
 800c0be:	6808      	ldr	r0, [r1, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800c0c0:	3428      	adds	r4, #40	; 0x28
 800c0c2:	42a9      	cmp	r1, r5
 800c0c4:	bf08      	it	eq
 800c0c6:	f042 0201 	orreq.w	r2, r2, #1
      __HAL_DMA_DISABLE(hdma);
 800c0ca:	f020 0001 	bic.w	r0, r0, #1
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800c0ce:	42a1      	cmp	r1, r4
 800c0d0:	bf08      	it	eq
 800c0d2:	f042 0201 	orreq.w	r2, r2, #1
 800c0d6:	3414      	adds	r4, #20
      __HAL_DMA_DISABLE(hdma);
 800c0d8:	6008      	str	r0, [r1, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800c0da:	42a1      	cmp	r1, r4
 800c0dc:	bf08      	it	eq
 800c0de:	f042 0201 	orreq.w	r2, r2, #1
 800c0e2:	481e      	ldr	r0, [pc, #120]	; (800c15c <HAL_DMA_Abort_IT+0x18c>)
 800c0e4:	4281      	cmp	r1, r0
 800c0e6:	bf08      	it	eq
 800c0e8:	f042 0201 	orreq.w	r2, r2, #1
 800c0ec:	b912      	cbnz	r2, 800c0f4 <HAL_DMA_Abort_IT+0x124>
 800c0ee:	4a1c      	ldr	r2, [pc, #112]	; (800c160 <HAL_DMA_Abort_IT+0x190>)
 800c0f0:	4291      	cmp	r1, r2
 800c0f2:	d117      	bne.n	800c124 <HAL_DMA_Abort_IT+0x154>
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 800c0f4:	2201      	movs	r2, #1
        regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
 800c0f6:	6d9d      	ldr	r5, [r3, #88]	; 0x58
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 800c0f8:	e9d3 0417 	ldrd	r0, r4, [r3, #92]	; 0x5c
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 800c0fc:	6821      	ldr	r1, [r4, #0]
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 800c0fe:	f000 001f 	and.w	r0, r0, #31
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 800c102:	f421 7180 	bic.w	r1, r1, #256	; 0x100
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 800c106:	4082      	lsls	r2, r0
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 800c108:	6021      	str	r1, [r4, #0]
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 800c10a:	606a      	str	r2, [r5, #4]
        if(hdma->DMAmuxRequestGen != 0U)
 800c10c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800c10e:	e9d3 1019 	ldrd	r1, r0, [r3, #100]	; 0x64
 800c112:	6048      	str	r0, [r1, #4]
        if(hdma->DMAmuxRequestGen != 0U)
 800c114:	b132      	cbz	r2, 800c124 <HAL_DMA_Abort_IT+0x154>
          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 800c116:	6811      	ldr	r1, [r2, #0]
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800c118:	e9d3 041c 	ldrd	r0, r4, [r3, #112]	; 0x70
          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 800c11c:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 800c120:	6011      	str	r1, [r2, #0]
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800c122:	6044      	str	r4, [r0, #4]
      hdma->State = HAL_DMA_STATE_READY;
 800c124:	2101      	movs	r1, #1
      __HAL_UNLOCK(hdma);
 800c126:	2400      	movs	r4, #0
      if(hdma->XferAbortCallback != NULL)
 800c128:	6d1a      	ldr	r2, [r3, #80]	; 0x50
      hdma->State = HAL_DMA_STATE_READY;
 800c12a:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
      __HAL_UNLOCK(hdma);
 800c12e:	f883 4034 	strb.w	r4, [r3, #52]	; 0x34
      if(hdma->XferAbortCallback != NULL)
 800c132:	b11a      	cbz	r2, 800c13c <HAL_DMA_Abort_IT+0x16c>
        hdma->XferAbortCallback(hdma);
 800c134:	4618      	mov	r0, r3
 800c136:	4790      	blx	r2
  return HAL_OK;
 800c138:	4620      	mov	r0, r4
}
 800c13a:	bd38      	pop	{r3, r4, r5, pc}
  return HAL_OK;
 800c13c:	4610      	mov	r0, r2
}
 800c13e:	bd38      	pop	{r3, r4, r5, pc}
 800c140:	40020010 	.word	0x40020010
 800c144:	40020040 	.word	0x40020040
 800c148:	40020070 	.word	0x40020070
 800c14c:	400204b8 	.word	0x400204b8
 800c150:	5802541c 	.word	0x5802541c
 800c154:	58025408 	.word	0x58025408
 800c158:	58025430 	.word	0x58025430
 800c15c:	58025480 	.word	0x58025480
 800c160:	58025494 	.word	0x58025494

0800c164 <HAL_DMA_IRQHandler>:
{
 800c164:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  __IO uint32_t count = 0U;
 800c168:	2200      	movs	r2, #0
  uint32_t timeout = SystemCoreClock / 9600U;
 800c16a:	4b9c      	ldr	r3, [pc, #624]	; (800c3dc <HAL_DMA_IRQHandler+0x278>)
{
 800c16c:	b083      	sub	sp, #12
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 800c16e:	4e9c      	ldr	r6, [pc, #624]	; (800c3e0 <HAL_DMA_IRQHandler+0x27c>)
  uint32_t timeout = SystemCoreClock / 9600U;
 800c170:	681d      	ldr	r5, [r3, #0]
{
 800c172:	4681      	mov	r9, r0
  __IO uint32_t count = 0U;
 800c174:	9201      	str	r2, [sp, #4]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 800c176:	6803      	ldr	r3, [r0, #0]
 800c178:	4a9a      	ldr	r2, [pc, #616]	; (800c3e4 <HAL_DMA_IRQHandler+0x280>)
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 800c17a:	6d84      	ldr	r4, [r0, #88]	; 0x58
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 800c17c:	4293      	cmp	r3, r2
 800c17e:	bf18      	it	ne
 800c180:	42b3      	cmpne	r3, r6
  tmpisr_dma  = regs_dma->ISR;
 800c182:	6827      	ldr	r7, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 800c184:	bf08      	it	eq
 800c186:	2601      	moveq	r6, #1
  tmpisr_bdma = regs_bdma->ISR;
 800c188:	6821      	ldr	r1, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 800c18a:	bf18      	it	ne
 800c18c:	2600      	movne	r6, #0
 800c18e:	d045      	beq.n	800c21c <HAL_DMA_IRQHandler+0xb8>
 800c190:	3218      	adds	r2, #24
 800c192:	4895      	ldr	r0, [pc, #596]	; (800c3e8 <HAL_DMA_IRQHandler+0x284>)
 800c194:	4283      	cmp	r3, r0
 800c196:	bf18      	it	ne
 800c198:	4293      	cmpne	r3, r2
 800c19a:	f100 0018 	add.w	r0, r0, #24
 800c19e:	bf0c      	ite	eq
 800c1a0:	2201      	moveq	r2, #1
 800c1a2:	2200      	movne	r2, #0
 800c1a4:	4283      	cmp	r3, r0
 800c1a6:	bf08      	it	eq
 800c1a8:	f042 0201 	orreq.w	r2, r2, #1
 800c1ac:	3018      	adds	r0, #24
 800c1ae:	4283      	cmp	r3, r0
 800c1b0:	bf08      	it	eq
 800c1b2:	f042 0201 	orreq.w	r2, r2, #1
 800c1b6:	3018      	adds	r0, #24
 800c1b8:	4283      	cmp	r3, r0
 800c1ba:	bf08      	it	eq
 800c1bc:	f042 0201 	orreq.w	r2, r2, #1
 800c1c0:	3018      	adds	r0, #24
 800c1c2:	4283      	cmp	r3, r0
 800c1c4:	bf08      	it	eq
 800c1c6:	f042 0201 	orreq.w	r2, r2, #1
 800c1ca:	f500 7056 	add.w	r0, r0, #856	; 0x358
 800c1ce:	4283      	cmp	r3, r0
 800c1d0:	bf08      	it	eq
 800c1d2:	f042 0201 	orreq.w	r2, r2, #1
 800c1d6:	3018      	adds	r0, #24
 800c1d8:	4283      	cmp	r3, r0
 800c1da:	bf08      	it	eq
 800c1dc:	f042 0201 	orreq.w	r2, r2, #1
 800c1e0:	3018      	adds	r0, #24
 800c1e2:	4283      	cmp	r3, r0
 800c1e4:	bf08      	it	eq
 800c1e6:	f042 0201 	orreq.w	r2, r2, #1
 800c1ea:	3018      	adds	r0, #24
 800c1ec:	4283      	cmp	r3, r0
 800c1ee:	bf08      	it	eq
 800c1f0:	f042 0201 	orreq.w	r2, r2, #1
 800c1f4:	3018      	adds	r0, #24
 800c1f6:	4283      	cmp	r3, r0
 800c1f8:	bf08      	it	eq
 800c1fa:	f042 0201 	orreq.w	r2, r2, #1
 800c1fe:	3018      	adds	r0, #24
 800c200:	4283      	cmp	r3, r0
 800c202:	bf08      	it	eq
 800c204:	f042 0201 	orreq.w	r2, r2, #1
 800c208:	3018      	adds	r0, #24
 800c20a:	4283      	cmp	r3, r0
 800c20c:	bf08      	it	eq
 800c20e:	f042 0201 	orreq.w	r2, r2, #1
 800c212:	b91a      	cbnz	r2, 800c21c <HAL_DMA_IRQHandler+0xb8>
 800c214:	4a75      	ldr	r2, [pc, #468]	; (800c3ec <HAL_DMA_IRQHandler+0x288>)
 800c216:	4293      	cmp	r3, r2
 800c218:	f040 8250 	bne.w	800c6bc <HAL_DMA_IRQHandler+0x558>
    if ((tmpisr_dma & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 800c21c:	f8d9 105c 	ldr.w	r1, [r9, #92]	; 0x5c
 800c220:	2208      	movs	r2, #8
 800c222:	f001 0c1f 	and.w	ip, r1, #31
 800c226:	fa02 f20c 	lsl.w	r2, r2, ip
 800c22a:	4217      	tst	r7, r2
 800c22c:	f040 8188 	bne.w	800c540 <HAL_DMA_IRQHandler+0x3dc>
    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 800c230:	fa27 f20c 	lsr.w	r2, r7, ip
 800c234:	07d2      	lsls	r2, r2, #31
 800c236:	d50c      	bpl.n	800c252 <HAL_DMA_IRQHandler+0xee>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
 800c238:	695a      	ldr	r2, [r3, #20]
 800c23a:	0610      	lsls	r0, r2, #24
 800c23c:	d509      	bpl.n	800c252 <HAL_DMA_IRQHandler+0xee>
        regs_dma->IFCR = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
 800c23e:	2201      	movs	r2, #1
 800c240:	fa02 f20c 	lsl.w	r2, r2, ip
 800c244:	60a2      	str	r2, [r4, #8]
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 800c246:	f8d9 2054 	ldr.w	r2, [r9, #84]	; 0x54
 800c24a:	f042 0202 	orr.w	r2, r2, #2
 800c24e:	f8c9 2054 	str.w	r2, [r9, #84]	; 0x54
    if ((tmpisr_dma & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 800c252:	f04f 0e04 	mov.w	lr, #4
 800c256:	fa0e f00c 	lsl.w	r0, lr, ip
 800c25a:	4238      	tst	r0, r7
 800c25c:	d05b      	beq.n	800c316 <HAL_DMA_IRQHandler+0x1b2>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
 800c25e:	2e00      	cmp	r6, #0
 800c260:	d14f      	bne.n	800c302 <HAL_DMA_IRQHandler+0x19e>
 800c262:	4a61      	ldr	r2, [pc, #388]	; (800c3e8 <HAL_DMA_IRQHandler+0x284>)
 800c264:	f8df 8188 	ldr.w	r8, [pc, #392]	; 800c3f0 <HAL_DMA_IRQHandler+0x28c>
 800c268:	4543      	cmp	r3, r8
 800c26a:	bf18      	it	ne
 800c26c:	4293      	cmpne	r3, r2
 800c26e:	f108 0830 	add.w	r8, r8, #48	; 0x30
 800c272:	bf0c      	ite	eq
 800c274:	2201      	moveq	r2, #1
 800c276:	2200      	movne	r2, #0
 800c278:	4543      	cmp	r3, r8
 800c27a:	bf08      	it	eq
 800c27c:	f042 0201 	orreq.w	r2, r2, #1
 800c280:	f108 0818 	add.w	r8, r8, #24
 800c284:	4543      	cmp	r3, r8
 800c286:	bf08      	it	eq
 800c288:	f042 0201 	orreq.w	r2, r2, #1
 800c28c:	f108 0818 	add.w	r8, r8, #24
 800c290:	4543      	cmp	r3, r8
 800c292:	bf08      	it	eq
 800c294:	f042 0201 	orreq.w	r2, r2, #1
 800c298:	f108 0818 	add.w	r8, r8, #24
 800c29c:	4543      	cmp	r3, r8
 800c29e:	bf08      	it	eq
 800c2a0:	f042 0201 	orreq.w	r2, r2, #1
 800c2a4:	f508 7856 	add.w	r8, r8, #856	; 0x358
 800c2a8:	4543      	cmp	r3, r8
 800c2aa:	bf08      	it	eq
 800c2ac:	f042 0201 	orreq.w	r2, r2, #1
 800c2b0:	f108 0818 	add.w	r8, r8, #24
 800c2b4:	4543      	cmp	r3, r8
 800c2b6:	bf08      	it	eq
 800c2b8:	f042 0201 	orreq.w	r2, r2, #1
 800c2bc:	f108 0818 	add.w	r8, r8, #24
 800c2c0:	4543      	cmp	r3, r8
 800c2c2:	bf08      	it	eq
 800c2c4:	f042 0201 	orreq.w	r2, r2, #1
 800c2c8:	f108 0818 	add.w	r8, r8, #24
 800c2cc:	4543      	cmp	r3, r8
 800c2ce:	bf08      	it	eq
 800c2d0:	f042 0201 	orreq.w	r2, r2, #1
 800c2d4:	f108 0818 	add.w	r8, r8, #24
 800c2d8:	4543      	cmp	r3, r8
 800c2da:	bf08      	it	eq
 800c2dc:	f042 0201 	orreq.w	r2, r2, #1
 800c2e0:	f108 0818 	add.w	r8, r8, #24
 800c2e4:	4543      	cmp	r3, r8
 800c2e6:	bf08      	it	eq
 800c2e8:	f042 0201 	orreq.w	r2, r2, #1
 800c2ec:	f108 0818 	add.w	r8, r8, #24
 800c2f0:	4543      	cmp	r3, r8
 800c2f2:	bf08      	it	eq
 800c2f4:	f042 0201 	orreq.w	r2, r2, #1
 800c2f8:	b91a      	cbnz	r2, 800c302 <HAL_DMA_IRQHandler+0x19e>
 800c2fa:	4a3c      	ldr	r2, [pc, #240]	; (800c3ec <HAL_DMA_IRQHandler+0x288>)
 800c2fc:	4293      	cmp	r3, r2
 800c2fe:	f040 8219 	bne.w	800c734 <HAL_DMA_IRQHandler+0x5d0>
 800c302:	681a      	ldr	r2, [r3, #0]
 800c304:	0792      	lsls	r2, r2, #30
 800c306:	d506      	bpl.n	800c316 <HAL_DMA_IRQHandler+0x1b2>
        regs_dma->IFCR = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
 800c308:	60a0      	str	r0, [r4, #8]
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 800c30a:	f8d9 2054 	ldr.w	r2, [r9, #84]	; 0x54
 800c30e:	f042 0204 	orr.w	r2, r2, #4
 800c312:	f8c9 2054 	str.w	r2, [r9, #84]	; 0x54
    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 800c316:	2210      	movs	r2, #16
 800c318:	fa02 fc0c 	lsl.w	ip, r2, ip
 800c31c:	ea1c 0f07 	tst.w	ip, r7
 800c320:	d06c      	beq.n	800c3fc <HAL_DMA_IRQHandler+0x298>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
 800c322:	2e00      	cmp	r6, #0
 800c324:	d145      	bne.n	800c3b2 <HAL_DMA_IRQHandler+0x24e>
 800c326:	4a30      	ldr	r2, [pc, #192]	; (800c3e8 <HAL_DMA_IRQHandler+0x284>)
 800c328:	4e31      	ldr	r6, [pc, #196]	; (800c3f0 <HAL_DMA_IRQHandler+0x28c>)
 800c32a:	42b3      	cmp	r3, r6
 800c32c:	bf18      	it	ne
 800c32e:	4293      	cmpne	r3, r2
 800c330:	f106 0630 	add.w	r6, r6, #48	; 0x30
 800c334:	bf0c      	ite	eq
 800c336:	2201      	moveq	r2, #1
 800c338:	2200      	movne	r2, #0
 800c33a:	42b3      	cmp	r3, r6
 800c33c:	bf08      	it	eq
 800c33e:	f042 0201 	orreq.w	r2, r2, #1
 800c342:	3618      	adds	r6, #24
 800c344:	42b3      	cmp	r3, r6
 800c346:	bf08      	it	eq
 800c348:	f042 0201 	orreq.w	r2, r2, #1
 800c34c:	3618      	adds	r6, #24
 800c34e:	42b3      	cmp	r3, r6
 800c350:	bf08      	it	eq
 800c352:	f042 0201 	orreq.w	r2, r2, #1
 800c356:	3618      	adds	r6, #24
 800c358:	42b3      	cmp	r3, r6
 800c35a:	bf08      	it	eq
 800c35c:	f042 0201 	orreq.w	r2, r2, #1
 800c360:	f506 7656 	add.w	r6, r6, #856	; 0x358
 800c364:	42b3      	cmp	r3, r6
 800c366:	bf08      	it	eq
 800c368:	f042 0201 	orreq.w	r2, r2, #1
 800c36c:	3618      	adds	r6, #24
 800c36e:	42b3      	cmp	r3, r6
 800c370:	bf08      	it	eq
 800c372:	f042 0201 	orreq.w	r2, r2, #1
 800c376:	3618      	adds	r6, #24
 800c378:	42b3      	cmp	r3, r6
 800c37a:	bf08      	it	eq
 800c37c:	f042 0201 	orreq.w	r2, r2, #1
 800c380:	3618      	adds	r6, #24
 800c382:	42b3      	cmp	r3, r6
 800c384:	bf08      	it	eq
 800c386:	f042 0201 	orreq.w	r2, r2, #1
 800c38a:	3618      	adds	r6, #24
 800c38c:	42b3      	cmp	r3, r6
 800c38e:	bf08      	it	eq
 800c390:	f042 0201 	orreq.w	r2, r2, #1
 800c394:	3618      	adds	r6, #24
 800c396:	42b3      	cmp	r3, r6
 800c398:	bf08      	it	eq
 800c39a:	f042 0201 	orreq.w	r2, r2, #1
 800c39e:	3618      	adds	r6, #24
 800c3a0:	42b3      	cmp	r3, r6
 800c3a2:	bf08      	it	eq
 800c3a4:	f042 0201 	orreq.w	r2, r2, #1
 800c3a8:	b91a      	cbnz	r2, 800c3b2 <HAL_DMA_IRQHandler+0x24e>
 800c3aa:	4a10      	ldr	r2, [pc, #64]	; (800c3ec <HAL_DMA_IRQHandler+0x288>)
 800c3ac:	4293      	cmp	r3, r2
 800c3ae:	f040 81c9 	bne.w	800c744 <HAL_DMA_IRQHandler+0x5e0>
 800c3b2:	681a      	ldr	r2, [r3, #0]
 800c3b4:	0710      	lsls	r0, r2, #28
 800c3b6:	d521      	bpl.n	800c3fc <HAL_DMA_IRQHandler+0x298>
        regs_dma->IFCR = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
 800c3b8:	f8c4 c008 	str.w	ip, [r4, #8]
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
 800c3bc:	681a      	ldr	r2, [r3, #0]
 800c3be:	0356      	lsls	r6, r2, #13
 800c3c0:	f100 814c 	bmi.w	800c65c <HAL_DMA_IRQHandler+0x4f8>
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
 800c3c4:	681a      	ldr	r2, [r3, #0]
 800c3c6:	05d2      	lsls	r2, r2, #23
 800c3c8:	d403      	bmi.n	800c3d2 <HAL_DMA_IRQHandler+0x26e>
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
 800c3ca:	681a      	ldr	r2, [r3, #0]
 800c3cc:	f022 0208 	bic.w	r2, r2, #8
 800c3d0:	601a      	str	r2, [r3, #0]
          if(hdma->XferHalfCpltCallback != NULL)
 800c3d2:	f8d9 3040 	ldr.w	r3, [r9, #64]	; 0x40
 800c3d6:	b18b      	cbz	r3, 800c3fc <HAL_DMA_IRQHandler+0x298>
 800c3d8:	e00c      	b.n	800c3f4 <HAL_DMA_IRQHandler+0x290>
 800c3da:	bf00      	nop
 800c3dc:	24008000 	.word	0x24008000
 800c3e0:	40020010 	.word	0x40020010
 800c3e4:	40020028 	.word	0x40020028
 800c3e8:	40020058 	.word	0x40020058
 800c3ec:	400204b8 	.word	0x400204b8
 800c3f0:	40020040 	.word	0x40020040
            hdma->XferHalfCpltCallback(hdma);
 800c3f4:	4648      	mov	r0, r9
 800c3f6:	4798      	blx	r3
 800c3f8:	f8d9 105c 	ldr.w	r1, [r9, #92]	; 0x5c
    if ((tmpisr_dma & (DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 800c3fc:	f001 011f 	and.w	r1, r1, #31
 800c400:	2620      	movs	r6, #32
 800c402:	408e      	lsls	r6, r1
 800c404:	423e      	tst	r6, r7
 800c406:	d068      	beq.n	800c4da <HAL_DMA_IRQHandler+0x376>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
 800c408:	f8d9 2000 	ldr.w	r2, [r9]
 800c40c:	4ba5      	ldr	r3, [pc, #660]	; (800c6a4 <HAL_DMA_IRQHandler+0x540>)
 800c40e:	4fa6      	ldr	r7, [pc, #664]	; (800c6a8 <HAL_DMA_IRQHandler+0x544>)
 800c410:	42ba      	cmp	r2, r7
 800c412:	bf18      	it	ne
 800c414:	429a      	cmpne	r2, r3
 800c416:	f107 0718 	add.w	r7, r7, #24
 800c41a:	bf0c      	ite	eq
 800c41c:	2301      	moveq	r3, #1
 800c41e:	2300      	movne	r3, #0
 800c420:	42ba      	cmp	r2, r7
 800c422:	bf08      	it	eq
 800c424:	f043 0301 	orreq.w	r3, r3, #1
 800c428:	3718      	adds	r7, #24
 800c42a:	42ba      	cmp	r2, r7
 800c42c:	bf08      	it	eq
 800c42e:	f043 0301 	orreq.w	r3, r3, #1
 800c432:	3718      	adds	r7, #24
 800c434:	42ba      	cmp	r2, r7
 800c436:	bf08      	it	eq
 800c438:	f043 0301 	orreq.w	r3, r3, #1
 800c43c:	3718      	adds	r7, #24
 800c43e:	42ba      	cmp	r2, r7
 800c440:	bf08      	it	eq
 800c442:	f043 0301 	orreq.w	r3, r3, #1
 800c446:	3718      	adds	r7, #24
 800c448:	42ba      	cmp	r2, r7
 800c44a:	bf08      	it	eq
 800c44c:	f043 0301 	orreq.w	r3, r3, #1
 800c450:	3718      	adds	r7, #24
 800c452:	42ba      	cmp	r2, r7
 800c454:	bf08      	it	eq
 800c456:	f043 0301 	orreq.w	r3, r3, #1
 800c45a:	f507 7756 	add.w	r7, r7, #856	; 0x358
 800c45e:	42ba      	cmp	r2, r7
 800c460:	bf08      	it	eq
 800c462:	f043 0301 	orreq.w	r3, r3, #1
 800c466:	3718      	adds	r7, #24
 800c468:	42ba      	cmp	r2, r7
 800c46a:	bf08      	it	eq
 800c46c:	f043 0301 	orreq.w	r3, r3, #1
 800c470:	3718      	adds	r7, #24
 800c472:	42ba      	cmp	r2, r7
 800c474:	bf08      	it	eq
 800c476:	f043 0301 	orreq.w	r3, r3, #1
 800c47a:	3718      	adds	r7, #24
 800c47c:	42ba      	cmp	r2, r7
 800c47e:	bf08      	it	eq
 800c480:	f043 0301 	orreq.w	r3, r3, #1
 800c484:	3718      	adds	r7, #24
 800c486:	42ba      	cmp	r2, r7
 800c488:	bf08      	it	eq
 800c48a:	f043 0301 	orreq.w	r3, r3, #1
 800c48e:	3718      	adds	r7, #24
 800c490:	42ba      	cmp	r2, r7
 800c492:	bf08      	it	eq
 800c494:	f043 0301 	orreq.w	r3, r3, #1
 800c498:	3718      	adds	r7, #24
 800c49a:	42ba      	cmp	r2, r7
 800c49c:	bf08      	it	eq
 800c49e:	f043 0301 	orreq.w	r3, r3, #1
 800c4a2:	b91b      	cbnz	r3, 800c4ac <HAL_DMA_IRQHandler+0x348>
 800c4a4:	4b81      	ldr	r3, [pc, #516]	; (800c6ac <HAL_DMA_IRQHandler+0x548>)
 800c4a6:	429a      	cmp	r2, r3
 800c4a8:	f040 8162 	bne.w	800c770 <HAL_DMA_IRQHandler+0x60c>
 800c4ac:	6813      	ldr	r3, [r2, #0]
 800c4ae:	06db      	lsls	r3, r3, #27
 800c4b0:	d513      	bpl.n	800c4da <HAL_DMA_IRQHandler+0x376>
        regs_dma->IFCR = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
 800c4b2:	60a6      	str	r6, [r4, #8]
        if(HAL_DMA_STATE_ABORT == hdma->State)
 800c4b4:	f899 3035 	ldrb.w	r3, [r9, #53]	; 0x35
 800c4b8:	2b04      	cmp	r3, #4
          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 800c4ba:	6813      	ldr	r3, [r2, #0]
        if(HAL_DMA_STATE_ABORT == hdma->State)
 800c4bc:	f000 80ae 	beq.w	800c61c <HAL_DMA_IRQHandler+0x4b8>
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
 800c4c0:	f413 2f80 	tst.w	r3, #262144	; 0x40000
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
 800c4c4:	6813      	ldr	r3, [r2, #0]
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
 800c4c6:	f000 80d3 	beq.w	800c670 <HAL_DMA_IRQHandler+0x50c>
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
 800c4ca:	031c      	lsls	r4, r3, #12
 800c4cc:	f140 80de 	bpl.w	800c68c <HAL_DMA_IRQHandler+0x528>
          if(hdma->XferCpltCallback != NULL)
 800c4d0:	f8d9 303c 	ldr.w	r3, [r9, #60]	; 0x3c
 800c4d4:	b10b      	cbz	r3, 800c4da <HAL_DMA_IRQHandler+0x376>
            hdma->XferCpltCallback(hdma);
 800c4d6:	4648      	mov	r0, r9
 800c4d8:	4798      	blx	r3
    if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 800c4da:	f8d9 3054 	ldr.w	r3, [r9, #84]	; 0x54
 800c4de:	2b00      	cmp	r3, #0
 800c4e0:	f000 80b9 	beq.w	800c656 <HAL_DMA_IRQHandler+0x4f2>
      if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != 0U)
 800c4e4:	f8d9 3054 	ldr.w	r3, [r9, #84]	; 0x54
 800c4e8:	07d8      	lsls	r0, r3, #31
 800c4ea:	d51f      	bpl.n	800c52c <HAL_DMA_IRQHandler+0x3c8>
        __HAL_DMA_DISABLE(hdma);
 800c4ec:	f8d9 2000 	ldr.w	r2, [r9]
        hdma->State = HAL_DMA_STATE_ABORT;
 800c4f0:	2104      	movs	r1, #4
 800c4f2:	f889 1035 	strb.w	r1, [r9, #53]	; 0x35
        __HAL_DMA_DISABLE(hdma);
 800c4f6:	6813      	ldr	r3, [r2, #0]
 800c4f8:	f023 0301 	bic.w	r3, r3, #1
 800c4fc:	6013      	str	r3, [r2, #0]
  uint32_t timeout = SystemCoreClock / 9600U;
 800c4fe:	4b6c      	ldr	r3, [pc, #432]	; (800c6b0 <HAL_DMA_IRQHandler+0x54c>)
 800c500:	fba3 3505 	umull	r3, r5, r3, r5
 800c504:	0aad      	lsrs	r5, r5, #10
 800c506:	e002      	b.n	800c50e <HAL_DMA_IRQHandler+0x3aa>
        while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U);
 800c508:	6813      	ldr	r3, [r2, #0]
 800c50a:	07d9      	lsls	r1, r3, #31
 800c50c:	d504      	bpl.n	800c518 <HAL_DMA_IRQHandler+0x3b4>
          if (++count > timeout)
 800c50e:	9b01      	ldr	r3, [sp, #4]
 800c510:	3301      	adds	r3, #1
 800c512:	42ab      	cmp	r3, r5
 800c514:	9301      	str	r3, [sp, #4]
 800c516:	d9f7      	bls.n	800c508 <HAL_DMA_IRQHandler+0x3a4>
        if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
 800c518:	6813      	ldr	r3, [r2, #0]
 800c51a:	07db      	lsls	r3, r3, #31
          hdma->State = HAL_DMA_STATE_ERROR;
 800c51c:	bf4c      	ite	mi
 800c51e:	2303      	movmi	r3, #3
          hdma->State = HAL_DMA_STATE_READY;
 800c520:	2301      	movpl	r3, #1
 800c522:	f889 3035 	strb.w	r3, [r9, #53]	; 0x35
        __HAL_UNLOCK(hdma);
 800c526:	2300      	movs	r3, #0
 800c528:	f889 3034 	strb.w	r3, [r9, #52]	; 0x34
      if(hdma->XferErrorCallback != NULL)
 800c52c:	f8d9 304c 	ldr.w	r3, [r9, #76]	; 0x4c
 800c530:	2b00      	cmp	r3, #0
 800c532:	f000 8090 	beq.w	800c656 <HAL_DMA_IRQHandler+0x4f2>
          hdma->XferCpltCallback(hdma);
 800c536:	4648      	mov	r0, r9
}
 800c538:	b003      	add	sp, #12
 800c53a:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
          hdma->XferCpltCallback(hdma);
 800c53e:	4718      	bx	r3
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != 0U)
 800c540:	6818      	ldr	r0, [r3, #0]
 800c542:	0740      	lsls	r0, r0, #29
 800c544:	d50a      	bpl.n	800c55c <HAL_DMA_IRQHandler+0x3f8>
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);
 800c546:	6818      	ldr	r0, [r3, #0]
 800c548:	f020 0004 	bic.w	r0, r0, #4
 800c54c:	6018      	str	r0, [r3, #0]
        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
 800c54e:	60a2      	str	r2, [r4, #8]
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 800c550:	f8d9 2054 	ldr.w	r2, [r9, #84]	; 0x54
 800c554:	f042 0201 	orr.w	r2, r2, #1
 800c558:	f8c9 2054 	str.w	r2, [r9, #84]	; 0x54
    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 800c55c:	fa27 f20c 	lsr.w	r2, r7, ip
 800c560:	07d2      	lsls	r2, r2, #31
 800c562:	f57f ae76 	bpl.w	800c252 <HAL_DMA_IRQHandler+0xee>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
 800c566:	4a53      	ldr	r2, [pc, #332]	; (800c6b4 <HAL_DMA_IRQHandler+0x550>)
 800c568:	4853      	ldr	r0, [pc, #332]	; (800c6b8 <HAL_DMA_IRQHandler+0x554>)
 800c56a:	4283      	cmp	r3, r0
 800c56c:	bf18      	it	ne
 800c56e:	4293      	cmpne	r3, r2
 800c570:	f100 0030 	add.w	r0, r0, #48	; 0x30
 800c574:	bf0c      	ite	eq
 800c576:	2201      	moveq	r2, #1
 800c578:	2200      	movne	r2, #0
 800c57a:	4283      	cmp	r3, r0
 800c57c:	bf08      	it	eq
 800c57e:	f042 0201 	orreq.w	r2, r2, #1
 800c582:	3018      	adds	r0, #24
 800c584:	4283      	cmp	r3, r0
 800c586:	bf08      	it	eq
 800c588:	f042 0201 	orreq.w	r2, r2, #1
 800c58c:	3018      	adds	r0, #24
 800c58e:	4283      	cmp	r3, r0
 800c590:	bf08      	it	eq
 800c592:	f042 0201 	orreq.w	r2, r2, #1
 800c596:	3018      	adds	r0, #24
 800c598:	4283      	cmp	r3, r0
 800c59a:	bf08      	it	eq
 800c59c:	f042 0201 	orreq.w	r2, r2, #1
 800c5a0:	f500 7056 	add.w	r0, r0, #856	; 0x358
 800c5a4:	4283      	cmp	r3, r0
 800c5a6:	bf08      	it	eq
 800c5a8:	f042 0201 	orreq.w	r2, r2, #1
 800c5ac:	3018      	adds	r0, #24
 800c5ae:	4283      	cmp	r3, r0
 800c5b0:	bf08      	it	eq
 800c5b2:	f042 0201 	orreq.w	r2, r2, #1
 800c5b6:	3018      	adds	r0, #24
 800c5b8:	4283      	cmp	r3, r0
 800c5ba:	bf08      	it	eq
 800c5bc:	f042 0201 	orreq.w	r2, r2, #1
 800c5c0:	3018      	adds	r0, #24
 800c5c2:	4283      	cmp	r3, r0
 800c5c4:	bf08      	it	eq
 800c5c6:	f042 0201 	orreq.w	r2, r2, #1
 800c5ca:	3018      	adds	r0, #24
 800c5cc:	4283      	cmp	r3, r0
 800c5ce:	bf08      	it	eq
 800c5d0:	f042 0201 	orreq.w	r2, r2, #1
 800c5d4:	3018      	adds	r0, #24
 800c5d6:	4283      	cmp	r3, r0
 800c5d8:	bf08      	it	eq
 800c5da:	f042 0201 	orreq.w	r2, r2, #1
 800c5de:	3018      	adds	r0, #24
 800c5e0:	4283      	cmp	r3, r0
 800c5e2:	bf08      	it	eq
 800c5e4:	f042 0201 	orreq.w	r2, r2, #1
 800c5e8:	3018      	adds	r0, #24
 800c5ea:	4283      	cmp	r3, r0
 800c5ec:	bf08      	it	eq
 800c5ee:	f042 0201 	orreq.w	r2, r2, #1
 800c5f2:	2a00      	cmp	r2, #0
 800c5f4:	f47f ae20 	bne.w	800c238 <HAL_DMA_IRQHandler+0xd4>
 800c5f8:	2e00      	cmp	r6, #0
 800c5fa:	f47f ae1d 	bne.w	800c238 <HAL_DMA_IRQHandler+0xd4>
 800c5fe:	681a      	ldr	r2, [r3, #0]
    if ((tmpisr_dma & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 800c600:	2204      	movs	r2, #4
 800c602:	fa02 f20c 	lsl.w	r2, r2, ip
 800c606:	423a      	tst	r2, r7
 800c608:	f040 8094 	bne.w	800c734 <HAL_DMA_IRQHandler+0x5d0>
    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 800c60c:	2210      	movs	r2, #16
 800c60e:	fa02 fc0c 	lsl.w	ip, r2, ip
 800c612:	ea17 0f0c 	tst.w	r7, ip
 800c616:	f43f aef1 	beq.w	800c3fc <HAL_DMA_IRQHandler+0x298>
 800c61a:	e684      	b.n	800c326 <HAL_DMA_IRQHandler+0x1c2>
          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 800c61c:	f023 0316 	bic.w	r3, r3, #22
 800c620:	6013      	str	r3, [r2, #0]
          ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
 800c622:	6953      	ldr	r3, [r2, #20]
 800c624:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800c628:	6153      	str	r3, [r2, #20]
          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 800c62a:	f8d9 3040 	ldr.w	r3, [r9, #64]	; 0x40
 800c62e:	b39b      	cbz	r3, 800c698 <HAL_DMA_IRQHandler+0x534>
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
 800c630:	6813      	ldr	r3, [r2, #0]
 800c632:	f023 0308 	bic.w	r3, r3, #8
 800c636:	6013      	str	r3, [r2, #0]
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 800c638:	233f      	movs	r3, #63	; 0x3f
          hdma->State = HAL_DMA_STATE_READY;
 800c63a:	2501      	movs	r5, #1
          __HAL_UNLOCK(hdma);
 800c63c:	2200      	movs	r2, #0
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 800c63e:	fa03 f101 	lsl.w	r1, r3, r1
          if(hdma->XferAbortCallback != NULL)
 800c642:	f8d9 3050 	ldr.w	r3, [r9, #80]	; 0x50
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 800c646:	60a1      	str	r1, [r4, #8]
          hdma->State = HAL_DMA_STATE_READY;
 800c648:	f889 5035 	strb.w	r5, [r9, #53]	; 0x35
          __HAL_UNLOCK(hdma);
 800c64c:	f889 2034 	strb.w	r2, [r9, #52]	; 0x34
          if(hdma->XferAbortCallback != NULL)
 800c650:	2b00      	cmp	r3, #0
 800c652:	f47f af70 	bne.w	800c536 <HAL_DMA_IRQHandler+0x3d2>
}
 800c656:	b003      	add	sp, #12
 800c658:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
 800c65c:	681b      	ldr	r3, [r3, #0]
 800c65e:	0318      	lsls	r0, r3, #12
 800c660:	f57f aeb7 	bpl.w	800c3d2 <HAL_DMA_IRQHandler+0x26e>
            if(hdma->XferM1HalfCpltCallback != NULL)
 800c664:	f8d9 3048 	ldr.w	r3, [r9, #72]	; 0x48
 800c668:	2b00      	cmp	r3, #0
 800c66a:	f47f aec3 	bne.w	800c3f4 <HAL_DMA_IRQHandler+0x290>
 800c66e:	e6c5      	b.n	800c3fc <HAL_DMA_IRQHandler+0x298>
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
 800c670:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 800c674:	f47f af2c 	bne.w	800c4d0 <HAL_DMA_IRQHandler+0x36c>
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);
 800c678:	6811      	ldr	r1, [r2, #0]
 800c67a:	f021 0110 	bic.w	r1, r1, #16
 800c67e:	6011      	str	r1, [r2, #0]
            hdma->State = HAL_DMA_STATE_READY;
 800c680:	2201      	movs	r2, #1
            __HAL_UNLOCK(hdma);
 800c682:	f889 3034 	strb.w	r3, [r9, #52]	; 0x34
            hdma->State = HAL_DMA_STATE_READY;
 800c686:	f889 2035 	strb.w	r2, [r9, #53]	; 0x35
            __HAL_UNLOCK(hdma);
 800c68a:	e721      	b.n	800c4d0 <HAL_DMA_IRQHandler+0x36c>
            if(hdma->XferM1CpltCallback != NULL)
 800c68c:	f8d9 3044 	ldr.w	r3, [r9, #68]	; 0x44
 800c690:	2b00      	cmp	r3, #0
 800c692:	f47f af20 	bne.w	800c4d6 <HAL_DMA_IRQHandler+0x372>
 800c696:	e720      	b.n	800c4da <HAL_DMA_IRQHandler+0x376>
          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 800c698:	f8d9 3048 	ldr.w	r3, [r9, #72]	; 0x48
 800c69c:	2b00      	cmp	r3, #0
 800c69e:	d1c7      	bne.n	800c630 <HAL_DMA_IRQHandler+0x4cc>
 800c6a0:	e7ca      	b.n	800c638 <HAL_DMA_IRQHandler+0x4d4>
 800c6a2:	bf00      	nop
 800c6a4:	40020010 	.word	0x40020010
 800c6a8:	40020028 	.word	0x40020028
 800c6ac:	400204b8 	.word	0x400204b8
 800c6b0:	1b4e81b5 	.word	0x1b4e81b5
 800c6b4:	40020058 	.word	0x40020058
 800c6b8:	40020040 	.word	0x40020040
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U)  /* BDMA instance(s) */
 800c6bc:	4a4e      	ldr	r2, [pc, #312]	; (800c7f8 <HAL_DMA_IRQHandler+0x694>)
 800c6be:	4d4f      	ldr	r5, [pc, #316]	; (800c7fc <HAL_DMA_IRQHandler+0x698>)
 800c6c0:	42ab      	cmp	r3, r5
 800c6c2:	bf18      	it	ne
 800c6c4:	4293      	cmpne	r3, r2
 800c6c6:	f105 0514 	add.w	r5, r5, #20
 800c6ca:	bf0c      	ite	eq
 800c6cc:	2201      	moveq	r2, #1
 800c6ce:	2200      	movne	r2, #0
 800c6d0:	42ab      	cmp	r3, r5
 800c6d2:	bf08      	it	eq
 800c6d4:	f042 0201 	orreq.w	r2, r2, #1
 800c6d8:	3514      	adds	r5, #20
 800c6da:	42ab      	cmp	r3, r5
 800c6dc:	bf08      	it	eq
 800c6de:	f042 0201 	orreq.w	r2, r2, #1
 800c6e2:	3514      	adds	r5, #20
 800c6e4:	42ab      	cmp	r3, r5
 800c6e6:	bf08      	it	eq
 800c6e8:	f042 0201 	orreq.w	r2, r2, #1
 800c6ec:	3514      	adds	r5, #20
 800c6ee:	42ab      	cmp	r3, r5
 800c6f0:	bf08      	it	eq
 800c6f2:	f042 0201 	orreq.w	r2, r2, #1
 800c6f6:	3514      	adds	r5, #20
 800c6f8:	42ab      	cmp	r3, r5
 800c6fa:	bf08      	it	eq
 800c6fc:	f042 0201 	orreq.w	r2, r2, #1
 800c700:	b912      	cbnz	r2, 800c708 <HAL_DMA_IRQHandler+0x5a4>
 800c702:	4a3f      	ldr	r2, [pc, #252]	; (800c800 <HAL_DMA_IRQHandler+0x69c>)
 800c704:	4293      	cmp	r3, r2
 800c706:	d1a6      	bne.n	800c656 <HAL_DMA_IRQHandler+0x4f2>
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
 800c708:	f8d9 505c 	ldr.w	r5, [r9, #92]	; 0x5c
 800c70c:	2604      	movs	r6, #4
    ccr_reg = (((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR);
 800c70e:	681a      	ldr	r2, [r3, #0]
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
 800c710:	f005 051f 	and.w	r5, r5, #31
 800c714:	40ae      	lsls	r6, r5
 800c716:	420e      	tst	r6, r1
 800c718:	d019      	beq.n	800c74e <HAL_DMA_IRQHandler+0x5ea>
 800c71a:	0757      	lsls	r7, r2, #29
 800c71c:	d517      	bpl.n	800c74e <HAL_DMA_IRQHandler+0x5ea>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 800c71e:	0410      	lsls	r0, r2, #16
      regs_bdma->IFCR = (BDMA_ISR_HTIF0 << (hdma->StreamIndex & 0x1FU));
 800c720:	6066      	str	r6, [r4, #4]
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 800c722:	d54b      	bpl.n	800c7bc <HAL_DMA_IRQHandler+0x658>
        if((ccr_reg & BDMA_CCR_CT) == 0U)
 800c724:	03d1      	lsls	r1, r2, #15
 800c726:	d44f      	bmi.n	800c7c8 <HAL_DMA_IRQHandler+0x664>
          if(hdma->XferM1HalfCpltCallback != NULL)
 800c728:	f8d9 3048 	ldr.w	r3, [r9, #72]	; 0x48
 800c72c:	2b00      	cmp	r3, #0
 800c72e:	f47f af02 	bne.w	800c536 <HAL_DMA_IRQHandler+0x3d2>
 800c732:	e790      	b.n	800c656 <HAL_DMA_IRQHandler+0x4f2>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
 800c734:	681a      	ldr	r2, [r3, #0]
    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 800c736:	2210      	movs	r2, #16
 800c738:	fa02 fc0c 	lsl.w	ip, r2, ip
 800c73c:	ea17 0f0c 	tst.w	r7, ip
 800c740:	f43f ae5c 	beq.w	800c3fc <HAL_DMA_IRQHandler+0x298>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
 800c744:	681a      	ldr	r2, [r3, #0]
 800c746:	0752      	lsls	r2, r2, #29
 800c748:	f57f ae58 	bpl.w	800c3fc <HAL_DMA_IRQHandler+0x298>
 800c74c:	e634      	b.n	800c3b8 <HAL_DMA_IRQHandler+0x254>
    else if (((tmpisr_bdma & (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TCIE) != 0U))
 800c74e:	2602      	movs	r6, #2
 800c750:	40ae      	lsls	r6, r5
 800c752:	420e      	tst	r6, r1
 800c754:	d011      	beq.n	800c77a <HAL_DMA_IRQHandler+0x616>
 800c756:	0797      	lsls	r7, r2, #30
 800c758:	d50f      	bpl.n	800c77a <HAL_DMA_IRQHandler+0x616>
      regs_bdma->IFCR = (BDMA_ISR_TCIF0) << (hdma->StreamIndex & 0x1FU);
 800c75a:	6066      	str	r6, [r4, #4]
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 800c75c:	0414      	lsls	r4, r2, #16
 800c75e:	d539      	bpl.n	800c7d4 <HAL_DMA_IRQHandler+0x670>
        if((ccr_reg & BDMA_CCR_CT) == 0U)
 800c760:	03d0      	lsls	r0, r2, #15
 800c762:	d443      	bmi.n	800c7ec <HAL_DMA_IRQHandler+0x688>
          if(hdma->XferM1CpltCallback != NULL)
 800c764:	f8d9 3044 	ldr.w	r3, [r9, #68]	; 0x44
 800c768:	2b00      	cmp	r3, #0
 800c76a:	f47f aee4 	bne.w	800c536 <HAL_DMA_IRQHandler+0x3d2>
 800c76e:	e772      	b.n	800c656 <HAL_DMA_IRQHandler+0x4f2>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
 800c770:	6813      	ldr	r3, [r2, #0]
 800c772:	079f      	lsls	r7, r3, #30
 800c774:	f57f aeb1 	bpl.w	800c4da <HAL_DMA_IRQHandler+0x376>
 800c778:	e69b      	b.n	800c4b2 <HAL_DMA_IRQHandler+0x34e>
    else if (((tmpisr_bdma & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TEIE) != 0U))
 800c77a:	2608      	movs	r6, #8
 800c77c:	40ae      	lsls	r6, r5
 800c77e:	420e      	tst	r6, r1
 800c780:	f43f af69 	beq.w	800c656 <HAL_DMA_IRQHandler+0x4f2>
 800c784:	0711      	lsls	r1, r2, #28
 800c786:	f57f af66 	bpl.w	800c656 <HAL_DMA_IRQHandler+0x4f2>
      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 800c78a:	681a      	ldr	r2, [r3, #0]
      __HAL_UNLOCK(hdma);
 800c78c:	2100      	movs	r1, #0
      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 800c78e:	f022 020e 	bic.w	r2, r2, #14
 800c792:	601a      	str	r2, [r3, #0]
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
 800c794:	2301      	movs	r3, #1
      if (hdma->XferErrorCallback != NULL)
 800c796:	f8d9 204c 	ldr.w	r2, [r9, #76]	; 0x4c
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
 800c79a:	fa03 f505 	lsl.w	r5, r3, r5
 800c79e:	6065      	str	r5, [r4, #4]
      hdma->ErrorCode = HAL_DMA_ERROR_TE;
 800c7a0:	f8c9 3054 	str.w	r3, [r9, #84]	; 0x54
      __HAL_UNLOCK(hdma);
 800c7a4:	f889 1034 	strb.w	r1, [r9, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
 800c7a8:	f889 3035 	strb.w	r3, [r9, #53]	; 0x35
      if (hdma->XferErrorCallback != NULL)
 800c7ac:	2a00      	cmp	r2, #0
 800c7ae:	f43f af52 	beq.w	800c656 <HAL_DMA_IRQHandler+0x4f2>
        hdma->XferErrorCallback(hdma);
 800c7b2:	4648      	mov	r0, r9
}
 800c7b4:	b003      	add	sp, #12
 800c7b6:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        hdma->XferErrorCallback(hdma);
 800c7ba:	4710      	bx	r2
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
 800c7bc:	0692      	lsls	r2, r2, #26
 800c7be:	d403      	bmi.n	800c7c8 <HAL_DMA_IRQHandler+0x664>
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 800c7c0:	681a      	ldr	r2, [r3, #0]
 800c7c2:	f022 0204 	bic.w	r2, r2, #4
 800c7c6:	601a      	str	r2, [r3, #0]
       if(hdma->XferHalfCpltCallback != NULL)
 800c7c8:	f8d9 3040 	ldr.w	r3, [r9, #64]	; 0x40
 800c7cc:	2b00      	cmp	r3, #0
 800c7ce:	f47f aeb2 	bne.w	800c536 <HAL_DMA_IRQHandler+0x3d2>
 800c7d2:	e740      	b.n	800c656 <HAL_DMA_IRQHandler+0x4f2>
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
 800c7d4:	f012 0220 	ands.w	r2, r2, #32
 800c7d8:	d108      	bne.n	800c7ec <HAL_DMA_IRQHandler+0x688>
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 800c7da:	6819      	ldr	r1, [r3, #0]
          hdma->State = HAL_DMA_STATE_READY;
 800c7dc:	2401      	movs	r4, #1
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 800c7de:	f021 010a 	bic.w	r1, r1, #10
 800c7e2:	6019      	str	r1, [r3, #0]
          hdma->State = HAL_DMA_STATE_READY;
 800c7e4:	f889 4035 	strb.w	r4, [r9, #53]	; 0x35
          __HAL_UNLOCK(hdma);
 800c7e8:	f889 2034 	strb.w	r2, [r9, #52]	; 0x34
        if(hdma->XferCpltCallback != NULL)
 800c7ec:	f8d9 303c 	ldr.w	r3, [r9, #60]	; 0x3c
 800c7f0:	2b00      	cmp	r3, #0
 800c7f2:	f47f aea0 	bne.w	800c536 <HAL_DMA_IRQHandler+0x3d2>
 800c7f6:	e72e      	b.n	800c656 <HAL_DMA_IRQHandler+0x4f2>
 800c7f8:	58025408 	.word	0x58025408
 800c7fc:	5802541c 	.word	0x5802541c
 800c800:	58025494 	.word	0x58025494

0800c804 <HAL_DMA_GetError>:
  return hdma->ErrorCode;
 800c804:	6d40      	ldr	r0, [r0, #84]	; 0x54
}
 800c806:	4770      	bx	lr

0800c808 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800c808:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 800c80c:	680c      	ldr	r4, [r1, #0]
{
 800c80e:	b083      	sub	sp, #12
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 800c810:	2c00      	cmp	r4, #0
 800c812:	f000 80a6 	beq.w	800c962 <HAL_GPIO_Init+0x15a>
 800c816:	f04f 0c00 	mov.w	ip, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800c81a:	4f8e      	ldr	r7, [pc, #568]	; (800ca54 <HAL_GPIO_Init+0x24c>)
  uint32_t position = 0x00U;
 800c81c:	4663      	mov	r3, ip
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 800c81e:	2201      	movs	r2, #1
 800c820:	409a      	lsls	r2, r3
    if (iocurrent != 0x00U)
 800c822:	ea12 0e04 	ands.w	lr, r2, r4
 800c826:	f000 8095 	beq.w	800c954 <HAL_GPIO_Init+0x14c>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800c82a:	684d      	ldr	r5, [r1, #4]
 800c82c:	f005 0903 	and.w	r9, r5, #3
 800c830:	f109 36ff 	add.w	r6, r9, #4294967295	; 0xffffffff
 800c834:	2e01      	cmp	r6, #1
 800c836:	f240 8097 	bls.w	800c968 <HAL_GPIO_Init+0x160>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 800c83a:	f1b9 0f03 	cmp.w	r9, #3
 800c83e:	f040 80d1 	bne.w	800c9e4 <HAL_GPIO_Init+0x1dc>
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800c842:	fa09 f20c 	lsl.w	r2, r9, ip
 800c846:	ea6f 0802 	mvn.w	r8, r2
      temp = GPIOx->MODER;
 800c84a:	6806      	ldr	r6, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800c84c:	f415 3f40 	tst.w	r5, #196608	; 0x30000
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 800c850:	ea06 0808 	and.w	r8, r6, r8
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800c854:	ea42 0208 	orr.w	r2, r2, r8
      GPIOx->MODER = temp;
 800c858:	6002      	str	r2, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800c85a:	d07b      	beq.n	800c954 <HAL_GPIO_Init+0x14c>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800c85c:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 800c860:	f023 0803 	bic.w	r8, r3, #3

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800c864:	f003 0903 	and.w	r9, r3, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800c868:	f042 0202 	orr.w	r2, r2, #2
 800c86c:	f108 48b0 	add.w	r8, r8, #1476395008	; 0x58000000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800c870:	ea4f 0989 	mov.w	r9, r9, lsl #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800c874:	f8c7 20f4 	str.w	r2, [r7, #244]	; 0xf4
 800c878:	f508 6880 	add.w	r8, r8, #1024	; 0x400
 800c87c:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 800c880:	f002 0202 	and.w	r2, r2, #2
 800c884:	9201      	str	r2, [sp, #4]
 800c886:	9a01      	ldr	r2, [sp, #4]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800c888:	220f      	movs	r2, #15
        temp = SYSCFG->EXTICR[position >> 2U];
 800c88a:	f8d8 6008 	ldr.w	r6, [r8, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800c88e:	fa02 f209 	lsl.w	r2, r2, r9
 800c892:	ea26 0202 	bic.w	r2, r6, r2
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800c896:	4e70      	ldr	r6, [pc, #448]	; (800ca58 <HAL_GPIO_Init+0x250>)
 800c898:	42b0      	cmp	r0, r6
 800c89a:	d029      	beq.n	800c8f0 <HAL_GPIO_Init+0xe8>
 800c89c:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 800c8a0:	42b0      	cmp	r0, r6
 800c8a2:	f000 80ac 	beq.w	800c9fe <HAL_GPIO_Init+0x1f6>
 800c8a6:	4e6d      	ldr	r6, [pc, #436]	; (800ca5c <HAL_GPIO_Init+0x254>)
 800c8a8:	42b0      	cmp	r0, r6
 800c8aa:	f000 80ae 	beq.w	800ca0a <HAL_GPIO_Init+0x202>
 800c8ae:	4e6c      	ldr	r6, [pc, #432]	; (800ca60 <HAL_GPIO_Init+0x258>)
 800c8b0:	42b0      	cmp	r0, r6
 800c8b2:	f000 809e 	beq.w	800c9f2 <HAL_GPIO_Init+0x1ea>
 800c8b6:	4e6b      	ldr	r6, [pc, #428]	; (800ca64 <HAL_GPIO_Init+0x25c>)
 800c8b8:	42b0      	cmp	r0, r6
 800c8ba:	f000 80b2 	beq.w	800ca22 <HAL_GPIO_Init+0x21a>
 800c8be:	4e6a      	ldr	r6, [pc, #424]	; (800ca68 <HAL_GPIO_Init+0x260>)
 800c8c0:	42b0      	cmp	r0, r6
 800c8c2:	f000 80b4 	beq.w	800ca2e <HAL_GPIO_Init+0x226>
 800c8c6:	4e69      	ldr	r6, [pc, #420]	; (800ca6c <HAL_GPIO_Init+0x264>)
 800c8c8:	42b0      	cmp	r0, r6
 800c8ca:	f000 80a4 	beq.w	800ca16 <HAL_GPIO_Init+0x20e>
 800c8ce:	4e68      	ldr	r6, [pc, #416]	; (800ca70 <HAL_GPIO_Init+0x268>)
 800c8d0:	42b0      	cmp	r0, r6
 800c8d2:	f000 80b2 	beq.w	800ca3a <HAL_GPIO_Init+0x232>
 800c8d6:	4e67      	ldr	r6, [pc, #412]	; (800ca74 <HAL_GPIO_Init+0x26c>)
 800c8d8:	42b0      	cmp	r0, r6
 800c8da:	f000 80b4 	beq.w	800ca46 <HAL_GPIO_Init+0x23e>
 800c8de:	4e66      	ldr	r6, [pc, #408]	; (800ca78 <HAL_GPIO_Init+0x270>)
 800c8e0:	42b0      	cmp	r0, r6
 800c8e2:	bf0c      	ite	eq
 800c8e4:	2609      	moveq	r6, #9
 800c8e6:	260a      	movne	r6, #10
 800c8e8:	fa06 f909 	lsl.w	r9, r6, r9
 800c8ec:	ea42 0209 	orr.w	r2, r2, r9
        SYSCFG->EXTICR[position >> 2U] = temp;
 800c8f0:	f8c8 2008 	str.w	r2, [r8, #8]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 800c8f4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 800c8f8:	02ee      	lsls	r6, r5, #11
        temp &= ~(iocurrent);
 800c8fa:	ea6f 080e 	mvn.w	r8, lr
        temp = EXTI->RTSR1;
 800c8fe:	6812      	ldr	r2, [r2, #0]
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;
 800c900:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
 800c904:	bf54      	ite	pl
 800c906:	ea08 0202 	andpl.w	r2, r8, r2
          temp |= iocurrent;
 800c90a:	ea4e 0202 	orrmi.w	r2, lr, r2
        EXTI->RTSR1 = temp;
 800c90e:	6032      	str	r2, [r6, #0]

        temp = EXTI->FTSR1;
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 800c910:	02aa      	lsls	r2, r5, #10
        temp = EXTI->FTSR1;
 800c912:	6876      	ldr	r6, [r6, #4]
        {
          temp |= iocurrent;
        }
        EXTI->FTSR1 = temp;
 800c914:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
 800c918:	bf54      	ite	pl
 800c91a:	ea08 0606 	andpl.w	r6, r8, r6
          temp |= iocurrent;
 800c91e:	ea4e 0606 	orrmi.w	r6, lr, r6
        EXTI->FTSR1 = temp;
 800c922:	6056      	str	r6, [r2, #4]

        temp = EXTI_CurrentCPU->EMR1;
 800c924:	f8d2 6084 	ldr.w	r6, [r2, #132]	; 0x84
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 800c928:	03aa      	lsls	r2, r5, #14
        {
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->EMR1 = temp;
 800c92a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
 800c92e:	bf54      	ite	pl
 800c930:	ea08 0606 	andpl.w	r6, r8, r6
          temp |= iocurrent;
 800c934:	ea4e 0606 	orrmi.w	r6, lr, r6

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 800c938:	03ed      	lsls	r5, r5, #15
        {
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->IMR1 = temp;
 800c93a:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
        EXTI_CurrentCPU->EMR1 = temp;
 800c93e:	f8c2 6084 	str.w	r6, [r2, #132]	; 0x84
        temp = EXTI_CurrentCPU->IMR1;
 800c942:	f8d2 2080 	ldr.w	r2, [r2, #128]	; 0x80
        temp &= ~(iocurrent);
 800c946:	bf54      	ite	pl
 800c948:	ea08 0202 	andpl.w	r2, r8, r2
          temp |= iocurrent;
 800c94c:	ea4e 0202 	orrmi.w	r2, lr, r2
        EXTI_CurrentCPU->IMR1 = temp;
 800c950:	f8c5 2080 	str.w	r2, [r5, #128]	; 0x80
      }
    }

    position++;
 800c954:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 800c956:	f10c 0c02 	add.w	ip, ip, #2
 800c95a:	fa34 f203 	lsrs.w	r2, r4, r3
 800c95e:	f47f af5e 	bne.w	800c81e <HAL_GPIO_Init+0x16>
  }
}
 800c962:	b003      	add	sp, #12
 800c964:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800c968:	f04f 0803 	mov.w	r8, #3
        temp = GPIOx->OSPEEDR;
 800c96c:	6886      	ldr	r6, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800c96e:	fa08 f80c 	lsl.w	r8, r8, ip
 800c972:	ea26 0a08 	bic.w	sl, r6, r8
        temp |= (GPIO_Init->Speed << (position * 2U));
 800c976:	68ce      	ldr	r6, [r1, #12]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800c978:	ea6f 0808 	mvn.w	r8, r8
        temp |= (GPIO_Init->Speed << (position * 2U));
 800c97c:	fa06 f60c 	lsl.w	r6, r6, ip
 800c980:	ea46 060a 	orr.w	r6, r6, sl
        GPIOx->OSPEEDR = temp;
 800c984:	6086      	str	r6, [r0, #8]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800c986:	f3c5 1600 	ubfx	r6, r5, #4, #1
        temp = GPIOx->OTYPER;
 800c98a:	f8d0 a004 	ldr.w	sl, [r0, #4]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800c98e:	409e      	lsls	r6, r3
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 800c990:	ea2a 0202 	bic.w	r2, sl, r2
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800c994:	4332      	orrs	r2, r6
        GPIOx->OTYPER = temp;
 800c996:	6042      	str	r2, [r0, #4]
      temp = GPIOx->PUPDR;
 800c998:	68c2      	ldr	r2, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800c99a:	f1b9 0f02 	cmp.w	r9, #2
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800c99e:	688e      	ldr	r6, [r1, #8]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800c9a0:	ea02 0208 	and.w	r2, r2, r8
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800c9a4:	fa06 f60c 	lsl.w	r6, r6, ip
 800c9a8:	ea46 0602 	orr.w	r6, r6, r2
      GPIOx->PUPDR = temp;
 800c9ac:	fa09 f20c 	lsl.w	r2, r9, ip
 800c9b0:	60c6      	str	r6, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800c9b2:	f47f af4a 	bne.w	800c84a <HAL_GPIO_Init+0x42>
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800c9b6:	f003 0607 	and.w	r6, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 800c9ba:	ea4f 09d3 	mov.w	r9, r3, lsr #3
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800c9be:	ea4f 0b86 	mov.w	fp, r6, lsl #2
 800c9c2:	260f      	movs	r6, #15
 800c9c4:	eb00 0989 	add.w	r9, r0, r9, lsl #2
 800c9c8:	fa06 f60b 	lsl.w	r6, r6, fp
        temp = GPIOx->AFR[position >> 3U];
 800c9cc:	f8d9 a020 	ldr.w	sl, [r9, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800c9d0:	ea2a 0a06 	bic.w	sl, sl, r6
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 800c9d4:	690e      	ldr	r6, [r1, #16]
 800c9d6:	fa06 f60b 	lsl.w	r6, r6, fp
 800c9da:	ea46 060a 	orr.w	r6, r6, sl
        GPIOx->AFR[position >> 3U] = temp;
 800c9de:	f8c9 6020 	str.w	r6, [r9, #32]
 800c9e2:	e732      	b.n	800c84a <HAL_GPIO_Init+0x42>
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800c9e4:	f04f 0803 	mov.w	r8, #3
 800c9e8:	fa08 f80c 	lsl.w	r8, r8, ip
 800c9ec:	ea6f 0808 	mvn.w	r8, r8
 800c9f0:	e7d2      	b.n	800c998 <HAL_GPIO_Init+0x190>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800c9f2:	2603      	movs	r6, #3
 800c9f4:	fa06 f909 	lsl.w	r9, r6, r9
 800c9f8:	ea42 0209 	orr.w	r2, r2, r9
 800c9fc:	e778      	b.n	800c8f0 <HAL_GPIO_Init+0xe8>
 800c9fe:	2601      	movs	r6, #1
 800ca00:	fa06 f909 	lsl.w	r9, r6, r9
 800ca04:	ea42 0209 	orr.w	r2, r2, r9
 800ca08:	e772      	b.n	800c8f0 <HAL_GPIO_Init+0xe8>
 800ca0a:	2602      	movs	r6, #2
 800ca0c:	fa06 f909 	lsl.w	r9, r6, r9
 800ca10:	ea42 0209 	orr.w	r2, r2, r9
 800ca14:	e76c      	b.n	800c8f0 <HAL_GPIO_Init+0xe8>
 800ca16:	2606      	movs	r6, #6
 800ca18:	fa06 f909 	lsl.w	r9, r6, r9
 800ca1c:	ea42 0209 	orr.w	r2, r2, r9
 800ca20:	e766      	b.n	800c8f0 <HAL_GPIO_Init+0xe8>
 800ca22:	2604      	movs	r6, #4
 800ca24:	fa06 f909 	lsl.w	r9, r6, r9
 800ca28:	ea42 0209 	orr.w	r2, r2, r9
 800ca2c:	e760      	b.n	800c8f0 <HAL_GPIO_Init+0xe8>
 800ca2e:	2605      	movs	r6, #5
 800ca30:	fa06 f909 	lsl.w	r9, r6, r9
 800ca34:	ea42 0209 	orr.w	r2, r2, r9
 800ca38:	e75a      	b.n	800c8f0 <HAL_GPIO_Init+0xe8>
 800ca3a:	2607      	movs	r6, #7
 800ca3c:	fa06 f909 	lsl.w	r9, r6, r9
 800ca40:	ea42 0209 	orr.w	r2, r2, r9
 800ca44:	e754      	b.n	800c8f0 <HAL_GPIO_Init+0xe8>
 800ca46:	2608      	movs	r6, #8
 800ca48:	fa06 f909 	lsl.w	r9, r6, r9
 800ca4c:	ea42 0209 	orr.w	r2, r2, r9
 800ca50:	e74e      	b.n	800c8f0 <HAL_GPIO_Init+0xe8>
 800ca52:	bf00      	nop
 800ca54:	58024400 	.word	0x58024400
 800ca58:	58020000 	.word	0x58020000
 800ca5c:	58020800 	.word	0x58020800
 800ca60:	58020c00 	.word	0x58020c00
 800ca64:	58021000 	.word	0x58021000
 800ca68:	58021400 	.word	0x58021400
 800ca6c:	58021800 	.word	0x58021800
 800ca70:	58021c00 	.word	0x58021c00
 800ca74:	58022000 	.word	0x58022000
 800ca78:	58022400 	.word	0x58022400

0800ca7c <HAL_GPIO_DeInit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00U)
 800ca7c:	2900      	cmp	r1, #0
 800ca7e:	f000 80a8 	beq.w	800cbd2 <HAL_GPIO_DeInit+0x156>
  uint32_t position = 0x00U;
 800ca82:	2300      	movs	r3, #0
{
 800ca84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ca88:	f8df 9168 	ldr.w	r9, [pc, #360]	; 800cbf4 <HAL_GPIO_DeInit+0x178>
 800ca8c:	b083      	sub	sp, #12
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      tmp = SYSCFG->EXTICR[position >> 2U];
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 800ca8e:	f8df 8168 	ldr.w	r8, [pc, #360]	; 800cbf8 <HAL_GPIO_DeInit+0x17c>
 800ca92:	f8df a168 	ldr.w	sl, [pc, #360]	; 800cbfc <HAL_GPIO_DeInit+0x180>
 800ca96:	f8df b168 	ldr.w	fp, [pc, #360]	; 800cc00 <HAL_GPIO_DeInit+0x184>
    iocurrent = GPIO_Pin & (1UL << position) ;
 800ca9a:	f04f 0e01 	mov.w	lr, #1
 800ca9e:	fa0e f203 	lsl.w	r2, lr, r3
    if (iocurrent != 0x00U)
 800caa2:	ea12 0c01 	ands.w	ip, r2, r1
 800caa6:	d06f      	beq.n	800cb88 <HAL_GPIO_DeInit+0x10c>
      tmp = SYSCFG->EXTICR[position >> 2U];
 800caa8:	f023 0503 	bic.w	r5, r3, #3
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
 800caac:	f003 0403 	and.w	r4, r3, #3
 800cab0:	260f      	movs	r6, #15
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 800cab2:	4540      	cmp	r0, r8
 800cab4:	444d      	add	r5, r9
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
 800cab6:	ea4f 0484 	mov.w	r4, r4, lsl #2
      tmp = SYSCFG->EXTICR[position >> 2U];
 800caba:	68af      	ldr	r7, [r5, #8]
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
 800cabc:	fa06 f604 	lsl.w	r6, r6, r4
 800cac0:	ea07 0706 	and.w	r7, r7, r6
 800cac4:	9701      	str	r7, [sp, #4]
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 800cac6:	d021      	beq.n	800cb0c <HAL_GPIO_DeInit+0x90>
 800cac8:	4550      	cmp	r0, sl
 800caca:	d066      	beq.n	800cb9a <HAL_GPIO_DeInit+0x11e>
 800cacc:	4558      	cmp	r0, fp
 800cace:	d067      	beq.n	800cba0 <HAL_GPIO_DeInit+0x124>
 800cad0:	4f43      	ldr	r7, [pc, #268]	; (800cbe0 <HAL_GPIO_DeInit+0x164>)
 800cad2:	42b8      	cmp	r0, r7
 800cad4:	d06e      	beq.n	800cbb4 <HAL_GPIO_DeInit+0x138>
 800cad6:	4f43      	ldr	r7, [pc, #268]	; (800cbe4 <HAL_GPIO_DeInit+0x168>)
 800cad8:	42b8      	cmp	r0, r7
 800cada:	d070      	beq.n	800cbbe <HAL_GPIO_DeInit+0x142>
 800cadc:	4f42      	ldr	r7, [pc, #264]	; (800cbe8 <HAL_GPIO_DeInit+0x16c>)
 800cade:	42b8      	cmp	r0, r7
 800cae0:	d063      	beq.n	800cbaa <HAL_GPIO_DeInit+0x12e>
 800cae2:	4f42      	ldr	r7, [pc, #264]	; (800cbec <HAL_GPIO_DeInit+0x170>)
 800cae4:	42b8      	cmp	r0, r7
 800cae6:	d056      	beq.n	800cb96 <HAL_GPIO_DeInit+0x11a>
 800cae8:	4f41      	ldr	r7, [pc, #260]	; (800cbf0 <HAL_GPIO_DeInit+0x174>)
 800caea:	42b8      	cmp	r0, r7
 800caec:	d072      	beq.n	800cbd4 <HAL_GPIO_DeInit+0x158>
 800caee:	f8df e114 	ldr.w	lr, [pc, #276]	; 800cc04 <HAL_GPIO_DeInit+0x188>
 800caf2:	4570      	cmp	r0, lr
 800caf4:	d068      	beq.n	800cbc8 <HAL_GPIO_DeInit+0x14c>
 800caf6:	f8df e110 	ldr.w	lr, [pc, #272]	; 800cc08 <HAL_GPIO_DeInit+0x18c>
 800cafa:	4570      	cmp	r0, lr
 800cafc:	bf14      	ite	ne
 800cafe:	f04f 0e0a 	movne.w	lr, #10
 800cb02:	f04f 0e09 	moveq.w	lr, #9
 800cb06:	fa0e f404 	lsl.w	r4, lr, r4
 800cb0a:	e000      	b.n	800cb0e <HAL_GPIO_DeInit+0x92>
 800cb0c:	2400      	movs	r4, #0
 800cb0e:	9f01      	ldr	r7, [sp, #4]
 800cb10:	42a7      	cmp	r7, r4
 800cb12:	d119      	bne.n	800cb48 <HAL_GPIO_DeInit+0xcc>
      {
        /* Clear EXTI line configuration for Current CPU */
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
 800cb14:	f04f 44b0 	mov.w	r4, #1476395008	; 0x58000000
 800cb18:	f8d4 7080 	ldr.w	r7, [r4, #128]	; 0x80
 800cb1c:	ea27 070c 	bic.w	r7, r7, ip
 800cb20:	f8c4 7080 	str.w	r7, [r4, #128]	; 0x80
        EXTI_CurrentCPU->EMR1 &= ~(iocurrent);
 800cb24:	f8d4 7084 	ldr.w	r7, [r4, #132]	; 0x84
 800cb28:	ea27 070c 	bic.w	r7, r7, ip
 800cb2c:	f8c4 7084 	str.w	r7, [r4, #132]	; 0x84

        /* Clear Rising Falling edge configuration */
        EXTI->FTSR1 &= ~(iocurrent);
 800cb30:	6867      	ldr	r7, [r4, #4]
 800cb32:	ea27 070c 	bic.w	r7, r7, ip
 800cb36:	6067      	str	r7, [r4, #4]
        EXTI->RTSR1 &= ~(iocurrent);
 800cb38:	6827      	ldr	r7, [r4, #0]
 800cb3a:	ea27 070c 	bic.w	r7, r7, ip
 800cb3e:	6027      	str	r7, [r4, #0]

        tmp = 0x0FUL << (4U * (position & 0x03U));
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
 800cb40:	68ac      	ldr	r4, [r5, #8]
 800cb42:	ea24 0606 	bic.w	r6, r4, r6
 800cb46:	60ae      	str	r6, [r5, #8]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 800cb48:	2503      	movs	r5, #3
 800cb4a:	005c      	lsls	r4, r3, #1

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 800cb4c:	f003 0707 	and.w	r7, r3, #7
 800cb50:	260f      	movs	r6, #15
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 800cb52:	fa05 f404 	lsl.w	r4, r5, r4
 800cb56:	6805      	ldr	r5, [r0, #0]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 800cb58:	00bf      	lsls	r7, r7, #2
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 800cb5a:	4325      	orrs	r5, r4
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 800cb5c:	fa06 f707 	lsl.w	r7, r6, r7
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 800cb60:	6005      	str	r5, [r0, #0]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 800cb62:	08dd      	lsrs	r5, r3, #3
 800cb64:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 800cb68:	6a2e      	ldr	r6, [r5, #32]
 800cb6a:	ea26 0607 	bic.w	r6, r6, r7
 800cb6e:	622e      	str	r6, [r5, #32]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800cb70:	68c5      	ldr	r5, [r0, #12]
 800cb72:	ea25 0504 	bic.w	r5, r5, r4
 800cb76:	60c5      	str	r5, [r0, #12]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 800cb78:	6845      	ldr	r5, [r0, #4]
 800cb7a:	ea25 0202 	bic.w	r2, r5, r2
 800cb7e:	6042      	str	r2, [r0, #4]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800cb80:	6882      	ldr	r2, [r0, #8]
 800cb82:	ea22 0404 	bic.w	r4, r2, r4
 800cb86:	6084      	str	r4, [r0, #8]
    }

    position++;
 800cb88:	3301      	adds	r3, #1
  while ((GPIO_Pin >> position) != 0x00U)
 800cb8a:	fa31 f203 	lsrs.w	r2, r1, r3
 800cb8e:	d184      	bne.n	800ca9a <HAL_GPIO_DeInit+0x1e>
  }
}
 800cb90:	b003      	add	sp, #12
 800cb92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 800cb96:	f04f 0e06 	mov.w	lr, #6
 800cb9a:	fa0e f404 	lsl.w	r4, lr, r4
 800cb9e:	e7b6      	b.n	800cb0e <HAL_GPIO_DeInit+0x92>
 800cba0:	f04f 0e02 	mov.w	lr, #2
 800cba4:	fa0e f404 	lsl.w	r4, lr, r4
 800cba8:	e7b1      	b.n	800cb0e <HAL_GPIO_DeInit+0x92>
 800cbaa:	f04f 0e05 	mov.w	lr, #5
 800cbae:	fa0e f404 	lsl.w	r4, lr, r4
 800cbb2:	e7ac      	b.n	800cb0e <HAL_GPIO_DeInit+0x92>
 800cbb4:	f04f 0e03 	mov.w	lr, #3
 800cbb8:	fa0e f404 	lsl.w	r4, lr, r4
 800cbbc:	e7a7      	b.n	800cb0e <HAL_GPIO_DeInit+0x92>
 800cbbe:	f04f 0e04 	mov.w	lr, #4
 800cbc2:	fa0e f404 	lsl.w	r4, lr, r4
 800cbc6:	e7a2      	b.n	800cb0e <HAL_GPIO_DeInit+0x92>
 800cbc8:	f04f 0e08 	mov.w	lr, #8
 800cbcc:	fa0e f404 	lsl.w	r4, lr, r4
 800cbd0:	e79d      	b.n	800cb0e <HAL_GPIO_DeInit+0x92>
 800cbd2:	4770      	bx	lr
 800cbd4:	f04f 0e07 	mov.w	lr, #7
 800cbd8:	fa0e f404 	lsl.w	r4, lr, r4
 800cbdc:	e797      	b.n	800cb0e <HAL_GPIO_DeInit+0x92>
 800cbde:	bf00      	nop
 800cbe0:	58020c00 	.word	0x58020c00
 800cbe4:	58021000 	.word	0x58021000
 800cbe8:	58021400 	.word	0x58021400
 800cbec:	58021800 	.word	0x58021800
 800cbf0:	58021c00 	.word	0x58021c00
 800cbf4:	58000400 	.word	0x58000400
 800cbf8:	58020000 	.word	0x58020000
 800cbfc:	58020400 	.word	0x58020400
 800cc00:	58020800 	.word	0x58020800
 800cc04:	58022000 	.word	0x58022000
 800cc08:	58022400 	.word	0x58022400

0800cc0c <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 800cc0c:	b902      	cbnz	r2, 800cc10 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 800cc0e:	0409      	lsls	r1, r1, #16
 800cc10:	6181      	str	r1, [r0, #24]
  }
}
 800cc12:	4770      	bx	lr

0800cc14 <HAL_HSEM_FastTake>:
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
  }
#else  
  /* Read the RLR register to take the semaphore */
  if (HSEM->RLR[SemID] == (HSEM_CR_COREID_CURRENT | HSEM_RLR_LOCK))
 800cc14:	4a04      	ldr	r2, [pc, #16]	; (800cc28 <HAL_HSEM_FastTake+0x14>)
 800cc16:	3020      	adds	r0, #32
 800cc18:	4b04      	ldr	r3, [pc, #16]	; (800cc2c <HAL_HSEM_FastTake+0x18>)
 800cc1a:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
  }
#endif

  /* Semaphore take fails */
  return HAL_ERROR;
}
 800cc1e:	1ac0      	subs	r0, r0, r3
 800cc20:	bf18      	it	ne
 800cc22:	2001      	movne	r0, #1
 800cc24:	4770      	bx	lr
 800cc26:	bf00      	nop
 800cc28:	58026400 	.word	0x58026400
 800cc2c:	80000300 	.word	0x80000300

0800cc30 <HAL_HSEM_Release>:

  /* Clear the semaphore by writing to the R register : the MasterID , the processID and take bit = 0  */
#if  USE_MULTI_CORE_SHARED_CODE != 0U
  HSEM->R[SemID] = (ProcessID | ((HAL_GetCurrentCPUID() << POSITION_VAL(HSEM_R_MASTERID)) & HSEM_R_MASTERID));
#else
  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT);
 800cc30:	4b02      	ldr	r3, [pc, #8]	; (800cc3c <HAL_HSEM_Release+0xc>)
 800cc32:	f441 7140 	orr.w	r1, r1, #768	; 0x300
 800cc36:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
#endif

}
 800cc3a:	4770      	bx	lr
 800cc3c:	58026400 	.word	0x58026400

0800cc40 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 800cc40:	b5f0      	push	{r4, r5, r6, r7, lr}
 800cc42:	b08b      	sub	sp, #44	; 0x2c
  USB_OTG_GlobalTypeDef *USBx;
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 800cc44:	2800      	cmp	r0, #0
 800cc46:	f000 8088 	beq.w	800cd5a <HAL_PCD_Init+0x11a>
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  USBx = hpcd->Instance;

  if (hpcd->State == HAL_PCD_STATE_RESET)
 800cc4a:	f890 34bd 	ldrb.w	r3, [r0, #1213]	; 0x4bd
 800cc4e:	4605      	mov	r5, r0
  USBx = hpcd->Instance;
 800cc50:	6804      	ldr	r4, [r0, #0]
  if (hpcd->State == HAL_PCD_STATE_RESET)
 800cc52:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800cc56:	2b00      	cmp	r3, #0
 800cc58:	d079      	beq.n	800cd4e <HAL_PCD_Init+0x10e>
 800cc5a:	4620      	mov	r0, r4
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 800cc5c:	2303      	movs	r3, #3

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 800cc5e:	462e      	mov	r6, r5
 800cc60:	1d2f      	adds	r7, r5, #4
  hpcd->State = HAL_PCD_STATE_BUSY;
 800cc62:	f885 34bd 	strb.w	r3, [r5, #1213]	; 0x4bd
  if ((USBx->CID & (0x1U << 8)) == 0U)
 800cc66:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 800cc68:	466c      	mov	r4, sp
  if ((USBx->CID & (0x1U << 8)) == 0U)
 800cc6a:	f413 7380 	ands.w	r3, r3, #256	; 0x100
    hpcd->Init.dma_enable = 0U;
 800cc6e:	bf08      	it	eq
 800cc70:	612b      	streq	r3, [r5, #16]
  __HAL_PCD_DISABLE(hpcd);
 800cc72:	f004 fb39 	bl	80112e8 <USB_DisableGlobalInt>
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 800cc76:	f856 eb10 	ldr.w	lr, [r6], #16
 800cc7a:	46b4      	mov	ip, r6
 800cc7c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800cc80:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800cc82:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800cc86:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800cc88:	e89c 0003 	ldmia.w	ip, {r0, r1}
 800cc8c:	e884 0003 	stmia.w	r4, {r0, r1}
 800cc90:	4670      	mov	r0, lr
 800cc92:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 800cc96:	f004 fa03 	bl	80110a0 <USB_CoreInit>
 800cc9a:	4604      	mov	r4, r0
 800cc9c:	b130      	cbz	r0, 800ccac <HAL_PCD_Init+0x6c>

  /* Init Device */
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
    return HAL_ERROR;
 800cc9e:	2401      	movs	r4, #1
    hpcd->State = HAL_PCD_STATE_ERROR;
 800cca0:	2302      	movs	r3, #2
  }

  (void)USB_DevDisconnect(hpcd->Instance);

  return HAL_OK;
}
 800cca2:	4620      	mov	r0, r4
    hpcd->State = HAL_PCD_STATE_ERROR;
 800cca4:	f885 34bd 	strb.w	r3, [r5, #1213]	; 0x4bd
}
 800cca8:	b00b      	add	sp, #44	; 0x2c
 800ccaa:	bdf0      	pop	{r4, r5, r6, r7, pc}
  (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);
 800ccac:	4601      	mov	r1, r0
 800ccae:	6828      	ldr	r0, [r5, #0]
 800ccb0:	f004 fb22 	bl	80112f8 <USB_SetCurrentMode>
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800ccb4:	6868      	ldr	r0, [r5, #4]
 800ccb6:	b358      	cbz	r0, 800cd10 <HAL_PCD_Init+0xd0>
 800ccb8:	4622      	mov	r2, r4
    hpcd->IN_ep[i].is_in = 1U;
 800ccba:	f04f 0e01 	mov.w	lr, #1
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 800ccbe:	4621      	mov	r1, r4
    hpcd->IN_ep[i].is_in = 1U;
 800ccc0:	eb02 03c2 	add.w	r3, r2, r2, lsl #3
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800ccc4:	f102 0c01 	add.w	ip, r2, #1
    hpcd->IN_ep[i].is_in = 1U;
 800ccc8:	eb05 0383 	add.w	r3, r5, r3, lsl #2
    hpcd->IN_ep[i].num = i;
 800cccc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    hpcd->IN_ep[i].tx_fifo_num = i;
 800ccd0:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800ccd4:	fa5f f28c 	uxtb.w	r2, ip
    hpcd->IN_ep[i].is_in = 1U;
 800ccd8:	f883 e03d 	strb.w	lr, [r3, #61]	; 0x3d
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800ccdc:	4282      	cmp	r2, r0
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 800ccde:	f883 1040 	strb.w	r1, [r3, #64]	; 0x40
    hpcd->IN_ep[i].xfer_len = 0U;
 800cce2:	6559      	str	r1, [r3, #84]	; 0x54
    hpcd->IN_ep[i].xfer_buff = 0U;
 800cce4:	e9c3 1112 	strd	r1, r1, [r3, #72]	; 0x48
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800cce8:	d3ea      	bcc.n	800ccc0 <HAL_PCD_Init+0x80>
    hpcd->OUT_ep[i].is_in = 0U;
 800ccea:	2200      	movs	r2, #0
 800ccec:	eb04 03c4 	add.w	r3, r4, r4, lsl #3
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800ccf0:	1c61      	adds	r1, r4, #1
    hpcd->OUT_ep[i].is_in = 0U;
 800ccf2:	eb05 0383 	add.w	r3, r5, r3, lsl #2
    hpcd->OUT_ep[i].num = i;
 800ccf6:	f883 427c 	strb.w	r4, [r3, #636]	; 0x27c
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800ccfa:	b2cc      	uxtb	r4, r1
    hpcd->OUT_ep[i].is_in = 0U;
 800ccfc:	f883 227d 	strb.w	r2, [r3, #637]	; 0x27d
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800cd00:	4284      	cmp	r4, r0
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 800cd02:	f883 2280 	strb.w	r2, [r3, #640]	; 0x280
    hpcd->OUT_ep[i].xfer_len = 0U;
 800cd06:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
    hpcd->OUT_ep[i].xfer_buff = 0U;
 800cd0a:	e9c3 22a2 	strd	r2, r2, [r3, #648]	; 0x288
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800cd0e:	d3ed      	bcc.n	800ccec <HAL_PCD_Init+0xac>
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 800cd10:	466c      	mov	r4, sp
 800cd12:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800cd14:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800cd16:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800cd18:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800cd1a:	e896 0003 	ldmia.w	r6, {r0, r1}
 800cd1e:	e884 0003 	stmia.w	r4, {r0, r1}
 800cd22:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
 800cd26:	6828      	ldr	r0, [r5, #0]
 800cd28:	f004 fb1c 	bl	8011364 <USB_DevInit>
 800cd2c:	4604      	mov	r4, r0
 800cd2e:	2800      	cmp	r0, #0
 800cd30:	d1b5      	bne.n	800cc9e <HAL_PCD_Init+0x5e>
  hpcd->State = HAL_PCD_STATE_READY;
 800cd32:	2201      	movs	r2, #1
  if (hpcd->Init.lpm_enable == 1U)
 800cd34:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  hpcd->USB_Address = 0U;
 800cd36:	f885 0038 	strb.w	r0, [r5, #56]	; 0x38
  if (hpcd->Init.lpm_enable == 1U)
 800cd3a:	4293      	cmp	r3, r2
  hpcd->State = HAL_PCD_STATE_READY;
 800cd3c:	f885 24bd 	strb.w	r2, [r5, #1213]	; 0x4bd
  if (hpcd->Init.lpm_enable == 1U)
 800cd40:	d00f      	beq.n	800cd62 <HAL_PCD_Init+0x122>
  (void)USB_DevDisconnect(hpcd->Instance);
 800cd42:	6828      	ldr	r0, [r5, #0]
 800cd44:	f004 ffd2 	bl	8011cec <USB_DevDisconnect>
}
 800cd48:	4620      	mov	r0, r4
 800cd4a:	b00b      	add	sp, #44	; 0x2c
 800cd4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hpcd->Lock = HAL_UNLOCKED;
 800cd4e:	f880 24bc 	strb.w	r2, [r0, #1212]	; 0x4bc
    HAL_PCD_MspInit(hpcd);
 800cd52:	f006 ffed 	bl	8013d30 <HAL_PCD_MspInit>
  __HAL_PCD_DISABLE(hpcd);
 800cd56:	6828      	ldr	r0, [r5, #0]
 800cd58:	e780      	b.n	800cc5c <HAL_PCD_Init+0x1c>
    return HAL_ERROR;
 800cd5a:	2401      	movs	r4, #1
}
 800cd5c:	4620      	mov	r0, r4
 800cd5e:	b00b      	add	sp, #44	; 0x2c
 800cd60:	bdf0      	pop	{r4, r5, r6, r7, pc}
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 800cd62:	4628      	mov	r0, r5
 800cd64:	f000 ff5c 	bl	800dc20 <HAL_PCDEx_ActivateLPM>
 800cd68:	e7eb      	b.n	800cd42 <HAL_PCD_Init+0x102>
 800cd6a:	bf00      	nop

0800cd6c <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 800cd6c:	b510      	push	{r4, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;

  __HAL_LOCK(hpcd);
 800cd6e:	f890 34bc 	ldrb.w	r3, [r0, #1212]	; 0x4bc
{
 800cd72:	4604      	mov	r4, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800cd74:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hpcd);
 800cd76:	2b01      	cmp	r3, #1
 800cd78:	d017      	beq.n	800cdaa <HAL_PCD_Start+0x3e>
 800cd7a:	2201      	movs	r2, #1

  if ((hpcd->Init.battery_charging_enable == 1U) &&
 800cd7c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800cd7e:	4293      	cmp	r3, r2
  __HAL_LOCK(hpcd);
 800cd80:	f884 24bc 	strb.w	r2, [r4, #1212]	; 0x4bc
  if ((hpcd->Init.battery_charging_enable == 1U) &&
 800cd84:	d009      	beq.n	800cd9a <HAL_PCD_Start+0x2e>
  {
    /* Enable USB Transceiver */
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
  }

  __HAL_PCD_ENABLE(hpcd);
 800cd86:	f004 faa7 	bl	80112d8 <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
 800cd8a:	6820      	ldr	r0, [r4, #0]
 800cd8c:	f004 ff9e 	bl	8011ccc <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 800cd90:	2300      	movs	r3, #0

  return HAL_OK;
 800cd92:	4618      	mov	r0, r3
  __HAL_UNLOCK(hpcd);
 800cd94:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc
}
 800cd98:	bd10      	pop	{r4, pc}
  if ((hpcd->Init.battery_charging_enable == 1U) &&
 800cd9a:	69a3      	ldr	r3, [r4, #24]
 800cd9c:	4293      	cmp	r3, r2
 800cd9e:	d0f2      	beq.n	800cd86 <HAL_PCD_Start+0x1a>
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 800cda0:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800cda2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800cda6:	6383      	str	r3, [r0, #56]	; 0x38
 800cda8:	e7ed      	b.n	800cd86 <HAL_PCD_Start+0x1a>
  __HAL_LOCK(hpcd);
 800cdaa:	2002      	movs	r0, #2
}
 800cdac:	bd10      	pop	{r4, pc}
 800cdae:	bf00      	nop

0800cdb0 <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 800cdb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800cdb4:	6805      	ldr	r5, [r0, #0]
{
 800cdb6:	b089      	sub	sp, #36	; 0x24
 800cdb8:	4604      	mov	r4, r0
  uint32_t epnum;
  uint32_t fifoemptymsk;
  uint32_t RegVal;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 800cdba:	4628      	mov	r0, r5
 800cdbc:	f004 ffd4 	bl	8011d68 <USB_GetMode>
 800cdc0:	b110      	cbz	r0, 800cdc8 <HAL_PCD_IRQHandler+0x18>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= RegVal;
    }
  }
}
 800cdc2:	b009      	add	sp, #36	; 0x24
 800cdc4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 800cdc8:	4683      	mov	fp, r0
 800cdca:	6820      	ldr	r0, [r4, #0]
 800cdcc:	f004 ff9e 	bl	8011d0c <USB_ReadInterrupts>
 800cdd0:	2800      	cmp	r0, #0
 800cdd2:	d0f6      	beq.n	800cdc2 <HAL_PCD_IRQHandler+0x12>
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 800cdd4:	f8d5 3808 	ldr.w	r3, [r5, #2056]	; 0x808
 800cdd8:	f505 6200 	add.w	r2, r5, #2048	; 0x800
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 800cddc:	6820      	ldr	r0, [r4, #0]
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 800cdde:	f3c3 230d 	ubfx	r3, r3, #8, #14
 800cde2:	9202      	str	r2, [sp, #8]
 800cde4:	f8c4 34fc 	str.w	r3, [r4, #1276]	; 0x4fc
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 800cde8:	f004 ff90 	bl	8011d0c <USB_ReadInterrupts>
 800cdec:	f010 0f02 	tst.w	r0, #2
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 800cdf0:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 800cdf2:	d003      	beq.n	800cdfc <HAL_PCD_IRQHandler+0x4c>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 800cdf4:	6943      	ldr	r3, [r0, #20]
 800cdf6:	f003 0302 	and.w	r3, r3, #2
 800cdfa:	6143      	str	r3, [r0, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 800cdfc:	f004 ff86 	bl	8011d0c <USB_ReadInterrupts>
 800ce00:	f010 0f10 	tst.w	r0, #16
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800ce04:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 800ce06:	d012      	beq.n	800ce2e <HAL_PCD_IRQHandler+0x7e>
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800ce08:	6983      	ldr	r3, [r0, #24]
 800ce0a:	f023 0310 	bic.w	r3, r3, #16
 800ce0e:	6183      	str	r3, [r0, #24]
      RegVal = USBx->GRXSTSP;
 800ce10:	6a2e      	ldr	r6, [r5, #32]
      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 800ce12:	f3c6 4343 	ubfx	r3, r6, #17, #4
      ep = &hpcd->OUT_ep[RegVal & USB_OTG_GRXSTSP_EPNUM];
 800ce16:	f006 070f 	and.w	r7, r6, #15
      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 800ce1a:	2b02      	cmp	r3, #2
 800ce1c:	f000 83e3 	beq.w	800d5e6 <HAL_PCD_IRQHandler+0x836>
      else if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) == STS_SETUP_UPDT)
 800ce20:	2b06      	cmp	r3, #6
 800ce22:	f000 8322 	beq.w	800d46a <HAL_PCD_IRQHandler+0x6ba>
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800ce26:	6983      	ldr	r3, [r0, #24]
 800ce28:	f043 0310 	orr.w	r3, r3, #16
 800ce2c:	6183      	str	r3, [r0, #24]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 800ce2e:	f004 ff6d 	bl	8011d0c <USB_ReadInterrupts>
 800ce32:	0307      	lsls	r7, r0, #12
 800ce34:	f100 8280 	bmi.w	800d338 <HAL_PCD_IRQHandler+0x588>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 800ce38:	6820      	ldr	r0, [r4, #0]
 800ce3a:	f004 ff67 	bl	8011d0c <USB_ReadInterrupts>
 800ce3e:	0346      	lsls	r6, r0, #13
 800ce40:	f100 8228 	bmi.w	800d294 <HAL_PCD_IRQHandler+0x4e4>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 800ce44:	6820      	ldr	r0, [r4, #0]
 800ce46:	f004 ff61 	bl	8011d0c <USB_ReadInterrupts>
 800ce4a:	2800      	cmp	r0, #0
 800ce4c:	f2c0 819a 	blt.w	800d184 <HAL_PCD_IRQHandler+0x3d4>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 800ce50:	6820      	ldr	r0, [r4, #0]
 800ce52:	f004 ff5b 	bl	8011d0c <USB_ReadInterrupts>
 800ce56:	0503      	lsls	r3, r0, #20
 800ce58:	f100 8157 	bmi.w	800d10a <HAL_PCD_IRQHandler+0x35a>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
 800ce5c:	6820      	ldr	r0, [r4, #0]
 800ce5e:	f004 ff55 	bl	8011d0c <USB_ReadInterrupts>
 800ce62:	0106      	lsls	r6, r0, #4
 800ce64:	d514      	bpl.n	800ce90 <HAL_PCD_IRQHandler+0xe0>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);
 800ce66:	6822      	ldr	r2, [r4, #0]
 800ce68:	6953      	ldr	r3, [r2, #20]
 800ce6a:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800ce6e:	6153      	str	r3, [r2, #20]
      if (hpcd->LPM_State == LPM_L0)
 800ce70:	f894 34f4 	ldrb.w	r3, [r4, #1268]	; 0x4f4
 800ce74:	2b00      	cmp	r3, #0
 800ce76:	f040 82ab 	bne.w	800d3d0 <HAL_PCD_IRQHandler+0x620>
        hpcd->LPM_State = LPM_L1;
 800ce7a:	2101      	movs	r1, #1
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 800ce7c:	4620      	mov	r0, r4
        hpcd->LPM_State = LPM_L1;
 800ce7e:	f884 14f4 	strb.w	r1, [r4, #1268]	; 0x4f4
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 800ce82:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800ce84:	f3c3 0383 	ubfx	r3, r3, #2, #4
 800ce88:	f8c4 34f8 	str.w	r3, [r4, #1272]	; 0x4f8
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 800ce8c:	f000 fee0 	bl	800dc50 <HAL_PCDEx_LPM_Callback>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 800ce90:	6820      	ldr	r0, [r4, #0]
 800ce92:	f004 ff3b 	bl	8011d0c <USB_ReadInterrupts>
 800ce96:	04c0      	lsls	r0, r0, #19
 800ce98:	f100 819e 	bmi.w	800d1d8 <HAL_PCD_IRQHandler+0x428>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 800ce9c:	6820      	ldr	r0, [r4, #0]
 800ce9e:	f004 ff35 	bl	8011d0c <USB_ReadInterrupts>
 800cea2:	f410 5f00 	tst.w	r0, #8192	; 0x2000
      (void)USB_ActivateSetup(hpcd->Instance);
 800cea6:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 800cea8:	f040 817f 	bne.w	800d1aa <HAL_PCD_IRQHandler+0x3fa>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 800ceac:	f004 ff2e 	bl	8011d0c <USB_ReadInterrupts>
 800ceb0:	0701      	lsls	r1, r0, #28
 800ceb2:	f100 81e6 	bmi.w	800d282 <HAL_PCD_IRQHandler+0x4d2>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_BOUTNAKEFF))
 800ceb6:	6820      	ldr	r0, [r4, #0]
 800ceb8:	f004 ff28 	bl	8011d0c <USB_ReadInterrupts>
 800cebc:	0602      	lsls	r2, r0, #24
 800cebe:	d571      	bpl.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
 800cec0:	69aa      	ldr	r2, [r5, #24]
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cec2:	6863      	ldr	r3, [r4, #4]
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
 800cec4:	f022 0280 	bic.w	r2, r2, #128	; 0x80
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cec8:	2b01      	cmp	r3, #1
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
 800ceca:	61aa      	str	r2, [r5, #24]
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cecc:	d96a      	bls.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800cece:	f894 22a3 	ldrb.w	r2, [r4, #675]	; 0x2a3
 800ced2:	2a01      	cmp	r2, #1
 800ced4:	f000 83e8 	beq.w	800d6a8 <HAL_PCD_IRQHandler+0x8f8>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800ced8:	2b02      	cmp	r3, #2
 800ceda:	d963      	bls.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800cedc:	f894 22c7 	ldrb.w	r2, [r4, #711]	; 0x2c7
 800cee0:	2a01      	cmp	r2, #1
 800cee2:	f000 83fc 	beq.w	800d6de <HAL_PCD_IRQHandler+0x92e>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cee6:	2b03      	cmp	r3, #3
 800cee8:	d95c      	bls.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800ceea:	f894 22eb 	ldrb.w	r2, [r4, #747]	; 0x2eb
 800ceee:	2a01      	cmp	r2, #1
 800cef0:	f000 82b4 	beq.w	800d45c <HAL_PCD_IRQHandler+0x6ac>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cef4:	2b04      	cmp	r3, #4
 800cef6:	d955      	bls.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800cef8:	f894 230f 	ldrb.w	r2, [r4, #783]	; 0x30f
 800cefc:	2a01      	cmp	r2, #1
 800cefe:	f000 82c7 	beq.w	800d490 <HAL_PCD_IRQHandler+0x6e0>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cf02:	2b05      	cmp	r3, #5
 800cf04:	d94e      	bls.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800cf06:	f894 2333 	ldrb.w	r2, [r4, #819]	; 0x333
 800cf0a:	2a01      	cmp	r2, #1
 800cf0c:	f000 8424 	beq.w	800d758 <HAL_PCD_IRQHandler+0x9a8>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cf10:	2b06      	cmp	r3, #6
 800cf12:	d947      	bls.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800cf14:	f894 2357 	ldrb.w	r2, [r4, #855]	; 0x357
 800cf18:	2a01      	cmp	r2, #1
 800cf1a:	f000 8431 	beq.w	800d780 <HAL_PCD_IRQHandler+0x9d0>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cf1e:	2b07      	cmp	r3, #7
 800cf20:	d940      	bls.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800cf22:	f894 237b 	ldrb.w	r2, [r4, #891]	; 0x37b
 800cf26:	2a01      	cmp	r2, #1
 800cf28:	f000 8448 	beq.w	800d7bc <HAL_PCD_IRQHandler+0xa0c>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cf2c:	2b08      	cmp	r3, #8
 800cf2e:	d939      	bls.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800cf30:	f894 239f 	ldrb.w	r2, [r4, #927]	; 0x39f
 800cf34:	2a01      	cmp	r2, #1
 800cf36:	f000 8455 	beq.w	800d7e4 <HAL_PCD_IRQHandler+0xa34>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cf3a:	2b09      	cmp	r3, #9
 800cf3c:	d932      	bls.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800cf3e:	f894 23c3 	ldrb.w	r2, [r4, #963]	; 0x3c3
 800cf42:	2a01      	cmp	r2, #1
 800cf44:	f000 8462 	beq.w	800d80c <HAL_PCD_IRQHandler+0xa5c>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cf48:	2b0a      	cmp	r3, #10
 800cf4a:	d92b      	bls.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800cf4c:	f894 23e7 	ldrb.w	r2, [r4, #999]	; 0x3e7
 800cf50:	2a01      	cmp	r2, #1
 800cf52:	f000 846f 	beq.w	800d834 <HAL_PCD_IRQHandler+0xa84>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cf56:	2b0b      	cmp	r3, #11
 800cf58:	d924      	bls.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800cf5a:	f894 240b 	ldrb.w	r2, [r4, #1035]	; 0x40b
 800cf5e:	2a01      	cmp	r2, #1
 800cf60:	f000 847c 	beq.w	800d85c <HAL_PCD_IRQHandler+0xaac>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cf64:	2b0c      	cmp	r3, #12
 800cf66:	d91d      	bls.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800cf68:	f894 242f 	ldrb.w	r2, [r4, #1071]	; 0x42f
 800cf6c:	2a01      	cmp	r2, #1
 800cf6e:	f000 847d 	beq.w	800d86c <HAL_PCD_IRQHandler+0xabc>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cf72:	2b0d      	cmp	r3, #13
 800cf74:	d916      	bls.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800cf76:	f894 2453 	ldrb.w	r2, [r4, #1107]	; 0x453
 800cf7a:	2a01      	cmp	r2, #1
 800cf7c:	f000 849d 	beq.w	800d8ba <HAL_PCD_IRQHandler+0xb0a>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cf80:	2b0e      	cmp	r3, #14
 800cf82:	d90f      	bls.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800cf84:	f894 2477 	ldrb.w	r2, [r4, #1143]	; 0x477
 800cf88:	2a01      	cmp	r2, #1
 800cf8a:	f000 84a4 	beq.w	800d8d6 <HAL_PCD_IRQHandler+0xb26>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cf8e:	2b0f      	cmp	r3, #15
 800cf90:	d908      	bls.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800cf92:	f894 349b 	ldrb.w	r3, [r4, #1179]	; 0x49b
 800cf96:	2b01      	cmp	r3, #1
 800cf98:	d104      	bne.n	800cfa4 <HAL_PCD_IRQHandler+0x1f4>
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
  }

  /* Stop Xfer */
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800cf9a:	f504 6193 	add.w	r1, r4, #1176	; 0x498
 800cf9e:	6820      	ldr	r0, [r4, #0]
 800cfa0:	f004 fda2 	bl	8011ae8 <USB_EPStopXfer>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 800cfa4:	6820      	ldr	r0, [r4, #0]
 800cfa6:	f004 feb1 	bl	8011d0c <USB_ReadInterrupts>
 800cfaa:	02c3      	lsls	r3, r0, #11
 800cfac:	f140 80ab 	bpl.w	800d106 <HAL_PCD_IRQHandler+0x356>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cfb0:	6863      	ldr	r3, [r4, #4]
 800cfb2:	2b01      	cmp	r3, #1
 800cfb4:	f240 8089 	bls.w	800d0ca <HAL_PCD_IRQHandler+0x31a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800cfb8:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800cfbc:	f8d5 1920 	ldr.w	r1, [r5, #2336]	; 0x920
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800cfc0:	2a01      	cmp	r2, #1
 800cfc2:	f000 8214 	beq.w	800d3ee <HAL_PCD_IRQHandler+0x63e>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cfc6:	2b02      	cmp	r3, #2
 800cfc8:	d97f      	bls.n	800d0ca <HAL_PCD_IRQHandler+0x31a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800cfca:	f894 2088 	ldrb.w	r2, [r4, #136]	; 0x88
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800cfce:	f8d5 1940 	ldr.w	r1, [r5, #2368]	; 0x940
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800cfd2:	2a01      	cmp	r2, #1
 800cfd4:	f000 821e 	beq.w	800d414 <HAL_PCD_IRQHandler+0x664>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cfd8:	2b03      	cmp	r3, #3
 800cfda:	d976      	bls.n	800d0ca <HAL_PCD_IRQHandler+0x31a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800cfdc:	f894 20ac 	ldrb.w	r2, [r4, #172]	; 0xac
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800cfe0:	f8d5 1960 	ldr.w	r1, [r5, #2400]	; 0x960
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800cfe4:	2a01      	cmp	r2, #1
 800cfe6:	f000 8221 	beq.w	800d42c <HAL_PCD_IRQHandler+0x67c>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cfea:	2b04      	cmp	r3, #4
 800cfec:	d96d      	bls.n	800d0ca <HAL_PCD_IRQHandler+0x31a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800cfee:	f894 20d0 	ldrb.w	r2, [r4, #208]	; 0xd0
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800cff2:	f8d5 1980 	ldr.w	r1, [r5, #2432]	; 0x980
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800cff6:	2a01      	cmp	r2, #1
 800cff8:	f000 8224 	beq.w	800d444 <HAL_PCD_IRQHandler+0x694>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800cffc:	2b05      	cmp	r3, #5
 800cffe:	d964      	bls.n	800d0ca <HAL_PCD_IRQHandler+0x31a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d000:	f894 20f4 	ldrb.w	r2, [r4, #244]	; 0xf4
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800d004:	f8d5 19a0 	ldr.w	r1, [r5, #2464]	; 0x9a0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d008:	2a01      	cmp	r2, #1
 800d00a:	f000 8341 	beq.w	800d690 <HAL_PCD_IRQHandler+0x8e0>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d00e:	2b06      	cmp	r3, #6
 800d010:	d95b      	bls.n	800d0ca <HAL_PCD_IRQHandler+0x31a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d012:	f894 2118 	ldrb.w	r2, [r4, #280]	; 0x118
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800d016:	f8d5 19c0 	ldr.w	r1, [r5, #2496]	; 0x9c0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d01a:	2a01      	cmp	r2, #1
 800d01c:	f000 8353 	beq.w	800d6c6 <HAL_PCD_IRQHandler+0x916>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d020:	2b07      	cmp	r3, #7
 800d022:	d952      	bls.n	800d0ca <HAL_PCD_IRQHandler+0x31a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d024:	f894 213c 	ldrb.w	r2, [r4, #316]	; 0x13c
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800d028:	f8d5 19e0 	ldr.w	r1, [r5, #2528]	; 0x9e0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d02c:	2a01      	cmp	r2, #1
 800d02e:	f000 835e 	beq.w	800d6ee <HAL_PCD_IRQHandler+0x93e>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d032:	2b08      	cmp	r3, #8
 800d034:	d949      	bls.n	800d0ca <HAL_PCD_IRQHandler+0x31a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d036:	f894 2160 	ldrb.w	r2, [r4, #352]	; 0x160
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800d03a:	f8d5 1a00 	ldr.w	r1, [r5, #2560]	; 0xa00
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d03e:	2a01      	cmp	r2, #1
 800d040:	f000 8361 	beq.w	800d706 <HAL_PCD_IRQHandler+0x956>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d044:	2b09      	cmp	r3, #9
 800d046:	d940      	bls.n	800d0ca <HAL_PCD_IRQHandler+0x31a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d048:	f894 2184 	ldrb.w	r2, [r4, #388]	; 0x184
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800d04c:	f8d5 1a20 	ldr.w	r1, [r5, #2592]	; 0xa20
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d050:	2a01      	cmp	r2, #1
 800d052:	f000 836c 	beq.w	800d72e <HAL_PCD_IRQHandler+0x97e>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d056:	2b0a      	cmp	r3, #10
 800d058:	d937      	bls.n	800d0ca <HAL_PCD_IRQHandler+0x31a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d05a:	f894 21a8 	ldrb.w	r2, [r4, #424]	; 0x1a8
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800d05e:	f8d5 1a40 	ldr.w	r1, [r5, #2624]	; 0xa40
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d062:	2a01      	cmp	r2, #1
 800d064:	f000 8380 	beq.w	800d768 <HAL_PCD_IRQHandler+0x9b8>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d068:	2b0b      	cmp	r3, #11
 800d06a:	d92e      	bls.n	800d0ca <HAL_PCD_IRQHandler+0x31a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d06c:	f894 21cc 	ldrb.w	r2, [r4, #460]	; 0x1cc
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800d070:	f8d5 1a60 	ldr.w	r1, [r5, #2656]	; 0xa60
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d074:	2a01      	cmp	r2, #1
 800d076:	f000 8395 	beq.w	800d7a4 <HAL_PCD_IRQHandler+0x9f4>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d07a:	2b0c      	cmp	r3, #12
 800d07c:	d925      	bls.n	800d0ca <HAL_PCD_IRQHandler+0x31a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d07e:	f894 21f0 	ldrb.w	r2, [r4, #496]	; 0x1f0
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800d082:	f8d5 1a80 	ldr.w	r1, [r5, #2688]	; 0xa80
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d086:	2a01      	cmp	r2, #1
 800d088:	f000 83a0 	beq.w	800d7cc <HAL_PCD_IRQHandler+0xa1c>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d08c:	2b0d      	cmp	r3, #13
 800d08e:	d91c      	bls.n	800d0ca <HAL_PCD_IRQHandler+0x31a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d090:	f894 2214 	ldrb.w	r2, [r4, #532]	; 0x214
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800d094:	f8d5 1aa0 	ldr.w	r1, [r5, #2720]	; 0xaa0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d098:	2a01      	cmp	r2, #1
 800d09a:	f000 83ab 	beq.w	800d7f4 <HAL_PCD_IRQHandler+0xa44>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d09e:	2b0e      	cmp	r3, #14
 800d0a0:	d913      	bls.n	800d0ca <HAL_PCD_IRQHandler+0x31a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d0a2:	f894 2238 	ldrb.w	r2, [r4, #568]	; 0x238
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800d0a6:	f8d5 1ac0 	ldr.w	r1, [r5, #2752]	; 0xac0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d0aa:	2a01      	cmp	r2, #1
 800d0ac:	f000 83b6 	beq.w	800d81c <HAL_PCD_IRQHandler+0xa6c>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d0b0:	2b0f      	cmp	r3, #15
 800d0b2:	d90a      	bls.n	800d0ca <HAL_PCD_IRQHandler+0x31a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d0b4:	f894 225c 	ldrb.w	r2, [r4, #604]	; 0x25c
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800d0b8:	f8d5 1ae0 	ldr.w	r1, [r5, #2784]	; 0xae0
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d0bc:	2a01      	cmp	r2, #1
 800d0be:	f000 83c1 	beq.w	800d844 <HAL_PCD_IRQHandler+0xa94>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d0c2:	2b10      	cmp	r3, #16
 800d0c4:	d901      	bls.n	800d0ca <HAL_PCD_IRQHandler+0x31a>
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800d0c6:	f8d5 3b00 	ldr.w	r3, [r5, #2816]	; 0xb00
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 800d0ca:	6820      	ldr	r0, [r4, #0]
 800d0cc:	6943      	ldr	r3, [r0, #20]
 800d0ce:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800d0d2:	6143      	str	r3, [r0, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 800d0d4:	f004 fe1a 	bl	8011d0c <USB_ReadInterrupts>
 800d0d8:	0287      	lsls	r7, r0, #10
 800d0da:	d421      	bmi.n	800d120 <HAL_PCD_IRQHandler+0x370>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 800d0dc:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 800d0de:	f004 fe15 	bl	8011d0c <USB_ReadInterrupts>
 800d0e2:	0040      	lsls	r0, r0, #1
 800d0e4:	f100 80c4 	bmi.w	800d270 <HAL_PCD_IRQHandler+0x4c0>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 800d0e8:	6820      	ldr	r0, [r4, #0]
 800d0ea:	f004 fe0f 	bl	8011d0c <USB_ReadInterrupts>
 800d0ee:	0741      	lsls	r1, r0, #29
 800d0f0:	f57f ae67 	bpl.w	800cdc2 <HAL_PCD_IRQHandler+0x12>
      RegVal = hpcd->Instance->GOTGINT;
 800d0f4:	6823      	ldr	r3, [r4, #0]
 800d0f6:	685d      	ldr	r5, [r3, #4]
      if ((RegVal & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 800d0f8:	076a      	lsls	r2, r5, #29
 800d0fa:	f100 8295 	bmi.w	800d628 <HAL_PCD_IRQHandler+0x878>
      hpcd->Instance->GOTGINT |= RegVal;
 800d0fe:	685a      	ldr	r2, [r3, #4]
 800d100:	432a      	orrs	r2, r5
 800d102:	605a      	str	r2, [r3, #4]
 800d104:	e65d      	b.n	800cdc2 <HAL_PCD_IRQHandler+0x12>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 800d106:	6820      	ldr	r0, [r4, #0]
 800d108:	e7e4      	b.n	800d0d4 <HAL_PCD_IRQHandler+0x324>
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 800d10a:	9b02      	ldr	r3, [sp, #8]
 800d10c:	689b      	ldr	r3, [r3, #8]
 800d10e:	07df      	lsls	r7, r3, #31
 800d110:	f100 8286 	bmi.w	800d620 <HAL_PCD_IRQHandler+0x870>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 800d114:	6820      	ldr	r0, [r4, #0]
 800d116:	6943      	ldr	r3, [r0, #20]
 800d118:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800d11c:	6143      	str	r3, [r0, #20]
 800d11e:	e69e      	b.n	800ce5e <HAL_PCD_IRQHandler+0xae>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d120:	f8d4 c004 	ldr.w	ip, [r4, #4]
 800d124:	f1bc 0f01 	cmp.w	ip, #1
 800d128:	d926      	bls.n	800d178 <HAL_PCD_IRQHandler+0x3c8>
 800d12a:	f505 6232 	add.w	r2, r5, #2848	; 0xb20
 800d12e:	4623      	mov	r3, r4
 800d130:	2101      	movs	r1, #1
 800d132:	e004      	b.n	800d13e <HAL_PCD_IRQHandler+0x38e>
 800d134:	3101      	adds	r1, #1
 800d136:	3220      	adds	r2, #32
 800d138:	3324      	adds	r3, #36	; 0x24
 800d13a:	4561      	cmp	r1, ip
 800d13c:	d01c      	beq.n	800d178 <HAL_PCD_IRQHandler+0x3c8>
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 800d13e:	f893 02a4 	ldrb.w	r0, [r3, #676]	; 0x2a4
        RegVal = USBx_OUTEP(epnum)->DOEPCTL;
 800d142:	6816      	ldr	r6, [r2, #0]
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 800d144:	2801      	cmp	r0, #1
 800d146:	d1f5      	bne.n	800d134 <HAL_PCD_IRQHandler+0x384>
 800d148:	2e00      	cmp	r6, #0
 800d14a:	daf3      	bge.n	800d134 <HAL_PCD_IRQHandler+0x384>
            ((RegVal & (0x1U << 16)) == (hpcd->FrameNumber & 0x1U)))
 800d14c:	f8d4 74fc 	ldr.w	r7, [r4, #1276]	; 0x4fc
 800d150:	f406 3680 	and.w	r6, r6, #65536	; 0x10000
 800d154:	f007 0701 	and.w	r7, r7, #1
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 800d158:	42be      	cmp	r6, r7
 800d15a:	d1eb      	bne.n	800d134 <HAL_PCD_IRQHandler+0x384>
          hpcd->OUT_ep[epnum].is_iso_incomplete = 1U;
 800d15c:	f883 02a3 	strb.w	r0, [r3, #675]	; 0x2a3
          USBx->GINTMSK |= USB_OTG_GINTMSK_GONAKEFFM;
 800d160:	69a8      	ldr	r0, [r5, #24]
 800d162:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 800d166:	61a8      	str	r0, [r5, #24]
          if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == 0U)
 800d168:	6968      	ldr	r0, [r5, #20]
 800d16a:	0606      	lsls	r6, r0, #24
 800d16c:	d4e2      	bmi.n	800d134 <HAL_PCD_IRQHandler+0x384>
            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SGONAK;
 800d16e:	9a02      	ldr	r2, [sp, #8]
 800d170:	6853      	ldr	r3, [r2, #4]
 800d172:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800d176:	6053      	str	r3, [r2, #4]
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 800d178:	6820      	ldr	r0, [r4, #0]
 800d17a:	6943      	ldr	r3, [r0, #20]
 800d17c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800d180:	6143      	str	r3, [r0, #20]
 800d182:	e7ac      	b.n	800d0de <HAL_PCD_IRQHandler+0x32e>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 800d184:	9a02      	ldr	r2, [sp, #8]
 800d186:	6853      	ldr	r3, [r2, #4]
 800d188:	f023 0301 	bic.w	r3, r3, #1
 800d18c:	6053      	str	r3, [r2, #4]
      if (hpcd->LPM_State == LPM_L1)
 800d18e:	f894 34f4 	ldrb.w	r3, [r4, #1268]	; 0x4f4
 800d192:	2b01      	cmp	r3, #1
 800d194:	f000 8137 	beq.w	800d406 <HAL_PCD_IRQHandler+0x656>
        HAL_PCD_ResumeCallback(hpcd);
 800d198:	4620      	mov	r0, r4
 800d19a:	f006 fe87 	bl	8013eac <HAL_PCD_ResumeCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 800d19e:	6820      	ldr	r0, [r4, #0]
 800d1a0:	6943      	ldr	r3, [r0, #20]
 800d1a2:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 800d1a6:	6143      	str	r3, [r0, #20]
 800d1a8:	e653      	b.n	800ce52 <HAL_PCD_IRQHandler+0xa2>
      (void)USB_ActivateSetup(hpcd->Instance);
 800d1aa:	f004 fde1 	bl	8011d70 <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 800d1ae:	6820      	ldr	r0, [r4, #0]
 800d1b0:	f004 fa16 	bl	80115e0 <USB_GetDevSpeed>
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 800d1b4:	6826      	ldr	r6, [r4, #0]
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 800d1b6:	60e0      	str	r0, [r4, #12]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 800d1b8:	f001 fab2 	bl	800e720 <HAL_RCC_GetHCLKFreq>
 800d1bc:	7b22      	ldrb	r2, [r4, #12]
 800d1be:	4601      	mov	r1, r0
 800d1c0:	4630      	mov	r0, r6
 800d1c2:	f004 f80f 	bl	80111e4 <USB_SetTurnaroundTime>
      HAL_PCD_ResetCallback(hpcd);
 800d1c6:	4620      	mov	r0, r4
 800d1c8:	f006 fe42 	bl	8013e50 <HAL_PCD_ResetCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 800d1cc:	6820      	ldr	r0, [r4, #0]
 800d1ce:	6943      	ldr	r3, [r0, #20]
 800d1d0:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 800d1d4:	6143      	str	r3, [r0, #20]
 800d1d6:	e669      	b.n	800ceac <HAL_PCD_IRQHandler+0xfc>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 800d1d8:	9a02      	ldr	r2, [sp, #8]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 800d1da:	2110      	movs	r1, #16
 800d1dc:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 800d1de:	6853      	ldr	r3, [r2, #4]
 800d1e0:	f023 0301 	bic.w	r3, r3, #1
 800d1e4:	6053      	str	r3, [r2, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 800d1e6:	f004 f9d1 	bl	801158c <USB_FlushTxFifo>
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800d1ea:	6860      	ldr	r0, [r4, #4]
 800d1ec:	b1e0      	cbz	r0, 800d228 <HAL_PCD_IRQHandler+0x478>
 800d1ee:	f505 6310 	add.w	r3, r5, #2304	; 0x900
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 800d1f2:	f64f 317f 	movw	r1, #64383	; 0xfb7f
 800d1f6:	6099      	str	r1, [r3, #8]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800d1f8:	f10b 0b01 	add.w	fp, fp, #1
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 800d1fc:	681a      	ldr	r2, [r3, #0]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800d1fe:	3320      	adds	r3, #32
 800d200:	4583      	cmp	fp, r0
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 800d202:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 800d206:	f843 2c20 	str.w	r2, [r3, #-32]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 800d20a:	f8c3 11e8 	str.w	r1, [r3, #488]	; 0x1e8
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 800d20e:	f8d3 21e0 	ldr.w	r2, [r3, #480]	; 0x1e0
 800d212:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 800d216:	f8c3 21e0 	str.w	r2, [r3, #480]	; 0x1e0
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 800d21a:	f8d3 21e0 	ldr.w	r2, [r3, #480]	; 0x1e0
 800d21e:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 800d222:	f8c3 21e0 	str.w	r2, [r3, #480]	; 0x1e0
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800d226:	d1e6      	bne.n	800d1f6 <HAL_PCD_IRQHandler+0x446>
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 800d228:	9902      	ldr	r1, [sp, #8]
      if (hpcd->Init.use_dedicated_ep1 != 0U)
 800d22a:	6b22      	ldr	r2, [r4, #48]	; 0x30
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 800d22c:	69cb      	ldr	r3, [r1, #28]
 800d22e:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 800d232:	61cb      	str	r3, [r1, #28]
      if (hpcd->Init.use_dedicated_ep1 != 0U)
 800d234:	2a00      	cmp	r2, #0
 800d236:	f040 80cf 	bne.w	800d3d8 <HAL_PCD_IRQHandler+0x628>
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 800d23a:	694a      	ldr	r2, [r1, #20]
 800d23c:	f242 032b 	movw	r3, #8235	; 0x202b
 800d240:	4313      	orrs	r3, r2
 800d242:	614b      	str	r3, [r1, #20]
        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 800d244:	690b      	ldr	r3, [r1, #16]
 800d246:	f043 030b 	orr.w	r3, r3, #11
 800d24a:	610b      	str	r3, [r1, #16]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 800d24c:	f8d5 3800 	ldr.w	r3, [r5, #2048]	; 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 800d250:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 800d254:	7c21      	ldrb	r1, [r4, #16]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 800d256:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 800d25a:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 800d25c:	f8c5 3800 	str.w	r3, [r5, #2048]	; 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 800d260:	f004 fd9c 	bl	8011d9c <USB_EP0_OutStart>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 800d264:	6820      	ldr	r0, [r4, #0]
 800d266:	6943      	ldr	r3, [r0, #20]
 800d268:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800d26c:	6143      	str	r3, [r0, #20]
 800d26e:	e616      	b.n	800ce9e <HAL_PCD_IRQHandler+0xee>
      HAL_PCD_ConnectCallback(hpcd);
 800d270:	4620      	mov	r0, r4
 800d272:	f006 fe27 	bl	8013ec4 <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 800d276:	6820      	ldr	r0, [r4, #0]
 800d278:	6943      	ldr	r3, [r0, #20]
 800d27a:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 800d27e:	6143      	str	r3, [r0, #20]
 800d280:	e733      	b.n	800d0ea <HAL_PCD_IRQHandler+0x33a>
      HAL_PCD_SOFCallback(hpcd);
 800d282:	4620      	mov	r0, r4
 800d284:	f006 fde0 	bl	8013e48 <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 800d288:	6820      	ldr	r0, [r4, #0]
 800d28a:	6943      	ldr	r3, [r0, #20]
 800d28c:	f003 0308 	and.w	r3, r3, #8
 800d290:	6143      	str	r3, [r0, #20]
 800d292:	e611      	b.n	800ceb8 <HAL_PCD_IRQHandler+0x108>
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 800d294:	6820      	ldr	r0, [r4, #0]
 800d296:	f004 fd45 	bl	8011d24 <USB_ReadDevAllInEpInterrupt>
      while (ep_intr != 0U)
 800d29a:	4680      	mov	r8, r0
 800d29c:	2800      	cmp	r0, #0
 800d29e:	f43f add1 	beq.w	800ce44 <HAL_PCD_IRQHandler+0x94>
      epnum = 0U;
 800d2a2:	f04f 0a00 	mov.w	sl, #0
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 800d2a6:	6820      	ldr	r0, [r4, #0]
 800d2a8:	4627      	mov	r7, r4
 800d2aa:	f505 6910 	add.w	r9, r5, #2304	; 0x900
              ep->is_iso_incomplete = 0U;
 800d2ae:	4656      	mov	r6, sl
 800d2b0:	9503      	str	r5, [sp, #12]
 800d2b2:	f8cd b010 	str.w	fp, [sp, #16]
 800d2b6:	e009      	b.n	800d2cc <HAL_PCD_IRQHandler+0x51c>
      while (ep_intr != 0U)
 800d2b8:	ea5f 0858 	movs.w	r8, r8, lsr #1
        epnum++;
 800d2bc:	f106 0601 	add.w	r6, r6, #1
      while (ep_intr != 0U)
 800d2c0:	f107 0724 	add.w	r7, r7, #36	; 0x24
 800d2c4:	f109 0920 	add.w	r9, r9, #32
 800d2c8:	f000 80ec 	beq.w	800d4a4 <HAL_PCD_IRQHandler+0x6f4>
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 800d2cc:	f018 0f01 	tst.w	r8, #1
 800d2d0:	d0f2      	beq.n	800d2b8 <HAL_PCD_IRQHandler+0x508>
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 800d2d2:	fa5f fa86 	uxtb.w	sl, r6
 800d2d6:	4651      	mov	r1, sl
 800d2d8:	f004 fd36 	bl	8011d48 <USB_ReadDevInEPInterrupt>
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 800d2dc:	07c1      	lsls	r1, r0, #31
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 800d2de:	4605      	mov	r5, r0
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 800d2e0:	d513      	bpl.n	800d30a <HAL_PCD_IRQHandler+0x55a>
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 800d2e2:	9902      	ldr	r1, [sp, #8]
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 800d2e4:	f006 030f 	and.w	r3, r6, #15
 800d2e8:	2201      	movs	r2, #1
 800d2ea:	409a      	lsls	r2, r3
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 800d2ec:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800d2ee:	ea23 0302 	bic.w	r3, r3, r2
 800d2f2:	634b      	str	r3, [r1, #52]	; 0x34
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 800d2f4:	2301      	movs	r3, #1
            if (hpcd->Init.dma_enable == 1U)
 800d2f6:	6921      	ldr	r1, [r4, #16]
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 800d2f8:	f8c9 3008 	str.w	r3, [r9, #8]
            if (hpcd->Init.dma_enable == 1U)
 800d2fc:	4299      	cmp	r1, r3
 800d2fe:	f000 8198 	beq.w	800d632 <HAL_PCD_IRQHandler+0x882>
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 800d302:	4651      	mov	r1, sl
 800d304:	4620      	mov	r0, r4
 800d306:	f006 fd95 	bl	8013e34 <HAL_PCD_DataInStageCallback>
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 800d30a:	072a      	lsls	r2, r5, #28
 800d30c:	d502      	bpl.n	800d314 <HAL_PCD_IRQHandler+0x564>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 800d30e:	2308      	movs	r3, #8
 800d310:	f8c9 3008 	str.w	r3, [r9, #8]
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 800d314:	06eb      	lsls	r3, r5, #27
 800d316:	d502      	bpl.n	800d31e <HAL_PCD_IRQHandler+0x56e>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 800d318:	2310      	movs	r3, #16
 800d31a:	f8c9 3008 	str.w	r3, [r9, #8]
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 800d31e:	0668      	lsls	r0, r5, #25
 800d320:	d502      	bpl.n	800d328 <HAL_PCD_IRQHandler+0x578>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 800d322:	2340      	movs	r3, #64	; 0x40
 800d324:	f8c9 3008 	str.w	r3, [r9, #8]
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 800d328:	07a9      	lsls	r1, r5, #30
 800d32a:	f100 814f 	bmi.w	800d5cc <HAL_PCD_IRQHandler+0x81c>
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 800d32e:	062a      	lsls	r2, r5, #24
 800d330:	f100 80f9 	bmi.w	800d526 <HAL_PCD_IRQHandler+0x776>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 800d334:	6820      	ldr	r0, [r4, #0]
 800d336:	e7bf      	b.n	800d2b8 <HAL_PCD_IRQHandler+0x508>
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 800d338:	6820      	ldr	r0, [r4, #0]
 800d33a:	f004 fceb 	bl	8011d14 <USB_ReadDevAllOutEpInterrupt>
      while (ep_intr != 0U)
 800d33e:	4606      	mov	r6, r0
 800d340:	2800      	cmp	r0, #0
 800d342:	f43f ad79 	beq.w	800ce38 <HAL_PCD_IRQHandler+0x88>
 800d346:	f505 6730 	add.w	r7, r5, #2816	; 0xb00
 800d34a:	46a2      	mov	sl, r4
      epnum = 0U;
 800d34c:	f04f 0900 	mov.w	r9, #0
      /* ... */
    }
  }
  else
  {
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
 800d350:	f8cd b00c 	str.w	fp, [sp, #12]
 800d354:	e008      	b.n	800d368 <HAL_PCD_IRQHandler+0x5b8>
      while (ep_intr != 0U)
 800d356:	0876      	lsrs	r6, r6, #1
        epnum++;
 800d358:	f109 0901 	add.w	r9, r9, #1
      while (ep_intr != 0U)
 800d35c:	f107 0720 	add.w	r7, r7, #32
 800d360:	f10a 0a24 	add.w	sl, sl, #36	; 0x24
 800d364:	f000 809b 	beq.w	800d49e <HAL_PCD_IRQHandler+0x6ee>
        if ((ep_intr & 0x1U) != 0U)
 800d368:	07f0      	lsls	r0, r6, #31
 800d36a:	d5f4      	bpl.n	800d356 <HAL_PCD_IRQHandler+0x5a6>
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 800d36c:	fa5f fb89 	uxtb.w	fp, r9
 800d370:	6820      	ldr	r0, [r4, #0]
 800d372:	4659      	mov	r1, fp
 800d374:	f004 fcde 	bl	8011d34 <USB_ReadDevOutEPInterrupt>
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 800d378:	f010 0f01 	tst.w	r0, #1
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 800d37c:	4680      	mov	r8, r0
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 800d37e:	f040 80b3 	bne.w	800d4e8 <HAL_PCD_IRQHandler+0x738>
          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 800d382:	f018 0f08 	tst.w	r8, #8
 800d386:	f040 8090 	bne.w	800d4aa <HAL_PCD_IRQHandler+0x6fa>
          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 800d38a:	f018 0f10 	tst.w	r8, #16
 800d38e:	d001      	beq.n	800d394 <HAL_PCD_IRQHandler+0x5e4>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 800d390:	2210      	movs	r2, #16
 800d392:	60ba      	str	r2, [r7, #8]
          if ((epint & USB_OTG_DOEPINT_EPDISD) == USB_OTG_DOEPINT_EPDISD)
 800d394:	f018 0f02 	tst.w	r8, #2
 800d398:	d00e      	beq.n	800d3b8 <HAL_PCD_IRQHandler+0x608>
            if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == USB_OTG_GINTSTS_BOUTNAKEFF)
 800d39a:	696a      	ldr	r2, [r5, #20]
 800d39c:	0610      	lsls	r0, r2, #24
 800d39e:	d504      	bpl.n	800d3aa <HAL_PCD_IRQHandler+0x5fa>
              USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
 800d3a0:	9b02      	ldr	r3, [sp, #8]
 800d3a2:	685a      	ldr	r2, [r3, #4]
 800d3a4:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800d3a8:	605a      	str	r2, [r3, #4]
            if (ep->is_iso_incomplete == 1U)
 800d3aa:	f89a 227f 	ldrb.w	r2, [sl, #639]	; 0x27f
 800d3ae:	2a01      	cmp	r2, #1
 800d3b0:	f000 8181 	beq.w	800d6b6 <HAL_PCD_IRQHandler+0x906>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
 800d3b4:	2302      	movs	r3, #2
 800d3b6:	60bb      	str	r3, [r7, #8]
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 800d3b8:	f018 0f20 	tst.w	r8, #32
 800d3bc:	d001      	beq.n	800d3c2 <HAL_PCD_IRQHandler+0x612>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 800d3be:	2320      	movs	r3, #32
 800d3c0:	60bb      	str	r3, [r7, #8]
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 800d3c2:	f418 5f00 	tst.w	r8, #8192	; 0x2000
 800d3c6:	d0c6      	beq.n	800d356 <HAL_PCD_IRQHandler+0x5a6>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 800d3c8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800d3cc:	60bb      	str	r3, [r7, #8]
 800d3ce:	e7c2      	b.n	800d356 <HAL_PCD_IRQHandler+0x5a6>
        HAL_PCD_SuspendCallback(hpcd);
 800d3d0:	4620      	mov	r0, r4
 800d3d2:	f006 fd53 	bl	8013e7c <HAL_PCD_SuspendCallback>
 800d3d6:	e55b      	b.n	800ce90 <HAL_PCD_IRQHandler+0xe0>
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 800d3d8:	f8d1 3084 	ldr.w	r3, [r1, #132]	; 0x84
 800d3dc:	f043 030b 	orr.w	r3, r3, #11
 800d3e0:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 800d3e4:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 800d3e6:	f043 030b 	orr.w	r3, r3, #11
 800d3ea:	644b      	str	r3, [r1, #68]	; 0x44
 800d3ec:	e72e      	b.n	800d24c <HAL_PCD_IRQHandler+0x49c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d3ee:	2900      	cmp	r1, #0
 800d3f0:	f6bf ade9 	bge.w	800cfc6 <HAL_PCD_IRQHandler+0x216>
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800d3f4:	4621      	mov	r1, r4
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800d3f6:	f884 2063 	strb.w	r2, [r4, #99]	; 0x63
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d3fa:	f851 0b60 	ldr.w	r0, [r1], #96
 800d3fe:	f004 fb73 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d402:	6863      	ldr	r3, [r4, #4]
 800d404:	e5df      	b.n	800cfc6 <HAL_PCD_IRQHandler+0x216>
        hpcd->LPM_State = LPM_L0;
 800d406:	2100      	movs	r1, #0
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 800d408:	4620      	mov	r0, r4
        hpcd->LPM_State = LPM_L0;
 800d40a:	f884 14f4 	strb.w	r1, [r4, #1268]	; 0x4f4
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 800d40e:	f000 fc1f 	bl	800dc50 <HAL_PCDEx_LPM_Callback>
 800d412:	e6c4      	b.n	800d19e <HAL_PCD_IRQHandler+0x3ee>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d414:	2900      	cmp	r1, #0
 800d416:	f6bf addf 	bge.w	800cfd8 <HAL_PCD_IRQHandler+0x228>
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800d41a:	4621      	mov	r1, r4
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800d41c:	f884 2087 	strb.w	r2, [r4, #135]	; 0x87
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d420:	f851 0b84 	ldr.w	r0, [r1], #132
 800d424:	f004 fb60 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d428:	6863      	ldr	r3, [r4, #4]
 800d42a:	e5d5      	b.n	800cfd8 <HAL_PCD_IRQHandler+0x228>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d42c:	2900      	cmp	r1, #0
 800d42e:	f6bf addc 	bge.w	800cfea <HAL_PCD_IRQHandler+0x23a>
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800d432:	4621      	mov	r1, r4
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800d434:	f884 20ab 	strb.w	r2, [r4, #171]	; 0xab
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d438:	f851 0ba8 	ldr.w	r0, [r1], #168
 800d43c:	f004 fb54 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d440:	6863      	ldr	r3, [r4, #4]
 800d442:	e5d2      	b.n	800cfea <HAL_PCD_IRQHandler+0x23a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d444:	2900      	cmp	r1, #0
 800d446:	f6bf add9 	bge.w	800cffc <HAL_PCD_IRQHandler+0x24c>
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800d44a:	4621      	mov	r1, r4
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800d44c:	f884 20cf 	strb.w	r2, [r4, #207]	; 0xcf
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d450:	f851 0bcc 	ldr.w	r0, [r1], #204
 800d454:	f004 fb48 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d458:	6863      	ldr	r3, [r4, #4]
 800d45a:	e5cf      	b.n	800cffc <HAL_PCD_IRQHandler+0x24c>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d45c:	f504 713a 	add.w	r1, r4, #744	; 0x2e8
 800d460:	6820      	ldr	r0, [r4, #0]
 800d462:	f004 fb41 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d466:	6863      	ldr	r3, [r4, #4]
 800d468:	e544      	b.n	800cef4 <HAL_PCD_IRQHandler+0x144>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 800d46a:	eb07 07c7 	add.w	r7, r7, r7, lsl #3
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 800d46e:	2208      	movs	r2, #8
 800d470:	f204 41c4 	addw	r1, r4, #1220	; 0x4c4
 800d474:	4628      	mov	r0, r5
 800d476:	f004 fb91 	bl	8011b9c <USB_ReadPacket>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 800d47a:	f3c6 130a 	ubfx	r3, r6, #4, #11
 800d47e:	eb04 0287 	add.w	r2, r4, r7, lsl #2
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800d482:	6820      	ldr	r0, [r4, #0]
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 800d484:	f8d2 129c 	ldr.w	r1, [r2, #668]	; 0x29c
 800d488:	440b      	add	r3, r1
 800d48a:	f8c2 329c 	str.w	r3, [r2, #668]	; 0x29c
 800d48e:	e4ca      	b.n	800ce26 <HAL_PCD_IRQHandler+0x76>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d490:	f504 7143 	add.w	r1, r4, #780	; 0x30c
 800d494:	6820      	ldr	r0, [r4, #0]
 800d496:	f004 fb27 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d49a:	6863      	ldr	r3, [r4, #4]
 800d49c:	e531      	b.n	800cf02 <HAL_PCD_IRQHandler+0x152>
 800d49e:	f8dd b00c 	ldr.w	fp, [sp, #12]
 800d4a2:	e4c9      	b.n	800ce38 <HAL_PCD_IRQHandler+0x88>
 800d4a4:	e9dd 5b03 	ldrd	r5, fp, [sp, #12]
 800d4a8:	e4cd      	b.n	800ce46 <HAL_PCD_IRQHandler+0x96>
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800d4aa:	6821      	ldr	r1, [r4, #0]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 800d4ac:	2208      	movs	r2, #8
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800d4ae:	4bbb      	ldr	r3, [pc, #748]	; (800d79c <HAL_PCD_IRQHandler+0x9ec>)
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 800d4b0:	60ba      	str	r2, [r7, #8]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 800d4b2:	f501 6230 	add.w	r2, r1, #2816	; 0xb00
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 800d4b6:	6c09      	ldr	r1, [r1, #64]	; 0x40
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 800d4b8:	eb02 1249 	add.w	r2, r2, r9, lsl #5
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800d4bc:	4299      	cmp	r1, r3
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 800d4be:	6890      	ldr	r0, [r2, #8]
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800d4c0:	f240 80c8 	bls.w	800d654 <HAL_PCD_IRQHandler+0x8a4>
 800d4c4:	0403      	lsls	r3, r0, #16
 800d4c6:	d502      	bpl.n	800d4ce <HAL_PCD_IRQHandler+0x71e>
      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
  {
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 800d4c8:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800d4cc:	6091      	str	r1, [r2, #8]

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
 800d4ce:	4620      	mov	r0, r4
 800d4d0:	f006 fca0 	bl	8013e14 <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 800d4d4:	6921      	ldr	r1, [r4, #16]
 800d4d6:	2901      	cmp	r1, #1
 800d4d8:	f47f af57 	bne.w	800d38a <HAL_PCD_IRQHandler+0x5da>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800d4dc:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 800d4e0:	6820      	ldr	r0, [r4, #0]
 800d4e2:	f004 fc5b 	bl	8011d9c <USB_EP0_OutStart>
 800d4e6:	e750      	b.n	800d38a <HAL_PCD_IRQHandler+0x5da>
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800d4e8:	6820      	ldr	r0, [r4, #0]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 800d4ea:	2201      	movs	r2, #1
  if (hpcd->Init.dma_enable == 1U)
 800d4ec:	6921      	ldr	r1, [r4, #16]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 800d4ee:	60ba      	str	r2, [r7, #8]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 800d4f0:	f500 6230 	add.w	r2, r0, #2816	; 0xb00
  if (hpcd->Init.dma_enable == 1U)
 800d4f4:	2901      	cmp	r1, #1
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 800d4f6:	f8d0 c040 	ldr.w	ip, [r0, #64]	; 0x40
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 800d4fa:	eb02 1249 	add.w	r2, r2, r9, lsl #5
 800d4fe:	6893      	ldr	r3, [r2, #8]
  if (hpcd->Init.dma_enable == 1U)
 800d500:	f000 80ac 	beq.w	800d65c <HAL_PCD_IRQHandler+0x8ac>
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
 800d504:	49a6      	ldr	r1, [pc, #664]	; (800d7a0 <HAL_PCD_IRQHandler+0x9f0>)
 800d506:	458c      	cmp	ip, r1
 800d508:	f000 8109 	beq.w	800d71e <HAL_PCD_IRQHandler+0x96e>
      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 800d50c:	f1b9 0f00 	cmp.w	r9, #0
 800d510:	d104      	bne.n	800d51c <HAL_PCD_IRQHandler+0x76c>
 800d512:	f8d4 2294 	ldr.w	r2, [r4, #660]	; 0x294
 800d516:	2a00      	cmp	r2, #0
 800d518:	f000 81d7 	beq.w	800d8ca <HAL_PCD_IRQHandler+0xb1a>
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 800d51c:	4659      	mov	r1, fp
 800d51e:	4620      	mov	r0, r4
 800d520:	f006 fc7e 	bl	8013e20 <HAL_PCD_DataOutStageCallback>
 800d524:	e72d      	b.n	800d382 <HAL_PCD_IRQHandler+0x5d2>
  if (ep->xfer_count > ep->xfer_len)
 800d526:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d528:	6d7d      	ldr	r5, [r7, #84]	; 0x54
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800d52a:	f8d4 b000 	ldr.w	fp, [r4]
  if (ep->xfer_count > ep->xfer_len)
 800d52e:	42ab      	cmp	r3, r5
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800d530:	4658      	mov	r0, fp
  if (ep->xfer_count > ep->xfer_len)
 800d532:	f63f aec1 	bhi.w	800d2b8 <HAL_PCD_IRQHandler+0x508>
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800d536:	f50b 6210 	add.w	r2, fp, #2304	; 0x900
  len32b = (len + 3U) / 4U;
 800d53a:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  uint32_t USBx_BASE = (uint32_t)USBx;
 800d53c:	f8cd b01c 	str.w	fp, [sp, #28]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800d540:	eb02 1246 	add.w	r2, r2, r6, lsl #5
 800d544:	9205      	str	r2, [sp, #20]
  len = ep->xfer_len - ep->xfer_count;
 800d546:	1aea      	subs	r2, r5, r3
  len32b = (len + 3U) / 4U;
 800d548:	428a      	cmp	r2, r1
 800d54a:	bf28      	it	cs
 800d54c:	460a      	movcs	r2, r1
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800d54e:	9905      	ldr	r1, [sp, #20]
 800d550:	6989      	ldr	r1, [r1, #24]
  len32b = (len + 3U) / 4U;
 800d552:	3203      	adds	r2, #3
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800d554:	b289      	uxth	r1, r1
 800d556:	ebb1 0f92 	cmp.w	r1, r2, lsr #2
 800d55a:	f0c0 8095 	bcc.w	800d688 <HAL_PCD_IRQHandler+0x8d8>
 800d55e:	4652      	mov	r2, sl
 800d560:	9606      	str	r6, [sp, #24]
 800d562:	46ca      	mov	sl, r9
 800d564:	4626      	mov	r6, r4
 800d566:	46c1      	mov	r9, r8
 800d568:	9c05      	ldr	r4, [sp, #20]
 800d56a:	4690      	mov	r8, r2
 800d56c:	e019      	b.n	800d5a2 <HAL_PCD_IRQHandler+0x7f2>
    len = ep->xfer_len - ep->xfer_count;
 800d56e:	1aed      	subs	r5, r5, r3
    if (len > ep->maxpacket)
 800d570:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 800d572:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 800d574:	4642      	mov	r2, r8
 800d576:	429d      	cmp	r5, r3
 800d578:	4658      	mov	r0, fp
 800d57a:	bf28      	it	cs
 800d57c:	461d      	movcs	r5, r3
 800d57e:	7c33      	ldrb	r3, [r6, #16]
 800d580:	9300      	str	r3, [sp, #0]
 800d582:	b2ab      	uxth	r3, r5
 800d584:	f004 faf4 	bl	8011b70 <USB_WritePacket>
    ep->xfer_buff  += len;
 800d588:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800d58a:	69a1      	ldr	r1, [r4, #24]
    ep->xfer_buff  += len;
 800d58c:	442b      	add	r3, r5
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800d58e:	b289      	uxth	r1, r1
    ep->xfer_buff  += len;
 800d590:	64fb      	str	r3, [r7, #76]	; 0x4c
    ep->xfer_count += len;
 800d592:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d594:	442b      	add	r3, r5
    len32b = (len + 3U) / 4U;
 800d596:	3503      	adds	r5, #3
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800d598:	ebb1 0f95 	cmp.w	r1, r5, lsr #2
    ep->xfer_count += len;
 800d59c:	65fb      	str	r3, [r7, #92]	; 0x5c
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800d59e:	d36b      	bcc.n	800d678 <HAL_PCD_IRQHandler+0x8c8>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 800d5a0:	6d7d      	ldr	r5, [r7, #84]	; 0x54
 800d5a2:	429d      	cmp	r5, r3
 800d5a4:	d8e3      	bhi.n	800d56e <HAL_PCD_IRQHandler+0x7be>
 800d5a6:	4634      	mov	r4, r6
 800d5a8:	46c8      	mov	r8, r9
 800d5aa:	9e06      	ldr	r6, [sp, #24]
 800d5ac:	46d1      	mov	r9, sl
 800d5ae:	f8d4 b000 	ldr.w	fp, [r4]
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 800d5b2:	9b07      	ldr	r3, [sp, #28]
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 800d5b4:	2201      	movs	r2, #1
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 800d5b6:	4658      	mov	r0, fp
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 800d5b8:	f503 6100 	add.w	r1, r3, #2048	; 0x800
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 800d5bc:	f006 030f 	and.w	r3, r6, #15
 800d5c0:	409a      	lsls	r2, r3
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 800d5c2:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800d5c4:	ea23 0302 	bic.w	r3, r3, r2
 800d5c8:	634b      	str	r3, [r1, #52]	; 0x34
 800d5ca:	e675      	b.n	800d2b8 <HAL_PCD_IRQHandler+0x508>
            (void)USB_FlushTxFifo(USBx, epnum);
 800d5cc:	4631      	mov	r1, r6
 800d5ce:	9803      	ldr	r0, [sp, #12]
 800d5d0:	f003 ffdc 	bl	801158c <USB_FlushTxFifo>
            if (ep->is_iso_incomplete == 1U)
 800d5d4:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 800d5d8:	2b01      	cmp	r3, #1
 800d5da:	f000 80b4 	beq.w	800d746 <HAL_PCD_IRQHandler+0x996>
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 800d5de:	2302      	movs	r3, #2
 800d5e0:	f8c9 3008 	str.w	r3, [r9, #8]
 800d5e4:	e6a3      	b.n	800d32e <HAL_PCD_IRQHandler+0x57e>
        if ((RegVal & USB_OTG_GRXSTSP_BCNT) != 0U)
 800d5e6:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 800d5ea:	421e      	tst	r6, r3
 800d5ec:	f43f ac1b 	beq.w	800ce26 <HAL_PCD_IRQHandler+0x76>
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 800d5f0:	eb07 07c7 	add.w	r7, r7, r7, lsl #3
 800d5f4:	f3c6 120a 	ubfx	r2, r6, #4, #11
 800d5f8:	4628      	mov	r0, r5
 800d5fa:	eb04 0787 	add.w	r7, r4, r7, lsl #2
 800d5fe:	4616      	mov	r6, r2
 800d600:	f8d7 128c 	ldr.w	r1, [r7, #652]	; 0x28c
 800d604:	f004 faca 	bl	8011b9c <USB_ReadPacket>
          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 800d608:	f8d7 328c 	ldr.w	r3, [r7, #652]	; 0x28c
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800d60c:	6820      	ldr	r0, [r4, #0]
          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 800d60e:	4433      	add	r3, r6
 800d610:	f8c7 328c 	str.w	r3, [r7, #652]	; 0x28c
          ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 800d614:	f8d7 329c 	ldr.w	r3, [r7, #668]	; 0x29c
 800d618:	4433      	add	r3, r6
 800d61a:	f8c7 329c 	str.w	r3, [r7, #668]	; 0x29c
 800d61e:	e402      	b.n	800ce26 <HAL_PCD_IRQHandler+0x76>
        HAL_PCD_SuspendCallback(hpcd);
 800d620:	4620      	mov	r0, r4
 800d622:	f006 fc2b 	bl	8013e7c <HAL_PCD_SuspendCallback>
 800d626:	e575      	b.n	800d114 <HAL_PCD_IRQHandler+0x364>
        HAL_PCD_DisconnectCallback(hpcd);
 800d628:	4620      	mov	r0, r4
 800d62a:	f006 fc4f 	bl	8013ecc <HAL_PCD_DisconnectCallback>
      hpcd->Instance->GOTGINT |= RegVal;
 800d62e:	6823      	ldr	r3, [r4, #0]
 800d630:	e565      	b.n	800d0fe <HAL_PCD_IRQHandler+0x34e>
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
 800d632:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
 800d636:	4413      	add	r3, r2
 800d638:	64fb      	str	r3, [r7, #76]	; 0x4c
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 800d63a:	2e00      	cmp	r6, #0
 800d63c:	f47f ae61 	bne.w	800d302 <HAL_PCD_IRQHandler+0x552>
 800d640:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800d642:	2b00      	cmp	r3, #0
 800d644:	f47f ae5d 	bne.w	800d302 <HAL_PCD_IRQHandler+0x552>
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800d648:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 800d64c:	6820      	ldr	r0, [r4, #0]
 800d64e:	f004 fba5 	bl	8011d9c <USB_EP0_OutStart>
 800d652:	e656      	b.n	800d302 <HAL_PCD_IRQHandler+0x552>
  HAL_PCD_SetupStageCallback(hpcd);
 800d654:	4620      	mov	r0, r4
 800d656:	f006 fbdd 	bl	8013e14 <HAL_PCD_SetupStageCallback>
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 800d65a:	e696      	b.n	800d38a <HAL_PCD_IRQHandler+0x5da>
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
 800d65c:	0719      	lsls	r1, r3, #28
 800d65e:	f140 8097 	bpl.w	800d790 <HAL_PCD_IRQHandler+0x9e0>
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800d662:	494e      	ldr	r1, [pc, #312]	; (800d79c <HAL_PCD_IRQHandler+0x9ec>)
 800d664:	458c      	cmp	ip, r1
 800d666:	f67f ae8c 	bls.w	800d382 <HAL_PCD_IRQHandler+0x5d2>
 800d66a:	0418      	lsls	r0, r3, #16
 800d66c:	f57f ae89 	bpl.w	800d382 <HAL_PCD_IRQHandler+0x5d2>
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 800d670:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800d674:	6091      	str	r1, [r2, #8]
 800d676:	e684      	b.n	800d382 <HAL_PCD_IRQHandler+0x5d2>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 800d678:	4634      	mov	r4, r6
 800d67a:	46c8      	mov	r8, r9
 800d67c:	9e06      	ldr	r6, [sp, #24]
 800d67e:	46d1      	mov	r9, sl
 800d680:	f8d4 b000 	ldr.w	fp, [r4]
  if (ep->xfer_len <= ep->xfer_count)
 800d684:	6d7d      	ldr	r5, [r7, #84]	; 0x54
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 800d686:	4658      	mov	r0, fp
  if (ep->xfer_len <= ep->xfer_count)
 800d688:	429d      	cmp	r5, r3
 800d68a:	f63f ae15 	bhi.w	800d2b8 <HAL_PCD_IRQHandler+0x508>
 800d68e:	e790      	b.n	800d5b2 <HAL_PCD_IRQHandler+0x802>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d690:	2900      	cmp	r1, #0
 800d692:	f6bf acbc 	bge.w	800d00e <HAL_PCD_IRQHandler+0x25e>
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800d696:	4621      	mov	r1, r4
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800d698:	f884 20f3 	strb.w	r2, [r4, #243]	; 0xf3
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d69c:	f851 0bf0 	ldr.w	r0, [r1], #240
 800d6a0:	f004 fa22 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d6a4:	6863      	ldr	r3, [r4, #4]
 800d6a6:	e4b2      	b.n	800d00e <HAL_PCD_IRQHandler+0x25e>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d6a8:	f504 7128 	add.w	r1, r4, #672	; 0x2a0
 800d6ac:	6820      	ldr	r0, [r4, #0]
 800d6ae:	f004 fa1b 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d6b2:	6863      	ldr	r3, [r4, #4]
 800d6b4:	e410      	b.n	800ced8 <HAL_PCD_IRQHandler+0x128>
              ep->is_iso_incomplete = 0U;
 800d6b6:	2300      	movs	r3, #0
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 800d6b8:	4659      	mov	r1, fp
 800d6ba:	4620      	mov	r0, r4
              ep->is_iso_incomplete = 0U;
 800d6bc:	f88a 327f 	strb.w	r3, [sl, #639]	; 0x27f
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 800d6c0:	f006 fbf8 	bl	8013eb4 <HAL_PCD_ISOOUTIncompleteCallback>
 800d6c4:	e676      	b.n	800d3b4 <HAL_PCD_IRQHandler+0x604>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d6c6:	2900      	cmp	r1, #0
 800d6c8:	f6bf acaa 	bge.w	800d020 <HAL_PCD_IRQHandler+0x270>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d6cc:	f504 718a 	add.w	r1, r4, #276	; 0x114
 800d6d0:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800d6d2:	f884 2117 	strb.w	r2, [r4, #279]	; 0x117
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d6d6:	f004 fa07 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d6da:	6863      	ldr	r3, [r4, #4]
 800d6dc:	e4a0      	b.n	800d020 <HAL_PCD_IRQHandler+0x270>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d6de:	f504 7131 	add.w	r1, r4, #708	; 0x2c4
 800d6e2:	6820      	ldr	r0, [r4, #0]
 800d6e4:	f004 fa00 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d6e8:	6863      	ldr	r3, [r4, #4]
 800d6ea:	f7ff bbfc 	b.w	800cee6 <HAL_PCD_IRQHandler+0x136>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d6ee:	2900      	cmp	r1, #0
 800d6f0:	f6bf ac9f 	bge.w	800d032 <HAL_PCD_IRQHandler+0x282>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d6f4:	f504 719c 	add.w	r1, r4, #312	; 0x138
 800d6f8:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800d6fa:	f884 213b 	strb.w	r2, [r4, #315]	; 0x13b
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d6fe:	f004 f9f3 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d702:	6863      	ldr	r3, [r4, #4]
 800d704:	e495      	b.n	800d032 <HAL_PCD_IRQHandler+0x282>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d706:	2900      	cmp	r1, #0
 800d708:	f6bf ac9c 	bge.w	800d044 <HAL_PCD_IRQHandler+0x294>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d70c:	f504 71ae 	add.w	r1, r4, #348	; 0x15c
 800d710:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800d712:	f884 215f 	strb.w	r2, [r4, #351]	; 0x15f
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d716:	f004 f9e7 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d71a:	6863      	ldr	r3, [r4, #4]
 800d71c:	e492      	b.n	800d044 <HAL_PCD_IRQHandler+0x294>
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 800d71e:	0418      	lsls	r0, r3, #16
 800d720:	d4a6      	bmi.n	800d670 <HAL_PCD_IRQHandler+0x8c0>
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 800d722:	0699      	lsls	r1, r3, #26
 800d724:	f57f aefa 	bpl.w	800d51c <HAL_PCD_IRQHandler+0x76c>
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 800d728:	2120      	movs	r1, #32
 800d72a:	6091      	str	r1, [r2, #8]
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 800d72c:	e6f6      	b.n	800d51c <HAL_PCD_IRQHandler+0x76c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d72e:	2900      	cmp	r1, #0
 800d730:	f6bf ac91 	bge.w	800d056 <HAL_PCD_IRQHandler+0x2a6>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d734:	f504 71c0 	add.w	r1, r4, #384	; 0x180
 800d738:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800d73a:	f884 2183 	strb.w	r2, [r4, #387]	; 0x183
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d73e:	f004 f9d3 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d742:	6863      	ldr	r3, [r4, #4]
 800d744:	e487      	b.n	800d056 <HAL_PCD_IRQHandler+0x2a6>
              ep->is_iso_incomplete = 0U;
 800d746:	f04f 0300 	mov.w	r3, #0
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 800d74a:	4651      	mov	r1, sl
 800d74c:	4620      	mov	r0, r4
              ep->is_iso_incomplete = 0U;
 800d74e:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 800d752:	f006 fbb3 	bl	8013ebc <HAL_PCD_ISOINIncompleteCallback>
 800d756:	e742      	b.n	800d5de <HAL_PCD_IRQHandler+0x82e>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d758:	f504 714c 	add.w	r1, r4, #816	; 0x330
 800d75c:	6820      	ldr	r0, [r4, #0]
 800d75e:	f004 f9c3 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d762:	6863      	ldr	r3, [r4, #4]
 800d764:	f7ff bbd4 	b.w	800cf10 <HAL_PCD_IRQHandler+0x160>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d768:	2900      	cmp	r1, #0
 800d76a:	f6bf ac7d 	bge.w	800d068 <HAL_PCD_IRQHandler+0x2b8>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d76e:	f504 71d2 	add.w	r1, r4, #420	; 0x1a4
 800d772:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800d774:	f884 21a7 	strb.w	r2, [r4, #423]	; 0x1a7
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d778:	f004 f9b6 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d77c:	6863      	ldr	r3, [r4, #4]
 800d77e:	e473      	b.n	800d068 <HAL_PCD_IRQHandler+0x2b8>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d780:	f504 7155 	add.w	r1, r4, #852	; 0x354
 800d784:	6820      	ldr	r0, [r4, #0]
 800d786:	f004 f9af 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d78a:	6863      	ldr	r3, [r4, #4]
 800d78c:	f7ff bbc7 	b.w	800cf1e <HAL_PCD_IRQHandler+0x16e>
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
 800d790:	0699      	lsls	r1, r3, #26
 800d792:	d573      	bpl.n	800d87c <HAL_PCD_IRQHandler+0xacc>
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 800d794:	2120      	movs	r1, #32
 800d796:	6091      	str	r1, [r2, #8]
 800d798:	e5f3      	b.n	800d382 <HAL_PCD_IRQHandler+0x5d2>
 800d79a:	bf00      	nop
 800d79c:	4f54300a 	.word	0x4f54300a
 800d7a0:	4f54310a 	.word	0x4f54310a
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d7a4:	2900      	cmp	r1, #0
 800d7a6:	f6bf ac68 	bge.w	800d07a <HAL_PCD_IRQHandler+0x2ca>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d7aa:	f504 71e4 	add.w	r1, r4, #456	; 0x1c8
 800d7ae:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800d7b0:	f884 21cb 	strb.w	r2, [r4, #459]	; 0x1cb
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d7b4:	f004 f998 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d7b8:	6863      	ldr	r3, [r4, #4]
 800d7ba:	e45e      	b.n	800d07a <HAL_PCD_IRQHandler+0x2ca>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d7bc:	f504 715e 	add.w	r1, r4, #888	; 0x378
 800d7c0:	6820      	ldr	r0, [r4, #0]
 800d7c2:	f004 f991 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d7c6:	6863      	ldr	r3, [r4, #4]
 800d7c8:	f7ff bbb0 	b.w	800cf2c <HAL_PCD_IRQHandler+0x17c>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d7cc:	2900      	cmp	r1, #0
 800d7ce:	f6bf ac5d 	bge.w	800d08c <HAL_PCD_IRQHandler+0x2dc>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d7d2:	f504 71f6 	add.w	r1, r4, #492	; 0x1ec
 800d7d6:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800d7d8:	f884 21ef 	strb.w	r2, [r4, #495]	; 0x1ef
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d7dc:	f004 f984 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d7e0:	6863      	ldr	r3, [r4, #4]
 800d7e2:	e453      	b.n	800d08c <HAL_PCD_IRQHandler+0x2dc>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d7e4:	f504 7167 	add.w	r1, r4, #924	; 0x39c
 800d7e8:	6820      	ldr	r0, [r4, #0]
 800d7ea:	f004 f97d 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d7ee:	6863      	ldr	r3, [r4, #4]
 800d7f0:	f7ff bba3 	b.w	800cf3a <HAL_PCD_IRQHandler+0x18a>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d7f4:	2900      	cmp	r1, #0
 800d7f6:	f6bf ac52 	bge.w	800d09e <HAL_PCD_IRQHandler+0x2ee>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d7fa:	f504 7104 	add.w	r1, r4, #528	; 0x210
 800d7fe:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800d800:	f884 2213 	strb.w	r2, [r4, #531]	; 0x213
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d804:	f004 f970 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d808:	6863      	ldr	r3, [r4, #4]
 800d80a:	e448      	b.n	800d09e <HAL_PCD_IRQHandler+0x2ee>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d80c:	f504 7170 	add.w	r1, r4, #960	; 0x3c0
 800d810:	6820      	ldr	r0, [r4, #0]
 800d812:	f004 f969 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d816:	6863      	ldr	r3, [r4, #4]
 800d818:	f7ff bb96 	b.w	800cf48 <HAL_PCD_IRQHandler+0x198>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d81c:	2900      	cmp	r1, #0
 800d81e:	f6bf ac47 	bge.w	800d0b0 <HAL_PCD_IRQHandler+0x300>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d822:	f504 710d 	add.w	r1, r4, #564	; 0x234
 800d826:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800d828:	f884 2237 	strb.w	r2, [r4, #567]	; 0x237
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d82c:	f004 f95c 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d830:	6863      	ldr	r3, [r4, #4]
 800d832:	e43d      	b.n	800d0b0 <HAL_PCD_IRQHandler+0x300>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d834:	f504 7179 	add.w	r1, r4, #996	; 0x3e4
 800d838:	6820      	ldr	r0, [r4, #0]
 800d83a:	f004 f955 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d83e:	6863      	ldr	r3, [r4, #4]
 800d840:	f7ff bb89 	b.w	800cf56 <HAL_PCD_IRQHandler+0x1a6>
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800d844:	2900      	cmp	r1, #0
 800d846:	f6bf ac3c 	bge.w	800d0c2 <HAL_PCD_IRQHandler+0x312>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d84a:	f504 7116 	add.w	r1, r4, #600	; 0x258
 800d84e:	6820      	ldr	r0, [r4, #0]
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800d850:	f884 225b 	strb.w	r2, [r4, #603]	; 0x25b
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d854:	f004 f948 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d858:	6863      	ldr	r3, [r4, #4]
 800d85a:	e432      	b.n	800d0c2 <HAL_PCD_IRQHandler+0x312>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d85c:	f504 6181 	add.w	r1, r4, #1032	; 0x408
 800d860:	6820      	ldr	r0, [r4, #0]
 800d862:	f004 f941 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d866:	6863      	ldr	r3, [r4, #4]
 800d868:	f7ff bb7c 	b.w	800cf64 <HAL_PCD_IRQHandler+0x1b4>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d86c:	f204 412c 	addw	r1, r4, #1068	; 0x42c
 800d870:	6820      	ldr	r0, [r4, #0]
 800d872:	f004 f939 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d876:	6863      	ldr	r3, [r4, #4]
 800d878:	f7ff bb7b 	b.w	800cf72 <HAL_PCD_IRQHandler+0x1c2>
    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
 800d87c:	f013 0f28 	tst.w	r3, #40	; 0x28
 800d880:	f47f ad7f 	bne.w	800d382 <HAL_PCD_IRQHandler+0x5d2>
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800d884:	491b      	ldr	r1, [pc, #108]	; (800d8f4 <HAL_PCD_IRQHandler+0xb44>)
 800d886:	458c      	cmp	ip, r1
 800d888:	d902      	bls.n	800d890 <HAL_PCD_IRQHandler+0xae0>
 800d88a:	041b      	lsls	r3, r3, #16
 800d88c:	f53f aef0 	bmi.w	800d670 <HAL_PCD_IRQHandler+0x8c0>
        ep->xfer_count = ep->xfer_size - (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
 800d890:	6911      	ldr	r1, [r2, #16]
 800d892:	f8da 2298 	ldr.w	r2, [sl, #664]	; 0x298
 800d896:	f3c1 0112 	ubfx	r1, r1, #0, #19
 800d89a:	1a52      	subs	r2, r2, r1
 800d89c:	f8ca 229c 	str.w	r2, [sl, #668]	; 0x29c
        if (epnum == 0U)
 800d8a0:	f1b9 0f00 	cmp.w	r9, #0
 800d8a4:	f47f ae3a 	bne.w	800d51c <HAL_PCD_IRQHandler+0x76c>
          if (ep->xfer_len == 0U)
 800d8a8:	f8d4 1294 	ldr.w	r1, [r4, #660]	; 0x294
 800d8ac:	b1d9      	cbz	r1, 800d8e6 <HAL_PCD_IRQHandler+0xb36>
            ep->xfer_buff += ep->xfer_count;
 800d8ae:	f8d4 128c 	ldr.w	r1, [r4, #652]	; 0x28c
 800d8b2:	440a      	add	r2, r1
 800d8b4:	f8c4 228c 	str.w	r2, [r4, #652]	; 0x28c
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 800d8b8:	e630      	b.n	800d51c <HAL_PCD_IRQHandler+0x76c>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d8ba:	f504 618a 	add.w	r1, r4, #1104	; 0x450
 800d8be:	6820      	ldr	r0, [r4, #0]
 800d8c0:	f004 f912 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d8c4:	6863      	ldr	r3, [r4, #4]
 800d8c6:	f7ff bb5b 	b.w	800cf80 <HAL_PCD_IRQHandler+0x1d0>
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
 800d8ca:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 800d8ce:	4649      	mov	r1, r9
 800d8d0:	f004 fa64 	bl	8011d9c <USB_EP0_OutStart>
 800d8d4:	e622      	b.n	800d51c <HAL_PCD_IRQHandler+0x76c>
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800d8d6:	f204 4174 	addw	r1, r4, #1140	; 0x474
 800d8da:	6820      	ldr	r0, [r4, #0]
 800d8dc:	f004 f904 	bl	8011ae8 <USB_EPStopXfer>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800d8e0:	6863      	ldr	r3, [r4, #4]
 800d8e2:	f7ff bb54 	b.w	800cf8e <HAL_PCD_IRQHandler+0x1de>
            (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800d8e6:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 800d8ea:	2101      	movs	r1, #1
 800d8ec:	f004 fa56 	bl	8011d9c <USB_EP0_OutStart>
 800d8f0:	e614      	b.n	800d51c <HAL_PCD_IRQHandler+0x76c>
 800d8f2:	bf00      	nop
 800d8f4:	4f54300a 	.word	0x4f54300a

0800d8f8 <HAL_PCD_SetAddress>:
  __HAL_LOCK(hpcd);
 800d8f8:	f890 24bc 	ldrb.w	r2, [r0, #1212]	; 0x4bc
 800d8fc:	2a01      	cmp	r2, #1
 800d8fe:	d00e      	beq.n	800d91e <HAL_PCD_SetAddress+0x26>
 800d900:	2201      	movs	r2, #1
{
 800d902:	b510      	push	{r4, lr}
 800d904:	4604      	mov	r4, r0
  (void)USB_SetDevAddress(hpcd->Instance, address);
 800d906:	6800      	ldr	r0, [r0, #0]
  hpcd->USB_Address = address;
 800d908:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
  __HAL_LOCK(hpcd);
 800d90c:	f884 24bc 	strb.w	r2, [r4, #1212]	; 0x4bc
  (void)USB_SetDevAddress(hpcd->Instance, address);
 800d910:	f004 f9ca 	bl	8011ca8 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 800d914:	2300      	movs	r3, #0
  return HAL_OK;
 800d916:	4618      	mov	r0, r3
  __HAL_UNLOCK(hpcd);
 800d918:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc
}
 800d91c:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 800d91e:	2002      	movs	r0, #2
}
 800d920:	4770      	bx	lr
 800d922:	bf00      	nop

0800d924 <HAL_PCD_EP_Open>:
{
 800d924:	b510      	push	{r4, lr}
 800d926:	f001 0e0f 	and.w	lr, r1, #15
  if ((ep_addr & 0x80U) == 0x80U)
 800d92a:	0609      	lsls	r1, r1, #24
{
 800d92c:	4604      	mov	r4, r0
  if ((ep_addr & 0x80U) == 0x80U)
 800d92e:	d427      	bmi.n	800d980 <HAL_PCD_EP_Open+0x5c>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800d930:	f04f 0c24 	mov.w	ip, #36	; 0x24
 800d934:	fb0c 0c0e 	mla	ip, ip, lr, r0
 800d938:	f50c 711f 	add.w	r1, ip, #636	; 0x27c
    ep->is_in = 0U;
 800d93c:	eb0e 0cce 	add.w	ip, lr, lr, lsl #3
 800d940:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 800d944:	2000      	movs	r0, #0
 800d946:	f88c 027d 	strb.w	r0, [ip, #637]	; 0x27d
  ep->maxpacket = ep_mps;
 800d94a:	60ca      	str	r2, [r1, #12]
  if (ep->is_in != 0U)
 800d94c:	784a      	ldrb	r2, [r1, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 800d94e:	f881 e000 	strb.w	lr, [r1]
  ep->type = ep_type;
 800d952:	710b      	strb	r3, [r1, #4]
  if (ep->is_in != 0U)
 800d954:	b10a      	cbz	r2, 800d95a <HAL_PCD_EP_Open+0x36>
    ep->tx_fifo_num = ep->num;
 800d956:	f8a1 e008 	strh.w	lr, [r1, #8]
  if (ep_type == EP_TYPE_BULK)
 800d95a:	2b02      	cmp	r3, #2
 800d95c:	d101      	bne.n	800d962 <HAL_PCD_EP_Open+0x3e>
    ep->data_pid_start = 0U;
 800d95e:	2300      	movs	r3, #0
 800d960:	714b      	strb	r3, [r1, #5]
  __HAL_LOCK(hpcd);
 800d962:	f894 34bc 	ldrb.w	r3, [r4, #1212]	; 0x4bc
 800d966:	2b01      	cmp	r3, #1
 800d968:	d018      	beq.n	800d99c <HAL_PCD_EP_Open+0x78>
 800d96a:	2301      	movs	r3, #1
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 800d96c:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 800d96e:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 800d972:	f003 fe41 	bl	80115f8 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 800d976:	2300      	movs	r3, #0
  return ret;
 800d978:	4618      	mov	r0, r3
  __HAL_UNLOCK(hpcd);
 800d97a:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc
}
 800d97e:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800d980:	2024      	movs	r0, #36	; 0x24
    ep->is_in = 1U;
 800d982:	f04f 0c01 	mov.w	ip, #1
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800d986:	fb00 400e 	mla	r0, r0, lr, r4
 800d98a:	f100 013c 	add.w	r1, r0, #60	; 0x3c
    ep->is_in = 1U;
 800d98e:	eb0e 00ce 	add.w	r0, lr, lr, lsl #3
 800d992:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 800d996:	f880 c03d 	strb.w	ip, [r0, #61]	; 0x3d
 800d99a:	e7d6      	b.n	800d94a <HAL_PCD_EP_Open+0x26>
  __HAL_LOCK(hpcd);
 800d99c:	2002      	movs	r0, #2
}
 800d99e:	bd10      	pop	{r4, pc}

0800d9a0 <HAL_PCD_EP_Close>:
  if ((ep_addr & 0x80U) == 0x80U)
 800d9a0:	f011 0f80 	tst.w	r1, #128	; 0x80
 800d9a4:	f001 030f 	and.w	r3, r1, #15
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800d9a8:	f04f 0124 	mov.w	r1, #36	; 0x24
{
 800d9ac:	b510      	push	{r4, lr}
 800d9ae:	4604      	mov	r4, r0
  if ((ep_addr & 0x80U) == 0x80U)
 800d9b0:	d11a      	bne.n	800d9e8 <HAL_PCD_EP_Close+0x48>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800d9b2:	fb01 4103 	mla	r1, r1, r3, r4
    ep->is_in = 0U;
 800d9b6:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
 800d9ba:	2000      	movs	r0, #0
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800d9bc:	f501 711f 	add.w	r1, r1, #636	; 0x27c
    ep->is_in = 0U;
 800d9c0:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 800d9c4:	f882 027d 	strb.w	r0, [r2, #637]	; 0x27d
  ep->num   = ep_addr & EP_ADDR_MSK;
 800d9c8:	700b      	strb	r3, [r1, #0]
  __HAL_LOCK(hpcd);
 800d9ca:	f894 34bc 	ldrb.w	r3, [r4, #1212]	; 0x4bc
 800d9ce:	2b01      	cmp	r3, #1
 800d9d0:	d019      	beq.n	800da06 <HAL_PCD_EP_Close+0x66>
 800d9d2:	2301      	movs	r3, #1
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 800d9d4:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 800d9d6:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 800d9da:	f003 fe55 	bl	8011688 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 800d9de:	2300      	movs	r3, #0
  return HAL_OK;
 800d9e0:	4618      	mov	r0, r3
  __HAL_UNLOCK(hpcd);
 800d9e2:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc
}
 800d9e6:	bd10      	pop	{r4, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800d9e8:	fb01 4103 	mla	r1, r1, r3, r4
    ep->is_in = 1U;
 800d9ec:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
 800d9f0:	2001      	movs	r0, #1
 800d9f2:	eb04 0282 	add.w	r2, r4, r2, lsl #2
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800d9f6:	313c      	adds	r1, #60	; 0x3c
    ep->is_in = 1U;
 800d9f8:	f882 003d 	strb.w	r0, [r2, #61]	; 0x3d
  ep->num   = ep_addr & EP_ADDR_MSK;
 800d9fc:	700b      	strb	r3, [r1, #0]
  __HAL_LOCK(hpcd);
 800d9fe:	f894 34bc 	ldrb.w	r3, [r4, #1212]	; 0x4bc
 800da02:	2b01      	cmp	r3, #1
 800da04:	d1e5      	bne.n	800d9d2 <HAL_PCD_EP_Close+0x32>
 800da06:	2002      	movs	r0, #2
}
 800da08:	bd10      	pop	{r4, pc}
 800da0a:	bf00      	nop

0800da0c <HAL_PCD_EP_Receive>:
{
 800da0c:	b510      	push	{r4, lr}
 800da0e:	f001 040f 	and.w	r4, r1, #15
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800da12:	2124      	movs	r1, #36	; 0x24
  ep->xfer_buff = pBuf;
 800da14:	eb04 0cc4 	add.w	ip, r4, r4, lsl #3
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800da18:	fb01 0104 	mla	r1, r1, r4, r0
  ep->xfer_buff = pBuf;
 800da1c:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800da20:	f501 711f 	add.w	r1, r1, #636	; 0x27c
  ep->xfer_len = len;
 800da24:	f8cc 3294 	str.w	r3, [ip, #660]	; 0x294
  ep->xfer_count = 0U;
 800da28:	2300      	movs	r3, #0
  ep->xfer_buff = pBuf;
 800da2a:	f8cc 228c 	str.w	r2, [ip, #652]	; 0x28c
  ep->num = ep_addr & EP_ADDR_MSK;
 800da2e:	f88c 427c 	strb.w	r4, [ip, #636]	; 0x27c
  ep->xfer_count = 0U;
 800da32:	f8cc 329c 	str.w	r3, [ip, #668]	; 0x29c
  ep->is_in = 0U;
 800da36:	f88c 327d 	strb.w	r3, [ip, #637]	; 0x27d
  if (hpcd->Init.dma_enable == 1U)
 800da3a:	6903      	ldr	r3, [r0, #16]
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800da3c:	6800      	ldr	r0, [r0, #0]
  if (hpcd->Init.dma_enable == 1U)
 800da3e:	2b01      	cmp	r3, #1
    ep->dma_addr = (uint32_t)pBuf;
 800da40:	bf08      	it	eq
 800da42:	f8cc 2290 	streq.w	r2, [ip, #656]	; 0x290
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800da46:	b2da      	uxtb	r2, r3
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 800da48:	b91c      	cbnz	r4, 800da52 <HAL_PCD_EP_Receive+0x46>
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800da4a:	f003 ff93 	bl	8011974 <USB_EP0StartXfer>
}
 800da4e:	2000      	movs	r0, #0
 800da50:	bd10      	pop	{r4, pc}
    (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800da52:	f003 fe77 	bl	8011744 <USB_EPStartXfer>
}
 800da56:	2000      	movs	r0, #0
 800da58:	bd10      	pop	{r4, pc}
 800da5a:	bf00      	nop

0800da5c <HAL_PCD_EP_GetRxCount>:
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 800da5c:	f001 010f 	and.w	r1, r1, #15
 800da60:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
 800da64:	eb00 0181 	add.w	r1, r0, r1, lsl #2
}
 800da68:	f8d1 029c 	ldr.w	r0, [r1, #668]	; 0x29c
 800da6c:	4770      	bx	lr
 800da6e:	bf00      	nop

0800da70 <HAL_PCD_EP_Transmit>:
{
 800da70:	b510      	push	{r4, lr}
 800da72:	f001 040f 	and.w	r4, r1, #15
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800da76:	2124      	movs	r1, #36	; 0x24
  ep->xfer_buff = pBuf;
 800da78:	eb04 0cc4 	add.w	ip, r4, r4, lsl #3
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800da7c:	fb01 0104 	mla	r1, r1, r4, r0
  ep->xfer_buff = pBuf;
 800da80:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800da84:	313c      	adds	r1, #60	; 0x3c
  ep->xfer_len = len;
 800da86:	f8cc 3054 	str.w	r3, [ip, #84]	; 0x54
  ep->xfer_count = 0U;
 800da8a:	2300      	movs	r3, #0
  ep->xfer_buff = pBuf;
 800da8c:	f8cc 204c 	str.w	r2, [ip, #76]	; 0x4c
  ep->xfer_count = 0U;
 800da90:	f8cc 305c 	str.w	r3, [ip, #92]	; 0x5c
  ep->is_in = 1U;
 800da94:	2301      	movs	r3, #1
  ep->num = ep_addr & EP_ADDR_MSK;
 800da96:	f88c 403c 	strb.w	r4, [ip, #60]	; 0x3c
  ep->is_in = 1U;
 800da9a:	f88c 303d 	strb.w	r3, [ip, #61]	; 0x3d
  if (hpcd->Init.dma_enable == 1U)
 800da9e:	6903      	ldr	r3, [r0, #16]
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800daa0:	6800      	ldr	r0, [r0, #0]
  if (hpcd->Init.dma_enable == 1U)
 800daa2:	2b01      	cmp	r3, #1
    ep->dma_addr = (uint32_t)pBuf;
 800daa4:	bf08      	it	eq
 800daa6:	f8cc 2050 	streq.w	r2, [ip, #80]	; 0x50
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800daaa:	b2da      	uxtb	r2, r3
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 800daac:	b91c      	cbnz	r4, 800dab6 <HAL_PCD_EP_Transmit+0x46>
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800daae:	f003 ff61 	bl	8011974 <USB_EP0StartXfer>
}
 800dab2:	2000      	movs	r0, #0
 800dab4:	bd10      	pop	{r4, pc}
    (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800dab6:	f003 fe45 	bl	8011744 <USB_EPStartXfer>
}
 800daba:	2000      	movs	r0, #0
 800dabc:	bd10      	pop	{r4, pc}
 800dabe:	bf00      	nop

0800dac0 <HAL_PCD_EP_SetStall>:
{
 800dac0:	b538      	push	{r3, r4, r5, lr}
  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 800dac2:	6843      	ldr	r3, [r0, #4]
 800dac4:	f001 050f 	and.w	r5, r1, #15
 800dac8:	429d      	cmp	r5, r3
 800daca:	d834      	bhi.n	800db36 <HAL_PCD_EP_SetStall+0x76>
  if ((0x80U & ep_addr) == 0x80U)
 800dacc:	060b      	lsls	r3, r1, #24
 800dace:	4604      	mov	r4, r0
 800dad0:	d41d      	bmi.n	800db0e <HAL_PCD_EP_SetStall+0x4e>
    ep = &hpcd->OUT_ep[ep_addr];
 800dad2:	2224      	movs	r2, #36	; 0x24
    ep->is_in = 0U;
 800dad4:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
    ep = &hpcd->OUT_ep[ep_addr];
 800dad8:	fb02 0101 	mla	r1, r2, r1, r0
    ep->is_in = 0U;
 800dadc:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800dae0:	2200      	movs	r2, #0
    ep = &hpcd->OUT_ep[ep_addr];
 800dae2:	f501 711f 	add.w	r1, r1, #636	; 0x27c
    ep->is_in = 0U;
 800dae6:	f883 227d 	strb.w	r2, [r3, #637]	; 0x27d
  ep->is_stall = 1U;
 800daea:	2301      	movs	r3, #1
  ep->num = ep_addr & EP_ADDR_MSK;
 800daec:	700d      	strb	r5, [r1, #0]
  ep->is_stall = 1U;
 800daee:	708b      	strb	r3, [r1, #2]
  __HAL_LOCK(hpcd);
 800daf0:	f894 24bc 	ldrb.w	r2, [r4, #1212]	; 0x4bc
 800daf4:	429a      	cmp	r2, r3
 800daf6:	d01c      	beq.n	800db32 <HAL_PCD_EP_SetStall+0x72>
  (void)USB_EPSetStall(hpcd->Instance, ep);
 800daf8:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 800dafa:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc
  (void)USB_EPSetStall(hpcd->Instance, ep);
 800dafe:	f004 f873 	bl	8011be8 <USB_EPSetStall>
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 800db02:	b1d5      	cbz	r5, 800db3a <HAL_PCD_EP_SetStall+0x7a>
  __HAL_UNLOCK(hpcd);
 800db04:	2300      	movs	r3, #0
  return HAL_OK;
 800db06:	4618      	mov	r0, r3
  __HAL_UNLOCK(hpcd);
 800db08:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc
}
 800db0c:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800db0e:	2124      	movs	r1, #36	; 0x24
    ep->is_in = 1U;
 800db10:	eb05 03c5 	add.w	r3, r5, r5, lsl #3
 800db14:	2201      	movs	r2, #1
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800db16:	fb01 0105 	mla	r1, r1, r5, r0
    ep->is_in = 1U;
 800db1a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800db1e:	313c      	adds	r1, #60	; 0x3c
    ep->is_in = 1U;
 800db20:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  ep->is_stall = 1U;
 800db24:	2301      	movs	r3, #1
  ep->num = ep_addr & EP_ADDR_MSK;
 800db26:	700d      	strb	r5, [r1, #0]
  ep->is_stall = 1U;
 800db28:	708b      	strb	r3, [r1, #2]
  __HAL_LOCK(hpcd);
 800db2a:	f894 24bc 	ldrb.w	r2, [r4, #1212]	; 0x4bc
 800db2e:	429a      	cmp	r2, r3
 800db30:	d1e2      	bne.n	800daf8 <HAL_PCD_EP_SetStall+0x38>
 800db32:	2002      	movs	r0, #2
}
 800db34:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 800db36:	2001      	movs	r0, #1
}
 800db38:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 800db3a:	f204 42c4 	addw	r2, r4, #1220	; 0x4c4
 800db3e:	7c21      	ldrb	r1, [r4, #16]
 800db40:	6820      	ldr	r0, [r4, #0]
 800db42:	f004 f92b 	bl	8011d9c <USB_EP0_OutStart>
 800db46:	e7dd      	b.n	800db04 <HAL_PCD_EP_SetStall+0x44>

0800db48 <HAL_PCD_EP_ClrStall>:
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 800db48:	6842      	ldr	r2, [r0, #4]
{
 800db4a:	b538      	push	{r3, r4, r5, lr}
 800db4c:	f001 030f 	and.w	r3, r1, #15
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 800db50:	4293      	cmp	r3, r2
 800db52:	d832      	bhi.n	800dbba <HAL_PCD_EP_ClrStall+0x72>
  if ((0x80U & ep_addr) == 0x80U)
 800db54:	f011 0f80 	tst.w	r1, #128	; 0x80
 800db58:	4604      	mov	r4, r0
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800db5a:	f04f 0124 	mov.w	r1, #36	; 0x24
    ep->is_in = 1U;
 800db5e:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
  if ((0x80U & ep_addr) == 0x80U)
 800db62:	d119      	bne.n	800db98 <HAL_PCD_EP_ClrStall+0x50>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800db64:	fb01 4103 	mla	r1, r1, r3, r4
    ep->is_in = 0U;
 800db68:	2000      	movs	r0, #0
 800db6a:	eb04 0282 	add.w	r2, r4, r2, lsl #2
  ep->is_stall = 0U;
 800db6e:	2500      	movs	r5, #0
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800db70:	f501 711f 	add.w	r1, r1, #636	; 0x27c
    ep->is_in = 0U;
 800db74:	f882 027d 	strb.w	r0, [r2, #637]	; 0x27d
  ep->num = ep_addr & EP_ADDR_MSK;
 800db78:	700b      	strb	r3, [r1, #0]
  ep->is_stall = 0U;
 800db7a:	708d      	strb	r5, [r1, #2]
  __HAL_LOCK(hpcd);
 800db7c:	f894 34bc 	ldrb.w	r3, [r4, #1212]	; 0x4bc
 800db80:	2b01      	cmp	r3, #1
 800db82:	d018      	beq.n	800dbb6 <HAL_PCD_EP_ClrStall+0x6e>
 800db84:	2301      	movs	r3, #1
  (void)USB_EPClearStall(hpcd->Instance, ep);
 800db86:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 800db88:	f884 34bc 	strb.w	r3, [r4, #1212]	; 0x4bc
  (void)USB_EPClearStall(hpcd->Instance, ep);
 800db8c:	f004 f860 	bl	8011c50 <USB_EPClearStall>
  return HAL_OK;
 800db90:	4628      	mov	r0, r5
  __HAL_UNLOCK(hpcd);
 800db92:	f884 54bc 	strb.w	r5, [r4, #1212]	; 0x4bc
}
 800db96:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800db98:	fb01 4103 	mla	r1, r1, r3, r4
    ep->is_in = 1U;
 800db9c:	2001      	movs	r0, #1
 800db9e:	eb04 0282 	add.w	r2, r4, r2, lsl #2
  ep->is_stall = 0U;
 800dba2:	2500      	movs	r5, #0
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800dba4:	313c      	adds	r1, #60	; 0x3c
    ep->is_in = 1U;
 800dba6:	f882 003d 	strb.w	r0, [r2, #61]	; 0x3d
  ep->num = ep_addr & EP_ADDR_MSK;
 800dbaa:	700b      	strb	r3, [r1, #0]
  ep->is_stall = 0U;
 800dbac:	708d      	strb	r5, [r1, #2]
  __HAL_LOCK(hpcd);
 800dbae:	f894 34bc 	ldrb.w	r3, [r4, #1212]	; 0x4bc
 800dbb2:	2b01      	cmp	r3, #1
 800dbb4:	d1e6      	bne.n	800db84 <HAL_PCD_EP_ClrStall+0x3c>
 800dbb6:	2002      	movs	r0, #2
}
 800dbb8:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 800dbba:	2001      	movs	r0, #1
}
 800dbbc:	bd38      	pop	{r3, r4, r5, pc}
 800dbbe:	bf00      	nop

0800dbc0 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 800dbc0:	b410      	push	{r4}
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 800dbc2:	6804      	ldr	r4, [r0, #0]
 800dbc4:	6a60      	ldr	r0, [r4, #36]	; 0x24

  if (fifo == 0U)
 800dbc6:	b931      	cbnz	r1, 800dbd6 <HAL_PCDEx_SetTxFiFo+0x16>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 800dbc8:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 800dbcc:	62a0      	str	r0, [r4, #40]	; 0x28
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
  }

  return HAL_OK;
}
 800dbce:	2000      	movs	r0, #0
 800dbd0:	f85d 4b04 	ldr.w	r4, [sp], #4
 800dbd4:	4770      	bx	lr
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 800dbd6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    for (i = 0U; i < (fifo - 1U); i++)
 800dbd8:	f1b1 0c01 	subs.w	ip, r1, #1
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 800dbdc:	eb00 4013 	add.w	r0, r0, r3, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 800dbe0:	d00b      	beq.n	800dbfa <HAL_PCDEx_SetTxFiFo+0x3a>
 800dbe2:	2300      	movs	r3, #0
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 800dbe4:	f103 0140 	add.w	r1, r3, #64	; 0x40
    for (i = 0U; i < (fifo - 1U); i++)
 800dbe8:	3301      	adds	r3, #1
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 800dbea:	eb04 0181 	add.w	r1, r4, r1, lsl #2
    for (i = 0U; i < (fifo - 1U); i++)
 800dbee:	b2db      	uxtb	r3, r3
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 800dbf0:	6849      	ldr	r1, [r1, #4]
    for (i = 0U; i < (fifo - 1U); i++)
 800dbf2:	4563      	cmp	r3, ip
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 800dbf4:	eb00 4011 	add.w	r0, r0, r1, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 800dbf8:	d3f4      	bcc.n	800dbe4 <HAL_PCDEx_SetTxFiFo+0x24>
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 800dbfa:	f10c 0c40 	add.w	ip, ip, #64	; 0x40
 800dbfe:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 800dc02:	eb04 0c8c 	add.w	ip, r4, ip, lsl #2
}
 800dc06:	f85d 4b04 	ldr.w	r4, [sp], #4
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 800dc0a:	f8cc 0004 	str.w	r0, [ip, #4]
}
 800dc0e:	2000      	movs	r0, #0
 800dc10:	4770      	bx	lr
 800dc12:	bf00      	nop

0800dc14 <HAL_PCDEx_SetRxFiFo>:
  * @param  hpcd PCD handle
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
 800dc14:	4603      	mov	r3, r0
  hpcd->Instance->GRXFSIZ = size;

  return HAL_OK;
}
 800dc16:	2000      	movs	r0, #0
  hpcd->Instance->GRXFSIZ = size;
 800dc18:	681b      	ldr	r3, [r3, #0]
 800dc1a:	6259      	str	r1, [r3, #36]	; 0x24
}
 800dc1c:	4770      	bx	lr
 800dc1e:	bf00      	nop

0800dc20 <HAL_PCDEx_ActivateLPM>:
  * @brief  Activate LPM feature.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
 800dc20:	4603      	mov	r3, r0
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;

  hpcd->lpm_active = 1U;
  hpcd->LPM_State = LPM_L0;
 800dc22:	f04f 0c00 	mov.w	ip, #0
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 800dc26:	4909      	ldr	r1, [pc, #36]	; (800dc4c <HAL_PCDEx_ActivateLPM+0x2c>)
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800dc28:	681a      	ldr	r2, [r3, #0]

  return HAL_OK;
}
 800dc2a:	4660      	mov	r0, ip
{
 800dc2c:	b410      	push	{r4}
  hpcd->lpm_active = 1U;
 800dc2e:	2401      	movs	r4, #1
  hpcd->LPM_State = LPM_L0;
 800dc30:	f883 c4f4 	strb.w	ip, [r3, #1268]	; 0x4f4
  hpcd->lpm_active = 1U;
 800dc34:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 800dc38:	6993      	ldr	r3, [r2, #24]
}
 800dc3a:	f85d 4b04 	ldr.w	r4, [sp], #4
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 800dc3e:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800dc42:	6193      	str	r3, [r2, #24]
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 800dc44:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800dc46:	4319      	orrs	r1, r3
 800dc48:	6551      	str	r1, [r2, #84]	; 0x54
}
 800dc4a:	4770      	bx	lr
 800dc4c:	10000003 	.word	0x10000003

0800dc50 <HAL_PCDEx_LPM_Callback>:
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 800dc50:	4770      	bx	lr
 800dc52:	bf00      	nop

0800dc54 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
 800dc54:	b570      	push	{r4, r5, r6, lr}

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
 800dc56:	4c1d      	ldr	r4, [pc, #116]	; (800dccc <HAL_PWREx_ConfigSupply+0x78>)
{
 800dc58:	4605      	mov	r5, r0
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
 800dc5a:	68e3      	ldr	r3, [r4, #12]
 800dc5c:	f003 0307 	and.w	r3, r3, #7
 800dc60:	2b06      	cmp	r3, #6
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 800dc62:	68e3      	ldr	r3, [r4, #12]
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
 800dc64:	d005      	beq.n	800dc72 <HAL_PWREx_ConfigSupply+0x1e>
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 800dc66:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
 800dc6a:	1a18      	subs	r0, r3, r0
 800dc6c:	bf18      	it	ne
 800dc6e:	2001      	movne	r0, #1
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
}
 800dc70:	bd70      	pop	{r4, r5, r6, pc}
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
 800dc72:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800dc76:	4303      	orrs	r3, r0
 800dc78:	60e3      	str	r3, [r4, #12]
  tickstart = HAL_GetTick ();
 800dc7a:	f7fd f847 	bl	800ad0c <HAL_GetTick>
 800dc7e:	4606      	mov	r6, r0
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 800dc80:	e005      	b.n	800dc8e <HAL_PWREx_ConfigSupply+0x3a>
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
 800dc82:	f7fd f843 	bl	800ad0c <HAL_GetTick>
 800dc86:	1b83      	subs	r3, r0, r6
 800dc88:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800dc8c:	d81b      	bhi.n	800dcc6 <HAL_PWREx_ConfigSupply+0x72>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 800dc8e:	6863      	ldr	r3, [r4, #4]
 800dc90:	049a      	lsls	r2, r3, #18
 800dc92:	d5f6      	bpl.n	800dc82 <HAL_PWREx_ConfigSupply+0x2e>
      (SupplySource == PWR_SMPS_1V8_SUPPLIES_EXT)         ||
 800dc94:	f1a5 031d 	sub.w	r3, r5, #29
 800dc98:	2b01      	cmp	r3, #1
 800dc9a:	d905      	bls.n	800dca8 <HAL_PWREx_ConfigSupply+0x54>
      (SupplySource == PWR_SMPS_2V5_SUPPLIES_EXT))
 800dc9c:	f1a5 002d 	sub.w	r0, r5, #45	; 0x2d
      (SupplySource == PWR_SMPS_1V8_SUPPLIES_EXT)         ||
 800dca0:	2801      	cmp	r0, #1
 800dca2:	d901      	bls.n	800dca8 <HAL_PWREx_ConfigSupply+0x54>
  return HAL_OK;
 800dca4:	2000      	movs	r0, #0
}
 800dca6:	bd70      	pop	{r4, r5, r6, pc}
    tickstart = HAL_GetTick ();
 800dca8:	f7fd f830 	bl	800ad0c <HAL_GetTick>
    while (__HAL_PWR_GET_FLAG (PWR_FLAG_SMPSEXTRDY) == 0U)
 800dcac:	4d07      	ldr	r5, [pc, #28]	; (800dccc <HAL_PWREx_ConfigSupply+0x78>)
    tickstart = HAL_GetTick ();
 800dcae:	4604      	mov	r4, r0
    while (__HAL_PWR_GET_FLAG (PWR_FLAG_SMPSEXTRDY) == 0U)
 800dcb0:	e005      	b.n	800dcbe <HAL_PWREx_ConfigSupply+0x6a>
      if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
 800dcb2:	f7fd f82b 	bl	800ad0c <HAL_GetTick>
 800dcb6:	1b00      	subs	r0, r0, r4
 800dcb8:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800dcbc:	d803      	bhi.n	800dcc6 <HAL_PWREx_ConfigSupply+0x72>
    while (__HAL_PWR_GET_FLAG (PWR_FLAG_SMPSEXTRDY) == 0U)
 800dcbe:	68eb      	ldr	r3, [r5, #12]
 800dcc0:	03db      	lsls	r3, r3, #15
 800dcc2:	d5f6      	bpl.n	800dcb2 <HAL_PWREx_ConfigSupply+0x5e>
 800dcc4:	e7ee      	b.n	800dca4 <HAL_PWREx_ConfigSupply+0x50>
      return HAL_ERROR;
 800dcc6:	2001      	movs	r0, #1
}
 800dcc8:	bd70      	pop	{r4, r5, r6, pc}
 800dcca:	bf00      	nop
 800dccc:	58024800 	.word	0x58024800

0800dcd0 <HAL_PWREx_EnableUSBVoltageDetector>:
  * @retval None.
  */
void HAL_PWREx_EnableUSBVoltageDetector (void)
{
  /* Enable the USB voltage detector */
  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);
 800dcd0:	4a02      	ldr	r2, [pc, #8]	; (800dcdc <HAL_PWREx_EnableUSBVoltageDetector+0xc>)
 800dcd2:	68d3      	ldr	r3, [r2, #12]
 800dcd4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800dcd8:	60d3      	str	r3, [r2, #12]
}
 800dcda:	4770      	bx	lr
 800dcdc:	58024800 	.word	0x58024800

0800dce0 <HAL_RCC_GetSysClockFreq.part.0>:
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800dce0:	4b3b      	ldr	r3, [pc, #236]	; (800ddd0 <HAL_RCC_GetSysClockFreq.part.0+0xf0>)
uint32_t HAL_RCC_GetSysClockFreq(void)
 800dce2:	b430      	push	{r4, r5}
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800dce4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 800dce6:	6a9c      	ldr	r4, [r3, #40]	; 0x28
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 800dce8:	6add      	ldr	r5, [r3, #44]	; 0x2c
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));

    if (pllm != 0U)
 800dcea:	f414 7f7c 	tst.w	r4, #1008	; 0x3f0
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 800dcee:	6b59      	ldr	r1, [r3, #52]	; 0x34
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 800dcf0:	f3c4 1005 	ubfx	r0, r4, #4, #6
    if (pllm != 0U)
 800dcf4:	d038      	beq.n	800dd68 <HAL_RCC_GetSysClockFreq.part.0+0x88>
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 800dcf6:	f3c1 01cc 	ubfx	r1, r1, #3, #13
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 800dcfa:	f005 0501 	and.w	r5, r5, #1
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800dcfe:	f002 0203 	and.w	r2, r2, #3
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 800dd02:	fb05 f101 	mul.w	r1, r5, r1
 800dd06:	2a01      	cmp	r2, #1
 800dd08:	ee07 1a90 	vmov	s15, r1
 800dd0c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    {
      switch (pllsource)
 800dd10:	d002      	beq.n	800dd18 <HAL_RCC_GetSysClockFreq.part.0+0x38>
 800dd12:	2a02      	cmp	r2, #2
 800dd14:	d04e      	beq.n	800ddb4 <HAL_RCC_GetSysClockFreq.part.0+0xd4>
 800dd16:	b34a      	cbz	r2, 800dd6c <HAL_RCC_GetSysClockFreq.part.0+0x8c>
      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        break;

      default:
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800dd18:	ee07 0a90 	vmov	s15, r0
 800dd1c:	eddf 6a2d 	vldr	s13, [pc, #180]	; 800ddd4 <HAL_RCC_GetSysClockFreq.part.0+0xf4>
 800dd20:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800dd24:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800dd26:	ee86 6aa7 	vdiv.f32	s12, s13, s15
 800dd2a:	eddf 5a2b 	vldr	s11, [pc, #172]	; 800ddd8 <HAL_RCC_GetSysClockFreq.part.0+0xf8>
 800dd2e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800dd32:	ee06 3a90 	vmov	s13, r3
 800dd36:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 800dd3a:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800dd3e:	ee76 6a85 	vadd.f32	s13, s13, s10
 800dd42:	eee7 6a25 	vfma.f32	s13, s14, s11
 800dd46:	ee66 6a26 	vmul.f32	s13, s12, s13
        break;
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
 800dd4a:	4b21      	ldr	r3, [pc, #132]	; (800ddd0 <HAL_RCC_GetSysClockFreq.part.0+0xf0>)
 800dd4c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800dd4e:	f3c3 2346 	ubfx	r3, r3, #9, #7
 800dd52:	3301      	adds	r3, #1
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
 800dd54:	ee07 3a90 	vmov	s15, r3
 800dd58:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800dd5c:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800dd60:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800dd64:	ee17 0a90 	vmov	r0, s15
    sysclockfreq = CSI_VALUE;
    break;
  }

  return sysclockfreq;
}
 800dd68:	bc30      	pop	{r4, r5}
 800dd6a:	4770      	bx	lr
       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800dd6c:	681a      	ldr	r2, [r3, #0]
 800dd6e:	0692      	lsls	r2, r2, #26
 800dd70:	d527      	bpl.n	800ddc2 <HAL_RCC_GetSysClockFreq.part.0+0xe2>
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800dd72:	6819      	ldr	r1, [r3, #0]
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800dd74:	ee07 0a90 	vmov	s15, r0
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800dd78:	4a18      	ldr	r2, [pc, #96]	; (800dddc <HAL_RCC_GetSysClockFreq.part.0+0xfc>)
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800dd7a:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 800dd7e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800dd80:	f3c1 01c1 	ubfx	r1, r1, #3, #2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800dd84:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800dd88:	ed9f 5a13 	vldr	s10, [pc, #76]	; 800ddd8 <HAL_RCC_GetSysClockFreq.part.0+0xf8>
 800dd8c:	f3c3 0308 	ubfx	r3, r3, #0, #9
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800dd90:	40ca      	lsrs	r2, r1
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800dd92:	ee06 3a90 	vmov	s13, r3
 800dd96:	ee05 2a90 	vmov	s11, r2
 800dd9a:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800dd9e:	eef8 5ae5 	vcvt.f32.s32	s11, s11
 800dda2:	ee76 6a86 	vadd.f32	s13, s13, s12
 800dda6:	ee85 6aa7 	vdiv.f32	s12, s11, s15
 800ddaa:	eee7 6a05 	vfma.f32	s13, s14, s10
 800ddae:	ee66 6a26 	vmul.f32	s13, s12, s13
 800ddb2:	e7ca      	b.n	800dd4a <HAL_RCC_GetSysClockFreq.part.0+0x6a>
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800ddb4:	ee07 0a90 	vmov	s15, r0
 800ddb8:	eddf 6a09 	vldr	s13, [pc, #36]	; 800dde0 <HAL_RCC_GetSysClockFreq.part.0+0x100>
 800ddbc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800ddc0:	e7b0      	b.n	800dd24 <HAL_RCC_GetSysClockFreq.part.0+0x44>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800ddc2:	ee07 0a90 	vmov	s15, r0
 800ddc6:	eddf 6a07 	vldr	s13, [pc, #28]	; 800dde4 <HAL_RCC_GetSysClockFreq.part.0+0x104>
 800ddca:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800ddce:	e7a9      	b.n	800dd24 <HAL_RCC_GetSysClockFreq.part.0+0x44>
 800ddd0:	58024400 	.word	0x58024400
 800ddd4:	4a742400 	.word	0x4a742400
 800ddd8:	39000000 	.word	0x39000000
 800dddc:	03d09000 	.word	0x03d09000
 800dde0:	4af42400 	.word	0x4af42400
 800dde4:	4c742400 	.word	0x4c742400

0800dde8 <HAL_RCC_OscConfig>:
  if(RCC_OscInitStruct == NULL)
 800dde8:	2800      	cmp	r0, #0
 800ddea:	f000 81e8 	beq.w	800e1be <HAL_RCC_OscConfig+0x3d6>
{
 800ddee:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800ddf0:	6803      	ldr	r3, [r0, #0]
 800ddf2:	4604      	mov	r4, r0
 800ddf4:	07d9      	lsls	r1, r3, #31
 800ddf6:	d52e      	bpl.n	800de56 <HAL_RCC_OscConfig+0x6e>
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800ddf8:	49a4      	ldr	r1, [pc, #656]	; (800e08c <HAL_RCC_OscConfig+0x2a4>)
 800ddfa:	690a      	ldr	r2, [r1, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 800ddfc:	6a89      	ldr	r1, [r1, #40]	; 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800ddfe:	f002 0238 	and.w	r2, r2, #56	; 0x38
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
 800de02:	2a10      	cmp	r2, #16
 800de04:	f000 8107 	beq.w	800e016 <HAL_RCC_OscConfig+0x22e>
 800de08:	2a18      	cmp	r2, #24
 800de0a:	f000 80ff 	beq.w	800e00c <HAL_RCC_OscConfig+0x224>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800de0e:	6863      	ldr	r3, [r4, #4]
 800de10:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800de14:	f000 812a 	beq.w	800e06c <HAL_RCC_OscConfig+0x284>
 800de18:	2b00      	cmp	r3, #0
 800de1a:	f000 8168 	beq.w	800e0ee <HAL_RCC_OscConfig+0x306>
 800de1e:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800de22:	4b9a      	ldr	r3, [pc, #616]	; (800e08c <HAL_RCC_OscConfig+0x2a4>)
 800de24:	681a      	ldr	r2, [r3, #0]
 800de26:	f000 8269 	beq.w	800e2fc <HAL_RCC_OscConfig+0x514>
 800de2a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800de2e:	601a      	str	r2, [r3, #0]
 800de30:	681a      	ldr	r2, [r3, #0]
 800de32:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800de36:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800de38:	f7fc ff68 	bl	800ad0c <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800de3c:	4e93      	ldr	r6, [pc, #588]	; (800e08c <HAL_RCC_OscConfig+0x2a4>)
        tickstart = HAL_GetTick();
 800de3e:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800de40:	e005      	b.n	800de4e <HAL_RCC_OscConfig+0x66>
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800de42:	f7fc ff63 	bl	800ad0c <HAL_GetTick>
 800de46:	1b40      	subs	r0, r0, r5
 800de48:	2864      	cmp	r0, #100	; 0x64
 800de4a:	f200 814e 	bhi.w	800e0ea <HAL_RCC_OscConfig+0x302>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800de4e:	6833      	ldr	r3, [r6, #0]
 800de50:	039b      	lsls	r3, r3, #14
 800de52:	d5f6      	bpl.n	800de42 <HAL_RCC_OscConfig+0x5a>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800de54:	6823      	ldr	r3, [r4, #0]
 800de56:	079d      	lsls	r5, r3, #30
 800de58:	f100 808a 	bmi.w	800df70 <HAL_RCC_OscConfig+0x188>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
 800de5c:	06d9      	lsls	r1, r3, #27
 800de5e:	d533      	bpl.n	800dec8 <HAL_RCC_OscConfig+0xe0>
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800de60:	4a8a      	ldr	r2, [pc, #552]	; (800e08c <HAL_RCC_OscConfig+0x2a4>)
 800de62:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 800de64:	6a92      	ldr	r2, [r2, #40]	; 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800de66:	f003 0338 	and.w	r3, r3, #56	; 0x38
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
 800de6a:	2b08      	cmp	r3, #8
 800de6c:	f000 80e3 	beq.w	800e036 <HAL_RCC_OscConfig+0x24e>
 800de70:	2b18      	cmp	r3, #24
 800de72:	f000 80db 	beq.w	800e02c <HAL_RCC_OscConfig+0x244>
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
 800de76:	69e3      	ldr	r3, [r4, #28]
        __HAL_RCC_CSI_ENABLE();
 800de78:	4d84      	ldr	r5, [pc, #528]	; (800e08c <HAL_RCC_OscConfig+0x2a4>)
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
 800de7a:	2b00      	cmp	r3, #0
 800de7c:	f000 816f 	beq.w	800e15e <HAL_RCC_OscConfig+0x376>
        __HAL_RCC_CSI_ENABLE();
 800de80:	682b      	ldr	r3, [r5, #0]
 800de82:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800de86:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800de88:	f7fc ff40 	bl	800ad0c <HAL_GetTick>
 800de8c:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 800de8e:	e005      	b.n	800de9c <HAL_RCC_OscConfig+0xb4>
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
 800de90:	f7fc ff3c 	bl	800ad0c <HAL_GetTick>
 800de94:	1b80      	subs	r0, r0, r6
 800de96:	2802      	cmp	r0, #2
 800de98:	f200 8127 	bhi.w	800e0ea <HAL_RCC_OscConfig+0x302>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 800de9c:	682b      	ldr	r3, [r5, #0]
 800de9e:	05db      	lsls	r3, r3, #23
 800dea0:	d5f6      	bpl.n	800de90 <HAL_RCC_OscConfig+0xa8>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800dea2:	f7fc ff4b 	bl	800ad3c <HAL_GetREVID>
 800dea6:	f241 0303 	movw	r3, #4099	; 0x1003
 800deaa:	4298      	cmp	r0, r3
 800deac:	f200 8247 	bhi.w	800e33e <HAL_RCC_OscConfig+0x556>
 800deb0:	6a22      	ldr	r2, [r4, #32]
 800deb2:	686b      	ldr	r3, [r5, #4]
 800deb4:	2a20      	cmp	r2, #32
 800deb6:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 800deba:	bf0c      	ite	eq
 800debc:	f043 4380 	orreq.w	r3, r3, #1073741824	; 0x40000000
 800dec0:	ea43 6382 	orrne.w	r3, r3, r2, lsl #26
 800dec4:	606b      	str	r3, [r5, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800dec6:	6823      	ldr	r3, [r4, #0]
 800dec8:	071d      	lsls	r5, r3, #28
 800deca:	d516      	bpl.n	800defa <HAL_RCC_OscConfig+0x112>
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800decc:	6963      	ldr	r3, [r4, #20]
      __HAL_RCC_LSI_ENABLE();
 800dece:	4d6f      	ldr	r5, [pc, #444]	; (800e08c <HAL_RCC_OscConfig+0x2a4>)
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800ded0:	2b00      	cmp	r3, #0
 800ded2:	f000 8122 	beq.w	800e11a <HAL_RCC_OscConfig+0x332>
      __HAL_RCC_LSI_ENABLE();
 800ded6:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800ded8:	f043 0301 	orr.w	r3, r3, #1
 800dedc:	676b      	str	r3, [r5, #116]	; 0x74
      tickstart = HAL_GetTick();
 800dede:	f7fc ff15 	bl	800ad0c <HAL_GetTick>
 800dee2:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 800dee4:	e005      	b.n	800def2 <HAL_RCC_OscConfig+0x10a>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800dee6:	f7fc ff11 	bl	800ad0c <HAL_GetTick>
 800deea:	1b80      	subs	r0, r0, r6
 800deec:	2802      	cmp	r0, #2
 800deee:	f200 80fc 	bhi.w	800e0ea <HAL_RCC_OscConfig+0x302>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 800def2:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800def4:	0798      	lsls	r0, r3, #30
 800def6:	d5f6      	bpl.n	800dee6 <HAL_RCC_OscConfig+0xfe>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 800def8:	6823      	ldr	r3, [r4, #0]
 800defa:	069a      	lsls	r2, r3, #26
 800defc:	d516      	bpl.n	800df2c <HAL_RCC_OscConfig+0x144>
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
 800defe:	69a3      	ldr	r3, [r4, #24]
      __HAL_RCC_HSI48_ENABLE();
 800df00:	4d62      	ldr	r5, [pc, #392]	; (800e08c <HAL_RCC_OscConfig+0x2a4>)
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
 800df02:	2b00      	cmp	r3, #0
 800df04:	f000 811a 	beq.w	800e13c <HAL_RCC_OscConfig+0x354>
      __HAL_RCC_HSI48_ENABLE();
 800df08:	682b      	ldr	r3, [r5, #0]
 800df0a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800df0e:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 800df10:	f7fc fefc 	bl	800ad0c <HAL_GetTick>
 800df14:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 800df16:	e005      	b.n	800df24 <HAL_RCC_OscConfig+0x13c>
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
 800df18:	f7fc fef8 	bl	800ad0c <HAL_GetTick>
 800df1c:	1b80      	subs	r0, r0, r6
 800df1e:	2802      	cmp	r0, #2
 800df20:	f200 80e3 	bhi.w	800e0ea <HAL_RCC_OscConfig+0x302>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 800df24:	682b      	ldr	r3, [r5, #0]
 800df26:	049f      	lsls	r7, r3, #18
 800df28:	d5f6      	bpl.n	800df18 <HAL_RCC_OscConfig+0x130>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800df2a:	6823      	ldr	r3, [r4, #0]
 800df2c:	0759      	lsls	r1, r3, #29
 800df2e:	f100 80a3 	bmi.w	800e078 <HAL_RCC_OscConfig+0x290>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800df32:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800df34:	b1d0      	cbz	r0, 800df6c <HAL_RCC_OscConfig+0x184>
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
 800df36:	4d55      	ldr	r5, [pc, #340]	; (800e08c <HAL_RCC_OscConfig+0x2a4>)
 800df38:	692b      	ldr	r3, [r5, #16]
 800df3a:	f003 0338 	and.w	r3, r3, #56	; 0x38
 800df3e:	2b18      	cmp	r3, #24
 800df40:	f000 81ae 	beq.w	800e2a0 <HAL_RCC_OscConfig+0x4b8>
        __HAL_RCC_PLL_DISABLE();
 800df44:	682b      	ldr	r3, [r5, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800df46:	2802      	cmp	r0, #2
        __HAL_RCC_PLL_DISABLE();
 800df48:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800df4c:	602b      	str	r3, [r5, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800df4e:	f000 8142 	beq.w	800e1d6 <HAL_RCC_OscConfig+0x3ee>
        tickstart = HAL_GetTick();
 800df52:	f7fc fedb 	bl	800ad0c <HAL_GetTick>
 800df56:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800df58:	e005      	b.n	800df66 <HAL_RCC_OscConfig+0x17e>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800df5a:	f7fc fed7 	bl	800ad0c <HAL_GetTick>
 800df5e:	1b00      	subs	r0, r0, r4
 800df60:	2802      	cmp	r0, #2
 800df62:	f200 80c2 	bhi.w	800e0ea <HAL_RCC_OscConfig+0x302>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800df66:	682b      	ldr	r3, [r5, #0]
 800df68:	019b      	lsls	r3, r3, #6
 800df6a:	d4f6      	bmi.n	800df5a <HAL_RCC_OscConfig+0x172>
  return HAL_OK;
 800df6c:	2000      	movs	r0, #0
}
 800df6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800df70:	4a46      	ldr	r2, [pc, #280]	; (800e08c <HAL_RCC_OscConfig+0x2a4>)
 800df72:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 800df74:	6a92      	ldr	r2, [r2, #40]	; 0x28
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 800df76:	f013 0338 	ands.w	r3, r3, #56	; 0x38
 800df7a:	d12d      	bne.n	800dfd8 <HAL_RCC_OscConfig+0x1f0>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800df7c:	4b43      	ldr	r3, [pc, #268]	; (800e08c <HAL_RCC_OscConfig+0x2a4>)
 800df7e:	68e2      	ldr	r2, [r4, #12]
 800df80:	681b      	ldr	r3, [r3, #0]
 800df82:	0759      	lsls	r1, r3, #29
 800df84:	d501      	bpl.n	800df8a <HAL_RCC_OscConfig+0x1a2>
 800df86:	2a00      	cmp	r2, #0
 800df88:	d04e      	beq.n	800e028 <HAL_RCC_OscConfig+0x240>
          __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 800df8a:	4d40      	ldr	r5, [pc, #256]	; (800e08c <HAL_RCC_OscConfig+0x2a4>)
 800df8c:	682b      	ldr	r3, [r5, #0]
 800df8e:	f023 0319 	bic.w	r3, r3, #25
 800df92:	4313      	orrs	r3, r2
 800df94:	602b      	str	r3, [r5, #0]
          tickstart = HAL_GetTick();
 800df96:	f7fc feb9 	bl	800ad0c <HAL_GetTick>
 800df9a:	4606      	mov	r6, r0
          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800df9c:	e005      	b.n	800dfaa <HAL_RCC_OscConfig+0x1c2>
            if((uint32_t) (HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800df9e:	f7fc feb5 	bl	800ad0c <HAL_GetTick>
 800dfa2:	1b80      	subs	r0, r0, r6
 800dfa4:	2802      	cmp	r0, #2
 800dfa6:	f200 80a0 	bhi.w	800e0ea <HAL_RCC_OscConfig+0x302>
          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800dfaa:	682b      	ldr	r3, [r5, #0]
 800dfac:	075b      	lsls	r3, r3, #29
 800dfae:	d5f6      	bpl.n	800df9e <HAL_RCC_OscConfig+0x1b6>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800dfb0:	f7fc fec4 	bl	800ad3c <HAL_GetREVID>
 800dfb4:	f241 0303 	movw	r3, #4099	; 0x1003
 800dfb8:	4298      	cmp	r0, r3
 800dfba:	f200 80f7 	bhi.w	800e1ac <HAL_RCC_OscConfig+0x3c4>
 800dfbe:	6922      	ldr	r2, [r4, #16]
 800dfc0:	686b      	ldr	r3, [r5, #4]
 800dfc2:	2a40      	cmp	r2, #64	; 0x40
 800dfc4:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
 800dfc8:	bf0c      	ite	eq
 800dfca:	f443 3300 	orreq.w	r3, r3, #131072	; 0x20000
 800dfce:	ea43 3302 	orrne.w	r3, r3, r2, lsl #12
 800dfd2:	606b      	str	r3, [r5, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
 800dfd4:	6823      	ldr	r3, [r4, #0]
 800dfd6:	e741      	b.n	800de5c <HAL_RCC_OscConfig+0x74>
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 800dfd8:	2b18      	cmp	r3, #24
 800dfda:	f000 80e3 	beq.w	800e1a4 <HAL_RCC_OscConfig+0x3bc>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 800dfde:	4d2b      	ldr	r5, [pc, #172]	; (800e08c <HAL_RCC_OscConfig+0x2a4>)
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 800dfe0:	68e2      	ldr	r2, [r4, #12]
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 800dfe2:	682b      	ldr	r3, [r5, #0]
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 800dfe4:	2a00      	cmp	r2, #0
 800dfe6:	f000 80cc 	beq.w	800e182 <HAL_RCC_OscConfig+0x39a>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 800dfea:	f023 0319 	bic.w	r3, r3, #25
 800dfee:	4313      	orrs	r3, r2
 800dff0:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800dff2:	f7fc fe8b 	bl	800ad0c <HAL_GetTick>
 800dff6:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800dff8:	e004      	b.n	800e004 <HAL_RCC_OscConfig+0x21c>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800dffa:	f7fc fe87 	bl	800ad0c <HAL_GetTick>
 800dffe:	1b80      	subs	r0, r0, r6
 800e000:	2802      	cmp	r0, #2
 800e002:	d872      	bhi.n	800e0ea <HAL_RCC_OscConfig+0x302>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800e004:	682b      	ldr	r3, [r5, #0]
 800e006:	075f      	lsls	r7, r3, #29
 800e008:	d5f7      	bpl.n	800dffa <HAL_RCC_OscConfig+0x212>
 800e00a:	e7d1      	b.n	800dfb0 <HAL_RCC_OscConfig+0x1c8>
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
 800e00c:	f001 0103 	and.w	r1, r1, #3
 800e010:	2902      	cmp	r1, #2
 800e012:	f47f aefc 	bne.w	800de0e <HAL_RCC_OscConfig+0x26>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800e016:	4a1d      	ldr	r2, [pc, #116]	; (800e08c <HAL_RCC_OscConfig+0x2a4>)
 800e018:	6812      	ldr	r2, [r2, #0]
 800e01a:	0392      	lsls	r2, r2, #14
 800e01c:	f57f af1b 	bpl.w	800de56 <HAL_RCC_OscConfig+0x6e>
 800e020:	6862      	ldr	r2, [r4, #4]
 800e022:	2a00      	cmp	r2, #0
 800e024:	f47f af17 	bne.w	800de56 <HAL_RCC_OscConfig+0x6e>
        return HAL_ERROR;
 800e028:	2001      	movs	r0, #1
}
 800e02a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
 800e02c:	f002 0203 	and.w	r2, r2, #3
 800e030:	2a01      	cmp	r2, #1
 800e032:	f47f af20 	bne.w	800de76 <HAL_RCC_OscConfig+0x8e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 800e036:	4b15      	ldr	r3, [pc, #84]	; (800e08c <HAL_RCC_OscConfig+0x2a4>)
 800e038:	681b      	ldr	r3, [r3, #0]
 800e03a:	05da      	lsls	r2, r3, #23
 800e03c:	d502      	bpl.n	800e044 <HAL_RCC_OscConfig+0x25c>
 800e03e:	69e3      	ldr	r3, [r4, #28]
 800e040:	2b80      	cmp	r3, #128	; 0x80
 800e042:	d1f1      	bne.n	800e028 <HAL_RCC_OscConfig+0x240>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800e044:	f7fc fe7a 	bl	800ad3c <HAL_GetREVID>
 800e048:	f241 0303 	movw	r3, #4099	; 0x1003
 800e04c:	4298      	cmp	r0, r3
 800e04e:	f200 80b8 	bhi.w	800e1c2 <HAL_RCC_OscConfig+0x3da>
 800e052:	6a22      	ldr	r2, [r4, #32]
 800e054:	2a20      	cmp	r2, #32
 800e056:	f000 8187 	beq.w	800e368 <HAL_RCC_OscConfig+0x580>
 800e05a:	490c      	ldr	r1, [pc, #48]	; (800e08c <HAL_RCC_OscConfig+0x2a4>)
 800e05c:	684b      	ldr	r3, [r1, #4]
 800e05e:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 800e062:	ea43 6382 	orr.w	r3, r3, r2, lsl #26
 800e066:	604b      	str	r3, [r1, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800e068:	6823      	ldr	r3, [r4, #0]
 800e06a:	e72d      	b.n	800dec8 <HAL_RCC_OscConfig+0xe0>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800e06c:	4a07      	ldr	r2, [pc, #28]	; (800e08c <HAL_RCC_OscConfig+0x2a4>)
 800e06e:	6813      	ldr	r3, [r2, #0]
 800e070:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800e074:	6013      	str	r3, [r2, #0]
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800e076:	e6df      	b.n	800de38 <HAL_RCC_OscConfig+0x50>
    PWR->CR1 |= PWR_CR1_DBP;
 800e078:	4d05      	ldr	r5, [pc, #20]	; (800e090 <HAL_RCC_OscConfig+0x2a8>)
 800e07a:	682b      	ldr	r3, [r5, #0]
 800e07c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800e080:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 800e082:	f7fc fe43 	bl	800ad0c <HAL_GetTick>
 800e086:	4606      	mov	r6, r0
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800e088:	e009      	b.n	800e09e <HAL_RCC_OscConfig+0x2b6>
 800e08a:	bf00      	nop
 800e08c:	58024400 	.word	0x58024400
 800e090:	58024800 	.word	0x58024800
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 800e094:	f7fc fe3a 	bl	800ad0c <HAL_GetTick>
 800e098:	1b80      	subs	r0, r0, r6
 800e09a:	2864      	cmp	r0, #100	; 0x64
 800e09c:	d825      	bhi.n	800e0ea <HAL_RCC_OscConfig+0x302>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800e09e:	682b      	ldr	r3, [r5, #0]
 800e0a0:	05da      	lsls	r2, r3, #23
 800e0a2:	d5f7      	bpl.n	800e094 <HAL_RCC_OscConfig+0x2ac>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800e0a4:	68a3      	ldr	r3, [r4, #8]
 800e0a6:	2b01      	cmp	r3, #1
 800e0a8:	f000 8158 	beq.w	800e35c <HAL_RCC_OscConfig+0x574>
 800e0ac:	2b00      	cmp	r3, #0
 800e0ae:	f000 812d 	beq.w	800e30c <HAL_RCC_OscConfig+0x524>
 800e0b2:	2b05      	cmp	r3, #5
 800e0b4:	4ba6      	ldr	r3, [pc, #664]	; (800e350 <HAL_RCC_OscConfig+0x568>)
 800e0b6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800e0b8:	f000 815f 	beq.w	800e37a <HAL_RCC_OscConfig+0x592>
 800e0bc:	f022 0201 	bic.w	r2, r2, #1
 800e0c0:	671a      	str	r2, [r3, #112]	; 0x70
 800e0c2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800e0c4:	f022 0204 	bic.w	r2, r2, #4
 800e0c8:	671a      	str	r2, [r3, #112]	; 0x70
      tickstart = HAL_GetTick();
 800e0ca:	f7fc fe1f 	bl	800ad0c <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800e0ce:	4ea0      	ldr	r6, [pc, #640]	; (800e350 <HAL_RCC_OscConfig+0x568>)
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800e0d0:	f241 3788 	movw	r7, #5000	; 0x1388
      tickstart = HAL_GetTick();
 800e0d4:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800e0d6:	e004      	b.n	800e0e2 <HAL_RCC_OscConfig+0x2fa>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800e0d8:	f7fc fe18 	bl	800ad0c <HAL_GetTick>
 800e0dc:	1b40      	subs	r0, r0, r5
 800e0de:	42b8      	cmp	r0, r7
 800e0e0:	d803      	bhi.n	800e0ea <HAL_RCC_OscConfig+0x302>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800e0e2:	6f33      	ldr	r3, [r6, #112]	; 0x70
 800e0e4:	079b      	lsls	r3, r3, #30
 800e0e6:	d5f7      	bpl.n	800e0d8 <HAL_RCC_OscConfig+0x2f0>
 800e0e8:	e723      	b.n	800df32 <HAL_RCC_OscConfig+0x14a>
            return HAL_TIMEOUT;
 800e0ea:	2003      	movs	r0, #3
}
 800e0ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800e0ee:	4d98      	ldr	r5, [pc, #608]	; (800e350 <HAL_RCC_OscConfig+0x568>)
 800e0f0:	682b      	ldr	r3, [r5, #0]
 800e0f2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800e0f6:	602b      	str	r3, [r5, #0]
 800e0f8:	682b      	ldr	r3, [r5, #0]
 800e0fa:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800e0fe:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800e100:	f7fc fe04 	bl	800ad0c <HAL_GetTick>
 800e104:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 800e106:	e004      	b.n	800e112 <HAL_RCC_OscConfig+0x32a>
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800e108:	f7fc fe00 	bl	800ad0c <HAL_GetTick>
 800e10c:	1b80      	subs	r0, r0, r6
 800e10e:	2864      	cmp	r0, #100	; 0x64
 800e110:	d8eb      	bhi.n	800e0ea <HAL_RCC_OscConfig+0x302>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 800e112:	682b      	ldr	r3, [r5, #0]
 800e114:	039f      	lsls	r7, r3, #14
 800e116:	d4f7      	bmi.n	800e108 <HAL_RCC_OscConfig+0x320>
 800e118:	e69c      	b.n	800de54 <HAL_RCC_OscConfig+0x6c>
      __HAL_RCC_LSI_DISABLE();
 800e11a:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800e11c:	f023 0301 	bic.w	r3, r3, #1
 800e120:	676b      	str	r3, [r5, #116]	; 0x74
      tickstart = HAL_GetTick();
 800e122:	f7fc fdf3 	bl	800ad0c <HAL_GetTick>
 800e126:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 800e128:	e004      	b.n	800e134 <HAL_RCC_OscConfig+0x34c>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800e12a:	f7fc fdef 	bl	800ad0c <HAL_GetTick>
 800e12e:	1b80      	subs	r0, r0, r6
 800e130:	2802      	cmp	r0, #2
 800e132:	d8da      	bhi.n	800e0ea <HAL_RCC_OscConfig+0x302>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 800e134:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800e136:	0799      	lsls	r1, r3, #30
 800e138:	d4f7      	bmi.n	800e12a <HAL_RCC_OscConfig+0x342>
 800e13a:	e6dd      	b.n	800def8 <HAL_RCC_OscConfig+0x110>
      __HAL_RCC_HSI48_DISABLE();
 800e13c:	682b      	ldr	r3, [r5, #0]
 800e13e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800e142:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 800e144:	f7fc fde2 	bl	800ad0c <HAL_GetTick>
 800e148:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 800e14a:	e004      	b.n	800e156 <HAL_RCC_OscConfig+0x36e>
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
 800e14c:	f7fc fdde 	bl	800ad0c <HAL_GetTick>
 800e150:	1b80      	subs	r0, r0, r6
 800e152:	2802      	cmp	r0, #2
 800e154:	d8c9      	bhi.n	800e0ea <HAL_RCC_OscConfig+0x302>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 800e156:	682b      	ldr	r3, [r5, #0]
 800e158:	0498      	lsls	r0, r3, #18
 800e15a:	d4f7      	bmi.n	800e14c <HAL_RCC_OscConfig+0x364>
 800e15c:	e6e5      	b.n	800df2a <HAL_RCC_OscConfig+0x142>
        __HAL_RCC_CSI_DISABLE();
 800e15e:	682b      	ldr	r3, [r5, #0]
 800e160:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800e164:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800e166:	f7fc fdd1 	bl	800ad0c <HAL_GetTick>
 800e16a:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 800e16c:	e004      	b.n	800e178 <HAL_RCC_OscConfig+0x390>
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
 800e16e:	f7fc fdcd 	bl	800ad0c <HAL_GetTick>
 800e172:	1b80      	subs	r0, r0, r6
 800e174:	2802      	cmp	r0, #2
 800e176:	d8b8      	bhi.n	800e0ea <HAL_RCC_OscConfig+0x302>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 800e178:	682b      	ldr	r3, [r5, #0]
 800e17a:	05df      	lsls	r7, r3, #23
 800e17c:	d4f7      	bmi.n	800e16e <HAL_RCC_OscConfig+0x386>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800e17e:	6823      	ldr	r3, [r4, #0]
 800e180:	e6a2      	b.n	800dec8 <HAL_RCC_OscConfig+0xe0>
        __HAL_RCC_HSI_DISABLE();
 800e182:	f023 0301 	bic.w	r3, r3, #1
 800e186:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800e188:	f7fc fdc0 	bl	800ad0c <HAL_GetTick>
 800e18c:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 800e18e:	e004      	b.n	800e19a <HAL_RCC_OscConfig+0x3b2>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800e190:	f7fc fdbc 	bl	800ad0c <HAL_GetTick>
 800e194:	1b80      	subs	r0, r0, r6
 800e196:	2802      	cmp	r0, #2
 800e198:	d8a7      	bhi.n	800e0ea <HAL_RCC_OscConfig+0x302>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 800e19a:	682b      	ldr	r3, [r5, #0]
 800e19c:	0758      	lsls	r0, r3, #29
 800e19e:	d4f7      	bmi.n	800e190 <HAL_RCC_OscConfig+0x3a8>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
 800e1a0:	6823      	ldr	r3, [r4, #0]
 800e1a2:	e65b      	b.n	800de5c <HAL_RCC_OscConfig+0x74>
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 800e1a4:	0790      	lsls	r0, r2, #30
 800e1a6:	f47f af1a 	bne.w	800dfde <HAL_RCC_OscConfig+0x1f6>
 800e1aa:	e6e7      	b.n	800df7c <HAL_RCC_OscConfig+0x194>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800e1ac:	686b      	ldr	r3, [r5, #4]
 800e1ae:	6922      	ldr	r2, [r4, #16]
 800e1b0:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 800e1b4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800e1b8:	606b      	str	r3, [r5, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
 800e1ba:	6823      	ldr	r3, [r4, #0]
 800e1bc:	e64e      	b.n	800de5c <HAL_RCC_OscConfig+0x74>
    return HAL_ERROR;
 800e1be:	2001      	movs	r0, #1
}
 800e1c0:	4770      	bx	lr
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800e1c2:	4a63      	ldr	r2, [pc, #396]	; (800e350 <HAL_RCC_OscConfig+0x568>)
 800e1c4:	6a21      	ldr	r1, [r4, #32]
 800e1c6:	68d3      	ldr	r3, [r2, #12]
 800e1c8:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
 800e1cc:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800e1d0:	60d3      	str	r3, [r2, #12]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800e1d2:	6823      	ldr	r3, [r4, #0]
 800e1d4:	e678      	b.n	800dec8 <HAL_RCC_OscConfig+0xe0>
        tickstart = HAL_GetTick();
 800e1d6:	f7fc fd99 	bl	800ad0c <HAL_GetTick>
 800e1da:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800e1dc:	e004      	b.n	800e1e8 <HAL_RCC_OscConfig+0x400>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800e1de:	f7fc fd95 	bl	800ad0c <HAL_GetTick>
 800e1e2:	1b80      	subs	r0, r0, r6
 800e1e4:	2802      	cmp	r0, #2
 800e1e6:	d880      	bhi.n	800e0ea <HAL_RCC_OscConfig+0x302>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800e1e8:	682b      	ldr	r3, [r5, #0]
 800e1ea:	0199      	lsls	r1, r3, #6
 800e1ec:	d4f7      	bmi.n	800e1de <HAL_RCC_OscConfig+0x3f6>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800e1ee:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 800e1f0:	4b58      	ldr	r3, [pc, #352]	; (800e354 <HAL_RCC_OscConfig+0x56c>)
 800e1f2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800e1f4:	400b      	ands	r3, r1
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 800e1f6:	4958      	ldr	r1, [pc, #352]	; (800e358 <HAL_RCC_OscConfig+0x570>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800e1f8:	4e55      	ldr	r6, [pc, #340]	; (800e350 <HAL_RCC_OscConfig+0x568>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800e1fa:	4313      	orrs	r3, r2
 800e1fc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800e1fe:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 800e202:	62ab      	str	r3, [r5, #40]	; 0x28
 800e204:	e9d4 320d 	ldrd	r3, r2, [r4, #52]	; 0x34
 800e208:	3b01      	subs	r3, #1
 800e20a:	3a01      	subs	r2, #1
 800e20c:	025b      	lsls	r3, r3, #9
 800e20e:	0412      	lsls	r2, r2, #16
 800e210:	b29b      	uxth	r3, r3
 800e212:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
 800e216:	4313      	orrs	r3, r2
 800e218:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800e21a:	3a01      	subs	r2, #1
 800e21c:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800e220:	4313      	orrs	r3, r2
 800e222:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800e224:	3a01      	subs	r2, #1
 800e226:	0612      	lsls	r2, r2, #24
 800e228:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
 800e22c:	4313      	orrs	r3, r2
 800e22e:	632b      	str	r3, [r5, #48]	; 0x30
         __HAL_RCC_PLLFRACN_DISABLE();
 800e230:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800e232:	f023 0301 	bic.w	r3, r3, #1
 800e236:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 800e238:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 800e23a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800e23c:	4011      	ands	r1, r2
 800e23e:	ea41 01c3 	orr.w	r1, r1, r3, lsl #3
 800e242:	6369      	str	r1, [r5, #52]	; 0x34
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
 800e244:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800e246:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800e248:	f023 030c 	bic.w	r3, r3, #12
 800e24c:	4313      	orrs	r3, r2
 800e24e:	62eb      	str	r3, [r5, #44]	; 0x2c
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
 800e250:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800e252:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800e254:	f023 0302 	bic.w	r3, r3, #2
 800e258:	4313      	orrs	r3, r2
 800e25a:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 800e25c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800e25e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800e262:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800e264:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800e266:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800e26a:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
 800e26c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800e26e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800e272:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLFRACN_ENABLE();
 800e274:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800e276:	f043 0301 	orr.w	r3, r3, #1
 800e27a:	62eb      	str	r3, [r5, #44]	; 0x2c
        __HAL_RCC_PLL_ENABLE();
 800e27c:	682b      	ldr	r3, [r5, #0]
 800e27e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800e282:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800e284:	f7fc fd42 	bl	800ad0c <HAL_GetTick>
 800e288:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800e28a:	e005      	b.n	800e298 <HAL_RCC_OscConfig+0x4b0>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800e28c:	f7fc fd3e 	bl	800ad0c <HAL_GetTick>
 800e290:	1b00      	subs	r0, r0, r4
 800e292:	2802      	cmp	r0, #2
 800e294:	f63f af29 	bhi.w	800e0ea <HAL_RCC_OscConfig+0x302>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800e298:	6833      	ldr	r3, [r6, #0]
 800e29a:	019a      	lsls	r2, r3, #6
 800e29c:	d5f6      	bpl.n	800e28c <HAL_RCC_OscConfig+0x4a4>
 800e29e:	e665      	b.n	800df6c <HAL_RCC_OscConfig+0x184>
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800e2a0:	2801      	cmp	r0, #1
      temp1_pllckcfg = RCC->PLLCKSELR;
 800e2a2:	6aaa      	ldr	r2, [r5, #40]	; 0x28
      temp2_pllckcfg = RCC->PLL1DIVR;
 800e2a4:	6b2d      	ldr	r5, [r5, #48]	; 0x30
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800e2a6:	f43f ae62 	beq.w	800df6e <HAL_RCC_OscConfig+0x186>
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800e2aa:	f002 0303 	and.w	r3, r2, #3
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800e2ae:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800e2b0:	428b      	cmp	r3, r1
 800e2b2:	f47f aeb9 	bne.w	800e028 <HAL_RCC_OscConfig+0x240>
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 800e2b6:	f3c2 1205 	ubfx	r2, r2, #4, #6
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800e2ba:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800e2bc:	429a      	cmp	r2, r3
 800e2be:	f47f aeb3 	bne.w	800e028 <HAL_RCC_OscConfig+0x240>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 800e2c2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800e2c4:	f3c5 0208 	ubfx	r2, r5, #0, #9
 800e2c8:	3b01      	subs	r3, #1
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 800e2ca:	429a      	cmp	r2, r3
 800e2cc:	f47f aeac 	bne.w	800e028 <HAL_RCC_OscConfig+0x240>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 800e2d0:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800e2d2:	f3c5 2246 	ubfx	r2, r5, #9, #7
 800e2d6:	3b01      	subs	r3, #1
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 800e2d8:	429a      	cmp	r2, r3
 800e2da:	f47f aea5 	bne.w	800e028 <HAL_RCC_OscConfig+0x240>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 800e2de:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800e2e0:	f3c5 4206 	ubfx	r2, r5, #16, #7
 800e2e4:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 800e2e6:	429a      	cmp	r2, r3
 800e2e8:	f47f ae9e 	bne.w	800e028 <HAL_RCC_OscConfig+0x240>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
 800e2ec:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 800e2ee:	f3c5 6506 	ubfx	r5, r5, #24, #7
 800e2f2:	3801      	subs	r0, #1
  return HAL_OK;
 800e2f4:	1a28      	subs	r0, r5, r0
 800e2f6:	bf18      	it	ne
 800e2f8:	2001      	movne	r0, #1
}
 800e2fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800e2fc:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800e300:	601a      	str	r2, [r3, #0]
 800e302:	681a      	ldr	r2, [r3, #0]
 800e304:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800e308:	601a      	str	r2, [r3, #0]
 800e30a:	e595      	b.n	800de38 <HAL_RCC_OscConfig+0x50>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800e30c:	4d10      	ldr	r5, [pc, #64]	; (800e350 <HAL_RCC_OscConfig+0x568>)
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800e30e:	f241 3788 	movw	r7, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800e312:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800e314:	f023 0301 	bic.w	r3, r3, #1
 800e318:	672b      	str	r3, [r5, #112]	; 0x70
 800e31a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800e31c:	f023 0304 	bic.w	r3, r3, #4
 800e320:	672b      	str	r3, [r5, #112]	; 0x70
      tickstart = HAL_GetTick();
 800e322:	f7fc fcf3 	bl	800ad0c <HAL_GetTick>
 800e326:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 800e328:	e005      	b.n	800e336 <HAL_RCC_OscConfig+0x54e>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800e32a:	f7fc fcef 	bl	800ad0c <HAL_GetTick>
 800e32e:	1b80      	subs	r0, r0, r6
 800e330:	42b8      	cmp	r0, r7
 800e332:	f63f aeda 	bhi.w	800e0ea <HAL_RCC_OscConfig+0x302>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 800e336:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800e338:	0798      	lsls	r0, r3, #30
 800e33a:	d4f6      	bmi.n	800e32a <HAL_RCC_OscConfig+0x542>
 800e33c:	e5f9      	b.n	800df32 <HAL_RCC_OscConfig+0x14a>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800e33e:	68eb      	ldr	r3, [r5, #12]
 800e340:	6a22      	ldr	r2, [r4, #32]
 800e342:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
 800e346:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800e34a:	60eb      	str	r3, [r5, #12]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800e34c:	6823      	ldr	r3, [r4, #0]
 800e34e:	e5bb      	b.n	800dec8 <HAL_RCC_OscConfig+0xe0>
 800e350:	58024400 	.word	0x58024400
 800e354:	fffffc0c 	.word	0xfffffc0c
 800e358:	ffff0007 	.word	0xffff0007
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800e35c:	4a0b      	ldr	r2, [pc, #44]	; (800e38c <HAL_RCC_OscConfig+0x5a4>)
 800e35e:	6f13      	ldr	r3, [r2, #112]	; 0x70
 800e360:	f043 0301 	orr.w	r3, r3, #1
 800e364:	6713      	str	r3, [r2, #112]	; 0x70
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800e366:	e6b0      	b.n	800e0ca <HAL_RCC_OscConfig+0x2e2>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800e368:	4a08      	ldr	r2, [pc, #32]	; (800e38c <HAL_RCC_OscConfig+0x5a4>)
 800e36a:	6853      	ldr	r3, [r2, #4]
 800e36c:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 800e370:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800e374:	6053      	str	r3, [r2, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800e376:	6823      	ldr	r3, [r4, #0]
 800e378:	e5a6      	b.n	800dec8 <HAL_RCC_OscConfig+0xe0>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800e37a:	f042 0204 	orr.w	r2, r2, #4
 800e37e:	671a      	str	r2, [r3, #112]	; 0x70
 800e380:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800e382:	f042 0201 	orr.w	r2, r2, #1
 800e386:	671a      	str	r2, [r3, #112]	; 0x70
 800e388:	e69f      	b.n	800e0ca <HAL_RCC_OscConfig+0x2e2>
 800e38a:	bf00      	nop
 800e38c:	58024400 	.word	0x58024400

0800e390 <HAL_RCC_GetSysClockFreq>:
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800e390:	4a47      	ldr	r2, [pc, #284]	; (800e4b0 <HAL_RCC_GetSysClockFreq+0x120>)
 800e392:	6913      	ldr	r3, [r2, #16]
 800e394:	f003 0338 	and.w	r3, r3, #56	; 0x38
 800e398:	2b10      	cmp	r3, #16
 800e39a:	d004      	beq.n	800e3a6 <HAL_RCC_GetSysClockFreq+0x16>
 800e39c:	2b18      	cmp	r3, #24
 800e39e:	d00d      	beq.n	800e3bc <HAL_RCC_GetSysClockFreq+0x2c>
 800e3a0:	b11b      	cbz	r3, 800e3aa <HAL_RCC_GetSysClockFreq+0x1a>
    sysclockfreq = CSI_VALUE;
 800e3a2:	4844      	ldr	r0, [pc, #272]	; (800e4b4 <HAL_RCC_GetSysClockFreq+0x124>)
 800e3a4:	4770      	bx	lr
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800e3a6:	4844      	ldr	r0, [pc, #272]	; (800e4b8 <HAL_RCC_GetSysClockFreq+0x128>)
 800e3a8:	4770      	bx	lr
   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800e3aa:	6813      	ldr	r3, [r2, #0]
 800e3ac:	0699      	lsls	r1, r3, #26
 800e3ae:	d54a      	bpl.n	800e446 <HAL_RCC_GetSysClockFreq+0xb6>
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800e3b0:	6813      	ldr	r3, [r2, #0]
 800e3b2:	4842      	ldr	r0, [pc, #264]	; (800e4bc <HAL_RCC_GetSysClockFreq+0x12c>)
 800e3b4:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 800e3b8:	40d8      	lsrs	r0, r3
 800e3ba:	4770      	bx	lr
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800e3bc:	6a93      	ldr	r3, [r2, #40]	; 0x28
{
 800e3be:	b430      	push	{r4, r5}
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 800e3c0:	6a94      	ldr	r4, [r2, #40]	; 0x28
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 800e3c2:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
    if (pllm != 0U)
 800e3c4:	f414 7f7c 	tst.w	r4, #1008	; 0x3f0
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 800e3c8:	6b51      	ldr	r1, [r2, #52]	; 0x34
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 800e3ca:	f3c4 1005 	ubfx	r0, r4, #4, #6
    if (pllm != 0U)
 800e3ce:	d038      	beq.n	800e442 <HAL_RCC_GetSysClockFreq+0xb2>
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 800e3d0:	f3c1 01cc 	ubfx	r1, r1, #3, #13
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 800e3d4:	f005 0501 	and.w	r5, r5, #1
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800e3d8:	f003 0303 	and.w	r3, r3, #3
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 800e3dc:	fb05 f101 	mul.w	r1, r5, r1
 800e3e0:	2b01      	cmp	r3, #1
 800e3e2:	ee07 1a90 	vmov	s15, r1
 800e3e6:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
      switch (pllsource)
 800e3ea:	d002      	beq.n	800e3f2 <HAL_RCC_GetSysClockFreq+0x62>
 800e3ec:	2b02      	cmp	r3, #2
 800e3ee:	d02c      	beq.n	800e44a <HAL_RCC_GetSysClockFreq+0xba>
 800e3f0:	b393      	cbz	r3, 800e458 <HAL_RCC_GetSysClockFreq+0xc8>
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800e3f2:	ee07 0a90 	vmov	s15, r0
 800e3f6:	eddf 6a32 	vldr	s13, [pc, #200]	; 800e4c0 <HAL_RCC_GetSysClockFreq+0x130>
 800e3fa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800e3fe:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800e400:	ee86 6aa7 	vdiv.f32	s12, s13, s15
 800e404:	eddf 5a2f 	vldr	s11, [pc, #188]	; 800e4c4 <HAL_RCC_GetSysClockFreq+0x134>
 800e408:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800e40c:	ee06 3a90 	vmov	s13, r3
 800e410:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 800e414:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800e418:	ee76 6a85 	vadd.f32	s13, s13, s10
 800e41c:	eee7 6a25 	vfma.f32	s13, s14, s11
 800e420:	ee66 6a26 	vmul.f32	s13, s12, s13
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
 800e424:	4b22      	ldr	r3, [pc, #136]	; (800e4b0 <HAL_RCC_GetSysClockFreq+0x120>)
 800e426:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e428:	f3c3 2346 	ubfx	r3, r3, #9, #7
 800e42c:	3301      	adds	r3, #1
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
 800e42e:	ee07 3a90 	vmov	s15, r3
 800e432:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800e436:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800e43a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800e43e:	ee17 0a90 	vmov	r0, s15
}
 800e442:	bc30      	pop	{r4, r5}
 800e444:	4770      	bx	lr
        sysclockfreq = (uint32_t) HSI_VALUE;
 800e446:	481d      	ldr	r0, [pc, #116]	; (800e4bc <HAL_RCC_GetSysClockFreq+0x12c>)
}
 800e448:	4770      	bx	lr
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800e44a:	ee07 0a90 	vmov	s15, r0
 800e44e:	eddf 6a1e 	vldr	s13, [pc, #120]	; 800e4c8 <HAL_RCC_GetSysClockFreq+0x138>
 800e452:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800e456:	e7d2      	b.n	800e3fe <HAL_RCC_GetSysClockFreq+0x6e>
       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800e458:	6813      	ldr	r3, [r2, #0]
 800e45a:	069b      	lsls	r3, r3, #26
 800e45c:	d520      	bpl.n	800e4a0 <HAL_RCC_GetSysClockFreq+0x110>
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800e45e:	6814      	ldr	r4, [r2, #0]
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800e460:	ee07 0a90 	vmov	s15, r0
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800e464:	4915      	ldr	r1, [pc, #84]	; (800e4bc <HAL_RCC_GetSysClockFreq+0x12c>)
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800e466:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 800e46a:	6b13      	ldr	r3, [r2, #48]	; 0x30
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800e46c:	f3c4 04c1 	ubfx	r4, r4, #3, #2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800e470:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800e474:	ed9f 5a13 	vldr	s10, [pc, #76]	; 800e4c4 <HAL_RCC_GetSysClockFreq+0x134>
 800e478:	f3c3 0308 	ubfx	r3, r3, #0, #9
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800e47c:	40e1      	lsrs	r1, r4
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800e47e:	ee06 3a90 	vmov	s13, r3
 800e482:	ee05 1a90 	vmov	s11, r1
 800e486:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800e48a:	eef8 5ae5 	vcvt.f32.s32	s11, s11
 800e48e:	ee76 6a86 	vadd.f32	s13, s13, s12
 800e492:	ee85 6aa7 	vdiv.f32	s12, s11, s15
 800e496:	eee7 6a05 	vfma.f32	s13, s14, s10
 800e49a:	ee66 6a26 	vmul.f32	s13, s12, s13
 800e49e:	e7c1      	b.n	800e424 <HAL_RCC_GetSysClockFreq+0x94>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800e4a0:	ee07 0a90 	vmov	s15, r0
 800e4a4:	eddf 6a09 	vldr	s13, [pc, #36]	; 800e4cc <HAL_RCC_GetSysClockFreq+0x13c>
 800e4a8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800e4ac:	e7a7      	b.n	800e3fe <HAL_RCC_GetSysClockFreq+0x6e>
 800e4ae:	bf00      	nop
 800e4b0:	58024400 	.word	0x58024400
 800e4b4:	003d0900 	.word	0x003d0900
 800e4b8:	007a1200 	.word	0x007a1200
 800e4bc:	03d09000 	.word	0x03d09000
 800e4c0:	4a742400 	.word	0x4a742400
 800e4c4:	39000000 	.word	0x39000000
 800e4c8:	4af42400 	.word	0x4af42400
 800e4cc:	4c742400 	.word	0x4c742400

0800e4d0 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 800e4d0:	2800      	cmp	r0, #0
 800e4d2:	f000 810c 	beq.w	800e6ee <HAL_RCC_ClockConfig+0x21e>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800e4d6:	4a8c      	ldr	r2, [pc, #560]	; (800e708 <HAL_RCC_ClockConfig+0x238>)
 800e4d8:	6813      	ldr	r3, [r2, #0]
 800e4da:	f003 030f 	and.w	r3, r3, #15
 800e4de:	428b      	cmp	r3, r1
{
 800e4e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e4e4:	4604      	mov	r4, r0
 800e4e6:	460d      	mov	r5, r1
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800e4e8:	d20c      	bcs.n	800e504 <HAL_RCC_ClockConfig+0x34>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800e4ea:	6813      	ldr	r3, [r2, #0]
 800e4ec:	f023 030f 	bic.w	r3, r3, #15
 800e4f0:	430b      	orrs	r3, r1
 800e4f2:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800e4f4:	6813      	ldr	r3, [r2, #0]
 800e4f6:	f003 030f 	and.w	r3, r3, #15
 800e4fa:	428b      	cmp	r3, r1
 800e4fc:	d002      	beq.n	800e504 <HAL_RCC_ClockConfig+0x34>
    return HAL_ERROR;
 800e4fe:	2001      	movs	r0, #1
}
 800e500:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 800e504:	6823      	ldr	r3, [r4, #0]
 800e506:	075f      	lsls	r7, r3, #29
 800e508:	d50b      	bpl.n	800e522 <HAL_RCC_ClockConfig+0x52>
    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 800e50a:	4980      	ldr	r1, [pc, #512]	; (800e70c <HAL_RCC_ClockConfig+0x23c>)
 800e50c:	6920      	ldr	r0, [r4, #16]
 800e50e:	698a      	ldr	r2, [r1, #24]
 800e510:	f002 0270 	and.w	r2, r2, #112	; 0x70
 800e514:	4290      	cmp	r0, r2
 800e516:	d904      	bls.n	800e522 <HAL_RCC_ClockConfig+0x52>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 800e518:	698a      	ldr	r2, [r1, #24]
 800e51a:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 800e51e:	4302      	orrs	r2, r0
 800e520:	618a      	str	r2, [r1, #24]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800e522:	071e      	lsls	r6, r3, #28
 800e524:	d50b      	bpl.n	800e53e <HAL_RCC_ClockConfig+0x6e>
    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 800e526:	4979      	ldr	r1, [pc, #484]	; (800e70c <HAL_RCC_ClockConfig+0x23c>)
 800e528:	6960      	ldr	r0, [r4, #20]
 800e52a:	69ca      	ldr	r2, [r1, #28]
 800e52c:	f002 0270 	and.w	r2, r2, #112	; 0x70
 800e530:	4290      	cmp	r0, r2
 800e532:	d904      	bls.n	800e53e <HAL_RCC_ClockConfig+0x6e>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 800e534:	69ca      	ldr	r2, [r1, #28]
 800e536:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 800e53a:	4302      	orrs	r2, r0
 800e53c:	61ca      	str	r2, [r1, #28]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800e53e:	06d8      	lsls	r0, r3, #27
 800e540:	d50b      	bpl.n	800e55a <HAL_RCC_ClockConfig+0x8a>
    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 800e542:	4972      	ldr	r1, [pc, #456]	; (800e70c <HAL_RCC_ClockConfig+0x23c>)
 800e544:	69a0      	ldr	r0, [r4, #24]
 800e546:	69ca      	ldr	r2, [r1, #28]
 800e548:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 800e54c:	4290      	cmp	r0, r2
 800e54e:	d904      	bls.n	800e55a <HAL_RCC_ClockConfig+0x8a>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 800e550:	69ca      	ldr	r2, [r1, #28]
 800e552:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 800e556:	4302      	orrs	r2, r0
 800e558:	61ca      	str	r2, [r1, #28]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 800e55a:	0699      	lsls	r1, r3, #26
 800e55c:	d50b      	bpl.n	800e576 <HAL_RCC_ClockConfig+0xa6>
    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 800e55e:	496b      	ldr	r1, [pc, #428]	; (800e70c <HAL_RCC_ClockConfig+0x23c>)
 800e560:	69e0      	ldr	r0, [r4, #28]
 800e562:	6a0a      	ldr	r2, [r1, #32]
 800e564:	f002 0270 	and.w	r2, r2, #112	; 0x70
 800e568:	4290      	cmp	r0, r2
 800e56a:	d904      	bls.n	800e576 <HAL_RCC_ClockConfig+0xa6>
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
 800e56c:	6a0a      	ldr	r2, [r1, #32]
 800e56e:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 800e572:	4302      	orrs	r2, r0
 800e574:	620a      	str	r2, [r1, #32]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800e576:	079a      	lsls	r2, r3, #30
 800e578:	f140 80ab 	bpl.w	800e6d2 <HAL_RCC_ClockConfig+0x202>
    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 800e57c:	4863      	ldr	r0, [pc, #396]	; (800e70c <HAL_RCC_ClockConfig+0x23c>)
 800e57e:	68e1      	ldr	r1, [r4, #12]
 800e580:	6982      	ldr	r2, [r0, #24]
 800e582:	f002 020f 	and.w	r2, r2, #15
 800e586:	4291      	cmp	r1, r2
 800e588:	d904      	bls.n	800e594 <HAL_RCC_ClockConfig+0xc4>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800e58a:	6982      	ldr	r2, [r0, #24]
 800e58c:	f022 020f 	bic.w	r2, r2, #15
 800e590:	430a      	orrs	r2, r1
 800e592:	6182      	str	r2, [r0, #24]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800e594:	07d8      	lsls	r0, r3, #31
 800e596:	d530      	bpl.n	800e5fa <HAL_RCC_ClockConfig+0x12a>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
 800e598:	4a5c      	ldr	r2, [pc, #368]	; (800e70c <HAL_RCC_ClockConfig+0x23c>)
 800e59a:	68a1      	ldr	r1, [r4, #8]
 800e59c:	6993      	ldr	r3, [r2, #24]
 800e59e:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 800e5a2:	430b      	orrs	r3, r1
 800e5a4:	6193      	str	r3, [r2, #24]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800e5a6:	6861      	ldr	r1, [r4, #4]
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800e5a8:	6813      	ldr	r3, [r2, #0]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800e5aa:	2902      	cmp	r1, #2
 800e5ac:	f000 80a1 	beq.w	800e6f2 <HAL_RCC_ClockConfig+0x222>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800e5b0:	2903      	cmp	r1, #3
 800e5b2:	f000 8098 	beq.w	800e6e6 <HAL_RCC_ClockConfig+0x216>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
 800e5b6:	2901      	cmp	r1, #1
 800e5b8:	f000 80a1 	beq.w	800e6fe <HAL_RCC_ClockConfig+0x22e>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800e5bc:	0758      	lsls	r0, r3, #29
 800e5be:	d59e      	bpl.n	800e4fe <HAL_RCC_ClockConfig+0x2e>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 800e5c0:	4e52      	ldr	r6, [pc, #328]	; (800e70c <HAL_RCC_ClockConfig+0x23c>)
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800e5c2:	f241 3888 	movw	r8, #5000	; 0x1388
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 800e5c6:	6933      	ldr	r3, [r6, #16]
 800e5c8:	f023 0307 	bic.w	r3, r3, #7
 800e5cc:	430b      	orrs	r3, r1
 800e5ce:	6133      	str	r3, [r6, #16]
      tickstart = HAL_GetTick();
 800e5d0:	f7fc fb9c 	bl	800ad0c <HAL_GetTick>
 800e5d4:	4607      	mov	r7, r0
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800e5d6:	e005      	b.n	800e5e4 <HAL_RCC_ClockConfig+0x114>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800e5d8:	f7fc fb98 	bl	800ad0c <HAL_GetTick>
 800e5dc:	1bc0      	subs	r0, r0, r7
 800e5de:	4540      	cmp	r0, r8
 800e5e0:	f200 808b 	bhi.w	800e6fa <HAL_RCC_ClockConfig+0x22a>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800e5e4:	6933      	ldr	r3, [r6, #16]
 800e5e6:	6862      	ldr	r2, [r4, #4]
 800e5e8:	f003 0338 	and.w	r3, r3, #56	; 0x38
 800e5ec:	ebb3 0fc2 	cmp.w	r3, r2, lsl #3
 800e5f0:	d1f2      	bne.n	800e5d8 <HAL_RCC_ClockConfig+0x108>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800e5f2:	6823      	ldr	r3, [r4, #0]
 800e5f4:	0799      	lsls	r1, r3, #30
 800e5f6:	d506      	bpl.n	800e606 <HAL_RCC_ClockConfig+0x136>
    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 800e5f8:	68e1      	ldr	r1, [r4, #12]
 800e5fa:	4844      	ldr	r0, [pc, #272]	; (800e70c <HAL_RCC_ClockConfig+0x23c>)
 800e5fc:	6982      	ldr	r2, [r0, #24]
 800e5fe:	f002 020f 	and.w	r2, r2, #15
 800e602:	428a      	cmp	r2, r1
 800e604:	d869      	bhi.n	800e6da <HAL_RCC_ClockConfig+0x20a>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800e606:	4940      	ldr	r1, [pc, #256]	; (800e708 <HAL_RCC_ClockConfig+0x238>)
 800e608:	680a      	ldr	r2, [r1, #0]
 800e60a:	f002 020f 	and.w	r2, r2, #15
 800e60e:	42aa      	cmp	r2, r5
 800e610:	d90a      	bls.n	800e628 <HAL_RCC_ClockConfig+0x158>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800e612:	680a      	ldr	r2, [r1, #0]
 800e614:	f022 020f 	bic.w	r2, r2, #15
 800e618:	432a      	orrs	r2, r5
 800e61a:	600a      	str	r2, [r1, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800e61c:	680a      	ldr	r2, [r1, #0]
 800e61e:	f002 020f 	and.w	r2, r2, #15
 800e622:	42aa      	cmp	r2, r5
 800e624:	f47f af6b 	bne.w	800e4fe <HAL_RCC_ClockConfig+0x2e>
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 800e628:	075a      	lsls	r2, r3, #29
 800e62a:	d50b      	bpl.n	800e644 <HAL_RCC_ClockConfig+0x174>
   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 800e62c:	4937      	ldr	r1, [pc, #220]	; (800e70c <HAL_RCC_ClockConfig+0x23c>)
 800e62e:	6920      	ldr	r0, [r4, #16]
 800e630:	698a      	ldr	r2, [r1, #24]
 800e632:	f002 0270 	and.w	r2, r2, #112	; 0x70
 800e636:	4290      	cmp	r0, r2
 800e638:	d204      	bcs.n	800e644 <HAL_RCC_ClockConfig+0x174>
     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 800e63a:	698a      	ldr	r2, [r1, #24]
 800e63c:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 800e640:	4302      	orrs	r2, r0
 800e642:	618a      	str	r2, [r1, #24]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800e644:	071f      	lsls	r7, r3, #28
 800e646:	d50b      	bpl.n	800e660 <HAL_RCC_ClockConfig+0x190>
   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 800e648:	4930      	ldr	r1, [pc, #192]	; (800e70c <HAL_RCC_ClockConfig+0x23c>)
 800e64a:	6960      	ldr	r0, [r4, #20]
 800e64c:	69ca      	ldr	r2, [r1, #28]
 800e64e:	f002 0270 	and.w	r2, r2, #112	; 0x70
 800e652:	4290      	cmp	r0, r2
 800e654:	d204      	bcs.n	800e660 <HAL_RCC_ClockConfig+0x190>
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 800e656:	69ca      	ldr	r2, [r1, #28]
 800e658:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 800e65c:	4302      	orrs	r2, r0
 800e65e:	61ca      	str	r2, [r1, #28]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800e660:	06de      	lsls	r6, r3, #27
 800e662:	d50b      	bpl.n	800e67c <HAL_RCC_ClockConfig+0x1ac>
   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 800e664:	4929      	ldr	r1, [pc, #164]	; (800e70c <HAL_RCC_ClockConfig+0x23c>)
 800e666:	69a0      	ldr	r0, [r4, #24]
 800e668:	69ca      	ldr	r2, [r1, #28]
 800e66a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 800e66e:	4290      	cmp	r0, r2
 800e670:	d204      	bcs.n	800e67c <HAL_RCC_ClockConfig+0x1ac>
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 800e672:	69ca      	ldr	r2, [r1, #28]
 800e674:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 800e678:	4302      	orrs	r2, r0
 800e67a:	61ca      	str	r2, [r1, #28]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 800e67c:	069d      	lsls	r5, r3, #26
 800e67e:	d50b      	bpl.n	800e698 <HAL_RCC_ClockConfig+0x1c8>
   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 800e680:	4a22      	ldr	r2, [pc, #136]	; (800e70c <HAL_RCC_ClockConfig+0x23c>)
 800e682:	69e1      	ldr	r1, [r4, #28]
 800e684:	6a13      	ldr	r3, [r2, #32]
 800e686:	f003 0370 	and.w	r3, r3, #112	; 0x70
 800e68a:	4299      	cmp	r1, r3
 800e68c:	d204      	bcs.n	800e698 <HAL_RCC_ClockConfig+0x1c8>
     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
 800e68e:	6a13      	ldr	r3, [r2, #32]
 800e690:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800e694:	430b      	orrs	r3, r1
 800e696:	6213      	str	r3, [r2, #32]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800e698:	f7ff fe7a 	bl	800e390 <HAL_RCC_GetSysClockFreq>
 800e69c:	4a1b      	ldr	r2, [pc, #108]	; (800e70c <HAL_RCC_ClockConfig+0x23c>)
 800e69e:	4603      	mov	r3, r0
 800e6a0:	481b      	ldr	r0, [pc, #108]	; (800e710 <HAL_RCC_ClockConfig+0x240>)
 800e6a2:	6991      	ldr	r1, [r2, #24]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800e6a4:	6992      	ldr	r2, [r2, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800e6a6:	f3c1 2103 	ubfx	r1, r1, #8, #4
  SystemCoreClock = common_system_clock;
 800e6aa:	4d1a      	ldr	r5, [pc, #104]	; (800e714 <HAL_RCC_ClockConfig+0x244>)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800e6ac:	f002 020f 	and.w	r2, r2, #15
 800e6b0:	4c19      	ldr	r4, [pc, #100]	; (800e718 <HAL_RCC_ClockConfig+0x248>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800e6b2:	5c41      	ldrb	r1, [r0, r1]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800e6b4:	5c82      	ldrb	r2, [r0, r2]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800e6b6:	f001 011f 	and.w	r1, r1, #31
  halstatus = HAL_InitTick (uwTickPrio);
 800e6ba:	4818      	ldr	r0, [pc, #96]	; (800e71c <HAL_RCC_ClockConfig+0x24c>)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800e6bc:	f002 021f 	and.w	r2, r2, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 800e6c0:	40cb      	lsrs	r3, r1
  halstatus = HAL_InitTick (uwTickPrio);
 800e6c2:	6800      	ldr	r0, [r0, #0]
  SystemCoreClock = common_system_clock;
 800e6c4:	602b      	str	r3, [r5, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800e6c6:	40d3      	lsrs	r3, r2
 800e6c8:	6023      	str	r3, [r4, #0]
}
 800e6ca:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  halstatus = HAL_InitTick (uwTickPrio);
 800e6ce:	f7fc b9f3 	b.w	800aab8 <HAL_InitTick>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800e6d2:	07da      	lsls	r2, r3, #31
 800e6d4:	f53f af60 	bmi.w	800e598 <HAL_RCC_ClockConfig+0xc8>
 800e6d8:	e795      	b.n	800e606 <HAL_RCC_ClockConfig+0x136>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800e6da:	6982      	ldr	r2, [r0, #24]
 800e6dc:	f022 020f 	bic.w	r2, r2, #15
 800e6e0:	4311      	orrs	r1, r2
 800e6e2:	6181      	str	r1, [r0, #24]
 800e6e4:	e78f      	b.n	800e606 <HAL_RCC_ClockConfig+0x136>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800e6e6:	019f      	lsls	r7, r3, #6
 800e6e8:	f53f af6a 	bmi.w	800e5c0 <HAL_RCC_ClockConfig+0xf0>
 800e6ec:	e707      	b.n	800e4fe <HAL_RCC_ClockConfig+0x2e>
    return HAL_ERROR;
 800e6ee:	2001      	movs	r0, #1
}
 800e6f0:	4770      	bx	lr
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800e6f2:	039b      	lsls	r3, r3, #14
 800e6f4:	f53f af64 	bmi.w	800e5c0 <HAL_RCC_ClockConfig+0xf0>
 800e6f8:	e701      	b.n	800e4fe <HAL_RCC_ClockConfig+0x2e>
            return HAL_TIMEOUT;
 800e6fa:	2003      	movs	r0, #3
 800e6fc:	e700      	b.n	800e500 <HAL_RCC_ClockConfig+0x30>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 800e6fe:	05de      	lsls	r6, r3, #23
 800e700:	f53f af5e 	bmi.w	800e5c0 <HAL_RCC_ClockConfig+0xf0>
 800e704:	e6fb      	b.n	800e4fe <HAL_RCC_ClockConfig+0x2e>
 800e706:	bf00      	nop
 800e708:	52002000 	.word	0x52002000
 800e70c:	58024400 	.word	0x58024400
 800e710:	24008240 	.word	0x24008240
 800e714:	24008000 	.word	0x24008000
 800e718:	24008004 	.word	0x24008004
 800e71c:	2400801c 	.word	0x2400801c

0800e720 <HAL_RCC_GetHCLKFreq>:
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800e720:	4a18      	ldr	r2, [pc, #96]	; (800e784 <HAL_RCC_GetHCLKFreq+0x64>)
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800e722:	b538      	push	{r3, r4, r5, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800e724:	6913      	ldr	r3, [r2, #16]
 800e726:	f003 0338 	and.w	r3, r3, #56	; 0x38
 800e72a:	2b10      	cmp	r3, #16
 800e72c:	d01a      	beq.n	800e764 <HAL_RCC_GetHCLKFreq+0x44>
 800e72e:	2b18      	cmp	r3, #24
 800e730:	d023      	beq.n	800e77a <HAL_RCC_GetHCLKFreq+0x5a>
 800e732:	b1cb      	cbz	r3, 800e768 <HAL_RCC_GetHCLKFreq+0x48>
    sysclockfreq = CSI_VALUE;
 800e734:	4814      	ldr	r0, [pc, #80]	; (800e788 <HAL_RCC_GetHCLKFreq+0x68>)
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 800e736:	4b13      	ldr	r3, [pc, #76]	; (800e784 <HAL_RCC_GetHCLKFreq+0x64>)
 800e738:	4914      	ldr	r1, [pc, #80]	; (800e78c <HAL_RCC_GetHCLKFreq+0x6c>)
 800e73a:	699a      	ldr	r2, [r3, #24]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800e73c:	699b      	ldr	r3, [r3, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 800e73e:	f3c2 2203 	ubfx	r2, r2, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800e742:	4c13      	ldr	r4, [pc, #76]	; (800e790 <HAL_RCC_GetHCLKFreq+0x70>)
 800e744:	f003 030f 	and.w	r3, r3, #15
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 800e748:	4d12      	ldr	r5, [pc, #72]	; (800e794 <HAL_RCC_GetHCLKFreq+0x74>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 800e74a:	5c8a      	ldrb	r2, [r1, r2]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800e74c:	5ccb      	ldrb	r3, [r1, r3]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 800e74e:	f002 021f 	and.w	r2, r2, #31
 800e752:	fa20 f202 	lsr.w	r2, r0, r2
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800e756:	f003 001f 	and.w	r0, r3, #31
 800e75a:	fa22 f000 	lsr.w	r0, r2, r0
  SystemCoreClock = common_system_clock;
 800e75e:	602a      	str	r2, [r5, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800e760:	6020      	str	r0, [r4, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
}
 800e762:	bd38      	pop	{r3, r4, r5, pc}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800e764:	480c      	ldr	r0, [pc, #48]	; (800e798 <HAL_RCC_GetHCLKFreq+0x78>)
 800e766:	e7e6      	b.n	800e736 <HAL_RCC_GetHCLKFreq+0x16>
   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800e768:	6813      	ldr	r3, [r2, #0]
 800e76a:	069b      	lsls	r3, r3, #26
 800e76c:	d508      	bpl.n	800e780 <HAL_RCC_GetHCLKFreq+0x60>
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800e76e:	6812      	ldr	r2, [r2, #0]
 800e770:	480a      	ldr	r0, [pc, #40]	; (800e79c <HAL_RCC_GetHCLKFreq+0x7c>)
 800e772:	f3c2 02c1 	ubfx	r2, r2, #3, #2
 800e776:	40d0      	lsrs	r0, r2
 800e778:	e7dd      	b.n	800e736 <HAL_RCC_GetHCLKFreq+0x16>
 800e77a:	f7ff fab1 	bl	800dce0 <HAL_RCC_GetSysClockFreq.part.0>
 800e77e:	e7da      	b.n	800e736 <HAL_RCC_GetHCLKFreq+0x16>
        sysclockfreq = (uint32_t) HSI_VALUE;
 800e780:	4806      	ldr	r0, [pc, #24]	; (800e79c <HAL_RCC_GetHCLKFreq+0x7c>)
 800e782:	e7d8      	b.n	800e736 <HAL_RCC_GetHCLKFreq+0x16>
 800e784:	58024400 	.word	0x58024400
 800e788:	003d0900 	.word	0x003d0900
 800e78c:	24008240 	.word	0x24008240
 800e790:	24008004 	.word	0x24008004
 800e794:	24008000 	.word	0x24008000
 800e798:	007a1200 	.word	0x007a1200
 800e79c:	03d09000 	.word	0x03d09000

0800e7a0 <HAL_RCC_GetPCLK1Freq>:
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800e7a0:	4a1c      	ldr	r2, [pc, #112]	; (800e814 <HAL_RCC_GetPCLK1Freq+0x74>)
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800e7a2:	b538      	push	{r3, r4, r5, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800e7a4:	6913      	ldr	r3, [r2, #16]
 800e7a6:	f003 0338 	and.w	r3, r3, #56	; 0x38
 800e7aa:	2b10      	cmp	r3, #16
 800e7ac:	d021      	beq.n	800e7f2 <HAL_RCC_GetPCLK1Freq+0x52>
 800e7ae:	2b18      	cmp	r3, #24
 800e7b0:	d02b      	beq.n	800e80a <HAL_RCC_GetPCLK1Freq+0x6a>
 800e7b2:	b303      	cbz	r3, 800e7f6 <HAL_RCC_GetPCLK1Freq+0x56>
    sysclockfreq = CSI_VALUE;
 800e7b4:	4818      	ldr	r0, [pc, #96]	; (800e818 <HAL_RCC_GetPCLK1Freq+0x78>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 800e7b6:	4a17      	ldr	r2, [pc, #92]	; (800e814 <HAL_RCC_GetPCLK1Freq+0x74>)
 800e7b8:	4918      	ldr	r1, [pc, #96]	; (800e81c <HAL_RCC_GetPCLK1Freq+0x7c>)
 800e7ba:	6993      	ldr	r3, [r2, #24]
  SystemCoreClock = common_system_clock;
 800e7bc:	4d18      	ldr	r5, [pc, #96]	; (800e820 <HAL_RCC_GetPCLK1Freq+0x80>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 800e7be:	f3c3 2303 	ubfx	r3, r3, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800e7c2:	4c18      	ldr	r4, [pc, #96]	; (800e824 <HAL_RCC_GetPCLK1Freq+0x84>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 800e7c4:	5ccb      	ldrb	r3, [r1, r3]
 800e7c6:	f003 031f 	and.w	r3, r3, #31
 800e7ca:	fa20 f303 	lsr.w	r3, r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800e7ce:	6990      	ldr	r0, [r2, #24]
 800e7d0:	f000 000f 	and.w	r0, r0, #15
  SystemCoreClock = common_system_clock;
 800e7d4:	602b      	str	r3, [r5, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800e7d6:	5c08      	ldrb	r0, [r1, r0]
 800e7d8:	f000 001f 	and.w	r0, r0, #31
 800e7dc:	40c3      	lsrs	r3, r0
 800e7de:	6023      	str	r3, [r4, #0]
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1)>> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
 800e7e0:	69d2      	ldr	r2, [r2, #28]
 800e7e2:	f3c2 1202 	ubfx	r2, r2, #4, #3
 800e7e6:	5c88      	ldrb	r0, [r1, r2]
 800e7e8:	f000 001f 	and.w	r0, r0, #31
#else
 /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1)>> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
#endif
}
 800e7ec:	fa23 f000 	lsr.w	r0, r3, r0
 800e7f0:	bd38      	pop	{r3, r4, r5, pc}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800e7f2:	480d      	ldr	r0, [pc, #52]	; (800e828 <HAL_RCC_GetPCLK1Freq+0x88>)
 800e7f4:	e7df      	b.n	800e7b6 <HAL_RCC_GetPCLK1Freq+0x16>
   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800e7f6:	6813      	ldr	r3, [r2, #0]
 800e7f8:	069b      	lsls	r3, r3, #26
 800e7fa:	d509      	bpl.n	800e810 <HAL_RCC_GetPCLK1Freq+0x70>
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800e7fc:	6810      	ldr	r0, [r2, #0]
 800e7fe:	4b0b      	ldr	r3, [pc, #44]	; (800e82c <HAL_RCC_GetPCLK1Freq+0x8c>)
 800e800:	f3c0 00c1 	ubfx	r0, r0, #3, #2
 800e804:	fa23 f000 	lsr.w	r0, r3, r0
 800e808:	e7d5      	b.n	800e7b6 <HAL_RCC_GetPCLK1Freq+0x16>
 800e80a:	f7ff fa69 	bl	800dce0 <HAL_RCC_GetSysClockFreq.part.0>
 800e80e:	e7d2      	b.n	800e7b6 <HAL_RCC_GetPCLK1Freq+0x16>
        sysclockfreq = (uint32_t) HSI_VALUE;
 800e810:	4806      	ldr	r0, [pc, #24]	; (800e82c <HAL_RCC_GetPCLK1Freq+0x8c>)
 800e812:	e7d0      	b.n	800e7b6 <HAL_RCC_GetPCLK1Freq+0x16>
 800e814:	58024400 	.word	0x58024400
 800e818:	003d0900 	.word	0x003d0900
 800e81c:	24008240 	.word	0x24008240
 800e820:	24008000 	.word	0x24008000
 800e824:	24008004 	.word	0x24008004
 800e828:	007a1200 	.word	0x007a1200
 800e82c:	03d09000 	.word	0x03d09000

0800e830 <HAL_RCC_GetPCLK2Freq>:
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800e830:	4a1c      	ldr	r2, [pc, #112]	; (800e8a4 <HAL_RCC_GetPCLK2Freq+0x74>)
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800e832:	b538      	push	{r3, r4, r5, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800e834:	6913      	ldr	r3, [r2, #16]
 800e836:	f003 0338 	and.w	r3, r3, #56	; 0x38
 800e83a:	2b10      	cmp	r3, #16
 800e83c:	d021      	beq.n	800e882 <HAL_RCC_GetPCLK2Freq+0x52>
 800e83e:	2b18      	cmp	r3, #24
 800e840:	d02b      	beq.n	800e89a <HAL_RCC_GetPCLK2Freq+0x6a>
 800e842:	b303      	cbz	r3, 800e886 <HAL_RCC_GetPCLK2Freq+0x56>
    sysclockfreq = CSI_VALUE;
 800e844:	4818      	ldr	r0, [pc, #96]	; (800e8a8 <HAL_RCC_GetPCLK2Freq+0x78>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 800e846:	4a17      	ldr	r2, [pc, #92]	; (800e8a4 <HAL_RCC_GetPCLK2Freq+0x74>)
 800e848:	4918      	ldr	r1, [pc, #96]	; (800e8ac <HAL_RCC_GetPCLK2Freq+0x7c>)
 800e84a:	6993      	ldr	r3, [r2, #24]
  SystemCoreClock = common_system_clock;
 800e84c:	4d18      	ldr	r5, [pc, #96]	; (800e8b0 <HAL_RCC_GetPCLK2Freq+0x80>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 800e84e:	f3c3 2303 	ubfx	r3, r3, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800e852:	4c18      	ldr	r4, [pc, #96]	; (800e8b4 <HAL_RCC_GetPCLK2Freq+0x84>)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 800e854:	5ccb      	ldrb	r3, [r1, r3]
 800e856:	f003 031f 	and.w	r3, r3, #31
 800e85a:	fa20 f303 	lsr.w	r3, r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800e85e:	6990      	ldr	r0, [r2, #24]
 800e860:	f000 000f 	and.w	r0, r0, #15
  SystemCoreClock = common_system_clock;
 800e864:	602b      	str	r3, [r5, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800e866:	5c08      	ldrb	r0, [r1, r0]
 800e868:	f000 001f 	and.w	r0, r0, #31
 800e86c:	40c3      	lsrs	r3, r0
 800e86e:	6023      	str	r3, [r4, #0]
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
#if defined(RCC_D2CFGR_D2PPRE2)
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2)>> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
 800e870:	69d2      	ldr	r2, [r2, #28]
 800e872:	f3c2 2202 	ubfx	r2, r2, #8, #3
 800e876:	5c88      	ldrb	r0, [r1, r2]
 800e878:	f000 001f 	and.w	r0, r0, #31
#else
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2)>> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
#endif
}
 800e87c:	fa23 f000 	lsr.w	r0, r3, r0
 800e880:	bd38      	pop	{r3, r4, r5, pc}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800e882:	480d      	ldr	r0, [pc, #52]	; (800e8b8 <HAL_RCC_GetPCLK2Freq+0x88>)
 800e884:	e7df      	b.n	800e846 <HAL_RCC_GetPCLK2Freq+0x16>
   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800e886:	6813      	ldr	r3, [r2, #0]
 800e888:	069b      	lsls	r3, r3, #26
 800e88a:	d509      	bpl.n	800e8a0 <HAL_RCC_GetPCLK2Freq+0x70>
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800e88c:	6810      	ldr	r0, [r2, #0]
 800e88e:	4b0b      	ldr	r3, [pc, #44]	; (800e8bc <HAL_RCC_GetPCLK2Freq+0x8c>)
 800e890:	f3c0 00c1 	ubfx	r0, r0, #3, #2
 800e894:	fa23 f000 	lsr.w	r0, r3, r0
 800e898:	e7d5      	b.n	800e846 <HAL_RCC_GetPCLK2Freq+0x16>
 800e89a:	f7ff fa21 	bl	800dce0 <HAL_RCC_GetSysClockFreq.part.0>
 800e89e:	e7d2      	b.n	800e846 <HAL_RCC_GetPCLK2Freq+0x16>
        sysclockfreq = (uint32_t) HSI_VALUE;
 800e8a0:	4806      	ldr	r0, [pc, #24]	; (800e8bc <HAL_RCC_GetPCLK2Freq+0x8c>)
 800e8a2:	e7d0      	b.n	800e846 <HAL_RCC_GetPCLK2Freq+0x16>
 800e8a4:	58024400 	.word	0x58024400
 800e8a8:	003d0900 	.word	0x003d0900
 800e8ac:	24008240 	.word	0x24008240
 800e8b0:	24008000 	.word	0x24008000
 800e8b4:	24008004 	.word	0x24008004
 800e8b8:	007a1200 	.word	0x007a1200
 800e8bc:	03d09000 	.word	0x03d09000

0800e8c0 <HAL_RCC_GetClockConfig>:
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |
                                 RCC_CLOCKTYPE_PCLK2 |  RCC_CLOCKTYPE_D3PCLK1  ;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 800e8c0:	4b13      	ldr	r3, [pc, #76]	; (800e910 <HAL_RCC_GetClockConfig+0x50>)
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |
 800e8c2:	223f      	movs	r2, #63	; 0x3f
 800e8c4:	6002      	str	r2, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 800e8c6:	691a      	ldr	r2, [r3, #16]
 800e8c8:	f002 0207 	and.w	r2, r2, #7
 800e8cc:	6042      	str	r2, [r0, #4]

#if defined(RCC_D1CFGR_D1CPRE)
  /* Get the SYSCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1CPRE);
 800e8ce:	699a      	ldr	r2, [r3, #24]
 800e8d0:	f402 6270 	and.w	r2, r2, #3840	; 0xf00
 800e8d4:	6082      	str	r2, [r0, #8]

  /* Get the D1HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_HPRE);
 800e8d6:	699a      	ldr	r2, [r3, #24]
 800e8d8:	f002 020f 	and.w	r2, r2, #15
 800e8dc:	60c2      	str	r2, [r0, #12]

  /* Get the APB3 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1PPRE);
 800e8de:	699a      	ldr	r2, [r3, #24]
 800e8e0:	f002 0270 	and.w	r2, r2, #112	; 0x70
 800e8e4:	6102      	str	r2, [r0, #16]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1);
 800e8e6:	69da      	ldr	r2, [r3, #28]
 800e8e8:	f002 0270 	and.w	r2, r2, #112	; 0x70
 800e8ec:	6142      	str	r2, [r0, #20]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2);
 800e8ee:	69da      	ldr	r2, [r3, #28]
 800e8f0:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 800e8f4:	6182      	str	r2, [r0, #24]

  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);
 800e8f6:	6a1b      	ldr	r3, [r3, #32]
{
 800e8f8:	b410      	push	{r4}
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);
 800e8fa:	f003 0370 	and.w	r3, r3, #112	; 0x70
  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE);
#endif

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 800e8fe:	4c05      	ldr	r4, [pc, #20]	; (800e914 <HAL_RCC_GetClockConfig+0x54>)
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);
 800e900:	61c3      	str	r3, [r0, #28]
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 800e902:	6823      	ldr	r3, [r4, #0]
}
 800e904:	f85d 4b04 	ldr.w	r4, [sp], #4
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 800e908:	f003 030f 	and.w	r3, r3, #15
 800e90c:	600b      	str	r3, [r1, #0]
}
 800e90e:	4770      	bx	lr
 800e910:	58024400 	.word	0x58024400
 800e914:	52002000 	.word	0x52002000

0800e918 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
 800e918:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));

  /* Check that PLL2 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 800e91a:	4c3a      	ldr	r4, [pc, #232]	; (800ea04 <RCCEx_PLL2_Config+0xec>)
 800e91c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800e91e:	f003 0303 	and.w	r3, r3, #3
 800e922:	2b03      	cmp	r3, #3
 800e924:	d067      	beq.n	800e9f6 <RCCEx_PLL2_Config+0xde>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
 800e926:	6823      	ldr	r3, [r4, #0]
 800e928:	4606      	mov	r6, r0
 800e92a:	460f      	mov	r7, r1
 800e92c:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800e930:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800e932:	f7fc f9eb 	bl	800ad0c <HAL_GetTick>
 800e936:	4605      	mov	r5, r0

    /* Wait till PLL is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 800e938:	e004      	b.n	800e944 <RCCEx_PLL2_Config+0x2c>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
 800e93a:	f7fc f9e7 	bl	800ad0c <HAL_GetTick>
 800e93e:	1b43      	subs	r3, r0, r5
 800e940:	2b02      	cmp	r3, #2
 800e942:	d856      	bhi.n	800e9f2 <RCCEx_PLL2_Config+0xda>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 800e944:	6823      	ldr	r3, [r4, #0]
 800e946:	011a      	lsls	r2, r3, #4
 800e948:	d4f7      	bmi.n	800e93a <RCCEx_PLL2_Config+0x22>
        return HAL_TIMEOUT;
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
 800e94a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800e94c:	6832      	ldr	r2, [r6, #0]
 800e94e:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
 800e952:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
 800e956:	62a3      	str	r3, [r4, #40]	; 0x28
 800e958:	e9d6 3202 	ldrd	r3, r2, [r6, #8]
 800e95c:	3b01      	subs	r3, #1
 800e95e:	3a01      	subs	r2, #1
 800e960:	025b      	lsls	r3, r3, #9
 800e962:	0412      	lsls	r2, r2, #16
 800e964:	b29b      	uxth	r3, r3
 800e966:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
 800e96a:	4313      	orrs	r3, r2
 800e96c:	6872      	ldr	r2, [r6, #4]
 800e96e:	3a01      	subs	r2, #1
 800e970:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800e974:	4313      	orrs	r3, r2
 800e976:	6932      	ldr	r2, [r6, #16]
 800e978:	3a01      	subs	r2, #1
 800e97a:	0612      	lsls	r2, r2, #24
 800e97c:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
 800e980:	4313      	orrs	r3, r2
 800e982:	63a3      	str	r3, [r4, #56]	; 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
 800e984:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800e986:	6972      	ldr	r2, [r6, #20]
 800e988:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800e98c:	4313      	orrs	r3, r2
 800e98e:	62e3      	str	r3, [r4, #44]	; 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
 800e990:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800e992:	69b3      	ldr	r3, [r6, #24]
 800e994:	f022 0220 	bic.w	r2, r2, #32
 800e998:	431a      	orrs	r2, r3

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 800e99a:	4b1b      	ldr	r3, [pc, #108]	; (800ea08 <RCCEx_PLL2_Config+0xf0>)
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
 800e99c:	62e2      	str	r2, [r4, #44]	; 0x2c
    __HAL_RCC_PLL2FRACN_DISABLE();
 800e99e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800e9a0:	f022 0210 	bic.w	r2, r2, #16
 800e9a4:	62e2      	str	r2, [r4, #44]	; 0x2c
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 800e9a6:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800e9a8:	69f2      	ldr	r2, [r6, #28]
 800e9aa:	400b      	ands	r3, r1
 800e9ac:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800e9b0:	63e3      	str	r3, [r4, #60]	; 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
 800e9b2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800e9b4:	f043 0310 	orr.w	r3, r3, #16
 800e9b8:	62e3      	str	r3, [r4, #44]	; 0x2c

    /* Enable the PLL2 clock output */
    if(Divider == DIVIDER_P_UPDATE)
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
 800e9ba:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    if(Divider == DIVIDER_P_UPDATE)
 800e9bc:	b1ef      	cbz	r7, 800e9fa <RCCEx_PLL2_Config+0xe2>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
 800e9be:	2f01      	cmp	r7, #1
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
 800e9c0:	bf0c      	ite	eq
 800e9c2:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
 800e9c6:	f443 1300 	orrne.w	r3, r3, #2097152	; 0x200000
 800e9ca:	62e3      	str	r3, [r4, #44]	; 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
 800e9cc:	4c0d      	ldr	r4, [pc, #52]	; (800ea04 <RCCEx_PLL2_Config+0xec>)
 800e9ce:	6823      	ldr	r3, [r4, #0]
 800e9d0:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800e9d4:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800e9d6:	f7fc f999 	bl	800ad0c <HAL_GetTick>
 800e9da:	4605      	mov	r5, r0

    /* Wait till PLL2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 800e9dc:	e004      	b.n	800e9e8 <RCCEx_PLL2_Config+0xd0>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
 800e9de:	f7fc f995 	bl	800ad0c <HAL_GetTick>
 800e9e2:	1b40      	subs	r0, r0, r5
 800e9e4:	2802      	cmp	r0, #2
 800e9e6:	d804      	bhi.n	800e9f2 <RCCEx_PLL2_Config+0xda>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 800e9e8:	6823      	ldr	r3, [r4, #0]
 800e9ea:	011b      	lsls	r3, r3, #4
 800e9ec:	d5f7      	bpl.n	800e9de <RCCEx_PLL2_Config+0xc6>
    }

  }


  return status;
 800e9ee:	2000      	movs	r0, #0
}
 800e9f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return HAL_TIMEOUT;
 800e9f2:	2003      	movs	r0, #3
}
 800e9f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 800e9f6:	2001      	movs	r0, #1
}
 800e9f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
 800e9fa:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 800e9fe:	62e3      	str	r3, [r4, #44]	; 0x2c
 800ea00:	e7e4      	b.n	800e9cc <RCCEx_PLL2_Config+0xb4>
 800ea02:	bf00      	nop
 800ea04:	58024400 	.word	0x58024400
 800ea08:	ffff0007 	.word	0xffff0007

0800ea0c <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
 800ea0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));

  /* Check that PLL3 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 800ea0e:	4c3a      	ldr	r4, [pc, #232]	; (800eaf8 <RCCEx_PLL3_Config+0xec>)
 800ea10:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800ea12:	f003 0303 	and.w	r3, r3, #3
 800ea16:	2b03      	cmp	r3, #3
 800ea18:	d067      	beq.n	800eaea <RCCEx_PLL3_Config+0xde>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
 800ea1a:	6823      	ldr	r3, [r4, #0]
 800ea1c:	4606      	mov	r6, r0
 800ea1e:	460f      	mov	r7, r1
 800ea20:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800ea24:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800ea26:	f7fc f971 	bl	800ad0c <HAL_GetTick>
 800ea2a:	4605      	mov	r5, r0
    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 800ea2c:	e004      	b.n	800ea38 <RCCEx_PLL3_Config+0x2c>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
 800ea2e:	f7fc f96d 	bl	800ad0c <HAL_GetTick>
 800ea32:	1b43      	subs	r3, r0, r5
 800ea34:	2b02      	cmp	r3, #2
 800ea36:	d856      	bhi.n	800eae6 <RCCEx_PLL3_Config+0xda>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 800ea38:	6823      	ldr	r3, [r4, #0]
 800ea3a:	009a      	lsls	r2, r3, #2
 800ea3c:	d4f7      	bmi.n	800ea2e <RCCEx_PLL3_Config+0x22>
        return HAL_TIMEOUT;
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
 800ea3e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800ea40:	6832      	ldr	r2, [r6, #0]
 800ea42:	f023 737c 	bic.w	r3, r3, #66060288	; 0x3f00000
 800ea46:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
 800ea4a:	62a3      	str	r3, [r4, #40]	; 0x28
 800ea4c:	e9d6 3202 	ldrd	r3, r2, [r6, #8]
 800ea50:	3b01      	subs	r3, #1
 800ea52:	3a01      	subs	r2, #1
 800ea54:	025b      	lsls	r3, r3, #9
 800ea56:	0412      	lsls	r2, r2, #16
 800ea58:	b29b      	uxth	r3, r3
 800ea5a:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
 800ea5e:	4313      	orrs	r3, r2
 800ea60:	6872      	ldr	r2, [r6, #4]
 800ea62:	3a01      	subs	r2, #1
 800ea64:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800ea68:	4313      	orrs	r3, r2
 800ea6a:	6932      	ldr	r2, [r6, #16]
 800ea6c:	3a01      	subs	r2, #1
 800ea6e:	0612      	lsls	r2, r2, #24
 800ea70:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
 800ea74:	4313      	orrs	r3, r2
 800ea76:	6423      	str	r3, [r4, #64]	; 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
 800ea78:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800ea7a:	6972      	ldr	r2, [r6, #20]
 800ea7c:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 800ea80:	4313      	orrs	r3, r2
 800ea82:	62e3      	str	r3, [r4, #44]	; 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
 800ea84:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800ea86:	69b3      	ldr	r3, [r6, #24]
 800ea88:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 800ea8c:	431a      	orrs	r2, r3

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 800ea8e:	4b1b      	ldr	r3, [pc, #108]	; (800eafc <RCCEx_PLL3_Config+0xf0>)
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
 800ea90:	62e2      	str	r2, [r4, #44]	; 0x2c
    __HAL_RCC_PLL3FRACN_DISABLE();
 800ea92:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800ea94:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800ea98:	62e2      	str	r2, [r4, #44]	; 0x2c
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 800ea9a:	6c61      	ldr	r1, [r4, #68]	; 0x44
 800ea9c:	69f2      	ldr	r2, [r6, #28]
 800ea9e:	400b      	ands	r3, r1
 800eaa0:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800eaa4:	6463      	str	r3, [r4, #68]	; 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
 800eaa6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800eaa8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800eaac:	62e3      	str	r3, [r4, #44]	; 0x2c

    /* Enable the PLL3 clock output */
    if(Divider == DIVIDER_P_UPDATE)
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
 800eaae:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    if(Divider == DIVIDER_P_UPDATE)
 800eab0:	b1ef      	cbz	r7, 800eaee <RCCEx_PLL3_Config+0xe2>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
 800eab2:	2f01      	cmp	r7, #1
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
 800eab4:	bf0c      	ite	eq
 800eab6:	f443 0300 	orreq.w	r3, r3, #8388608	; 0x800000
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
 800eaba:	f043 7380 	orrne.w	r3, r3, #16777216	; 0x1000000
 800eabe:	62e3      	str	r3, [r4, #44]	; 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
 800eac0:	4c0d      	ldr	r4, [pc, #52]	; (800eaf8 <RCCEx_PLL3_Config+0xec>)
 800eac2:	6823      	ldr	r3, [r4, #0]
 800eac4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800eac8:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800eaca:	f7fc f91f 	bl	800ad0c <HAL_GetTick>
 800eace:	4605      	mov	r5, r0

    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 800ead0:	e004      	b.n	800eadc <RCCEx_PLL3_Config+0xd0>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
 800ead2:	f7fc f91b 	bl	800ad0c <HAL_GetTick>
 800ead6:	1b40      	subs	r0, r0, r5
 800ead8:	2802      	cmp	r0, #2
 800eada:	d804      	bhi.n	800eae6 <RCCEx_PLL3_Config+0xda>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 800eadc:	6823      	ldr	r3, [r4, #0]
 800eade:	009b      	lsls	r3, r3, #2
 800eae0:	d5f7      	bpl.n	800ead2 <RCCEx_PLL3_Config+0xc6>
    }

  }


  return status;
 800eae2:	2000      	movs	r0, #0
}
 800eae4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return HAL_TIMEOUT;
 800eae6:	2003      	movs	r0, #3
}
 800eae8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 800eaea:	2001      	movs	r0, #1
}
 800eaec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
 800eaee:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800eaf2:	62e3      	str	r3, [r4, #44]	; 0x2c
 800eaf4:	e7e4      	b.n	800eac0 <RCCEx_PLL3_Config+0xb4>
 800eaf6:	bf00      	nop
 800eaf8:	58024400 	.word	0x58024400
 800eafc:	ffff0007 	.word	0xffff0007

0800eb00 <HAL_RCCEx_PeriphCLKConfig>:
{
 800eb00:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 800eb04:	6803      	ldr	r3, [r0, #0]
{
 800eb06:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 800eb08:	f013 6600 	ands.w	r6, r3, #134217728	; 0x8000000
 800eb0c:	d022      	beq.n	800eb54 <HAL_RCCEx_PeriphCLKConfig+0x54>
    switch(PeriphClkInit->SpdifrxClockSelection)
 800eb0e:	6e42      	ldr	r2, [r0, #100]	; 0x64
 800eb10:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
 800eb14:	f000 8499 	beq.w	800f44a <HAL_RCCEx_PeriphCLKConfig+0x94a>
 800eb18:	d811      	bhi.n	800eb3e <HAL_RCCEx_PeriphCLKConfig+0x3e>
 800eb1a:	2a00      	cmp	r2, #0
 800eb1c:	f000 8503 	beq.w	800f526 <HAL_RCCEx_PeriphCLKConfig+0xa26>
 800eb20:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 800eb24:	f040 84fc 	bne.w	800f520 <HAL_RCCEx_PeriphCLKConfig+0xa20>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 800eb28:	2102      	movs	r1, #2
 800eb2a:	3004      	adds	r0, #4
 800eb2c:	f7ff fef4 	bl	800e918 <RCCEx_PLL2_Config>
 800eb30:	4606      	mov	r6, r0
    if(ret == HAL_OK)
 800eb32:	2e00      	cmp	r6, #0
 800eb34:	f040 8491 	bne.w	800f45a <HAL_RCCEx_PeriphCLKConfig+0x95a>
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
 800eb38:	6e62      	ldr	r2, [r4, #100]	; 0x64
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 800eb3a:	6823      	ldr	r3, [r4, #0]
 800eb3c:	e003      	b.n	800eb46 <HAL_RCCEx_PeriphCLKConfig+0x46>
    switch(PeriphClkInit->SpdifrxClockSelection)
 800eb3e:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
 800eb42:	f040 84ed 	bne.w	800f520 <HAL_RCCEx_PeriphCLKConfig+0xa20>
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
 800eb46:	48a8      	ldr	r0, [pc, #672]	; (800ede8 <HAL_RCCEx_PeriphCLKConfig+0x2e8>)
 800eb48:	2600      	movs	r6, #0
 800eb4a:	6d01      	ldr	r1, [r0, #80]	; 0x50
 800eb4c:	f421 1140 	bic.w	r1, r1, #3145728	; 0x300000
 800eb50:	430a      	orrs	r2, r1
 800eb52:	6502      	str	r2, [r0, #80]	; 0x50
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 800eb54:	05dd      	lsls	r5, r3, #23
 800eb56:	d50a      	bpl.n	800eb6e <HAL_RCCEx_PeriphCLKConfig+0x6e>
    switch(PeriphClkInit->Sai1ClockSelection)
 800eb58:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800eb5a:	2a04      	cmp	r2, #4
 800eb5c:	d806      	bhi.n	800eb6c <HAL_RCCEx_PeriphCLKConfig+0x6c>
 800eb5e:	e8df f012 	tbh	[pc, r2, lsl #1]
 800eb62:	04ad      	.short	0x04ad
 800eb64:	0493048c 	.word	0x0493048c
 800eb68:	02e902e9 	.word	0x02e902e9
 800eb6c:	2601      	movs	r6, #1
 800eb6e:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
 800eb70:	0598      	lsls	r0, r3, #22
 800eb72:	d51b      	bpl.n	800ebac <HAL_RCCEx_PeriphCLKConfig+0xac>
    switch(PeriphClkInit->Sai23ClockSelection)
 800eb74:	6da2      	ldr	r2, [r4, #88]	; 0x58
 800eb76:	2a80      	cmp	r2, #128	; 0x80
 800eb78:	f000 8497 	beq.w	800f4aa <HAL_RCCEx_PeriphCLKConfig+0x9aa>
 800eb7c:	f200 80ec 	bhi.w	800ed58 <HAL_RCCEx_PeriphCLKConfig+0x258>
 800eb80:	2a00      	cmp	r2, #0
 800eb82:	f000 8394 	beq.w	800f2ae <HAL_RCCEx_PeriphCLKConfig+0x7ae>
 800eb86:	2a40      	cmp	r2, #64	; 0x40
 800eb88:	f040 80ed 	bne.w	800ed66 <HAL_RCCEx_PeriphCLKConfig+0x266>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800eb8c:	2100      	movs	r1, #0
 800eb8e:	1d20      	adds	r0, r4, #4
 800eb90:	f7ff fec2 	bl	800e918 <RCCEx_PLL2_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
 800eb94:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800eb96:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800eb98:	2d00      	cmp	r5, #0
 800eb9a:	f040 836e 	bne.w	800f27a <HAL_RCCEx_PeriphCLKConfig+0x77a>
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
 800eb9e:	4992      	ldr	r1, [pc, #584]	; (800ede8 <HAL_RCCEx_PeriphCLKConfig+0x2e8>)
 800eba0:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800eba2:	6d0a      	ldr	r2, [r1, #80]	; 0x50
 800eba4:	f422 72e0 	bic.w	r2, r2, #448	; 0x1c0
 800eba8:	4302      	orrs	r2, r0
 800ebaa:	650a      	str	r2, [r1, #80]	; 0x50
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
 800ebac:	0559      	lsls	r1, r3, #21
 800ebae:	d51f      	bpl.n	800ebf0 <HAL_RCCEx_PeriphCLKConfig+0xf0>
    switch(PeriphClkInit->Sai4AClockSelection)
 800ebb0:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
 800ebb4:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
 800ebb8:	f000 8456 	beq.w	800f468 <HAL_RCCEx_PeriphCLKConfig+0x968>
 800ebbc:	f200 80d6 	bhi.w	800ed6c <HAL_RCCEx_PeriphCLKConfig+0x26c>
 800ebc0:	2a00      	cmp	r2, #0
 800ebc2:	f000 837a 	beq.w	800f2ba <HAL_RCCEx_PeriphCLKConfig+0x7ba>
 800ebc6:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
 800ebca:	f040 80d7 	bne.w	800ed7c <HAL_RCCEx_PeriphCLKConfig+0x27c>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800ebce:	2100      	movs	r1, #0
 800ebd0:	1d20      	adds	r0, r4, #4
 800ebd2:	f7ff fea1 	bl	800e918 <RCCEx_PLL2_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
 800ebd6:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800ebd8:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ebda:	2d00      	cmp	r5, #0
 800ebdc:	f040 8351 	bne.w	800f282 <HAL_RCCEx_PeriphCLKConfig+0x782>
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
 800ebe0:	4981      	ldr	r1, [pc, #516]	; (800ede8 <HAL_RCCEx_PeriphCLKConfig+0x2e8>)
 800ebe2:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
 800ebe6:	6d8a      	ldr	r2, [r1, #88]	; 0x58
 800ebe8:	f422 0260 	bic.w	r2, r2, #14680064	; 0xe00000
 800ebec:	4302      	orrs	r2, r0
 800ebee:	658a      	str	r2, [r1, #88]	; 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
 800ebf0:	051a      	lsls	r2, r3, #20
 800ebf2:	d51f      	bpl.n	800ec34 <HAL_RCCEx_PeriphCLKConfig+0x134>
    switch(PeriphClkInit->Sai4BClockSelection)
 800ebf4:	f8d4 20a8 	ldr.w	r2, [r4, #168]	; 0xa8
 800ebf8:	f1b2 7f00 	cmp.w	r2, #33554432	; 0x2000000
 800ebfc:	f000 8465 	beq.w	800f4ca <HAL_RCCEx_PeriphCLKConfig+0x9ca>
 800ec00:	f200 80bf 	bhi.w	800ed82 <HAL_RCCEx_PeriphCLKConfig+0x282>
 800ec04:	2a00      	cmp	r2, #0
 800ec06:	f000 835e 	beq.w	800f2c6 <HAL_RCCEx_PeriphCLKConfig+0x7c6>
 800ec0a:	f1b2 7f80 	cmp.w	r2, #16777216	; 0x1000000
 800ec0e:	f040 80c0 	bne.w	800ed92 <HAL_RCCEx_PeriphCLKConfig+0x292>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800ec12:	2100      	movs	r1, #0
 800ec14:	1d20      	adds	r0, r4, #4
 800ec16:	f7ff fe7f 	bl	800e918 <RCCEx_PLL2_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
 800ec1a:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800ec1c:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ec1e:	2d00      	cmp	r5, #0
 800ec20:	f040 8333 	bne.w	800f28a <HAL_RCCEx_PeriphCLKConfig+0x78a>
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
 800ec24:	4970      	ldr	r1, [pc, #448]	; (800ede8 <HAL_RCCEx_PeriphCLKConfig+0x2e8>)
 800ec26:	f8d4 00a8 	ldr.w	r0, [r4, #168]	; 0xa8
 800ec2a:	6d8a      	ldr	r2, [r1, #88]	; 0x58
 800ec2c:	f022 62e0 	bic.w	r2, r2, #117440512	; 0x7000000
 800ec30:	4302      	orrs	r2, r0
 800ec32:	658a      	str	r2, [r1, #88]	; 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
 800ec34:	019f      	lsls	r7, r3, #6
 800ec36:	d518      	bpl.n	800ec6a <HAL_RCCEx_PeriphCLKConfig+0x16a>
    switch(PeriphClkInit->QspiClockSelection)
 800ec38:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 800ec3a:	2a20      	cmp	r2, #32
 800ec3c:	f000 83ce 	beq.w	800f3dc <HAL_RCCEx_PeriphCLKConfig+0x8dc>
 800ec40:	f200 80aa 	bhi.w	800ed98 <HAL_RCCEx_PeriphCLKConfig+0x298>
 800ec44:	b13a      	cbz	r2, 800ec56 <HAL_RCCEx_PeriphCLKConfig+0x156>
 800ec46:	2a10      	cmp	r2, #16
 800ec48:	f040 80a9 	bne.w	800ed9e <HAL_RCCEx_PeriphCLKConfig+0x29e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800ec4c:	4966      	ldr	r1, [pc, #408]	; (800ede8 <HAL_RCCEx_PeriphCLKConfig+0x2e8>)
 800ec4e:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 800ec50:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800ec54:	62ca      	str	r2, [r1, #44]	; 0x2c
    if(ret == HAL_OK)
 800ec56:	2d00      	cmp	r5, #0
 800ec58:	f040 8360 	bne.w	800f31c <HAL_RCCEx_PeriphCLKConfig+0x81c>
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 800ec5c:	4962      	ldr	r1, [pc, #392]	; (800ede8 <HAL_RCCEx_PeriphCLKConfig+0x2e8>)
 800ec5e:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 800ec60:	6cca      	ldr	r2, [r1, #76]	; 0x4c
 800ec62:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 800ec66:	4302      	orrs	r2, r0
 800ec68:	64ca      	str	r2, [r1, #76]	; 0x4c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
 800ec6a:	04d8      	lsls	r0, r3, #19
 800ec6c:	d51d      	bpl.n	800ecaa <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    switch(PeriphClkInit->Spi123ClockSelection)
 800ec6e:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 800ec70:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 800ec74:	f000 8410 	beq.w	800f498 <HAL_RCCEx_PeriphCLKConfig+0x998>
 800ec78:	f200 8094 	bhi.w	800eda4 <HAL_RCCEx_PeriphCLKConfig+0x2a4>
 800ec7c:	2a00      	cmp	r2, #0
 800ec7e:	f000 8328 	beq.w	800f2d2 <HAL_RCCEx_PeriphCLKConfig+0x7d2>
 800ec82:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 800ec86:	f040 8095 	bne.w	800edb4 <HAL_RCCEx_PeriphCLKConfig+0x2b4>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800ec8a:	2100      	movs	r1, #0
 800ec8c:	1d20      	adds	r0, r4, #4
 800ec8e:	f7ff fe43 	bl	800e918 <RCCEx_PLL2_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
 800ec92:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800ec94:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ec96:	2d00      	cmp	r5, #0
 800ec98:	f040 82f1 	bne.w	800f27e <HAL_RCCEx_PeriphCLKConfig+0x77e>
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
 800ec9c:	4952      	ldr	r1, [pc, #328]	; (800ede8 <HAL_RCCEx_PeriphCLKConfig+0x2e8>)
 800ec9e:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 800eca0:	6d0a      	ldr	r2, [r1, #80]	; 0x50
 800eca2:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 800eca6:	4302      	orrs	r2, r0
 800eca8:	650a      	str	r2, [r1, #80]	; 0x50
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
 800ecaa:	0499      	lsls	r1, r3, #18
 800ecac:	d51a      	bpl.n	800ece4 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
    switch(PeriphClkInit->Spi45ClockSelection)
 800ecae:	6e22      	ldr	r2, [r4, #96]	; 0x60
 800ecb0:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
 800ecb4:	f000 8376 	beq.w	800f3a4 <HAL_RCCEx_PeriphCLKConfig+0x8a4>
 800ecb8:	d87f      	bhi.n	800edba <HAL_RCCEx_PeriphCLKConfig+0x2ba>
 800ecba:	b14a      	cbz	r2, 800ecd0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>
 800ecbc:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 800ecc0:	f040 8083 	bne.w	800edca <HAL_RCCEx_PeriphCLKConfig+0x2ca>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800ecc4:	2101      	movs	r1, #1
 800ecc6:	1d20      	adds	r0, r4, #4
 800ecc8:	f7ff fe26 	bl	800e918 <RCCEx_PLL2_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
 800eccc:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800ecce:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ecd0:	2d00      	cmp	r5, #0
 800ecd2:	f040 8325 	bne.w	800f320 <HAL_RCCEx_PeriphCLKConfig+0x820>
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
 800ecd6:	4944      	ldr	r1, [pc, #272]	; (800ede8 <HAL_RCCEx_PeriphCLKConfig+0x2e8>)
 800ecd8:	6e20      	ldr	r0, [r4, #96]	; 0x60
 800ecda:	6d0a      	ldr	r2, [r1, #80]	; 0x50
 800ecdc:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
 800ece0:	4302      	orrs	r2, r0
 800ece2:	650a      	str	r2, [r1, #80]	; 0x50
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
 800ece4:	045a      	lsls	r2, r3, #17
 800ece6:	d51b      	bpl.n	800ed20 <HAL_RCCEx_PeriphCLKConfig+0x220>
    switch(PeriphClkInit->Spi6ClockSelection)
 800ece8:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
 800ecec:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
 800ecf0:	f000 8362 	beq.w	800f3b8 <HAL_RCCEx_PeriphCLKConfig+0x8b8>
 800ecf4:	d86c      	bhi.n	800edd0 <HAL_RCCEx_PeriphCLKConfig+0x2d0>
 800ecf6:	b142      	cbz	r2, 800ed0a <HAL_RCCEx_PeriphCLKConfig+0x20a>
 800ecf8:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 800ecfc:	d170      	bne.n	800ede0 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800ecfe:	2101      	movs	r1, #1
 800ed00:	1d20      	adds	r0, r4, #4
 800ed02:	f7ff fe09 	bl	800e918 <RCCEx_PLL2_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 800ed06:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800ed08:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ed0a:	2d00      	cmp	r5, #0
 800ed0c:	f040 830a 	bne.w	800f324 <HAL_RCCEx_PeriphCLKConfig+0x824>
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
 800ed10:	4935      	ldr	r1, [pc, #212]	; (800ede8 <HAL_RCCEx_PeriphCLKConfig+0x2e8>)
 800ed12:	f8d4 00ac 	ldr.w	r0, [r4, #172]	; 0xac
 800ed16:	6d8a      	ldr	r2, [r1, #88]	; 0x58
 800ed18:	f022 42e0 	bic.w	r2, r2, #1879048192	; 0x70000000
 800ed1c:	4302      	orrs	r2, r0
 800ed1e:	658a      	str	r2, [r1, #88]	; 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 800ed20:	041f      	lsls	r7, r3, #16
 800ed22:	d50d      	bpl.n	800ed40 <HAL_RCCEx_PeriphCLKConfig+0x240>
    switch(PeriphClkInit->FdcanClockSelection)
 800ed24:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800ed26:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 800ed2a:	f000 834f 	beq.w	800f3cc <HAL_RCCEx_PeriphCLKConfig+0x8cc>
 800ed2e:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
 800ed32:	f000 820b 	beq.w	800f14c <HAL_RCCEx_PeriphCLKConfig+0x64c>
 800ed36:	2a00      	cmp	r2, #0
 800ed38:	f000 820e 	beq.w	800f158 <HAL_RCCEx_PeriphCLKConfig+0x658>
 800ed3c:	2601      	movs	r6, #1
 800ed3e:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
 800ed40:	01d8      	lsls	r0, r3, #7
 800ed42:	d55d      	bpl.n	800ee00 <HAL_RCCEx_PeriphCLKConfig+0x300>
    switch(PeriphClkInit->FmcClockSelection)
 800ed44:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800ed46:	2a03      	cmp	r2, #3
 800ed48:	f200 8418 	bhi.w	800f57c <HAL_RCCEx_PeriphCLKConfig+0xa7c>
 800ed4c:	e8df f012 	tbh	[pc, r2, lsl #1]
 800ed50:	035a0054 	.word	0x035a0054
 800ed54:	0054004e 	.word	0x0054004e
    switch(PeriphClkInit->Sai23ClockSelection)
 800ed58:	2ac0      	cmp	r2, #192	; 0xc0
 800ed5a:	f43f af1d 	beq.w	800eb98 <HAL_RCCEx_PeriphCLKConfig+0x98>
 800ed5e:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 800ed62:	f43f af19 	beq.w	800eb98 <HAL_RCCEx_PeriphCLKConfig+0x98>
 800ed66:	2601      	movs	r6, #1
 800ed68:	4635      	mov	r5, r6
 800ed6a:	e71f      	b.n	800ebac <HAL_RCCEx_PeriphCLKConfig+0xac>
    switch(PeriphClkInit->Sai4AClockSelection)
 800ed6c:	f5b2 0fc0 	cmp.w	r2, #6291456	; 0x600000
 800ed70:	f43f af33 	beq.w	800ebda <HAL_RCCEx_PeriphCLKConfig+0xda>
 800ed74:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 800ed78:	f43f af2f 	beq.w	800ebda <HAL_RCCEx_PeriphCLKConfig+0xda>
 800ed7c:	2601      	movs	r6, #1
 800ed7e:	4635      	mov	r5, r6
 800ed80:	e736      	b.n	800ebf0 <HAL_RCCEx_PeriphCLKConfig+0xf0>
    switch(PeriphClkInit->Sai4BClockSelection)
 800ed82:	f1b2 7f40 	cmp.w	r2, #50331648	; 0x3000000
 800ed86:	f43f af4a 	beq.w	800ec1e <HAL_RCCEx_PeriphCLKConfig+0x11e>
 800ed8a:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
 800ed8e:	f43f af46 	beq.w	800ec1e <HAL_RCCEx_PeriphCLKConfig+0x11e>
 800ed92:	2601      	movs	r6, #1
 800ed94:	4635      	mov	r5, r6
 800ed96:	e74d      	b.n	800ec34 <HAL_RCCEx_PeriphCLKConfig+0x134>
    switch(PeriphClkInit->QspiClockSelection)
 800ed98:	2a30      	cmp	r2, #48	; 0x30
 800ed9a:	f43f af5c 	beq.w	800ec56 <HAL_RCCEx_PeriphCLKConfig+0x156>
 800ed9e:	2601      	movs	r6, #1
 800eda0:	4635      	mov	r5, r6
 800eda2:	e762      	b.n	800ec6a <HAL_RCCEx_PeriphCLKConfig+0x16a>
    switch(PeriphClkInit->Spi123ClockSelection)
 800eda4:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
 800eda8:	f43f af75 	beq.w	800ec96 <HAL_RCCEx_PeriphCLKConfig+0x196>
 800edac:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
 800edb0:	f43f af71 	beq.w	800ec96 <HAL_RCCEx_PeriphCLKConfig+0x196>
 800edb4:	2601      	movs	r6, #1
 800edb6:	4635      	mov	r5, r6
 800edb8:	e777      	b.n	800ecaa <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    switch(PeriphClkInit->Spi45ClockSelection)
 800edba:	f422 3180 	bic.w	r1, r2, #65536	; 0x10000
 800edbe:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
 800edc2:	d085      	beq.n	800ecd0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>
 800edc4:	f5b2 3f40 	cmp.w	r2, #196608	; 0x30000
 800edc8:	d082      	beq.n	800ecd0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>
 800edca:	2601      	movs	r6, #1
 800edcc:	4635      	mov	r5, r6
 800edce:	e789      	b.n	800ece4 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
    switch(PeriphClkInit->Spi6ClockSelection)
 800edd0:	f022 5180 	bic.w	r1, r2, #268435456	; 0x10000000
 800edd4:	f1b1 4f80 	cmp.w	r1, #1073741824	; 0x40000000
 800edd8:	d097      	beq.n	800ed0a <HAL_RCCEx_PeriphCLKConfig+0x20a>
 800edda:	f1b2 5f40 	cmp.w	r2, #805306368	; 0x30000000
 800edde:	d094      	beq.n	800ed0a <HAL_RCCEx_PeriphCLKConfig+0x20a>
 800ede0:	2601      	movs	r6, #1
 800ede2:	4635      	mov	r5, r6
 800ede4:	e79c      	b.n	800ed20 <HAL_RCCEx_PeriphCLKConfig+0x220>
 800ede6:	bf00      	nop
 800ede8:	58024400 	.word	0x58024400
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 800edec:	2102      	movs	r1, #2
 800edee:	1d20      	adds	r0, r4, #4
 800edf0:	f7ff fd92 	bl	800e918 <RCCEx_PLL2_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800edf4:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 800edf6:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800edf8:	2d00      	cmp	r5, #0
 800edfa:	f000 8272 	beq.w	800f2e2 <HAL_RCCEx_PeriphCLKConfig+0x7e2>
 800edfe:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800ee00:	0259      	lsls	r1, r3, #9
 800ee02:	f100 81ee 	bmi.w	800f1e2 <HAL_RCCEx_PeriphCLKConfig+0x6e2>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
 800ee06:	07df      	lsls	r7, r3, #31
 800ee08:	d52f      	bpl.n	800ee6a <HAL_RCCEx_PeriphCLKConfig+0x36a>
    switch(PeriphClkInit->Usart16ClockSelection)
 800ee0a:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 800ee0c:	2a28      	cmp	r2, #40	; 0x28
 800ee0e:	d82a      	bhi.n	800ee66 <HAL_RCCEx_PeriphCLKConfig+0x366>
 800ee10:	e8df f012 	tbh	[pc, r2, lsl #1]
 800ee14:	002901dc 	.word	0x002901dc
 800ee18:	00290029 	.word	0x00290029
 800ee1c:	00290029 	.word	0x00290029
 800ee20:	00290029 	.word	0x00290029
 800ee24:	00290378 	.word	0x00290378
 800ee28:	00290029 	.word	0x00290029
 800ee2c:	00290029 	.word	0x00290029
 800ee30:	00290029 	.word	0x00290029
 800ee34:	002901d5 	.word	0x002901d5
 800ee38:	00290029 	.word	0x00290029
 800ee3c:	00290029 	.word	0x00290029
 800ee40:	00290029 	.word	0x00290029
 800ee44:	002901dc 	.word	0x002901dc
 800ee48:	00290029 	.word	0x00290029
 800ee4c:	00290029 	.word	0x00290029
 800ee50:	00290029 	.word	0x00290029
 800ee54:	002901dc 	.word	0x002901dc
 800ee58:	00290029 	.word	0x00290029
 800ee5c:	00290029 	.word	0x00290029
 800ee60:	00290029 	.word	0x00290029
 800ee64:	01dc      	.short	0x01dc
 800ee66:	2601      	movs	r6, #1
 800ee68:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
 800ee6a:	0798      	lsls	r0, r3, #30
 800ee6c:	d516      	bpl.n	800ee9c <HAL_RCCEx_PeriphCLKConfig+0x39c>
    switch(PeriphClkInit->Usart234578ClockSelection)
 800ee6e:	6f62      	ldr	r2, [r4, #116]	; 0x74
 800ee70:	2a05      	cmp	r2, #5
 800ee72:	f200 8380 	bhi.w	800f576 <HAL_RCCEx_PeriphCLKConfig+0xa76>
 800ee76:	e8df f012 	tbh	[pc, r2, lsl #1]
 800ee7a:	000d      	.short	0x000d
 800ee7c:	00060331 	.word	0x00060331
 800ee80:	000d000d 	.word	0x000d000d
 800ee84:	000d      	.short	0x000d
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800ee86:	2101      	movs	r1, #1
 800ee88:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800ee8c:	f7ff fdbe 	bl	800ea0c <RCCEx_PLL3_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800ee90:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800ee92:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ee94:	2d00      	cmp	r5, #0
 800ee96:	f000 822e 	beq.w	800f2f6 <HAL_RCCEx_PeriphCLKConfig+0x7f6>
 800ee9a:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800ee9c:	0759      	lsls	r1, r3, #29
 800ee9e:	d517      	bpl.n	800eed0 <HAL_RCCEx_PeriphCLKConfig+0x3d0>
    switch(PeriphClkInit->Lpuart1ClockSelection)
 800eea0:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 800eea4:	2a05      	cmp	r2, #5
 800eea6:	f200 836c 	bhi.w	800f582 <HAL_RCCEx_PeriphCLKConfig+0xa82>
 800eeaa:	e8df f012 	tbh	[pc, r2, lsl #1]
 800eeae:	000d      	.short	0x000d
 800eeb0:	00060321 	.word	0x00060321
 800eeb4:	000d000d 	.word	0x000d000d
 800eeb8:	000d      	.short	0x000d
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800eeba:	2101      	movs	r1, #1
 800eebc:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800eec0:	f7ff fda4 	bl	800ea0c <RCCEx_PLL3_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 800eec4:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800eec6:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800eec8:	2d00      	cmp	r5, #0
 800eeca:	f000 821c 	beq.w	800f306 <HAL_RCCEx_PeriphCLKConfig+0x806>
 800eece:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 800eed0:	069a      	lsls	r2, r3, #26
 800eed2:	d51d      	bpl.n	800ef10 <HAL_RCCEx_PeriphCLKConfig+0x410>
    switch(PeriphClkInit->Lptim1ClockSelection)
 800eed4:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 800eed8:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
 800eedc:	f000 8287 	beq.w	800f3ee <HAL_RCCEx_PeriphCLKConfig+0x8ee>
 800eee0:	f200 80e6 	bhi.w	800f0b0 <HAL_RCCEx_PeriphCLKConfig+0x5b0>
 800eee4:	b14a      	cbz	r2, 800eefa <HAL_RCCEx_PeriphCLKConfig+0x3fa>
 800eee6:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 800eeea:	f040 80eb 	bne.w	800f0c4 <HAL_RCCEx_PeriphCLKConfig+0x5c4>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800eeee:	2100      	movs	r1, #0
 800eef0:	1d20      	adds	r0, r4, #4
 800eef2:	f7ff fd11 	bl	800e918 <RCCEx_PLL2_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
 800eef6:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800eef8:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800eefa:	2d00      	cmp	r5, #0
 800eefc:	f040 81ef 	bne.w	800f2de <HAL_RCCEx_PeriphCLKConfig+0x7de>
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 800ef00:	49a4      	ldr	r1, [pc, #656]	; (800f194 <HAL_RCCEx_PeriphCLKConfig+0x694>)
 800ef02:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 800ef06:	6d4a      	ldr	r2, [r1, #84]	; 0x54
 800ef08:	f022 42e0 	bic.w	r2, r2, #1879048192	; 0x70000000
 800ef0c:	4302      	orrs	r2, r0
 800ef0e:	654a      	str	r2, [r1, #84]	; 0x54
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
 800ef10:	065f      	lsls	r7, r3, #25
 800ef12:	d51d      	bpl.n	800ef50 <HAL_RCCEx_PeriphCLKConfig+0x450>
    switch(PeriphClkInit->Lptim2ClockSelection)
 800ef14:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 800ef18:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 800ef1c:	f000 822e 	beq.w	800f37c <HAL_RCCEx_PeriphCLKConfig+0x87c>
 800ef20:	f200 80d3 	bhi.w	800f0ca <HAL_RCCEx_PeriphCLKConfig+0x5ca>
 800ef24:	b14a      	cbz	r2, 800ef3a <HAL_RCCEx_PeriphCLKConfig+0x43a>
 800ef26:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 800ef2a:	f040 80d8 	bne.w	800f0de <HAL_RCCEx_PeriphCLKConfig+0x5de>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800ef2e:	2100      	movs	r1, #0
 800ef30:	1d20      	adds	r0, r4, #4
 800ef32:	f7ff fcf1 	bl	800e918 <RCCEx_PLL2_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
 800ef36:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800ef38:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ef3a:	2d00      	cmp	r5, #0
 800ef3c:	f040 81f4 	bne.w	800f328 <HAL_RCCEx_PeriphCLKConfig+0x828>
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 800ef40:	4994      	ldr	r1, [pc, #592]	; (800f194 <HAL_RCCEx_PeriphCLKConfig+0x694>)
 800ef42:	f8d4 0098 	ldr.w	r0, [r4, #152]	; 0x98
 800ef46:	6d8a      	ldr	r2, [r1, #88]	; 0x58
 800ef48:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
 800ef4c:	4302      	orrs	r2, r0
 800ef4e:	658a      	str	r2, [r1, #88]	; 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
 800ef50:	0618      	lsls	r0, r3, #24
 800ef52:	d51d      	bpl.n	800ef90 <HAL_RCCEx_PeriphCLKConfig+0x490>
    switch(PeriphClkInit->Lptim345ClockSelection)
 800ef54:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
 800ef58:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
 800ef5c:	f000 8218 	beq.w	800f390 <HAL_RCCEx_PeriphCLKConfig+0x890>
 800ef60:	f200 80c0 	bhi.w	800f0e4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>
 800ef64:	b14a      	cbz	r2, 800ef7a <HAL_RCCEx_PeriphCLKConfig+0x47a>
 800ef66:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 800ef6a:	f040 80c5 	bne.w	800f0f8 <HAL_RCCEx_PeriphCLKConfig+0x5f8>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800ef6e:	2100      	movs	r1, #0
 800ef70:	1d20      	adds	r0, r4, #4
 800ef72:	f7ff fcd1 	bl	800e918 <RCCEx_PLL2_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
 800ef76:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800ef78:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ef7a:	2d00      	cmp	r5, #0
 800ef7c:	f040 81b9 	bne.w	800f2f2 <HAL_RCCEx_PeriphCLKConfig+0x7f2>
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
 800ef80:	4984      	ldr	r1, [pc, #528]	; (800f194 <HAL_RCCEx_PeriphCLKConfig+0x694>)
 800ef82:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
 800ef86:	6d8a      	ldr	r2, [r1, #88]	; 0x58
 800ef88:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 800ef8c:	4302      	orrs	r2, r0
 800ef8e:	658a      	str	r2, [r1, #88]	; 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
 800ef90:	0719      	lsls	r1, r3, #28
 800ef92:	d50b      	bpl.n	800efac <HAL_RCCEx_PeriphCLKConfig+0x4ac>
    if ((PeriphClkInit->I2c123ClockSelection )== RCC_I2C123CLKSOURCE_PLL3 )
 800ef94:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
 800ef98:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 800ef9c:	f000 823b 	beq.w	800f416 <HAL_RCCEx_PeriphCLKConfig+0x916>
      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
 800efa0:	487c      	ldr	r0, [pc, #496]	; (800f194 <HAL_RCCEx_PeriphCLKConfig+0x694>)
 800efa2:	6d42      	ldr	r2, [r0, #84]	; 0x54
 800efa4:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 800efa8:	430a      	orrs	r2, r1
 800efaa:	6542      	str	r2, [r0, #84]	; 0x54
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 800efac:	06da      	lsls	r2, r3, #27
 800efae:	d50b      	bpl.n	800efc8 <HAL_RCCEx_PeriphCLKConfig+0x4c8>
    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3 )
 800efb0:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
 800efb4:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 800efb8:	f000 823a 	beq.w	800f430 <HAL_RCCEx_PeriphCLKConfig+0x930>
      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 800efbc:	4875      	ldr	r0, [pc, #468]	; (800f194 <HAL_RCCEx_PeriphCLKConfig+0x694>)
 800efbe:	6d82      	ldr	r2, [r0, #88]	; 0x58
 800efc0:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 800efc4:	430a      	orrs	r2, r1
 800efc6:	6582      	str	r2, [r0, #88]	; 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 800efc8:	031f      	lsls	r7, r3, #12
 800efca:	d50e      	bpl.n	800efea <HAL_RCCEx_PeriphCLKConfig+0x4ea>
    switch(PeriphClkInit->AdcClockSelection)
 800efcc:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
 800efd0:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
 800efd4:	f000 80e0 	beq.w	800f198 <HAL_RCCEx_PeriphCLKConfig+0x698>
 800efd8:	f5b1 3f00 	cmp.w	r1, #131072	; 0x20000
 800efdc:	f000 80e3 	beq.w	800f1a6 <HAL_RCCEx_PeriphCLKConfig+0x6a6>
 800efe0:	2900      	cmp	r1, #0
 800efe2:	f000 81c3 	beq.w	800f36c <HAL_RCCEx_PeriphCLKConfig+0x86c>
 800efe6:	2601      	movs	r6, #1
 800efe8:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 800efea:	0358      	lsls	r0, r3, #13
 800efec:	d50f      	bpl.n	800f00e <HAL_RCCEx_PeriphCLKConfig+0x50e>
    switch(PeriphClkInit->UsbClockSelection)
 800efee:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
 800eff2:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
 800eff6:	f000 80ba 	beq.w	800f16e <HAL_RCCEx_PeriphCLKConfig+0x66e>
 800effa:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
 800effe:	f000 80bd 	beq.w	800f17c <HAL_RCCEx_PeriphCLKConfig+0x67c>
 800f002:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 800f006:	f000 81a9 	beq.w	800f35c <HAL_RCCEx_PeriphCLKConfig+0x85c>
 800f00a:	2601      	movs	r6, #1
 800f00c:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
 800f00e:	03d9      	lsls	r1, r3, #15
 800f010:	d509      	bpl.n	800f026 <HAL_RCCEx_PeriphCLKConfig+0x526>
    switch(PeriphClkInit->SdmmcClockSelection)
 800f012:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800f014:	2a00      	cmp	r2, #0
 800f016:	f000 818f 	beq.w	800f338 <HAL_RCCEx_PeriphCLKConfig+0x838>
 800f01a:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 800f01e:	f000 8136 	beq.w	800f28e <HAL_RCCEx_PeriphCLKConfig+0x78e>
 800f022:	2601      	movs	r6, #1
 800f024:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 800f026:	009a      	lsls	r2, r3, #2
 800f028:	f100 811c 	bmi.w	800f264 <HAL_RCCEx_PeriphCLKConfig+0x764>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 800f02c:	039f      	lsls	r7, r3, #14
 800f02e:	d466      	bmi.n	800f0fe <HAL_RCCEx_PeriphCLKConfig+0x5fe>
    return HAL_OK;
 800f030:	1e30      	subs	r0, r6, #0
 800f032:	bf18      	it	ne
 800f034:	2001      	movne	r0, #1
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 800f036:	02de      	lsls	r6, r3, #11
 800f038:	d506      	bpl.n	800f048 <HAL_RCCEx_PeriphCLKConfig+0x548>
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 800f03a:	4956      	ldr	r1, [pc, #344]	; (800f194 <HAL_RCCEx_PeriphCLKConfig+0x694>)
 800f03c:	6f25      	ldr	r5, [r4, #112]	; 0x70
 800f03e:	6d0a      	ldr	r2, [r1, #80]	; 0x50
 800f040:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 800f044:	432a      	orrs	r2, r5
 800f046:	650a      	str	r2, [r1, #80]	; 0x50
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_HRTIM1) == RCC_PERIPHCLK_HRTIM1)
 800f048:	00dd      	lsls	r5, r3, #3
 800f04a:	d507      	bpl.n	800f05c <HAL_RCCEx_PeriphCLKConfig+0x55c>
    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);
 800f04c:	4951      	ldr	r1, [pc, #324]	; (800f194 <HAL_RCCEx_PeriphCLKConfig+0x694>)
 800f04e:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
 800f052:	690a      	ldr	r2, [r1, #16]
 800f054:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800f058:	432a      	orrs	r2, r5
 800f05a:	610a      	str	r2, [r1, #16]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 800f05c:	0299      	lsls	r1, r3, #10
 800f05e:	d506      	bpl.n	800f06e <HAL_RCCEx_PeriphCLKConfig+0x56e>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 800f060:	494c      	ldr	r1, [pc, #304]	; (800f194 <HAL_RCCEx_PeriphCLKConfig+0x694>)
 800f062:	6ea5      	ldr	r5, [r4, #104]	; 0x68
 800f064:	6d0a      	ldr	r2, [r1, #80]	; 0x50
 800f066:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 800f06a:	432a      	orrs	r2, r5
 800f06c:	650a      	str	r2, [r1, #80]	; 0x50
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
 800f06e:	005a      	lsls	r2, r3, #1
 800f070:	d509      	bpl.n	800f086 <HAL_RCCEx_PeriphCLKConfig+0x586>
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 800f072:	4a48      	ldr	r2, [pc, #288]	; (800f194 <HAL_RCCEx_PeriphCLKConfig+0x694>)
 800f074:	6911      	ldr	r1, [r2, #16]
 800f076:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
 800f07a:	6111      	str	r1, [r2, #16]
 800f07c:	6911      	ldr	r1, [r2, #16]
 800f07e:	f8d4 50b8 	ldr.w	r5, [r4, #184]	; 0xb8
 800f082:	4329      	orrs	r1, r5
 800f084:	6111      	str	r1, [r2, #16]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
 800f086:	2b00      	cmp	r3, #0
 800f088:	da06      	bge.n	800f098 <HAL_RCCEx_PeriphCLKConfig+0x598>
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
 800f08a:	4942      	ldr	r1, [pc, #264]	; (800f194 <HAL_RCCEx_PeriphCLKConfig+0x694>)
 800f08c:	6d25      	ldr	r5, [r4, #80]	; 0x50
 800f08e:	6cca      	ldr	r2, [r1, #76]	; 0x4c
 800f090:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 800f094:	432a      	orrs	r2, r5
 800f096:	64ca      	str	r2, [r1, #76]	; 0x4c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 800f098:	021b      	lsls	r3, r3, #8
 800f09a:	d507      	bpl.n	800f0ac <HAL_RCCEx_PeriphCLKConfig+0x5ac>
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 800f09c:	4a3d      	ldr	r2, [pc, #244]	; (800f194 <HAL_RCCEx_PeriphCLKConfig+0x694>)
 800f09e:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
 800f0a2:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800f0a4:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 800f0a8:	430b      	orrs	r3, r1
 800f0aa:	6553      	str	r3, [r2, #84]	; 0x54
}
 800f0ac:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    switch(PeriphClkInit->Lptim1ClockSelection)
 800f0b0:	f022 5180 	bic.w	r1, r2, #268435456	; 0x10000000
 800f0b4:	f1b1 4f80 	cmp.w	r1, #1073741824	; 0x40000000
 800f0b8:	f43f af1f 	beq.w	800eefa <HAL_RCCEx_PeriphCLKConfig+0x3fa>
 800f0bc:	f1b2 5f40 	cmp.w	r2, #805306368	; 0x30000000
 800f0c0:	f43f af1b 	beq.w	800eefa <HAL_RCCEx_PeriphCLKConfig+0x3fa>
 800f0c4:	2601      	movs	r6, #1
 800f0c6:	4635      	mov	r5, r6
 800f0c8:	e722      	b.n	800ef10 <HAL_RCCEx_PeriphCLKConfig+0x410>
    switch(PeriphClkInit->Lptim2ClockSelection)
 800f0ca:	f422 6180 	bic.w	r1, r2, #1024	; 0x400
 800f0ce:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 800f0d2:	f43f af32 	beq.w	800ef3a <HAL_RCCEx_PeriphCLKConfig+0x43a>
 800f0d6:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 800f0da:	f43f af2e 	beq.w	800ef3a <HAL_RCCEx_PeriphCLKConfig+0x43a>
 800f0de:	2601      	movs	r6, #1
 800f0e0:	4635      	mov	r5, r6
 800f0e2:	e735      	b.n	800ef50 <HAL_RCCEx_PeriphCLKConfig+0x450>
    switch(PeriphClkInit->Lptim345ClockSelection)
 800f0e4:	f422 5100 	bic.w	r1, r2, #8192	; 0x2000
 800f0e8:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800f0ec:	f43f af45 	beq.w	800ef7a <HAL_RCCEx_PeriphCLKConfig+0x47a>
 800f0f0:	f5b2 4fc0 	cmp.w	r2, #24576	; 0x6000
 800f0f4:	f43f af41 	beq.w	800ef7a <HAL_RCCEx_PeriphCLKConfig+0x47a>
 800f0f8:	2601      	movs	r6, #1
 800f0fa:	4635      	mov	r5, r6
 800f0fc:	e748      	b.n	800ef90 <HAL_RCCEx_PeriphCLKConfig+0x490>
    switch(PeriphClkInit->RngClockSelection)
 800f0fe:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 800f100:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 800f104:	f000 8121 	beq.w	800f34a <HAL_RCCEx_PeriphCLKConfig+0x84a>
 800f108:	d906      	bls.n	800f118 <HAL_RCCEx_PeriphCLKConfig+0x618>
 800f10a:	f422 7180 	bic.w	r1, r2, #256	; 0x100
 800f10e:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 800f112:	d003      	beq.n	800f11c <HAL_RCCEx_PeriphCLKConfig+0x61c>
 800f114:	2001      	movs	r0, #1
 800f116:	e78e      	b.n	800f036 <HAL_RCCEx_PeriphCLKConfig+0x536>
 800f118:	2a00      	cmp	r2, #0
 800f11a:	d1fb      	bne.n	800f114 <HAL_RCCEx_PeriphCLKConfig+0x614>
    if(ret == HAL_OK)
 800f11c:	2d00      	cmp	r5, #0
 800f11e:	d1f9      	bne.n	800f114 <HAL_RCCEx_PeriphCLKConfig+0x614>
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 800f120:	4d1c      	ldr	r5, [pc, #112]	; (800f194 <HAL_RCCEx_PeriphCLKConfig+0x694>)
    return HAL_OK;
 800f122:	1e30      	subs	r0, r6, #0
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 800f124:	6d69      	ldr	r1, [r5, #84]	; 0x54
    return HAL_OK;
 800f126:	bf18      	it	ne
 800f128:	2001      	movne	r0, #1
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 800f12a:	f421 7140 	bic.w	r1, r1, #768	; 0x300
 800f12e:	430a      	orrs	r2, r1
 800f130:	656a      	str	r2, [r5, #84]	; 0x54
 800f132:	e780      	b.n	800f036 <HAL_RCCEx_PeriphCLKConfig+0x536>
    switch(PeriphClkInit->Sai1ClockSelection)
 800f134:	4635      	mov	r5, r6
    if(ret == HAL_OK)
 800f136:	2d00      	cmp	r5, #0
 800f138:	f040 80a5 	bne.w	800f286 <HAL_RCCEx_PeriphCLKConfig+0x786>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 800f13c:	4915      	ldr	r1, [pc, #84]	; (800f194 <HAL_RCCEx_PeriphCLKConfig+0x694>)
 800f13e:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800f140:	6d0a      	ldr	r2, [r1, #80]	; 0x50
 800f142:	f022 0207 	bic.w	r2, r2, #7
 800f146:	4302      	orrs	r2, r0
 800f148:	650a      	str	r2, [r1, #80]	; 0x50
 800f14a:	e511      	b.n	800eb70 <HAL_RCCEx_PeriphCLKConfig+0x70>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800f14c:	2101      	movs	r1, #1
 800f14e:	1d20      	adds	r0, r4, #4
 800f150:	f7ff fbe2 	bl	800e918 <RCCEx_PLL2_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
 800f154:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800f156:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800f158:	2d00      	cmp	r5, #0
 800f15a:	f040 80dd 	bne.w	800f318 <HAL_RCCEx_PeriphCLKConfig+0x818>
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 800f15e:	490d      	ldr	r1, [pc, #52]	; (800f194 <HAL_RCCEx_PeriphCLKConfig+0x694>)
 800f160:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800f162:	6d0a      	ldr	r2, [r1, #80]	; 0x50
 800f164:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 800f168:	4302      	orrs	r2, r0
 800f16a:	650a      	str	r2, [r1, #80]	; 0x50
 800f16c:	e5e8      	b.n	800ed40 <HAL_RCCEx_PeriphCLKConfig+0x240>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800f16e:	2101      	movs	r1, #1
 800f170:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800f174:	f7ff fc4a 	bl	800ea0c <RCCEx_PLL3_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
 800f178:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800f17a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800f17c:	2d00      	cmp	r5, #0
 800f17e:	f040 80d9 	bne.w	800f334 <HAL_RCCEx_PeriphCLKConfig+0x834>
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800f182:	4904      	ldr	r1, [pc, #16]	; (800f194 <HAL_RCCEx_PeriphCLKConfig+0x694>)
 800f184:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 800f188:	6d4a      	ldr	r2, [r1, #84]	; 0x54
 800f18a:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 800f18e:	4302      	orrs	r2, r0
 800f190:	654a      	str	r2, [r1, #84]	; 0x54
 800f192:	e73c      	b.n	800f00e <HAL_RCCEx_PeriphCLKConfig+0x50e>
 800f194:	58024400 	.word	0x58024400
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 800f198:	2102      	movs	r1, #2
 800f19a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800f19e:	f7ff fc35 	bl	800ea0c <RCCEx_PLL3_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 800f1a2:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 800f1a4:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800f1a6:	2d00      	cmp	r5, #0
 800f1a8:	f040 80c2 	bne.w	800f330 <HAL_RCCEx_PeriphCLKConfig+0x830>
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 800f1ac:	49ac      	ldr	r1, [pc, #688]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f1ae:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
 800f1b2:	6d8a      	ldr	r2, [r1, #88]	; 0x58
 800f1b4:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 800f1b8:	4302      	orrs	r2, r0
 800f1ba:	658a      	str	r2, [r1, #88]	; 0x58
 800f1bc:	e715      	b.n	800efea <HAL_RCCEx_PeriphCLKConfig+0x4ea>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800f1be:	2101      	movs	r1, #1
 800f1c0:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800f1c4:	f7ff fc22 	bl	800ea0c <RCCEx_PLL3_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
 800f1c8:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800f1ca:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800f1cc:	2d00      	cmp	r5, #0
 800f1ce:	f040 80ad 	bne.w	800f32c <HAL_RCCEx_PeriphCLKConfig+0x82c>
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
 800f1d2:	49a3      	ldr	r1, [pc, #652]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f1d4:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 800f1d6:	6d4a      	ldr	r2, [r1, #84]	; 0x54
 800f1d8:	f022 0238 	bic.w	r2, r2, #56	; 0x38
 800f1dc:	4302      	orrs	r2, r0
 800f1de:	654a      	str	r2, [r1, #84]	; 0x54
 800f1e0:	e643      	b.n	800ee6a <HAL_RCCEx_PeriphCLKConfig+0x36a>
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 800f1e2:	4fa0      	ldr	r7, [pc, #640]	; (800f464 <HAL_RCCEx_PeriphCLKConfig+0x964>)
 800f1e4:	683b      	ldr	r3, [r7, #0]
 800f1e6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800f1ea:	603b      	str	r3, [r7, #0]
    tickstart = HAL_GetTick();
 800f1ec:	f7fb fd8e 	bl	800ad0c <HAL_GetTick>
 800f1f0:	4680      	mov	r8, r0
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800f1f2:	e006      	b.n	800f202 <HAL_RCCEx_PeriphCLKConfig+0x702>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800f1f4:	f7fb fd8a 	bl	800ad0c <HAL_GetTick>
 800f1f8:	eba0 0008 	sub.w	r0, r0, r8
 800f1fc:	2864      	cmp	r0, #100	; 0x64
 800f1fe:	f200 818b 	bhi.w	800f518 <HAL_RCCEx_PeriphCLKConfig+0xa18>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800f202:	683b      	ldr	r3, [r7, #0]
 800f204:	05da      	lsls	r2, r3, #23
 800f206:	d5f5      	bpl.n	800f1f4 <HAL_RCCEx_PeriphCLKConfig+0x6f4>
    if(ret == HAL_OK)
 800f208:	2d00      	cmp	r5, #0
 800f20a:	f040 81b1 	bne.w	800f570 <HAL_RCCEx_PeriphCLKConfig+0xa70>
      if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 800f20e:	4a94      	ldr	r2, [pc, #592]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f210:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
 800f214:	6f11      	ldr	r1, [r2, #112]	; 0x70
 800f216:	4059      	eors	r1, r3
 800f218:	f411 7f40 	tst.w	r1, #768	; 0x300
 800f21c:	d00b      	beq.n	800f236 <HAL_RCCEx_PeriphCLKConfig+0x736>
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800f21e:	6f11      	ldr	r1, [r2, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_FORCE();
 800f220:	6f10      	ldr	r0, [r2, #112]	; 0x70
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800f222:	f421 7140 	bic.w	r1, r1, #768	; 0x300
        __HAL_RCC_BACKUPRESET_FORCE();
 800f226:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 800f22a:	6710      	str	r0, [r2, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
 800f22c:	6f10      	ldr	r0, [r2, #112]	; 0x70
 800f22e:	f420 3080 	bic.w	r0, r0, #65536	; 0x10000
 800f232:	6710      	str	r0, [r2, #112]	; 0x70
        RCC->BDCR = tmpreg;
 800f234:	6711      	str	r1, [r2, #112]	; 0x70
      if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
 800f236:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800f23a:	f000 817b 	beq.w	800f534 <HAL_RCCEx_PeriphCLKConfig+0xa34>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800f23e:	f403 7240 	and.w	r2, r3, #768	; 0x300
 800f242:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 800f246:	f000 8189 	beq.w	800f55c <HAL_RCCEx_PeriphCLKConfig+0xa5c>
 800f24a:	4985      	ldr	r1, [pc, #532]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f24c:	690a      	ldr	r2, [r1, #16]
 800f24e:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
 800f252:	610a      	str	r2, [r1, #16]
 800f254:	4a82      	ldr	r2, [pc, #520]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f256:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800f25a:	6f11      	ldr	r1, [r2, #112]	; 0x70
 800f25c:	430b      	orrs	r3, r1
 800f25e:	6713      	str	r3, [r2, #112]	; 0x70
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
 800f260:	6823      	ldr	r3, [r4, #0]
 800f262:	e5d0      	b.n	800ee06 <HAL_RCCEx_PeriphCLKConfig+0x306>
    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)
 800f264:	2102      	movs	r1, #2
 800f266:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800f26a:	f7ff fbcf 	bl	800ea0c <RCCEx_PLL3_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 800f26e:	6823      	ldr	r3, [r4, #0]
    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)
 800f270:	2800      	cmp	r0, #0
 800f272:	f43f aedb 	beq.w	800f02c <HAL_RCCEx_PeriphCLKConfig+0x52c>
      status=HAL_ERROR;
 800f276:	2601      	movs	r6, #1
 800f278:	e6d8      	b.n	800f02c <HAL_RCCEx_PeriphCLKConfig+0x52c>
 800f27a:	462e      	mov	r6, r5
 800f27c:	e496      	b.n	800ebac <HAL_RCCEx_PeriphCLKConfig+0xac>
 800f27e:	462e      	mov	r6, r5
 800f280:	e513      	b.n	800ecaa <HAL_RCCEx_PeriphCLKConfig+0x1aa>
 800f282:	462e      	mov	r6, r5
 800f284:	e4b4      	b.n	800ebf0 <HAL_RCCEx_PeriphCLKConfig+0xf0>
 800f286:	462e      	mov	r6, r5
 800f288:	e472      	b.n	800eb70 <HAL_RCCEx_PeriphCLKConfig+0x70>
 800f28a:	462e      	mov	r6, r5
 800f28c:	e4d2      	b.n	800ec34 <HAL_RCCEx_PeriphCLKConfig+0x134>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 800f28e:	2102      	movs	r1, #2
 800f290:	1d20      	adds	r0, r4, #4
 800f292:	f7ff fb41 	bl	800e918 <RCCEx_PLL2_Config>
 800f296:	4605      	mov	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 800f298:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800f29a:	2d00      	cmp	r5, #0
 800f29c:	d153      	bne.n	800f346 <HAL_RCCEx_PeriphCLKConfig+0x846>
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
 800f29e:	4970      	ldr	r1, [pc, #448]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f2a0:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 800f2a2:	6cca      	ldr	r2, [r1, #76]	; 0x4c
 800f2a4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800f2a8:	4302      	orrs	r2, r0
 800f2aa:	64ca      	str	r2, [r1, #76]	; 0x4c
 800f2ac:	e6bb      	b.n	800f026 <HAL_RCCEx_PeriphCLKConfig+0x526>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800f2ae:	496c      	ldr	r1, [pc, #432]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f2b0:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 800f2b2:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800f2b6:	62ca      	str	r2, [r1, #44]	; 0x2c
      break;
 800f2b8:	e46e      	b.n	800eb98 <HAL_RCCEx_PeriphCLKConfig+0x98>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800f2ba:	4969      	ldr	r1, [pc, #420]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f2bc:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 800f2be:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800f2c2:	62ca      	str	r2, [r1, #44]	; 0x2c
      break;
 800f2c4:	e489      	b.n	800ebda <HAL_RCCEx_PeriphCLKConfig+0xda>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800f2c6:	4966      	ldr	r1, [pc, #408]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f2c8:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 800f2ca:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800f2ce:	62ca      	str	r2, [r1, #44]	; 0x2c
      break;
 800f2d0:	e4a5      	b.n	800ec1e <HAL_RCCEx_PeriphCLKConfig+0x11e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800f2d2:	4963      	ldr	r1, [pc, #396]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f2d4:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 800f2d6:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800f2da:	62ca      	str	r2, [r1, #44]	; 0x2c
      break;
 800f2dc:	e4db      	b.n	800ec96 <HAL_RCCEx_PeriphCLKConfig+0x196>
 800f2de:	462e      	mov	r6, r5
 800f2e0:	e616      	b.n	800ef10 <HAL_RCCEx_PeriphCLKConfig+0x410>
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
 800f2e2:	495f      	ldr	r1, [pc, #380]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f2e4:	6c60      	ldr	r0, [r4, #68]	; 0x44
 800f2e6:	6cca      	ldr	r2, [r1, #76]	; 0x4c
 800f2e8:	f022 0203 	bic.w	r2, r2, #3
 800f2ec:	4302      	orrs	r2, r0
 800f2ee:	64ca      	str	r2, [r1, #76]	; 0x4c
 800f2f0:	e586      	b.n	800ee00 <HAL_RCCEx_PeriphCLKConfig+0x300>
 800f2f2:	462e      	mov	r6, r5
 800f2f4:	e64c      	b.n	800ef90 <HAL_RCCEx_PeriphCLKConfig+0x490>
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
 800f2f6:	495a      	ldr	r1, [pc, #360]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f2f8:	6f60      	ldr	r0, [r4, #116]	; 0x74
 800f2fa:	6d4a      	ldr	r2, [r1, #84]	; 0x54
 800f2fc:	f022 0207 	bic.w	r2, r2, #7
 800f300:	4302      	orrs	r2, r0
 800f302:	654a      	str	r2, [r1, #84]	; 0x54
 800f304:	e5ca      	b.n	800ee9c <HAL_RCCEx_PeriphCLKConfig+0x39c>
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 800f306:	4956      	ldr	r1, [pc, #344]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f308:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
 800f30c:	6d8a      	ldr	r2, [r1, #88]	; 0x58
 800f30e:	f022 0207 	bic.w	r2, r2, #7
 800f312:	4302      	orrs	r2, r0
 800f314:	658a      	str	r2, [r1, #88]	; 0x58
 800f316:	e5db      	b.n	800eed0 <HAL_RCCEx_PeriphCLKConfig+0x3d0>
 800f318:	462e      	mov	r6, r5
 800f31a:	e511      	b.n	800ed40 <HAL_RCCEx_PeriphCLKConfig+0x240>
 800f31c:	462e      	mov	r6, r5
 800f31e:	e4a4      	b.n	800ec6a <HAL_RCCEx_PeriphCLKConfig+0x16a>
 800f320:	462e      	mov	r6, r5
 800f322:	e4df      	b.n	800ece4 <HAL_RCCEx_PeriphCLKConfig+0x1e4>
 800f324:	462e      	mov	r6, r5
 800f326:	e4fb      	b.n	800ed20 <HAL_RCCEx_PeriphCLKConfig+0x220>
 800f328:	462e      	mov	r6, r5
 800f32a:	e611      	b.n	800ef50 <HAL_RCCEx_PeriphCLKConfig+0x450>
 800f32c:	462e      	mov	r6, r5
 800f32e:	e59c      	b.n	800ee6a <HAL_RCCEx_PeriphCLKConfig+0x36a>
 800f330:	462e      	mov	r6, r5
 800f332:	e65a      	b.n	800efea <HAL_RCCEx_PeriphCLKConfig+0x4ea>
 800f334:	462e      	mov	r6, r5
 800f336:	e66a      	b.n	800f00e <HAL_RCCEx_PeriphCLKConfig+0x50e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800f338:	4949      	ldr	r1, [pc, #292]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f33a:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 800f33c:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800f340:	62ca      	str	r2, [r1, #44]	; 0x2c
    if(ret == HAL_OK)
 800f342:	2d00      	cmp	r5, #0
 800f344:	d0ab      	beq.n	800f29e <HAL_RCCEx_PeriphCLKConfig+0x79e>
 800f346:	462e      	mov	r6, r5
 800f348:	e66d      	b.n	800f026 <HAL_RCCEx_PeriphCLKConfig+0x526>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800f34a:	4845      	ldr	r0, [pc, #276]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f34c:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800f34e:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
 800f352:	62c1      	str	r1, [r0, #44]	; 0x2c
    if(ret == HAL_OK)
 800f354:	2d00      	cmp	r5, #0
 800f356:	f47f aedd 	bne.w	800f114 <HAL_RCCEx_PeriphCLKConfig+0x614>
 800f35a:	e6e1      	b.n	800f120 <HAL_RCCEx_PeriphCLKConfig+0x620>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800f35c:	4940      	ldr	r1, [pc, #256]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f35e:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 800f360:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800f364:	62ca      	str	r2, [r1, #44]	; 0x2c
    if(ret == HAL_OK)
 800f366:	2d00      	cmp	r5, #0
 800f368:	d1e4      	bne.n	800f334 <HAL_RCCEx_PeriphCLKConfig+0x834>
 800f36a:	e70a      	b.n	800f182 <HAL_RCCEx_PeriphCLKConfig+0x682>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800f36c:	1d20      	adds	r0, r4, #4
 800f36e:	f7ff fad3 	bl	800e918 <RCCEx_PLL2_Config>
 800f372:	4605      	mov	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 800f374:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800f376:	2d00      	cmp	r5, #0
 800f378:	d1da      	bne.n	800f330 <HAL_RCCEx_PeriphCLKConfig+0x830>
 800f37a:	e717      	b.n	800f1ac <HAL_RCCEx_PeriphCLKConfig+0x6ac>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 800f37c:	2102      	movs	r1, #2
 800f37e:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800f382:	f7ff fb43 	bl	800ea0c <RCCEx_PLL3_Config>
 800f386:	4605      	mov	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
 800f388:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800f38a:	2d00      	cmp	r5, #0
 800f38c:	d1cc      	bne.n	800f328 <HAL_RCCEx_PeriphCLKConfig+0x828>
 800f38e:	e5d7      	b.n	800ef40 <HAL_RCCEx_PeriphCLKConfig+0x440>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 800f390:	2102      	movs	r1, #2
 800f392:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800f396:	f7ff fb39 	bl	800ea0c <RCCEx_PLL3_Config>
 800f39a:	4605      	mov	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
 800f39c:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800f39e:	2d00      	cmp	r5, #0
 800f3a0:	d1a7      	bne.n	800f2f2 <HAL_RCCEx_PeriphCLKConfig+0x7f2>
 800f3a2:	e5ed      	b.n	800ef80 <HAL_RCCEx_PeriphCLKConfig+0x480>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800f3a4:	2101      	movs	r1, #1
 800f3a6:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800f3aa:	f7ff fb2f 	bl	800ea0c <RCCEx_PLL3_Config>
 800f3ae:	4605      	mov	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
 800f3b0:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800f3b2:	2d00      	cmp	r5, #0
 800f3b4:	d1b4      	bne.n	800f320 <HAL_RCCEx_PeriphCLKConfig+0x820>
 800f3b6:	e48e      	b.n	800ecd6 <HAL_RCCEx_PeriphCLKConfig+0x1d6>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800f3b8:	2101      	movs	r1, #1
 800f3ba:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800f3be:	f7ff fb25 	bl	800ea0c <RCCEx_PLL3_Config>
 800f3c2:	4605      	mov	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 800f3c4:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800f3c6:	2d00      	cmp	r5, #0
 800f3c8:	d1ac      	bne.n	800f324 <HAL_RCCEx_PeriphCLKConfig+0x824>
 800f3ca:	e4a1      	b.n	800ed10 <HAL_RCCEx_PeriphCLKConfig+0x210>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800f3cc:	4924      	ldr	r1, [pc, #144]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f3ce:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 800f3d0:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800f3d4:	62ca      	str	r2, [r1, #44]	; 0x2c
    if(ret == HAL_OK)
 800f3d6:	2d00      	cmp	r5, #0
 800f3d8:	d19e      	bne.n	800f318 <HAL_RCCEx_PeriphCLKConfig+0x818>
 800f3da:	e6c0      	b.n	800f15e <HAL_RCCEx_PeriphCLKConfig+0x65e>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 800f3dc:	2102      	movs	r1, #2
 800f3de:	1d20      	adds	r0, r4, #4
 800f3e0:	f7ff fa9a 	bl	800e918 <RCCEx_PLL2_Config>
 800f3e4:	4605      	mov	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
 800f3e6:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800f3e8:	2d00      	cmp	r5, #0
 800f3ea:	d197      	bne.n	800f31c <HAL_RCCEx_PeriphCLKConfig+0x81c>
 800f3ec:	e436      	b.n	800ec5c <HAL_RCCEx_PeriphCLKConfig+0x15c>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 800f3ee:	2102      	movs	r1, #2
 800f3f0:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800f3f4:	f7ff fb0a 	bl	800ea0c <RCCEx_PLL3_Config>
 800f3f8:	4605      	mov	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
 800f3fa:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800f3fc:	2d00      	cmp	r5, #0
 800f3fe:	f47f af6e 	bne.w	800f2de <HAL_RCCEx_PeriphCLKConfig+0x7de>
 800f402:	e57d      	b.n	800ef00 <HAL_RCCEx_PeriphCLKConfig+0x400>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800f404:	4916      	ldr	r1, [pc, #88]	; (800f460 <HAL_RCCEx_PeriphCLKConfig+0x960>)
 800f406:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 800f408:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800f40c:	62ca      	str	r2, [r1, #44]	; 0x2c
    if(ret == HAL_OK)
 800f40e:	2d00      	cmp	r5, #0
 800f410:	f47f acf5 	bne.w	800edfe <HAL_RCCEx_PeriphCLKConfig+0x2fe>
 800f414:	e765      	b.n	800f2e2 <HAL_RCCEx_PeriphCLKConfig+0x7e2>
        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
 800f416:	2102      	movs	r1, #2
 800f418:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800f41c:	f7ff faf6 	bl	800ea0c <RCCEx_PLL3_Config>
      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
 800f420:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 800f424:	6823      	ldr	r3, [r4, #0]
        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
 800f426:	2800      	cmp	r0, #0
 800f428:	f43f adba 	beq.w	800efa0 <HAL_RCCEx_PeriphCLKConfig+0x4a0>
          status = HAL_ERROR;
 800f42c:	2601      	movs	r6, #1
 800f42e:	e5b7      	b.n	800efa0 <HAL_RCCEx_PeriphCLKConfig+0x4a0>
      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
 800f430:	2102      	movs	r1, #2
 800f432:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800f436:	f7ff fae9 	bl	800ea0c <RCCEx_PLL3_Config>
      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 800f43a:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 800f43e:	6823      	ldr	r3, [r4, #0]
      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
 800f440:	2800      	cmp	r0, #0
 800f442:	f43f adbb 	beq.w	800efbc <HAL_RCCEx_PeriphCLKConfig+0x4bc>
        status = HAL_ERROR;
 800f446:	2601      	movs	r6, #1
 800f448:	e5b8      	b.n	800efbc <HAL_RCCEx_PeriphCLKConfig+0x4bc>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 800f44a:	2102      	movs	r1, #2
 800f44c:	3024      	adds	r0, #36	; 0x24
 800f44e:	f7ff fadd 	bl	800ea0c <RCCEx_PLL3_Config>
 800f452:	4606      	mov	r6, r0
    if(ret == HAL_OK)
 800f454:	2e00      	cmp	r6, #0
 800f456:	f43f ab6f 	beq.w	800eb38 <HAL_RCCEx_PeriphCLKConfig+0x38>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 800f45a:	6823      	ldr	r3, [r4, #0]
 800f45c:	f7ff bb7a 	b.w	800eb54 <HAL_RCCEx_PeriphCLKConfig+0x54>
 800f460:	58024400 	.word	0x58024400
 800f464:	58024800 	.word	0x58024800
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 800f468:	2100      	movs	r1, #0
 800f46a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800f46e:	f7ff facd 	bl	800ea0c <RCCEx_PLL3_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
 800f472:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 800f474:	4605      	mov	r5, r0
      break;
 800f476:	f7ff bbb0 	b.w	800ebda <HAL_RCCEx_PeriphCLKConfig+0xda>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800f47a:	2100      	movs	r1, #0
 800f47c:	1d20      	adds	r0, r4, #4
 800f47e:	f7ff fa4b 	bl	800e918 <RCCEx_PLL2_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
 800f482:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800f484:	4605      	mov	r5, r0
      break;
 800f486:	e656      	b.n	800f136 <HAL_RCCEx_PeriphCLKConfig+0x636>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 800f488:	2100      	movs	r1, #0
 800f48a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800f48e:	f7ff fabd 	bl	800ea0c <RCCEx_PLL3_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
 800f492:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 800f494:	4605      	mov	r5, r0
      break;
 800f496:	e64e      	b.n	800f136 <HAL_RCCEx_PeriphCLKConfig+0x636>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 800f498:	2100      	movs	r1, #0
 800f49a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800f49e:	f7ff fab5 	bl	800ea0c <RCCEx_PLL3_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
 800f4a2:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 800f4a4:	4605      	mov	r5, r0
      break;
 800f4a6:	f7ff bbf6 	b.w	800ec96 <HAL_RCCEx_PeriphCLKConfig+0x196>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 800f4aa:	2100      	movs	r1, #0
 800f4ac:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800f4b0:	f7ff faac 	bl	800ea0c <RCCEx_PLL3_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
 800f4b4:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 800f4b6:	4605      	mov	r5, r0
      break;
 800f4b8:	f7ff bb6e 	b.w	800eb98 <HAL_RCCEx_PeriphCLKConfig+0x98>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800f4bc:	4932      	ldr	r1, [pc, #200]	; (800f588 <HAL_RCCEx_PeriphCLKConfig+0xa88>)
      break;
 800f4be:	4635      	mov	r5, r6
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800f4c0:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 800f4c2:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800f4c6:	62ca      	str	r2, [r1, #44]	; 0x2c
      break;
 800f4c8:	e635      	b.n	800f136 <HAL_RCCEx_PeriphCLKConfig+0x636>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 800f4ca:	2100      	movs	r1, #0
 800f4cc:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800f4d0:	f7ff fa9c 	bl	800ea0c <RCCEx_PLL3_Config>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
 800f4d4:	6823      	ldr	r3, [r4, #0]
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 800f4d6:	4605      	mov	r5, r0
      break;
 800f4d8:	f7ff bba1 	b.w	800ec1e <HAL_RCCEx_PeriphCLKConfig+0x11e>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800f4dc:	2101      	movs	r1, #1
 800f4de:	1d20      	adds	r0, r4, #4
 800f4e0:	f7ff fa1a 	bl	800e918 <RCCEx_PLL2_Config>
 800f4e4:	4605      	mov	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800f4e6:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800f4e8:	2d00      	cmp	r5, #0
 800f4ea:	f47f acd6 	bne.w	800ee9a <HAL_RCCEx_PeriphCLKConfig+0x39a>
 800f4ee:	e702      	b.n	800f2f6 <HAL_RCCEx_PeriphCLKConfig+0x7f6>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800f4f0:	2101      	movs	r1, #1
 800f4f2:	1d20      	adds	r0, r4, #4
 800f4f4:	f7ff fa10 	bl	800e918 <RCCEx_PLL2_Config>
 800f4f8:	4605      	mov	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 800f4fa:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800f4fc:	2d00      	cmp	r5, #0
 800f4fe:	f47f ace6 	bne.w	800eece <HAL_RCCEx_PeriphCLKConfig+0x3ce>
 800f502:	e700      	b.n	800f306 <HAL_RCCEx_PeriphCLKConfig+0x806>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800f504:	2101      	movs	r1, #1
 800f506:	1d20      	adds	r0, r4, #4
 800f508:	f7ff fa06 	bl	800e918 <RCCEx_PLL2_Config>
 800f50c:	4605      	mov	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
 800f50e:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800f510:	2d00      	cmp	r5, #0
 800f512:	f47f af0b 	bne.w	800f32c <HAL_RCCEx_PeriphCLKConfig+0x82c>
 800f516:	e65c      	b.n	800f1d2 <HAL_RCCEx_PeriphCLKConfig+0x6d2>
            ret = HAL_TIMEOUT;
 800f518:	2603      	movs	r6, #3
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
 800f51a:	6823      	ldr	r3, [r4, #0]
            ret = HAL_TIMEOUT;
 800f51c:	4635      	mov	r5, r6
 800f51e:	e472      	b.n	800ee06 <HAL_RCCEx_PeriphCLKConfig+0x306>
    switch(PeriphClkInit->SpdifrxClockSelection)
 800f520:	2601      	movs	r6, #1
 800f522:	f7ff bb17 	b.w	800eb54 <HAL_RCCEx_PeriphCLKConfig+0x54>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800f526:	4818      	ldr	r0, [pc, #96]	; (800f588 <HAL_RCCEx_PeriphCLKConfig+0xa88>)
 800f528:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800f52a:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
 800f52e:	62c1      	str	r1, [r0, #44]	; 0x2c
    if(ret == HAL_OK)
 800f530:	f7ff bb09 	b.w	800eb46 <HAL_RCCEx_PeriphCLKConfig+0x46>
        tickstart = HAL_GetTick();
 800f534:	f7fb fbea 	bl	800ad0c <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800f538:	f8df 804c 	ldr.w	r8, [pc, #76]	; 800f588 <HAL_RCCEx_PeriphCLKConfig+0xa88>
        tickstart = HAL_GetTick();
 800f53c:	4607      	mov	r7, r0
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800f53e:	f241 3988 	movw	r9, #5000	; 0x1388
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800f542:	e004      	b.n	800f54e <HAL_RCCEx_PeriphCLKConfig+0xa4e>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800f544:	f7fb fbe2 	bl	800ad0c <HAL_GetTick>
 800f548:	1bc0      	subs	r0, r0, r7
 800f54a:	4548      	cmp	r0, r9
 800f54c:	d8e4      	bhi.n	800f518 <HAL_RCCEx_PeriphCLKConfig+0xa18>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800f54e:	f8d8 3070 	ldr.w	r3, [r8, #112]	; 0x70
 800f552:	079b      	lsls	r3, r3, #30
 800f554:	d5f6      	bpl.n	800f544 <HAL_RCCEx_PeriphCLKConfig+0xa44>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800f556:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
 800f55a:	e670      	b.n	800f23e <HAL_RCCEx_PeriphCLKConfig+0x73e>
 800f55c:	480a      	ldr	r0, [pc, #40]	; (800f588 <HAL_RCCEx_PeriphCLKConfig+0xa88>)
 800f55e:	4a0b      	ldr	r2, [pc, #44]	; (800f58c <HAL_RCCEx_PeriphCLKConfig+0xa8c>)
 800f560:	6901      	ldr	r1, [r0, #16]
 800f562:	ea02 1213 	and.w	r2, r2, r3, lsr #4
 800f566:	f421 517c 	bic.w	r1, r1, #16128	; 0x3f00
 800f56a:	430a      	orrs	r2, r1
 800f56c:	6102      	str	r2, [r0, #16]
 800f56e:	e671      	b.n	800f254 <HAL_RCCEx_PeriphCLKConfig+0x754>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
 800f570:	6823      	ldr	r3, [r4, #0]
 800f572:	462e      	mov	r6, r5
 800f574:	e447      	b.n	800ee06 <HAL_RCCEx_PeriphCLKConfig+0x306>
    switch(PeriphClkInit->Usart234578ClockSelection)
 800f576:	2601      	movs	r6, #1
 800f578:	4635      	mov	r5, r6
 800f57a:	e48f      	b.n	800ee9c <HAL_RCCEx_PeriphCLKConfig+0x39c>
    switch(PeriphClkInit->FmcClockSelection)
 800f57c:	2601      	movs	r6, #1
 800f57e:	4635      	mov	r5, r6
 800f580:	e43e      	b.n	800ee00 <HAL_RCCEx_PeriphCLKConfig+0x300>
    switch(PeriphClkInit->Lpuart1ClockSelection)
 800f582:	2601      	movs	r6, #1
 800f584:	4635      	mov	r5, r6
 800f586:	e4a3      	b.n	800eed0 <HAL_RCCEx_PeriphCLKConfig+0x3d0>
 800f588:	58024400 	.word	0x58024400
 800f58c:	00ffffcf 	.word	0x00ffffcf

0800f590 <HAL_RCCEx_GetD3PCLK1Freq>:
{
 800f590:	b508      	push	{r3, lr}
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE)>> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
 800f592:	f7ff f8c5 	bl	800e720 <HAL_RCC_GetHCLKFreq>
 800f596:	4b05      	ldr	r3, [pc, #20]	; (800f5ac <HAL_RCCEx_GetD3PCLK1Freq+0x1c>)
 800f598:	4a05      	ldr	r2, [pc, #20]	; (800f5b0 <HAL_RCCEx_GetD3PCLK1Freq+0x20>)
 800f59a:	6a1b      	ldr	r3, [r3, #32]
 800f59c:	f3c3 1302 	ubfx	r3, r3, #4, #3
 800f5a0:	5cd3      	ldrb	r3, [r2, r3]
 800f5a2:	f003 031f 	and.w	r3, r3, #31
}
 800f5a6:	40d8      	lsrs	r0, r3
 800f5a8:	bd08      	pop	{r3, pc}
 800f5aa:	bf00      	nop
 800f5ac:	58024400 	.word	0x58024400
 800f5b0:	24008240 	.word	0x24008240

0800f5b4 <HAL_RCCEx_GetPLL2ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800f5b4:	4b4f      	ldr	r3, [pc, #316]	; (800f6f4 <HAL_RCCEx_GetPLL2ClockFreq+0x140>)
{
 800f5b6:	b470      	push	{r4, r5, r6}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800f5b8:	6a99      	ldr	r1, [r3, #40]	; 0x28
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
 800f5ba:	6a9d      	ldr	r5, [r3, #40]	; 0x28
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 800f5bc:	6ade      	ldr	r6, [r3, #44]	; 0x2c
  if (pll2m != 0U)
 800f5be:	f415 3f7c 	tst.w	r5, #258048	; 0x3f000
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
 800f5c2:	f3c5 3205 	ubfx	r2, r5, #12, #6
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
 800f5c6:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
  if (pll2m != 0U)
 800f5c8:	d05c      	beq.n	800f684 <HAL_RCCEx_GetPLL2ClockFreq+0xd0>
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
 800f5ca:	f3c4 04cc 	ubfx	r4, r4, #3, #13
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 800f5ce:	f3c6 1600 	ubfx	r6, r6, #4, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800f5d2:	f001 0103 	and.w	r1, r1, #3
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
 800f5d6:	fb06 f404 	mul.w	r4, r6, r4
    switch (pllsource)
 800f5da:	2901      	cmp	r1, #1
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
 800f5dc:	ee07 4a90 	vmov	s15, r4
 800f5e0:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    switch (pllsource)
 800f5e4:	d003      	beq.n	800f5ee <HAL_RCCEx_GetPLL2ClockFreq+0x3a>
 800f5e6:	2902      	cmp	r1, #2
 800f5e8:	d075      	beq.n	800f6d6 <HAL_RCCEx_GetPLL2ClockFreq+0x122>
 800f5ea:	2900      	cmp	r1, #0
 800f5ec:	d04f      	beq.n	800f68e <HAL_RCCEx_GetPLL2ClockFreq+0xda>
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 800f5ee:	ee07 2a90 	vmov	s15, r2
 800f5f2:	eddf 6a41 	vldr	s13, [pc, #260]	; 800f6f8 <HAL_RCCEx_GetPLL2ClockFreq+0x144>
 800f5f6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800f5fa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800f5fc:	ee86 6aa7 	vdiv.f32	s12, s13, s15
 800f600:	eddf 5a3e 	vldr	s11, [pc, #248]	; 800f6fc <HAL_RCCEx_GetPLL2ClockFreq+0x148>
 800f604:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800f608:	ee06 3a90 	vmov	s13, r3
 800f60c:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 800f610:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800f614:	ee76 6a85 	vadd.f32	s13, s13, s10
 800f618:	eee7 6a25 	vfma.f32	s13, s14, s11
 800f61c:	ee66 6a26 	vmul.f32	s13, s12, s13
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
 800f620:	4a34      	ldr	r2, [pc, #208]	; (800f6f4 <HAL_RCCEx_GetPLL2ClockFreq+0x140>)
 800f622:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 800f626:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800f628:	f3c3 2346 	ubfx	r3, r3, #9, #7
 800f62c:	ee07 3a10 	vmov	s14, r3
 800f630:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
}
 800f634:	bc70      	pop	{r4, r5, r6}
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
 800f636:	ee37 7a06 	vadd.f32	s14, s14, s12
 800f63a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800f63e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800f642:	edc0 7a00 	vstr	s15, [r0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >>16) + (float_t)1 )) ;
 800f646:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800f648:	f3c3 4306 	ubfx	r3, r3, #16, #7
 800f64c:	ee07 3a10 	vmov	s14, r3
 800f650:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800f654:	ee37 7a06 	vadd.f32	s14, s14, s12
 800f658:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800f65c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800f660:	edc0 7a01 	vstr	s15, [r0, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >>24) + (float_t)1 )) ;
 800f664:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800f666:	f3c3 6306 	ubfx	r3, r3, #24, #7
 800f66a:	ee07 3a90 	vmov	s15, r3
 800f66e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800f672:	ee77 7a86 	vadd.f32	s15, s15, s12
 800f676:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800f67a:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 800f67e:	ed80 7a02 	vstr	s14, [r0, #8]
}
 800f682:	4770      	bx	lr
 800f684:	bc70      	pop	{r4, r5, r6}
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
 800f686:	e9c0 2200 	strd	r2, r2, [r0]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
 800f68a:	6082      	str	r2, [r0, #8]
}
 800f68c:	4770      	bx	lr
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800f68e:	6819      	ldr	r1, [r3, #0]
 800f690:	0689      	lsls	r1, r1, #26
 800f692:	d527      	bpl.n	800f6e4 <HAL_RCCEx_GetPLL2ClockFreq+0x130>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800f694:	681c      	ldr	r4, [r3, #0]
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 800f696:	ee07 2a90 	vmov	s15, r2
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800f69a:	4919      	ldr	r1, [pc, #100]	; (800f700 <HAL_RCCEx_GetPLL2ClockFreq+0x14c>)
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 800f69c:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 800f6a0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800f6a2:	f3c4 02c1 	ubfx	r2, r4, #3, #2
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 800f6a6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800f6aa:	ed9f 5a14 	vldr	s10, [pc, #80]	; 800f6fc <HAL_RCCEx_GetPLL2ClockFreq+0x148>
 800f6ae:	f3c3 0308 	ubfx	r3, r3, #0, #9
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800f6b2:	40d1      	lsrs	r1, r2
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 800f6b4:	ee06 3a90 	vmov	s13, r3
 800f6b8:	ee05 1a90 	vmov	s11, r1
 800f6bc:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800f6c0:	eef8 5ae5 	vcvt.f32.s32	s11, s11
 800f6c4:	ee76 6a86 	vadd.f32	s13, s13, s12
 800f6c8:	ee85 6aa7 	vdiv.f32	s12, s11, s15
 800f6cc:	eee7 6a05 	vfma.f32	s13, s14, s10
 800f6d0:	ee66 6a26 	vmul.f32	s13, s12, s13
 800f6d4:	e7a4      	b.n	800f620 <HAL_RCCEx_GetPLL2ClockFreq+0x6c>
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 800f6d6:	ee07 2a90 	vmov	s15, r2
 800f6da:	eddf 6a0a 	vldr	s13, [pc, #40]	; 800f704 <HAL_RCCEx_GetPLL2ClockFreq+0x150>
 800f6de:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800f6e2:	e78a      	b.n	800f5fa <HAL_RCCEx_GetPLL2ClockFreq+0x46>
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 800f6e4:	ee07 2a90 	vmov	s15, r2
 800f6e8:	eddf 6a07 	vldr	s13, [pc, #28]	; 800f708 <HAL_RCCEx_GetPLL2ClockFreq+0x154>
 800f6ec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800f6f0:	e783      	b.n	800f5fa <HAL_RCCEx_GetPLL2ClockFreq+0x46>
 800f6f2:	bf00      	nop
 800f6f4:	58024400 	.word	0x58024400
 800f6f8:	4a742400 	.word	0x4a742400
 800f6fc:	39000000 	.word	0x39000000
 800f700:	03d09000 	.word	0x03d09000
 800f704:	4af42400 	.word	0x4af42400
 800f708:	4c742400 	.word	0x4c742400

0800f70c <HAL_RCCEx_GetPLL3ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800f70c:	4b4f      	ldr	r3, [pc, #316]	; (800f84c <HAL_RCCEx_GetPLL3ClockFreq+0x140>)
{
 800f70e:	b470      	push	{r4, r5, r6}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800f710:	6a99      	ldr	r1, [r3, #40]	; 0x28
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
 800f712:	6a9d      	ldr	r5, [r3, #40]	; 0x28
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 800f714:	6ade      	ldr	r6, [r3, #44]	; 0x2c
  if (pll3m != 0U)
 800f716:	f015 7f7c 	tst.w	r5, #66060288	; 0x3f00000
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
 800f71a:	f3c5 5205 	ubfx	r2, r5, #20, #6
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
 800f71e:	6c5c      	ldr	r4, [r3, #68]	; 0x44
  if (pll3m != 0U)
 800f720:	d05c      	beq.n	800f7dc <HAL_RCCEx_GetPLL3ClockFreq+0xd0>
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
 800f722:	f3c4 04cc 	ubfx	r4, r4, #3, #13
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 800f726:	f3c6 2600 	ubfx	r6, r6, #8, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800f72a:	f001 0103 	and.w	r1, r1, #3
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
 800f72e:	fb06 f404 	mul.w	r4, r6, r4
    switch (pllsource)
 800f732:	2901      	cmp	r1, #1
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
 800f734:	ee07 4a90 	vmov	s15, r4
 800f738:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    switch (pllsource)
 800f73c:	d003      	beq.n	800f746 <HAL_RCCEx_GetPLL3ClockFreq+0x3a>
 800f73e:	2902      	cmp	r1, #2
 800f740:	d075      	beq.n	800f82e <HAL_RCCEx_GetPLL3ClockFreq+0x122>
 800f742:	2900      	cmp	r1, #0
 800f744:	d04f      	beq.n	800f7e6 <HAL_RCCEx_GetPLL3ClockFreq+0xda>
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800f746:	ee07 2a90 	vmov	s15, r2
 800f74a:	eddf 6a41 	vldr	s13, [pc, #260]	; 800f850 <HAL_RCCEx_GetPLL3ClockFreq+0x144>
 800f74e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800f752:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f754:	ee86 6aa7 	vdiv.f32	s12, s13, s15
 800f758:	eddf 5a3e 	vldr	s11, [pc, #248]	; 800f854 <HAL_RCCEx_GetPLL3ClockFreq+0x148>
 800f75c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800f760:	ee06 3a90 	vmov	s13, r3
 800f764:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 800f768:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800f76c:	ee76 6a85 	vadd.f32	s13, s13, s10
 800f770:	eee7 6a25 	vfma.f32	s13, s14, s11
 800f774:	ee66 6a26 	vmul.f32	s13, s12, s13
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
 800f778:	4a34      	ldr	r2, [pc, #208]	; (800f84c <HAL_RCCEx_GetPLL3ClockFreq+0x140>)
 800f77a:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 800f77e:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800f780:	f3c3 2346 	ubfx	r3, r3, #9, #7
 800f784:	ee07 3a10 	vmov	s14, r3
 800f788:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
}
 800f78c:	bc70      	pop	{r4, r5, r6}
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
 800f78e:	ee37 7a06 	vadd.f32	s14, s14, s12
 800f792:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800f796:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800f79a:	edc0 7a00 	vstr	s15, [r0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >>16) + (float_t)1 )) ;
 800f79e:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800f7a0:	f3c3 4306 	ubfx	r3, r3, #16, #7
 800f7a4:	ee07 3a10 	vmov	s14, r3
 800f7a8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800f7ac:	ee37 7a06 	vadd.f32	s14, s14, s12
 800f7b0:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800f7b4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800f7b8:	edc0 7a01 	vstr	s15, [r0, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >>24) + (float_t)1 )) ;
 800f7bc:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800f7be:	f3c3 6306 	ubfx	r3, r3, #24, #7
 800f7c2:	ee07 3a90 	vmov	s15, r3
 800f7c6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800f7ca:	ee77 7a86 	vadd.f32	s15, s15, s12
 800f7ce:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800f7d2:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 800f7d6:	ed80 7a02 	vstr	s14, [r0, #8]
}
 800f7da:	4770      	bx	lr
 800f7dc:	bc70      	pop	{r4, r5, r6}
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
 800f7de:	e9c0 2200 	strd	r2, r2, [r0]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
 800f7e2:	6082      	str	r2, [r0, #8]
}
 800f7e4:	4770      	bx	lr
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800f7e6:	6819      	ldr	r1, [r3, #0]
 800f7e8:	0689      	lsls	r1, r1, #26
 800f7ea:	d527      	bpl.n	800f83c <HAL_RCCEx_GetPLL3ClockFreq+0x130>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800f7ec:	681c      	ldr	r4, [r3, #0]
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800f7ee:	ee07 2a90 	vmov	s15, r2
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800f7f2:	4919      	ldr	r1, [pc, #100]	; (800f858 <HAL_RCCEx_GetPLL3ClockFreq+0x14c>)
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800f7f4:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 800f7f8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800f7fa:	f3c4 02c1 	ubfx	r2, r4, #3, #2
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800f7fe:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800f802:	ed9f 5a14 	vldr	s10, [pc, #80]	; 800f854 <HAL_RCCEx_GetPLL3ClockFreq+0x148>
 800f806:	f3c3 0308 	ubfx	r3, r3, #0, #9
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800f80a:	40d1      	lsrs	r1, r2
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800f80c:	ee06 3a90 	vmov	s13, r3
 800f810:	ee05 1a90 	vmov	s11, r1
 800f814:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800f818:	eef8 5ae5 	vcvt.f32.s32	s11, s11
 800f81c:	ee76 6a86 	vadd.f32	s13, s13, s12
 800f820:	ee85 6aa7 	vdiv.f32	s12, s11, s15
 800f824:	eee7 6a05 	vfma.f32	s13, s14, s10
 800f828:	ee66 6a26 	vmul.f32	s13, s12, s13
 800f82c:	e7a4      	b.n	800f778 <HAL_RCCEx_GetPLL3ClockFreq+0x6c>
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800f82e:	ee07 2a90 	vmov	s15, r2
 800f832:	eddf 6a0a 	vldr	s13, [pc, #40]	; 800f85c <HAL_RCCEx_GetPLL3ClockFreq+0x150>
 800f836:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800f83a:	e78a      	b.n	800f752 <HAL_RCCEx_GetPLL3ClockFreq+0x46>
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800f83c:	ee07 2a90 	vmov	s15, r2
 800f840:	eddf 6a07 	vldr	s13, [pc, #28]	; 800f860 <HAL_RCCEx_GetPLL3ClockFreq+0x154>
 800f844:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800f848:	e783      	b.n	800f752 <HAL_RCCEx_GetPLL3ClockFreq+0x46>
 800f84a:	bf00      	nop
 800f84c:	58024400 	.word	0x58024400
 800f850:	4a742400 	.word	0x4a742400
 800f854:	39000000 	.word	0x39000000
 800f858:	03d09000 	.word	0x03d09000
 800f85c:	4af42400 	.word	0x4af42400
 800f860:	4c742400 	.word	0x4c742400

0800f864 <HAL_RNG_Init>:
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{
  uint32_t tickstart;
  /* Check the RNG handle allocation */
  if (hrng == NULL)
 800f864:	2800      	cmp	r0, #0
 800f866:	d039      	beq.n	800f8dc <HAL_RNG_Init+0x78>
{
 800f868:	b538      	push	{r3, r4, r5, lr}

    /* Init the low level hardware */
    hrng->MspInitCallback(hrng);
  }
#else
  if (hrng->State == HAL_RNG_STATE_RESET)
 800f86a:	7a43      	ldrb	r3, [r0, #9]
 800f86c:	4604      	mov	r4, r0
 800f86e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800f872:	b37b      	cbz	r3, 800f8d4 <HAL_RNG_Init+0x70>
      }
    }
  }
#else
  /* Clock Error Detection Configuration */
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED, hrng->Init.ClockErrorDetection);
 800f874:	6823      	ldr	r3, [r4, #0]
  hrng->State = HAL_RNG_STATE_BUSY;
 800f876:	2202      	movs	r2, #2
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED, hrng->Init.ClockErrorDetection);
 800f878:	6861      	ldr	r1, [r4, #4]
  hrng->State = HAL_RNG_STATE_BUSY;
 800f87a:	7262      	strb	r2, [r4, #9]
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED, hrng->Init.ClockErrorDetection);
 800f87c:	681a      	ldr	r2, [r3, #0]
 800f87e:	f022 0220 	bic.w	r2, r2, #32
 800f882:	430a      	orrs	r2, r1
 800f884:	601a      	str	r2, [r3, #0]
#endif /* RNG_CR_CONDRST */

  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
 800f886:	681a      	ldr	r2, [r3, #0]
 800f888:	f042 0204 	orr.w	r2, r2, #4
 800f88c:	601a      	str	r2, [r3, #0]

  /* verify that no seed error */
  if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 800f88e:	685b      	ldr	r3, [r3, #4]
 800f890:	0658      	lsls	r0, r3, #25
 800f892:	d503      	bpl.n	800f89c <HAL_RNG_Init+0x38>
  {
    hrng->State = HAL_RNG_STATE_ERROR;
 800f894:	2304      	movs	r3, #4
    return HAL_ERROR;
 800f896:	2001      	movs	r0, #1
    hrng->State = HAL_RNG_STATE_ERROR;
 800f898:	7263      	strb	r3, [r4, #9]
  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;

  /* Return function status */
  return HAL_OK;
}
 800f89a:	bd38      	pop	{r3, r4, r5, pc}
  tickstart = HAL_GetTick();
 800f89c:	f7fb fa36 	bl	800ad0c <HAL_GetTick>
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 800f8a0:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 800f8a2:	4605      	mov	r5, r0
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 800f8a4:	685b      	ldr	r3, [r3, #4]
 800f8a6:	0759      	lsls	r1, r3, #29
 800f8a8:	d50e      	bpl.n	800f8c8 <HAL_RNG_Init+0x64>
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 800f8aa:	f7fb fa2f 	bl	800ad0c <HAL_GetTick>
 800f8ae:	1b43      	subs	r3, r0, r5
 800f8b0:	2b02      	cmp	r3, #2
      if (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 800f8b2:	6823      	ldr	r3, [r4, #0]
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 800f8b4:	d9f6      	bls.n	800f8a4 <HAL_RNG_Init+0x40>
      if (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 800f8b6:	685a      	ldr	r2, [r3, #4]
 800f8b8:	0752      	lsls	r2, r2, #29
 800f8ba:	d5f3      	bpl.n	800f8a4 <HAL_RNG_Init+0x40>
        hrng->State = HAL_RNG_STATE_ERROR;
 800f8bc:	2204      	movs	r2, #4
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 800f8be:	2302      	movs	r3, #2
        return HAL_ERROR;
 800f8c0:	2001      	movs	r0, #1
        hrng->State = HAL_RNG_STATE_ERROR;
 800f8c2:	7262      	strb	r2, [r4, #9]
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 800f8c4:	60e3      	str	r3, [r4, #12]
}
 800f8c6:	bd38      	pop	{r3, r4, r5, pc}
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 800f8c8:	2300      	movs	r3, #0
  hrng->State = HAL_RNG_STATE_READY;
 800f8ca:	2201      	movs	r2, #1
  return HAL_OK;
 800f8cc:	4618      	mov	r0, r3
  hrng->State = HAL_RNG_STATE_READY;
 800f8ce:	7262      	strb	r2, [r4, #9]
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 800f8d0:	60e3      	str	r3, [r4, #12]
}
 800f8d2:	bd38      	pop	{r3, r4, r5, pc}
    hrng->Lock = HAL_UNLOCKED;
 800f8d4:	7202      	strb	r2, [r0, #8]
    HAL_RNG_MspInit(hrng);
 800f8d6:	f7fa ff1b 	bl	800a710 <HAL_RNG_MspInit>
 800f8da:	e7cb      	b.n	800f874 <HAL_RNG_Init+0x10>
    return HAL_ERROR;
 800f8dc:	2001      	movs	r0, #1
}
 800f8de:	4770      	bx	lr

0800f8e0 <HAL_RNG_ReadyDataCallback>:
  UNUSED(hrng);
  UNUSED(random32bit);
  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_RNG_ReadyDataCallback must be implemented in the user file.
   */
}
 800f8e0:	4770      	bx	lr
 800f8e2:	bf00      	nop

0800f8e4 <HAL_RNG_ErrorCallback>:
 800f8e4:	4770      	bx	lr
 800f8e6:	bf00      	nop

0800f8e8 <HAL_RNG_IRQHandler>:
  if (__HAL_RNG_GET_IT(hrng, RNG_IT_CEI) != RESET)
 800f8e8:	6803      	ldr	r3, [r0, #0]
 800f8ea:	685a      	ldr	r2, [r3, #4]
 800f8ec:	0692      	lsls	r2, r2, #26
{
 800f8ee:	b510      	push	{r4, lr}
 800f8f0:	4604      	mov	r4, r0
  if (__HAL_RNG_GET_IT(hrng, RNG_IT_CEI) != RESET)
 800f8f2:	d416      	bmi.n	800f922 <HAL_RNG_IRQHandler+0x3a>
  else if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 800f8f4:	685a      	ldr	r2, [r3, #4]
 800f8f6:	0650      	lsls	r0, r2, #25
 800f8f8:	d506      	bpl.n	800f908 <HAL_RNG_IRQHandler+0x20>
    if (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) == RESET)
 800f8fa:	685a      	ldr	r2, [r3, #4]
 800f8fc:	0751      	lsls	r1, r2, #29
 800f8fe:	d424      	bmi.n	800f94a <HAL_RNG_IRQHandler+0x62>
      CLEAR_BIT(hrng->Instance->SR, RNG_IT_SEI);
 800f900:	685a      	ldr	r2, [r3, #4]
 800f902:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800f906:	605a      	str	r2, [r3, #4]
  if (__HAL_RNG_GET_IT(hrng, RNG_IT_DRDY) != RESET)
 800f908:	685a      	ldr	r2, [r3, #4]
 800f90a:	07d2      	lsls	r2, r2, #31
 800f90c:	d508      	bpl.n	800f920 <HAL_RNG_IRQHandler+0x38>
    __HAL_RNG_DISABLE_IT(hrng);
 800f90e:	681a      	ldr	r2, [r3, #0]
 800f910:	f022 0208 	bic.w	r2, r2, #8
 800f914:	601a      	str	r2, [r3, #0]
    hrng->RandomNumber = hrng->Instance->DR;
 800f916:	6899      	ldr	r1, [r3, #8]
    if (hrng->State != HAL_RNG_STATE_ERROR)
 800f918:	7a63      	ldrb	r3, [r4, #9]
    hrng->RandomNumber = hrng->Instance->DR;
 800f91a:	6121      	str	r1, [r4, #16]
    if (hrng->State != HAL_RNG_STATE_ERROR)
 800f91c:	2b04      	cmp	r3, #4
 800f91e:	d10c      	bne.n	800f93a <HAL_RNG_IRQHandler+0x52>
}
 800f920:	bd10      	pop	{r4, pc}
    hrng->ErrorCode = HAL_RNG_ERROR_CLOCK;
 800f922:	2310      	movs	r3, #16
 800f924:	60c3      	str	r3, [r0, #12]
    hrng->State = HAL_RNG_STATE_ERROR;
 800f926:	2304      	movs	r3, #4
    HAL_RNG_ErrorCallback(hrng);
 800f928:	4620      	mov	r0, r4
    hrng->State = HAL_RNG_STATE_ERROR;
 800f92a:	7263      	strb	r3, [r4, #9]
    HAL_RNG_ErrorCallback(hrng);
 800f92c:	f7ff ffda 	bl	800f8e4 <HAL_RNG_ErrorCallback>
    __HAL_RNG_CLEAR_IT(hrng, RNG_IT_CEI | RNG_IT_SEI);
 800f930:	6823      	ldr	r3, [r4, #0]
 800f932:	f06f 0260 	mvn.w	r2, #96	; 0x60
 800f936:	605a      	str	r2, [r3, #4]
}
 800f938:	bd10      	pop	{r4, pc}
      hrng->State = HAL_RNG_STATE_READY;
 800f93a:	2201      	movs	r2, #1
      __HAL_UNLOCK(hrng);
 800f93c:	2300      	movs	r3, #0
      HAL_RNG_ReadyDataCallback(hrng, hrng->RandomNumber);
 800f93e:	4620      	mov	r0, r4
      hrng->State = HAL_RNG_STATE_READY;
 800f940:	7262      	strb	r2, [r4, #9]
      __HAL_UNLOCK(hrng);
 800f942:	7223      	strb	r3, [r4, #8]
      HAL_RNG_ReadyDataCallback(hrng, hrng->RandomNumber);
 800f944:	f7ff ffcc 	bl	800f8e0 <HAL_RNG_ReadyDataCallback>
}
 800f948:	bd10      	pop	{r4, pc}
      hrng->ErrorCode = HAL_RNG_ERROR_SEED;
 800f94a:	2208      	movs	r2, #8
 800f94c:	60e2      	str	r2, [r4, #12]
      __HAL_RNG_DISABLE_IT(hrng);
 800f94e:	681a      	ldr	r2, [r3, #0]
 800f950:	f022 0208 	bic.w	r2, r2, #8
 800f954:	601a      	str	r2, [r3, #0]
  if (rngclockerror == 1U)
 800f956:	e7e6      	b.n	800f926 <HAL_RNG_IRQHandler+0x3e>

0800f958 <HAL_TIM_Base_MspInit>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 800f958:	4770      	bx	lr
 800f95a:	bf00      	nop

0800f95c <HAL_TIM_Base_Init>:
  if (htim == NULL)
 800f95c:	2800      	cmp	r0, #0
 800f95e:	f000 80a5 	beq.w	800faac <HAL_TIM_Base_Init+0x150>
{
 800f962:	b538      	push	{r3, r4, r5, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 800f964:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 800f968:	4604      	mov	r4, r0
 800f96a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800f96e:	2b00      	cmp	r3, #0
 800f970:	d076      	beq.n	800fa60 <HAL_TIM_Base_Init+0x104>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800f972:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 800f974:	2302      	movs	r3, #2
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800f976:	494e      	ldr	r1, [pc, #312]	; (800fab0 <HAL_TIM_Base_Init+0x154>)
 800f978:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
  htim->State = HAL_TIM_STATE_BUSY;
 800f97c:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800f980:	eba2 0101 	sub.w	r1, r2, r1
  tmpcr1 = TIMx->CR1;
 800f984:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800f986:	fab1 f181 	clz	r1, r1
 800f98a:	ea4f 1151 	mov.w	r1, r1, lsr #5
 800f98e:	d027      	beq.n	800f9e0 <HAL_TIM_Base_Init+0x84>
 800f990:	bb31      	cbnz	r1, 800f9e0 <HAL_TIM_Base_Init+0x84>
 800f992:	4848      	ldr	r0, [pc, #288]	; (800fab4 <HAL_TIM_Base_Init+0x158>)
 800f994:	4d48      	ldr	r5, [pc, #288]	; (800fab8 <HAL_TIM_Base_Init+0x15c>)
 800f996:	4282      	cmp	r2, r0
 800f998:	d067      	beq.n	800fa6a <HAL_TIM_Base_Init+0x10e>
 800f99a:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800f99e:	4282      	cmp	r2, r0
 800f9a0:	d063      	beq.n	800fa6a <HAL_TIM_Base_Init+0x10e>
 800f9a2:	1b55      	subs	r5, r2, r5
 800f9a4:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800f9a8:	fab5 f585 	clz	r5, r5
 800f9ac:	4282      	cmp	r2, r0
 800f9ae:	ea4f 1555 	mov.w	r5, r5, lsr #5
 800f9b2:	d063      	beq.n	800fa7c <HAL_TIM_Base_Init+0x120>
 800f9b4:	2d00      	cmp	r5, #0
 800f9b6:	d161      	bne.n	800fa7c <HAL_TIM_Base_Init+0x120>
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800f9b8:	4840      	ldr	r0, [pc, #256]	; (800fabc <HAL_TIM_Base_Init+0x160>)
 800f9ba:	4941      	ldr	r1, [pc, #260]	; (800fac0 <HAL_TIM_Base_Init+0x164>)
 800f9bc:	428a      	cmp	r2, r1
 800f9be:	bf18      	it	ne
 800f9c0:	4282      	cmpne	r2, r0
 800f9c2:	d065      	beq.n	800fa90 <HAL_TIM_Base_Init+0x134>
 800f9c4:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800f9c8:	428a      	cmp	r2, r1
 800f9ca:	d061      	beq.n	800fa90 <HAL_TIM_Base_Init+0x134>
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800f9cc:	69a0      	ldr	r0, [r4, #24]
 800f9ce:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800f9d2:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800f9d4:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
 800f9d6:	6013      	str	r3, [r2, #0]

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800f9d8:	6863      	ldr	r3, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800f9da:	62d1      	str	r1, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800f9dc:	6293      	str	r3, [r2, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800f9de:	e023      	b.n	800fa28 <HAL_TIM_Base_Init+0xcc>
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800f9e0:	4d35      	ldr	r5, [pc, #212]	; (800fab8 <HAL_TIM_Base_Init+0x15c>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800f9e2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800f9e6:	68a0      	ldr	r0, [r4, #8]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800f9e8:	1b55      	subs	r5, r2, r5
    tmpcr1 |= Structure->CounterMode;
 800f9ea:	4303      	orrs	r3, r0
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800f9ec:	fab5 f585 	clz	r5, r5
 800f9f0:	096d      	lsrs	r5, r5, #5
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800f9f2:	6920      	ldr	r0, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 800f9f4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800f9f8:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800f9fa:	69a0      	ldr	r0, [r4, #24]
 800f9fc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800fa00:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
 800fa02:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800fa04:	68e3      	ldr	r3, [r4, #12]
 800fa06:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800fa08:	6863      	ldr	r3, [r4, #4]
 800fa0a:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800fa0c:	b951      	cbnz	r1, 800fa24 <HAL_TIM_Base_Init+0xc8>
 800fa0e:	b94d      	cbnz	r5, 800fa24 <HAL_TIM_Base_Init+0xc8>
 800fa10:	492a      	ldr	r1, [pc, #168]	; (800fabc <HAL_TIM_Base_Init+0x160>)
 800fa12:	4b2b      	ldr	r3, [pc, #172]	; (800fac0 <HAL_TIM_Base_Init+0x164>)
 800fa14:	429a      	cmp	r2, r3
 800fa16:	bf18      	it	ne
 800fa18:	428a      	cmpne	r2, r1
 800fa1a:	d003      	beq.n	800fa24 <HAL_TIM_Base_Init+0xc8>
 800fa1c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800fa20:	429a      	cmp	r2, r3
 800fa22:	d101      	bne.n	800fa28 <HAL_TIM_Base_Init+0xcc>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800fa24:	6963      	ldr	r3, [r4, #20]
 800fa26:	6313      	str	r3, [r2, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 800fa28:	2301      	movs	r3, #1
  return HAL_OK;
 800fa2a:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
 800fa2c:	6153      	str	r3, [r2, #20]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800fa2e:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800fa32:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 800fa36:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 800fa3a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800fa3e:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 800fa42:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800fa46:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800fa4a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 800fa4e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800fa52:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
 800fa56:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
  htim->State = HAL_TIM_STATE_READY;
 800fa5a:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 800fa5e:	bd38      	pop	{r3, r4, r5, pc}
    htim->Lock = HAL_UNLOCKED;
 800fa60:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 800fa64:	f7ff ff78 	bl	800f958 <HAL_TIM_Base_MspInit>
 800fa68:	e783      	b.n	800f972 <HAL_TIM_Base_Init+0x16>
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800fa6a:	1b55      	subs	r5, r2, r5
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800fa6c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800fa70:	68a0      	ldr	r0, [r4, #8]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800fa72:	fab5 f585 	clz	r5, r5
    tmpcr1 |= Structure->CounterMode;
 800fa76:	4303      	orrs	r3, r0
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800fa78:	096d      	lsrs	r5, r5, #5
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800fa7a:	e7ba      	b.n	800f9f2 <HAL_TIM_Base_Init+0x96>
    tmpcr1 |= Structure->CounterMode;
 800fa7c:	68a0      	ldr	r0, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800fa7e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800fa82:	4303      	orrs	r3, r0
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800fa84:	480f      	ldr	r0, [pc, #60]	; (800fac4 <HAL_TIM_Base_Init+0x168>)
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800fa86:	4282      	cmp	r2, r0
 800fa88:	d0b3      	beq.n	800f9f2 <HAL_TIM_Base_Init+0x96>
 800fa8a:	2d00      	cmp	r5, #0
 800fa8c:	d1b1      	bne.n	800f9f2 <HAL_TIM_Base_Init+0x96>
 800fa8e:	e793      	b.n	800f9b8 <HAL_TIM_Base_Init+0x5c>
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800fa90:	6920      	ldr	r0, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 800fa92:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800fa96:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800fa98:	4303      	orrs	r3, r0
  TIMx->ARR = (uint32_t)Structure->Period ;
 800fa9a:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800fa9c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800faa0:	430b      	orrs	r3, r1
  TIMx->PSC = Structure->Prescaler;
 800faa2:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 800faa4:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800faa6:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800faa8:	6291      	str	r1, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800faaa:	e7b1      	b.n	800fa10 <HAL_TIM_Base_Init+0xb4>
    return HAL_ERROR;
 800faac:	2001      	movs	r0, #1
}
 800faae:	4770      	bx	lr
 800fab0:	40010000 	.word	0x40010000
 800fab4:	40000400 	.word	0x40000400
 800fab8:	40010400 	.word	0x40010400
 800fabc:	40014000 	.word	0x40014000
 800fac0:	40014400 	.word	0x40014400
 800fac4:	40000c00 	.word	0x40000c00

0800fac8 <HAL_TIM_Base_Start_IT>:
  if (htim->State != HAL_TIM_STATE_READY)
 800fac8:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 800facc:	2b01      	cmp	r3, #1
 800face:	d141      	bne.n	800fb54 <HAL_TIM_Base_Start_IT+0x8c>
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800fad0:	6802      	ldr	r2, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 800fad2:	2102      	movs	r1, #2
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800fad4:	4b24      	ldr	r3, [pc, #144]	; (800fb68 <HAL_TIM_Base_Start_IT+0xa0>)
 800fad6:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800fada:	bf18      	it	ne
 800fadc:	429a      	cmpne	r2, r3
{
 800fade:	b430      	push	{r4, r5}
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800fae0:	bf0c      	ite	eq
 800fae2:	2301      	moveq	r3, #1
 800fae4:	2300      	movne	r3, #0
 800fae6:	4d21      	ldr	r5, [pc, #132]	; (800fb6c <HAL_TIM_Base_Start_IT+0xa4>)
 800fae8:	4c21      	ldr	r4, [pc, #132]	; (800fb70 <HAL_TIM_Base_Start_IT+0xa8>)
 800faea:	42aa      	cmp	r2, r5
 800faec:	bf08      	it	eq
 800faee:	f043 0301 	orreq.w	r3, r3, #1
  htim->State = HAL_TIM_STATE_BUSY;
 800faf2:	f880 103d 	strb.w	r1, [r0, #61]	; 0x3d
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800faf6:	68d1      	ldr	r1, [r2, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800faf8:	42a2      	cmp	r2, r4
 800fafa:	bf08      	it	eq
 800fafc:	f043 0301 	orreq.w	r3, r3, #1
 800fb00:	f504 6480 	add.w	r4, r4, #1024	; 0x400
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800fb04:	f041 0101 	orr.w	r1, r1, #1
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800fb08:	481a      	ldr	r0, [pc, #104]	; (800fb74 <HAL_TIM_Base_Start_IT+0xac>)
 800fb0a:	42a2      	cmp	r2, r4
 800fb0c:	bf08      	it	eq
 800fb0e:	f043 0301 	orreq.w	r3, r3, #1
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800fb12:	60d1      	str	r1, [r2, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800fb14:	4282      	cmp	r2, r0
 800fb16:	bf08      	it	eq
 800fb18:	f043 0301 	orreq.w	r3, r3, #1
 800fb1c:	4916      	ldr	r1, [pc, #88]	; (800fb78 <HAL_TIM_Base_Start_IT+0xb0>)
 800fb1e:	428a      	cmp	r2, r1
 800fb20:	bf08      	it	eq
 800fb22:	f043 0301 	orreq.w	r3, r3, #1
 800fb26:	b933      	cbnz	r3, 800fb36 <HAL_TIM_Base_Start_IT+0x6e>
 800fb28:	f500 5070 	add.w	r0, r0, #15360	; 0x3c00
 800fb2c:	1a10      	subs	r0, r2, r0
 800fb2e:	fab0 f080 	clz	r0, r0
 800fb32:	0940      	lsrs	r0, r0, #5
 800fb34:	b198      	cbz	r0, 800fb5e <HAL_TIM_Base_Start_IT+0x96>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800fb36:	6891      	ldr	r1, [r2, #8]
 800fb38:	4b10      	ldr	r3, [pc, #64]	; (800fb7c <HAL_TIM_Base_Start_IT+0xb4>)
 800fb3a:	400b      	ands	r3, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800fb3c:	2b06      	cmp	r3, #6
 800fb3e:	d00b      	beq.n	800fb58 <HAL_TIM_Base_Start_IT+0x90>
 800fb40:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800fb44:	d008      	beq.n	800fb58 <HAL_TIM_Base_Start_IT+0x90>
      __HAL_TIM_ENABLE(htim);
 800fb46:	6813      	ldr	r3, [r2, #0]
  return HAL_OK;
 800fb48:	2000      	movs	r0, #0
      __HAL_TIM_ENABLE(htim);
 800fb4a:	f043 0301 	orr.w	r3, r3, #1
 800fb4e:	6013      	str	r3, [r2, #0]
}
 800fb50:	bc30      	pop	{r4, r5}
 800fb52:	4770      	bx	lr
    return HAL_ERROR;
 800fb54:	2001      	movs	r0, #1
}
 800fb56:	4770      	bx	lr
  return HAL_OK;
 800fb58:	2000      	movs	r0, #0
}
 800fb5a:	bc30      	pop	{r4, r5}
 800fb5c:	4770      	bx	lr
    __HAL_TIM_ENABLE(htim);
 800fb5e:	6813      	ldr	r3, [r2, #0]
 800fb60:	f043 0301 	orr.w	r3, r3, #1
 800fb64:	6013      	str	r3, [r2, #0]
 800fb66:	e7f3      	b.n	800fb50 <HAL_TIM_Base_Start_IT+0x88>
 800fb68:	40010000 	.word	0x40010000
 800fb6c:	40000400 	.word	0x40000400
 800fb70:	40000800 	.word	0x40000800
 800fb74:	40010400 	.word	0x40010400
 800fb78:	40001800 	.word	0x40001800
 800fb7c:	00010007 	.word	0x00010007

0800fb80 <HAL_TIM_OC_DelayElapsedCallback>:
 800fb80:	4770      	bx	lr
 800fb82:	bf00      	nop

0800fb84 <HAL_TIM_IC_CaptureCallback>:
 800fb84:	4770      	bx	lr
 800fb86:	bf00      	nop

0800fb88 <HAL_TIM_PWM_PulseFinishedCallback>:
 800fb88:	4770      	bx	lr
 800fb8a:	bf00      	nop

0800fb8c <HAL_TIM_TriggerCallback>:
 800fb8c:	4770      	bx	lr
 800fb8e:	bf00      	nop

0800fb90 <HAL_TIM_IRQHandler>:
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800fb90:	6803      	ldr	r3, [r0, #0]
 800fb92:	691a      	ldr	r2, [r3, #16]
 800fb94:	0791      	lsls	r1, r2, #30
{
 800fb96:	b510      	push	{r4, lr}
 800fb98:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800fb9a:	d502      	bpl.n	800fba2 <HAL_TIM_IRQHandler+0x12>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 800fb9c:	68da      	ldr	r2, [r3, #12]
 800fb9e:	0792      	lsls	r2, r2, #30
 800fba0:	d468      	bmi.n	800fc74 <HAL_TIM_IRQHandler+0xe4>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 800fba2:	691a      	ldr	r2, [r3, #16]
 800fba4:	0752      	lsls	r2, r2, #29
 800fba6:	d502      	bpl.n	800fbae <HAL_TIM_IRQHandler+0x1e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 800fba8:	68da      	ldr	r2, [r3, #12]
 800fbaa:	0750      	lsls	r0, r2, #29
 800fbac:	d44f      	bmi.n	800fc4e <HAL_TIM_IRQHandler+0xbe>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 800fbae:	691a      	ldr	r2, [r3, #16]
 800fbb0:	0711      	lsls	r1, r2, #28
 800fbb2:	d502      	bpl.n	800fbba <HAL_TIM_IRQHandler+0x2a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 800fbb4:	68da      	ldr	r2, [r3, #12]
 800fbb6:	0712      	lsls	r2, r2, #28
 800fbb8:	d437      	bmi.n	800fc2a <HAL_TIM_IRQHandler+0x9a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 800fbba:	691a      	ldr	r2, [r3, #16]
 800fbbc:	06d0      	lsls	r0, r2, #27
 800fbbe:	d502      	bpl.n	800fbc6 <HAL_TIM_IRQHandler+0x36>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 800fbc0:	68da      	ldr	r2, [r3, #12]
 800fbc2:	06d1      	lsls	r1, r2, #27
 800fbc4:	d41e      	bmi.n	800fc04 <HAL_TIM_IRQHandler+0x74>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 800fbc6:	691a      	ldr	r2, [r3, #16]
 800fbc8:	07d2      	lsls	r2, r2, #31
 800fbca:	d502      	bpl.n	800fbd2 <HAL_TIM_IRQHandler+0x42>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 800fbcc:	68da      	ldr	r2, [r3, #12]
 800fbce:	07d0      	lsls	r0, r2, #31
 800fbd0:	d469      	bmi.n	800fca6 <HAL_TIM_IRQHandler+0x116>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 800fbd2:	691a      	ldr	r2, [r3, #16]
 800fbd4:	0611      	lsls	r1, r2, #24
 800fbd6:	d502      	bpl.n	800fbde <HAL_TIM_IRQHandler+0x4e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800fbd8:	68da      	ldr	r2, [r3, #12]
 800fbda:	0612      	lsls	r2, r2, #24
 800fbdc:	d46b      	bmi.n	800fcb6 <HAL_TIM_IRQHandler+0x126>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 800fbde:	691a      	ldr	r2, [r3, #16]
 800fbe0:	05d0      	lsls	r0, r2, #23
 800fbe2:	d502      	bpl.n	800fbea <HAL_TIM_IRQHandler+0x5a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800fbe4:	68da      	ldr	r2, [r3, #12]
 800fbe6:	0611      	lsls	r1, r2, #24
 800fbe8:	d46d      	bmi.n	800fcc6 <HAL_TIM_IRQHandler+0x136>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 800fbea:	691a      	ldr	r2, [r3, #16]
 800fbec:	0652      	lsls	r2, r2, #25
 800fbee:	d502      	bpl.n	800fbf6 <HAL_TIM_IRQHandler+0x66>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 800fbf0:	68da      	ldr	r2, [r3, #12]
 800fbf2:	0650      	lsls	r0, r2, #25
 800fbf4:	d46f      	bmi.n	800fcd6 <HAL_TIM_IRQHandler+0x146>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 800fbf6:	691a      	ldr	r2, [r3, #16]
 800fbf8:	0691      	lsls	r1, r2, #26
 800fbfa:	d502      	bpl.n	800fc02 <HAL_TIM_IRQHandler+0x72>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 800fbfc:	68da      	ldr	r2, [r3, #12]
 800fbfe:	0692      	lsls	r2, r2, #26
 800fc00:	d449      	bmi.n	800fc96 <HAL_TIM_IRQHandler+0x106>
}
 800fc02:	bd10      	pop	{r4, pc}
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 800fc04:	f06f 0110 	mvn.w	r1, #16
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800fc08:	2208      	movs	r2, #8
        HAL_TIM_IC_CaptureCallback(htim);
 800fc0a:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 800fc0c:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800fc0e:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800fc10:	69db      	ldr	r3, [r3, #28]
 800fc12:	f413 7f40 	tst.w	r3, #768	; 0x300
 800fc16:	d16f      	bne.n	800fcf8 <HAL_TIM_IRQHandler+0x168>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800fc18:	f7ff ffb2 	bl	800fb80 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800fc1c:	4620      	mov	r0, r4
 800fc1e:	f7ff ffb3 	bl	800fb88 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800fc22:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 800fc24:	6823      	ldr	r3, [r4, #0]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800fc26:	7722      	strb	r2, [r4, #28]
 800fc28:	e7cd      	b.n	800fbc6 <HAL_TIM_IRQHandler+0x36>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 800fc2a:	f06f 0108 	mvn.w	r1, #8
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800fc2e:	2204      	movs	r2, #4
        HAL_TIM_IC_CaptureCallback(htim);
 800fc30:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 800fc32:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800fc34:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800fc36:	69db      	ldr	r3, [r3, #28]
 800fc38:	079b      	lsls	r3, r3, #30
 800fc3a:	d15a      	bne.n	800fcf2 <HAL_TIM_IRQHandler+0x162>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800fc3c:	f7ff ffa0 	bl	800fb80 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800fc40:	4620      	mov	r0, r4
 800fc42:	f7ff ffa1 	bl	800fb88 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800fc46:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 800fc48:	6823      	ldr	r3, [r4, #0]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800fc4a:	7722      	strb	r2, [r4, #28]
 800fc4c:	e7b5      	b.n	800fbba <HAL_TIM_IRQHandler+0x2a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800fc4e:	f06f 0104 	mvn.w	r1, #4
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800fc52:	2202      	movs	r2, #2
        HAL_TIM_IC_CaptureCallback(htim);
 800fc54:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800fc56:	6119      	str	r1, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800fc58:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800fc5a:	699b      	ldr	r3, [r3, #24]
 800fc5c:	f413 7f40 	tst.w	r3, #768	; 0x300
 800fc60:	d144      	bne.n	800fcec <HAL_TIM_IRQHandler+0x15c>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800fc62:	f7ff ff8d 	bl	800fb80 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800fc66:	4620      	mov	r0, r4
 800fc68:	f7ff ff8e 	bl	800fb88 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800fc6c:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 800fc6e:	6823      	ldr	r3, [r4, #0]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800fc70:	7722      	strb	r2, [r4, #28]
 800fc72:	e79c      	b.n	800fbae <HAL_TIM_IRQHandler+0x1e>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800fc74:	f06f 0102 	mvn.w	r1, #2
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800fc78:	2201      	movs	r2, #1
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800fc7a:	6119      	str	r1, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800fc7c:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 800fc7e:	699b      	ldr	r3, [r3, #24]
 800fc80:	0799      	lsls	r1, r3, #30
 800fc82:	d130      	bne.n	800fce6 <HAL_TIM_IRQHandler+0x156>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800fc84:	f7ff ff7c 	bl	800fb80 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 800fc88:	4620      	mov	r0, r4
 800fc8a:	f7ff ff7d 	bl	800fb88 <HAL_TIM_PWM_PulseFinishedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800fc8e:	2200      	movs	r2, #0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 800fc90:	6823      	ldr	r3, [r4, #0]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800fc92:	7722      	strb	r2, [r4, #28]
 800fc94:	e785      	b.n	800fba2 <HAL_TIM_IRQHandler+0x12>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800fc96:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutCallback(htim);
 800fc9a:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800fc9c:	611a      	str	r2, [r3, #16]
}
 800fc9e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutCallback(htim);
 800fca2:	f000 b82d 	b.w	800fd00 <HAL_TIMEx_CommutCallback>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800fca6:	f06f 0201 	mvn.w	r2, #1
      HAL_TIM_PeriodElapsedCallback(htim);
 800fcaa:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800fcac:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 800fcae:	f7fa fcf9 	bl	800a6a4 <HAL_TIM_PeriodElapsedCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 800fcb2:	6823      	ldr	r3, [r4, #0]
 800fcb4:	e78d      	b.n	800fbd2 <HAL_TIM_IRQHandler+0x42>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800fcb6:	f06f 0280 	mvn.w	r2, #128	; 0x80
      HAL_TIMEx_BreakCallback(htim);
 800fcba:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800fcbc:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 800fcbe:	f000 f821 	bl	800fd04 <HAL_TIMEx_BreakCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 800fcc2:	6823      	ldr	r3, [r4, #0]
 800fcc4:	e78b      	b.n	800fbde <HAL_TIM_IRQHandler+0x4e>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 800fcc6:	f46f 7280 	mvn.w	r2, #256	; 0x100
      HAL_TIMEx_Break2Callback(htim);
 800fcca:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 800fccc:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 800fcce:	f000 f81b 	bl	800fd08 <HAL_TIMEx_Break2Callback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 800fcd2:	6823      	ldr	r3, [r4, #0]
 800fcd4:	e789      	b.n	800fbea <HAL_TIM_IRQHandler+0x5a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800fcd6:	f06f 0240 	mvn.w	r2, #64	; 0x40
      HAL_TIM_TriggerCallback(htim);
 800fcda:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800fcdc:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 800fcde:	f7ff ff55 	bl	800fb8c <HAL_TIM_TriggerCallback>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 800fce2:	6823      	ldr	r3, [r4, #0]
 800fce4:	e787      	b.n	800fbf6 <HAL_TIM_IRQHandler+0x66>
          HAL_TIM_IC_CaptureCallback(htim);
 800fce6:	f7ff ff4d 	bl	800fb84 <HAL_TIM_IC_CaptureCallback>
 800fcea:	e7d0      	b.n	800fc8e <HAL_TIM_IRQHandler+0xfe>
        HAL_TIM_IC_CaptureCallback(htim);
 800fcec:	f7ff ff4a 	bl	800fb84 <HAL_TIM_IC_CaptureCallback>
 800fcf0:	e7bc      	b.n	800fc6c <HAL_TIM_IRQHandler+0xdc>
        HAL_TIM_IC_CaptureCallback(htim);
 800fcf2:	f7ff ff47 	bl	800fb84 <HAL_TIM_IC_CaptureCallback>
 800fcf6:	e7a6      	b.n	800fc46 <HAL_TIM_IRQHandler+0xb6>
        HAL_TIM_IC_CaptureCallback(htim);
 800fcf8:	f7ff ff44 	bl	800fb84 <HAL_TIM_IC_CaptureCallback>
 800fcfc:	e791      	b.n	800fc22 <HAL_TIM_IRQHandler+0x92>
 800fcfe:	bf00      	nop

0800fd00 <HAL_TIMEx_CommutCallback>:
 800fd00:	4770      	bx	lr
 800fd02:	bf00      	nop

0800fd04 <HAL_TIMEx_BreakCallback>:
 800fd04:	4770      	bx	lr
 800fd06:	bf00      	nop

0800fd08 <HAL_TIMEx_Break2Callback>:
 800fd08:	4770      	bx	lr
 800fd0a:	bf00      	nop

0800fd0c <HAL_UART_DeInit>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
{
  /* Check the UART handle allocation */
  if (huart == NULL)
 800fd0c:	b1d0      	cbz	r0, 800fd44 <HAL_UART_DeInit+0x38>
  }

  /* Check the parameters */
  assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));

  huart->gState = HAL_UART_STATE_BUSY;
 800fd0e:	2224      	movs	r2, #36	; 0x24
{
 800fd10:	b538      	push	{r3, r4, r5, lr}

  __HAL_UART_DISABLE(huart);
 800fd12:	6803      	ldr	r3, [r0, #0]

  huart->Instance->CR1 = 0x0U;
 800fd14:	2500      	movs	r5, #0
  huart->gState = HAL_UART_STATE_BUSY;
 800fd16:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
 800fd1a:	4604      	mov	r4, r0
  __HAL_UART_DISABLE(huart);
 800fd1c:	681a      	ldr	r2, [r3, #0]
 800fd1e:	f022 0201 	bic.w	r2, r2, #1
 800fd22:	601a      	str	r2, [r3, #0]
  huart->Instance->CR1 = 0x0U;
 800fd24:	601d      	str	r5, [r3, #0]
  huart->Instance->CR2 = 0x0U;
 800fd26:	605d      	str	r5, [r3, #4]
  huart->Instance->CR3 = 0x0U;
 800fd28:	609d      	str	r5, [r3, #8]
  }
  /* DeInit the low level hardware */
  huart->MspDeInitCallback(huart);
#else
  /* DeInit the low level hardware */
  HAL_UART_MspDeInit(huart);
 800fd2a:	f7fa fe71 	bl	800aa10 <HAL_UART_MspDeInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */

  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800fd2e:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
  huart->RxState = HAL_UART_STATE_RESET;
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;

  __HAL_UNLOCK(huart);

  return HAL_OK;
 800fd32:	4628      	mov	r0, r5
  huart->gState = HAL_UART_STATE_RESET;
 800fd34:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 800fd38:	f884 5080 	strb.w	r5, [r4, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_RESET;
 800fd3c:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800fd40:	66e5      	str	r5, [r4, #108]	; 0x6c
}
 800fd42:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 800fd44:	2001      	movs	r0, #1
}
 800fd46:	4770      	bx	lr

0800fd48 <HAL_UART_DMAStop>:
  * @brief Stop the DMA Transfer.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
{
 800fd48:	b538      	push	{r3, r4, r5, lr}

  const HAL_UART_StateTypeDef gstate = huart->gState;
  const HAL_UART_StateTypeDef rxstate = huart->RxState;

  /* Stop UART DMA Tx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 800fd4a:	6803      	ldr	r3, [r0, #0]
{
 800fd4c:	4604      	mov	r4, r0
  const HAL_UART_StateTypeDef gstate = huart->gState;
 800fd4e:	f8d0 1084 	ldr.w	r1, [r0, #132]	; 0x84
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
 800fd52:	f8d0 5088 	ldr.w	r5, [r0, #136]	; 0x88
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 800fd56:	689a      	ldr	r2, [r3, #8]
 800fd58:	0610      	lsls	r0, r2, #24
 800fd5a:	d501      	bpl.n	800fd60 <HAL_UART_DMAStop+0x18>
 800fd5c:	2921      	cmp	r1, #33	; 0x21
 800fd5e:	d006      	beq.n	800fd6e <HAL_UART_DMAStop+0x26>

    UART_EndTxTransfer(huart);
  }

  /* Stop UART DMA Rx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
 800fd60:	689a      	ldr	r2, [r3, #8]
 800fd62:	0652      	lsls	r2, r2, #25
 800fd64:	d501      	bpl.n	800fd6a <HAL_UART_DMAStop+0x22>
 800fd66:	2d22      	cmp	r5, #34	; 0x22
 800fd68:	d02c      	beq.n	800fdc4 <HAL_UART_DMAStop+0x7c>
    }

    UART_EndRxTransfer(huart);
  }

  return HAL_OK;
 800fd6a:	2000      	movs	r0, #0
}
 800fd6c:	bd38      	pop	{r3, r4, r5, pc}
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800fd6e:	f103 0208 	add.w	r2, r3, #8
 800fd72:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 800fd76:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800fd7a:	f103 0008 	add.w	r0, r3, #8
 800fd7e:	e840 2100 	strex	r1, r2, [r0]
 800fd82:	2900      	cmp	r1, #0
 800fd84:	d1f3      	bne.n	800fd6e <HAL_UART_DMAStop+0x26>
    if (huart->hdmatx != NULL)
 800fd86:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 800fd88:	b120      	cbz	r0, 800fd94 <HAL_UART_DMAStop+0x4c>
      if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
 800fd8a:	f7fb ffa9 	bl	800bce0 <HAL_DMA_Abort>
 800fd8e:	2800      	cmp	r0, #0
 800fd90:	d164      	bne.n	800fe5c <HAL_UART_DMAStop+0x114>
 800fd92:	6823      	ldr	r3, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800fd94:	e853 2f00 	ldrex	r2, [r3]
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable TXEIE, TCIE, TXFT interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
 800fd98:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800fd9c:	e843 2100 	strex	r1, r2, [r3]
 800fda0:	2900      	cmp	r1, #0
 800fda2:	d1f7      	bne.n	800fd94 <HAL_UART_DMAStop+0x4c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800fda4:	f103 0208 	add.w	r2, r3, #8
 800fda8:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));
 800fdac:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800fdb0:	f103 0008 	add.w	r0, r3, #8
 800fdb4:	e840 2100 	strex	r1, r2, [r0]
 800fdb8:	2900      	cmp	r1, #0
 800fdba:	d1f3      	bne.n	800fda4 <HAL_UART_DMAStop+0x5c>

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 800fdbc:	2220      	movs	r2, #32
 800fdbe:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
}
 800fdc2:	e7cd      	b.n	800fd60 <HAL_UART_DMAStop+0x18>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800fdc4:	f103 0208 	add.w	r2, r3, #8
 800fdc8:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800fdcc:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800fdd0:	f103 0008 	add.w	r0, r3, #8
 800fdd4:	e840 2100 	strex	r1, r2, [r0]
 800fdd8:	2900      	cmp	r1, #0
 800fdda:	d1f3      	bne.n	800fdc4 <HAL_UART_DMAStop+0x7c>
    if (huart->hdmarx != NULL)
 800fddc:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 800fdde:	b118      	cbz	r0, 800fde8 <HAL_UART_DMAStop+0xa0>
      if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
 800fde0:	f7fb ff7e 	bl	800bce0 <HAL_DMA_Abort>
 800fde4:	bb80      	cbnz	r0, 800fe48 <HAL_UART_DMAStop+0x100>
 800fde6:	6823      	ldr	r3, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800fde8:	e853 2f00 	ldrex	r2, [r3]
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 800fdec:	f422 7290 	bic.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800fdf0:	e843 2100 	strex	r1, r2, [r3]
 800fdf4:	2900      	cmp	r1, #0
 800fdf6:	d1f7      	bne.n	800fde8 <HAL_UART_DMAStop+0xa0>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 800fdf8:	481b      	ldr	r0, [pc, #108]	; (800fe68 <HAL_UART_DMAStop+0x120>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800fdfa:	f103 0208 	add.w	r2, r3, #8
 800fdfe:	e852 2f00 	ldrex	r2, [r2]
 800fe02:	4002      	ands	r2, r0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800fe04:	f103 0508 	add.w	r5, r3, #8
 800fe08:	e845 2100 	strex	r1, r2, [r5]
 800fe0c:	2900      	cmp	r1, #0
 800fe0e:	d1f4      	bne.n	800fdfa <HAL_UART_DMAStop+0xb2>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800fe10:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800fe12:	2a01      	cmp	r2, #1
 800fe14:	d007      	beq.n	800fe26 <HAL_UART_DMAStop+0xde>
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800fe16:	2300      	movs	r3, #0
  huart->RxState = HAL_UART_STATE_READY;
 800fe18:	2220      	movs	r2, #32
  return HAL_OK;
 800fe1a:	4618      	mov	r0, r3
  huart->RxState = HAL_UART_STATE_READY;
 800fe1c:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 800fe20:	6723      	str	r3, [r4, #112]	; 0x70
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800fe22:	66e3      	str	r3, [r4, #108]	; 0x6c
}
 800fe24:	bd38      	pop	{r3, r4, r5, pc}
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800fe26:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800fe2a:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800fe2e:	e843 2100 	strex	r1, r2, [r3]
 800fe32:	2900      	cmp	r1, #0
 800fe34:	d0ef      	beq.n	800fe16 <HAL_UART_DMAStop+0xce>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800fe36:	e853 2f00 	ldrex	r2, [r3]
 800fe3a:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800fe3e:	e843 2100 	strex	r1, r2, [r3]
 800fe42:	2900      	cmp	r1, #0
 800fe44:	d1ef      	bne.n	800fe26 <HAL_UART_DMAStop+0xde>
 800fe46:	e7e6      	b.n	800fe16 <HAL_UART_DMAStop+0xce>
        if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
 800fe48:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 800fe4a:	f7fc fcdb 	bl	800c804 <HAL_DMA_GetError>
 800fe4e:	2820      	cmp	r0, #32
 800fe50:	d1c9      	bne.n	800fde6 <HAL_UART_DMAStop+0x9e>
          huart->ErrorCode = HAL_UART_ERROR_DMA;
 800fe52:	2310      	movs	r3, #16
          return HAL_TIMEOUT;
 800fe54:	2003      	movs	r0, #3
          huart->ErrorCode = HAL_UART_ERROR_DMA;
 800fe56:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
}
 800fe5a:	bd38      	pop	{r3, r4, r5, pc}
        if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
 800fe5c:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 800fe5e:	f7fc fcd1 	bl	800c804 <HAL_DMA_GetError>
 800fe62:	2820      	cmp	r0, #32
 800fe64:	d195      	bne.n	800fd92 <HAL_UART_DMAStop+0x4a>
 800fe66:	e7f4      	b.n	800fe52 <HAL_UART_DMAStop+0x10a>
 800fe68:	effffffe 	.word	0xeffffffe

0800fe6c <HAL_UART_Abort>:
{
 800fe6c:	b510      	push	{r4, lr}
 800fe6e:	6803      	ldr	r3, [r0, #0]
 800fe70:	4604      	mov	r4, r0
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800fe72:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 800fe76:	f422 72f0 	bic.w	r2, r2, #480	; 0x1e0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800fe7a:	e843 2100 	strex	r1, r2, [r3]
 800fe7e:	2900      	cmp	r1, #0
 800fe80:	d1f7      	bne.n	800fe72 <HAL_UART_Abort+0x6>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE | USART_CR3_RXFTIE | USART_CR3_TXFTIE);
 800fe82:	4842      	ldr	r0, [pc, #264]	; (800ff8c <HAL_UART_Abort+0x120>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800fe84:	f103 0208 	add.w	r2, r3, #8
 800fe88:	e852 2f00 	ldrex	r2, [r2]
 800fe8c:	4002      	ands	r2, r0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800fe8e:	f103 0c08 	add.w	ip, r3, #8
 800fe92:	e84c 2100 	strex	r1, r2, [ip]
 800fe96:	2900      	cmp	r1, #0
 800fe98:	d1f4      	bne.n	800fe84 <HAL_UART_Abort+0x18>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800fe9a:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800fe9c:	2a01      	cmp	r2, #1
 800fe9e:	d051      	beq.n	800ff44 <HAL_UART_Abort+0xd8>
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
 800fea0:	6899      	ldr	r1, [r3, #8]
 800fea2:	461a      	mov	r2, r3
 800fea4:	0608      	lsls	r0, r1, #24
 800fea6:	d420      	bmi.n	800feea <HAL_UART_Abort+0x7e>
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800fea8:	6899      	ldr	r1, [r3, #8]
 800feaa:	0649      	lsls	r1, r1, #25
 800feac:	d435      	bmi.n	800ff1a <HAL_UART_Abort+0xae>
  if (huart->FifoMode == UART_FIFOMODE_ENABLE)
 800feae:	6e61      	ldr	r1, [r4, #100]	; 0x64
  huart->TxXferCount = 0U;
 800feb0:	2300      	movs	r3, #0
  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
 800feb2:	200f      	movs	r0, #15
  if (huart->FifoMode == UART_FIFOMODE_ENABLE)
 800feb4:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
  huart->TxXferCount = 0U;
 800feb8:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
  huart->RxXferCount = 0U;
 800febc:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
 800fec0:	6210      	str	r0, [r2, #32]
  if (huart->FifoMode == UART_FIFOMODE_ENABLE)
 800fec2:	d103      	bne.n	800fecc <HAL_UART_Abort+0x60>
    __HAL_UART_SEND_REQ(huart, UART_TXDATA_FLUSH_REQUEST);
 800fec4:	6993      	ldr	r3, [r2, #24]
 800fec6:	f043 0310 	orr.w	r3, r3, #16
 800feca:	6193      	str	r3, [r2, #24]
  __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800fecc:	6991      	ldr	r1, [r2, #24]
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800fece:	2300      	movs	r3, #0
  huart->gState  = HAL_UART_STATE_READY;
 800fed0:	2020      	movs	r0, #32
  __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800fed2:	f041 0108 	orr.w	r1, r1, #8
 800fed6:	6191      	str	r1, [r2, #24]
  huart->gState  = HAL_UART_STATE_READY;
 800fed8:	f8c4 0084 	str.w	r0, [r4, #132]	; 0x84
  huart->RxState = HAL_UART_STATE_READY;
 800fedc:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
  return HAL_OK;
 800fee0:	4618      	mov	r0, r3
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800fee2:	66e3      	str	r3, [r4, #108]	; 0x6c
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800fee4:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
}
 800fee8:	bd10      	pop	{r4, pc}
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800feea:	f103 0208 	add.w	r2, r3, #8
 800feee:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 800fef2:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800fef6:	f103 0008 	add.w	r0, r3, #8
 800fefa:	e840 2100 	strex	r1, r2, [r0]
 800fefe:	2900      	cmp	r1, #0
 800ff00:	d1f3      	bne.n	800feea <HAL_UART_Abort+0x7e>
    if (huart->hdmatx != NULL)
 800ff02:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 800ff04:	b128      	cbz	r0, 800ff12 <HAL_UART_Abort+0xa6>
      huart->hdmatx->XferAbortCallback = NULL;
 800ff06:	2300      	movs	r3, #0
 800ff08:	6503      	str	r3, [r0, #80]	; 0x50
      if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
 800ff0a:	f7fb fee9 	bl	800bce0 <HAL_DMA_Abort>
 800ff0e:	bb60      	cbnz	r0, 800ff6a <HAL_UART_Abort+0xfe>
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800ff10:	6823      	ldr	r3, [r4, #0]
 800ff12:	6899      	ldr	r1, [r3, #8]
 800ff14:	461a      	mov	r2, r3
 800ff16:	0649      	lsls	r1, r1, #25
 800ff18:	d5c9      	bpl.n	800feae <HAL_UART_Abort+0x42>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800ff1a:	f103 0208 	add.w	r2, r3, #8
 800ff1e:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800ff22:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800ff26:	f103 0008 	add.w	r0, r3, #8
 800ff2a:	e840 2100 	strex	r1, r2, [r0]
 800ff2e:	2900      	cmp	r1, #0
 800ff30:	d1f3      	bne.n	800ff1a <HAL_UART_Abort+0xae>
    if (huart->hdmarx != NULL)
 800ff32:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 800ff34:	b1b8      	cbz	r0, 800ff66 <HAL_UART_Abort+0xfa>
      huart->hdmarx->XferAbortCallback = NULL;
 800ff36:	2300      	movs	r3, #0
 800ff38:	6503      	str	r3, [r0, #80]	; 0x50
      if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
 800ff3a:	f7fb fed1 	bl	800bce0 <HAL_DMA_Abort>
 800ff3e:	b9f0      	cbnz	r0, 800ff7e <HAL_UART_Abort+0x112>
  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
 800ff40:	6822      	ldr	r2, [r4, #0]
 800ff42:	e7b4      	b.n	800feae <HAL_UART_Abort+0x42>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800ff44:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_IDLEIE));
 800ff48:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800ff4c:	e843 2100 	strex	r1, r2, [r3]
 800ff50:	2900      	cmp	r1, #0
 800ff52:	d0a5      	beq.n	800fea0 <HAL_UART_Abort+0x34>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800ff54:	e853 2f00 	ldrex	r2, [r3]
 800ff58:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800ff5c:	e843 2100 	strex	r1, r2, [r3]
 800ff60:	2900      	cmp	r1, #0
 800ff62:	d1ef      	bne.n	800ff44 <HAL_UART_Abort+0xd8>
 800ff64:	e79c      	b.n	800fea0 <HAL_UART_Abort+0x34>
  __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF | UART_CLEAR_NEF | UART_CLEAR_PEF | UART_CLEAR_FEF);
 800ff66:	461a      	mov	r2, r3
 800ff68:	e7a1      	b.n	800feae <HAL_UART_Abort+0x42>
        if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
 800ff6a:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 800ff6c:	f7fc fc4a 	bl	800c804 <HAL_DMA_GetError>
 800ff70:	2820      	cmp	r0, #32
 800ff72:	d1cd      	bne.n	800ff10 <HAL_UART_Abort+0xa4>
          huart->ErrorCode = HAL_UART_ERROR_DMA;
 800ff74:	2310      	movs	r3, #16
          return HAL_TIMEOUT;
 800ff76:	2003      	movs	r0, #3
          huart->ErrorCode = HAL_UART_ERROR_DMA;
 800ff78:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
}
 800ff7c:	bd10      	pop	{r4, pc}
        if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
 800ff7e:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 800ff80:	f7fc fc40 	bl	800c804 <HAL_DMA_GetError>
 800ff84:	2820      	cmp	r0, #32
 800ff86:	d1db      	bne.n	800ff40 <HAL_UART_Abort+0xd4>
 800ff88:	e7f4      	b.n	800ff74 <HAL_UART_Abort+0x108>
 800ff8a:	bf00      	nop
 800ff8c:	ef7ffffe 	.word	0xef7ffffe

0800ff90 <HAL_UART_RxCpltCallback>:
 800ff90:	4770      	bx	lr
 800ff92:	bf00      	nop

0800ff94 <HAL_UART_RxHalfCpltCallback>:
 800ff94:	4770      	bx	lr
 800ff96:	bf00      	nop

0800ff98 <UART_DMAError>:
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800ff98:	6b80      	ldr	r0, [r0, #56]	; 0x38

  const HAL_UART_StateTypeDef gstate = huart->gState;
  const HAL_UART_StateTypeDef rxstate = huart->RxState;

  /* Stop UART DMA Tx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 800ff9a:	6803      	ldr	r3, [r0, #0]
  const HAL_UART_StateTypeDef gstate = huart->gState;
 800ff9c:	f8d0 1084 	ldr.w	r1, [r0, #132]	; 0x84
{
 800ffa0:	b510      	push	{r4, lr}
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
 800ffa2:	f8d0 4088 	ldr.w	r4, [r0, #136]	; 0x88
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 800ffa6:	689a      	ldr	r2, [r3, #8]
 800ffa8:	0612      	lsls	r2, r2, #24
 800ffaa:	d501      	bpl.n	800ffb0 <UART_DMAError+0x18>
 800ffac:	2921      	cmp	r1, #33	; 0x21
 800ffae:	d00d      	beq.n	800ffcc <UART_DMAError+0x34>
    huart->TxXferCount = 0U;
    UART_EndTxTransfer(huart);
  }

  /* Stop UART DMA Rx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
 800ffb0:	689a      	ldr	r2, [r3, #8]
 800ffb2:	0652      	lsls	r2, r2, #25
 800ffb4:	d501      	bpl.n	800ffba <UART_DMAError+0x22>
 800ffb6:	2c22      	cmp	r4, #34	; 0x22
 800ffb8:	d023      	beq.n	8010002 <UART_DMAError+0x6a>
  {
    huart->RxXferCount = 0U;
    UART_EndRxTransfer(huart);
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 800ffba:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
 800ffbe:	f043 0310 	orr.w	r3, r3, #16
 800ffc2:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 800ffc6:	f001 ff75 	bl	8011eb4 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800ffca:	bd10      	pop	{r4, pc}
    huart->TxXferCount = 0U;
 800ffcc:	2200      	movs	r2, #0
 800ffce:	f8a0 2056 	strh.w	r2, [r0, #86]	; 0x56
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800ffd2:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
 800ffd6:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800ffda:	e843 2100 	strex	r1, r2, [r3]
 800ffde:	2900      	cmp	r1, #0
 800ffe0:	d1f7      	bne.n	800ffd2 <UART_DMAError+0x3a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800ffe2:	f103 0208 	add.w	r2, r3, #8
 800ffe6:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));
 800ffea:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800ffee:	f103 0c08 	add.w	ip, r3, #8
 800fff2:	e84c 2100 	strex	r1, r2, [ip]
 800fff6:	2900      	cmp	r1, #0
 800fff8:	d1f3      	bne.n	800ffe2 <UART_DMAError+0x4a>
  huart->gState = HAL_UART_STATE_READY;
 800fffa:	2220      	movs	r2, #32
 800fffc:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
}
 8010000:	e7d6      	b.n	800ffb0 <UART_DMAError+0x18>
    huart->RxXferCount = 0U;
 8010002:	2200      	movs	r2, #0
 8010004:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010008:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 801000c:	f422 7290 	bic.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010010:	e843 2100 	strex	r1, r2, [r3]
 8010014:	2900      	cmp	r1, #0
 8010016:	d1f7      	bne.n	8010008 <UART_DMAError+0x70>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8010018:	4c13      	ldr	r4, [pc, #76]	; (8010068 <UART_DMAError+0xd0>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801001a:	f103 0208 	add.w	r2, r3, #8
 801001e:	e852 2f00 	ldrex	r2, [r2]
 8010022:	4022      	ands	r2, r4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010024:	f103 0c08 	add.w	ip, r3, #8
 8010028:	e84c 2100 	strex	r1, r2, [ip]
 801002c:	2900      	cmp	r1, #0
 801002e:	d1f4      	bne.n	801001a <UART_DMAError+0x82>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8010030:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 8010032:	2a01      	cmp	r2, #1
 8010034:	d006      	beq.n	8010044 <UART_DMAError+0xac>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8010036:	2300      	movs	r3, #0
  huart->RxState = HAL_UART_STATE_READY;
 8010038:	2220      	movs	r2, #32
  huart->RxISR = NULL;
 801003a:	6703      	str	r3, [r0, #112]	; 0x70
  huart->RxState = HAL_UART_STATE_READY;
 801003c:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8010040:	66c3      	str	r3, [r0, #108]	; 0x6c
}
 8010042:	e7ba      	b.n	800ffba <UART_DMAError+0x22>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010044:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8010048:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801004c:	e843 2100 	strex	r1, r2, [r3]
 8010050:	2900      	cmp	r1, #0
 8010052:	d0f0      	beq.n	8010036 <UART_DMAError+0x9e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010054:	e853 2f00 	ldrex	r2, [r3]
 8010058:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801005c:	e843 2100 	strex	r1, r2, [r3]
 8010060:	2900      	cmp	r1, #0
 8010062:	d1ef      	bne.n	8010044 <UART_DMAError+0xac>
 8010064:	e7e7      	b.n	8010036 <UART_DMAError+0x9e>
 8010066:	bf00      	nop
 8010068:	effffffe 	.word	0xeffffffe

0801006c <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 801006c:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 801006e:	6b80      	ldr	r0, [r0, #56]	; 0x38
  huart->RxXferCount = 0U;
 8010070:	2300      	movs	r3, #0
 8010072:	f8a0 305e 	strh.w	r3, [r0, #94]	; 0x5e
  huart->TxXferCount = 0U;
 8010076:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 801007a:	f001 ff1b 	bl	8011eb4 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 801007e:	bd08      	pop	{r3, pc}

08010080 <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 8010080:	6803      	ldr	r3, [r0, #0]
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
 8010082:	f640 0c0f 	movw	ip, #2063	; 0x80f
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 8010086:	69da      	ldr	r2, [r3, #28]
  if (errorflags == 0U)
 8010088:	ea12 0f0c 	tst.w	r2, ip
{
 801008c:	b570      	push	{r4, r5, r6, lr}
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 801008e:	681d      	ldr	r5, [r3, #0]
{
 8010090:	4604      	mov	r4, r0
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8010092:	6899      	ldr	r1, [r3, #8]
  if (errorflags == 0U)
 8010094:	f000 811c 	beq.w	80102d0 <HAL_UART_IRQHandler+0x250>
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 8010098:	4eae      	ldr	r6, [pc, #696]	; (8010354 <HAL_UART_IRQHandler+0x2d4>)
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 801009a:	48af      	ldr	r0, [pc, #700]	; (8010358 <HAL_UART_IRQHandler+0x2d8>)
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 801009c:	ea05 0c06 	and.w	ip, r5, r6
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 80100a0:	4008      	ands	r0, r1
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 80100a2:	ea5c 0600 	orrs.w	r6, ip, r0
 80100a6:	f040 8086 	bne.w	80101b6 <HAL_UART_IRQHandler+0x136>
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80100aa:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80100ac:	2801      	cmp	r0, #1
 80100ae:	d022      	beq.n	80100f6 <HAL_UART_IRQHandler+0x76>
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 80100b0:	02d0      	lsls	r0, r2, #11
 80100b2:	d502      	bpl.n	80100ba <HAL_UART_IRQHandler+0x3a>
 80100b4:	024e      	lsls	r6, r1, #9
 80100b6:	f100 8134 	bmi.w	8010322 <HAL_UART_IRQHandler+0x2a2>
  if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
 80100ba:	0610      	lsls	r0, r2, #24
 80100bc:	d506      	bpl.n	80100cc <HAL_UART_IRQHandler+0x4c>
          || ((cr3its & USART_CR3_TXFTIE) != 0U)))
 80100be:	f401 0100 	and.w	r1, r1, #8388608	; 0x800000
      && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
 80100c2:	f005 0080 	and.w	r0, r5, #128	; 0x80
          || ((cr3its & USART_CR3_TXFTIE) != 0U)))
 80100c6:	4301      	orrs	r1, r0
 80100c8:	f040 8123 	bne.w	8010312 <HAL_UART_IRQHandler+0x292>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 80100cc:	0651      	lsls	r1, r2, #25
 80100ce:	d564      	bpl.n	801019a <HAL_UART_IRQHandler+0x11a>
 80100d0:	066e      	lsls	r6, r5, #25
 80100d2:	d562      	bpl.n	801019a <HAL_UART_IRQHandler+0x11a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80100d4:	e853 2f00 	ldrex	r2, [r3]
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 80100d8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80100dc:	e843 2100 	strex	r1, r2, [r3]
 80100e0:	2900      	cmp	r1, #0
 80100e2:	d1f7      	bne.n	80100d4 <HAL_UART_IRQHandler+0x54>

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 80100e4:	2220      	movs	r2, #32

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 80100e6:	2300      	movs	r3, #0
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 80100e8:	4620      	mov	r0, r4
  huart->gState = HAL_UART_STATE_READY;
 80100ea:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
  huart->TxISR = NULL;
 80100ee:	6763      	str	r3, [r4, #116]	; 0x74
  HAL_UART_TxCpltCallback(huart);
 80100f0:	f001 fea8 	bl	8011e44 <HAL_UART_TxCpltCallback>
}
 80100f4:	bd70      	pop	{r4, r5, r6, pc}
      && ((isrflags & USART_ISR_IDLE) != 0U)
 80100f6:	06d0      	lsls	r0, r2, #27
 80100f8:	d5da      	bpl.n	80100b0 <HAL_UART_IRQHandler+0x30>
      && ((cr1its & USART_ISR_IDLE) != 0U))
 80100fa:	06ee      	lsls	r6, r5, #27
 80100fc:	d5d8      	bpl.n	80100b0 <HAL_UART_IRQHandler+0x30>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 80100fe:	2210      	movs	r2, #16
 8010100:	621a      	str	r2, [r3, #32]
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8010102:	689a      	ldr	r2, [r3, #8]
 8010104:	0655      	lsls	r5, r2, #25
 8010106:	f140 8136 	bpl.w	8010376 <HAL_UART_IRQHandler+0x2f6>
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 801010a:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 801010c:	6801      	ldr	r1, [r0, #0]
 801010e:	684a      	ldr	r2, [r1, #4]
 8010110:	b292      	uxth	r2, r2
      if ((nb_remaining_rx_data > 0U)
 8010112:	2a00      	cmp	r2, #0
 8010114:	d0ee      	beq.n	80100f4 <HAL_UART_IRQHandler+0x74>
          && (nb_remaining_rx_data < huart->RxXferSize))
 8010116:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
 801011a:	4291      	cmp	r1, r2
 801011c:	d9ea      	bls.n	80100f4 <HAL_UART_IRQHandler+0x74>
        huart->RxXferCount = nb_remaining_rx_data;
 801011e:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
        if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
 8010122:	69c2      	ldr	r2, [r0, #28]
 8010124:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8010128:	d02f      	beq.n	801018a <HAL_UART_IRQHandler+0x10a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801012a:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 801012e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010132:	e843 2100 	strex	r1, r2, [r3]
 8010136:	2900      	cmp	r1, #0
 8010138:	d1f7      	bne.n	801012a <HAL_UART_IRQHandler+0xaa>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801013a:	f103 0208 	add.w	r2, r3, #8
 801013e:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8010142:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010146:	f103 0508 	add.w	r5, r3, #8
 801014a:	e845 2100 	strex	r1, r2, [r5]
 801014e:	2900      	cmp	r1, #0
 8010150:	d1f3      	bne.n	801013a <HAL_UART_IRQHandler+0xba>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010152:	f103 0208 	add.w	r2, r3, #8
 8010156:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 801015a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801015e:	f103 0508 	add.w	r5, r3, #8
 8010162:	e845 2100 	strex	r1, r2, [r5]
 8010166:	2900      	cmp	r1, #0
 8010168:	d1f3      	bne.n	8010152 <HAL_UART_IRQHandler+0xd2>
          huart->RxState = HAL_UART_STATE_READY;
 801016a:	2220      	movs	r2, #32
 801016c:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8010170:	66e1      	str	r1, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010172:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8010176:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801017a:	e843 2100 	strex	r1, r2, [r3]
 801017e:	2900      	cmp	r1, #0
 8010180:	d1f7      	bne.n	8010172 <HAL_UART_IRQHandler+0xf2>
          (void)HAL_DMA_Abort(huart->hdmarx);
 8010182:	f7fb fdad 	bl	800bce0 <HAL_DMA_Abort>
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 8010186:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
 801018a:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 801018e:	4620      	mov	r0, r4
 8010190:	1ac9      	subs	r1, r1, r3
 8010192:	b289      	uxth	r1, r1
 8010194:	f001 fe2e 	bl	8011df4 <HAL_UARTEx_RxEventCallback>
}
 8010198:	bd70      	pop	{r4, r5, r6, pc}
  if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
 801019a:	0210      	lsls	r0, r2, #8
 801019c:	d502      	bpl.n	80101a4 <HAL_UART_IRQHandler+0x124>
 801019e:	0069      	lsls	r1, r5, #1
 80101a0:	f100 80e4 	bmi.w	801036c <HAL_UART_IRQHandler+0x2ec>
  if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
 80101a4:	01d3      	lsls	r3, r2, #7
 80101a6:	d5a5      	bpl.n	80100f4 <HAL_UART_IRQHandler+0x74>
 80101a8:	2d00      	cmp	r5, #0
 80101aa:	daa3      	bge.n	80100f4 <HAL_UART_IRQHandler+0x74>
    HAL_UARTEx_RxFifoFullCallback(huart);
 80101ac:	4620      	mov	r0, r4
}
 80101ae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    HAL_UARTEx_RxFifoFullCallback(huart);
 80101b2:	f000 be6f 	b.w	8010e94 <HAL_UARTEx_RxFifoFullCallback>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 80101b6:	07d6      	lsls	r6, r2, #31
 80101b8:	d509      	bpl.n	80101ce <HAL_UART_IRQHandler+0x14e>
 80101ba:	05ee      	lsls	r6, r5, #23
 80101bc:	d507      	bpl.n	80101ce <HAL_UART_IRQHandler+0x14e>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 80101be:	2601      	movs	r6, #1
 80101c0:	621e      	str	r6, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 80101c2:	f8d4 608c 	ldr.w	r6, [r4, #140]	; 0x8c
 80101c6:	f046 0601 	orr.w	r6, r6, #1
 80101ca:	f8c4 608c 	str.w	r6, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80101ce:	0796      	lsls	r6, r2, #30
 80101d0:	f140 8090 	bpl.w	80102f4 <HAL_UART_IRQHandler+0x274>
 80101d4:	07ce      	lsls	r6, r1, #31
 80101d6:	d50a      	bpl.n	80101ee <HAL_UART_IRQHandler+0x16e>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 80101d8:	2602      	movs	r6, #2
 80101da:	621e      	str	r6, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 80101dc:	f8d4 608c 	ldr.w	r6, [r4, #140]	; 0x8c
 80101e0:	f046 0604 	orr.w	r6, r6, #4
 80101e4:	f8c4 608c 	str.w	r6, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80101e8:	0756      	lsls	r6, r2, #29
 80101ea:	f100 8089 	bmi.w	8010300 <HAL_UART_IRQHandler+0x280>
    if (((isrflags & USART_ISR_ORE) != 0U)
 80101ee:	0716      	lsls	r6, r2, #28
 80101f0:	d50b      	bpl.n	801020a <HAL_UART_IRQHandler+0x18a>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
 80101f2:	f005 0620 	and.w	r6, r5, #32
 80101f6:	4330      	orrs	r0, r6
 80101f8:	d007      	beq.n	801020a <HAL_UART_IRQHandler+0x18a>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 80101fa:	2008      	movs	r0, #8
 80101fc:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 80101fe:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 8010202:	f040 0008 	orr.w	r0, r0, #8
 8010206:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 801020a:	0516      	lsls	r6, r2, #20
 801020c:	d50a      	bpl.n	8010224 <HAL_UART_IRQHandler+0x1a4>
 801020e:	0168      	lsls	r0, r5, #5
 8010210:	d508      	bpl.n	8010224 <HAL_UART_IRQHandler+0x1a4>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8010212:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8010216:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 8010218:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 801021c:	f040 0020 	orr.w	r0, r0, #32
 8010220:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8010224:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 8010228:	2800      	cmp	r0, #0
 801022a:	f43f af63 	beq.w	80100f4 <HAL_UART_IRQHandler+0x74>
      if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 801022e:	0696      	lsls	r6, r2, #26
 8010230:	d50b      	bpl.n	801024a <HAL_UART_IRQHandler+0x1ca>
          && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 8010232:	f005 0520 	and.w	r5, r5, #32
              || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 8010236:	f001 5180 	and.w	r1, r1, #268435456	; 0x10000000
 801023a:	ea55 0201 	orrs.w	r2, r5, r1
 801023e:	d004      	beq.n	801024a <HAL_UART_IRQHandler+0x1ca>
        if (huart->RxISR != NULL)
 8010240:	6f22      	ldr	r2, [r4, #112]	; 0x70
 8010242:	b112      	cbz	r2, 801024a <HAL_UART_IRQHandler+0x1ca>
          huart->RxISR(huart);
 8010244:	4620      	mov	r0, r4
 8010246:	4790      	blx	r2
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8010248:	6823      	ldr	r3, [r4, #0]
      errorcode = huart->ErrorCode;
 801024a:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 801024e:	689a      	ldr	r2, [r3, #8]
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 8010250:	f005 0528 	and.w	r5, r5, #40	; 0x28
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8010254:	f002 0240 	and.w	r2, r2, #64	; 0x40
 8010258:	4315      	orrs	r5, r2
 801025a:	f000 80c0 	beq.w	80103de <HAL_UART_IRQHandler+0x35e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801025e:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8010262:	f422 7290 	bic.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010266:	e843 2100 	strex	r1, r2, [r3]
 801026a:	2900      	cmp	r1, #0
 801026c:	d1f7      	bne.n	801025e <HAL_UART_IRQHandler+0x1de>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 801026e:	483b      	ldr	r0, [pc, #236]	; (801035c <HAL_UART_IRQHandler+0x2dc>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010270:	f103 0208 	add.w	r2, r3, #8
 8010274:	e852 2f00 	ldrex	r2, [r2]
 8010278:	4002      	ands	r2, r0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801027a:	f103 0508 	add.w	r5, r3, #8
 801027e:	e845 2100 	strex	r1, r2, [r5]
 8010282:	2900      	cmp	r1, #0
 8010284:	d1f4      	bne.n	8010270 <HAL_UART_IRQHandler+0x1f0>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8010286:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8010288:	2a01      	cmp	r2, #1
 801028a:	d052      	beq.n	8010332 <HAL_UART_IRQHandler+0x2b2>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 801028c:	2200      	movs	r2, #0
  huart->RxState = HAL_UART_STATE_READY;
 801028e:	2120      	movs	r1, #32
 8010290:	f8c4 1088 	str.w	r1, [r4, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8010294:	66e2      	str	r2, [r4, #108]	; 0x6c
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8010296:	6899      	ldr	r1, [r3, #8]
  huart->RxISR = NULL;
 8010298:	6722      	str	r2, [r4, #112]	; 0x70
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 801029a:	064d      	lsls	r5, r1, #25
 801029c:	d562      	bpl.n	8010364 <HAL_UART_IRQHandler+0x2e4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801029e:	f103 0208 	add.w	r2, r3, #8
 80102a2:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 80102a6:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80102aa:	f103 0008 	add.w	r0, r3, #8
 80102ae:	e840 2100 	strex	r1, r2, [r0]
 80102b2:	2900      	cmp	r1, #0
 80102b4:	d1f3      	bne.n	801029e <HAL_UART_IRQHandler+0x21e>
          if (huart->hdmarx != NULL)
 80102b6:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 80102b8:	2800      	cmp	r0, #0
 80102ba:	d053      	beq.n	8010364 <HAL_UART_IRQHandler+0x2e4>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 80102bc:	4b28      	ldr	r3, [pc, #160]	; (8010360 <HAL_UART_IRQHandler+0x2e0>)
 80102be:	6503      	str	r3, [r0, #80]	; 0x50
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 80102c0:	f7fb fe86 	bl	800bfd0 <HAL_DMA_Abort_IT>
 80102c4:	2800      	cmp	r0, #0
 80102c6:	f43f af15 	beq.w	80100f4 <HAL_UART_IRQHandler+0x74>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 80102ca:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 80102cc:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80102ce:	e00e      	b.n	80102ee <HAL_UART_IRQHandler+0x26e>
    if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 80102d0:	0696      	lsls	r6, r2, #26
 80102d2:	f57f aeea 	bpl.w	80100aa <HAL_UART_IRQHandler+0x2a>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 80102d6:	f005 0620 	and.w	r6, r5, #32
            || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 80102da:	f001 5c80 	and.w	ip, r1, #268435456	; 0x10000000
 80102de:	ea56 060c 	orrs.w	r6, r6, ip
 80102e2:	f43f aee2 	beq.w	80100aa <HAL_UART_IRQHandler+0x2a>
      if (huart->RxISR != NULL)
 80102e6:	6f03      	ldr	r3, [r0, #112]	; 0x70
 80102e8:	2b00      	cmp	r3, #0
 80102ea:	f43f af03 	beq.w	80100f4 <HAL_UART_IRQHandler+0x74>
}
 80102ee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 80102f2:	4718      	bx	r3
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80102f4:	0756      	lsls	r6, r2, #29
 80102f6:	f57f af7a 	bpl.w	80101ee <HAL_UART_IRQHandler+0x16e>
 80102fa:	07ce      	lsls	r6, r1, #31
 80102fc:	f57f af77 	bpl.w	80101ee <HAL_UART_IRQHandler+0x16e>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 8010300:	2604      	movs	r6, #4
 8010302:	621e      	str	r6, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8010304:	f8d4 608c 	ldr.w	r6, [r4, #140]	; 0x8c
 8010308:	f046 0602 	orr.w	r6, r6, #2
 801030c:	f8c4 608c 	str.w	r6, [r4, #140]	; 0x8c
 8010310:	e76d      	b.n	80101ee <HAL_UART_IRQHandler+0x16e>
    if (huart->TxISR != NULL)
 8010312:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8010314:	2b00      	cmp	r3, #0
 8010316:	f43f aeed 	beq.w	80100f4 <HAL_UART_IRQHandler+0x74>
      huart->TxISR(huart);
 801031a:	4620      	mov	r0, r4
}
 801031c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      huart->TxISR(huart);
 8010320:	4718      	bx	r3
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 8010322:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    HAL_UARTEx_WakeupCallback(huart);
 8010326:	4620      	mov	r0, r4
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 8010328:	621a      	str	r2, [r3, #32]
}
 801032a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    HAL_UARTEx_WakeupCallback(huart);
 801032e:	f000 bdaf 	b.w	8010e90 <HAL_UARTEx_WakeupCallback>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010332:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8010336:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801033a:	e843 2100 	strex	r1, r2, [r3]
 801033e:	2900      	cmp	r1, #0
 8010340:	d0a4      	beq.n	801028c <HAL_UART_IRQHandler+0x20c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010342:	e853 2f00 	ldrex	r2, [r3]
 8010346:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801034a:	e843 2100 	strex	r1, r2, [r3]
 801034e:	2900      	cmp	r1, #0
 8010350:	d1ef      	bne.n	8010332 <HAL_UART_IRQHandler+0x2b2>
 8010352:	e79b      	b.n	801028c <HAL_UART_IRQHandler+0x20c>
 8010354:	04000120 	.word	0x04000120
 8010358:	10000001 	.word	0x10000001
 801035c:	effffffe 	.word	0xeffffffe
 8010360:	0801006d 	.word	0x0801006d
            HAL_UART_ErrorCallback(huart);
 8010364:	4620      	mov	r0, r4
 8010366:	f001 fda5 	bl	8011eb4 <HAL_UART_ErrorCallback>
}
 801036a:	bd70      	pop	{r4, r5, r6, pc}
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 801036c:	4620      	mov	r0, r4
}
 801036e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 8010372:	f000 bd91 	b.w	8010e98 <HAL_UARTEx_TxFifoEmptyCallback>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8010376:	f8b4 005e 	ldrh.w	r0, [r4, #94]	; 0x5e
 801037a:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
      if ((huart->RxXferCount > 0U)
 801037e:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8010382:	1a09      	subs	r1, r1, r0
      if ((huart->RxXferCount > 0U)
 8010384:	b292      	uxth	r2, r2
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8010386:	b289      	uxth	r1, r1
          && (nb_rx_data > 0U))
 8010388:	2a00      	cmp	r2, #0
 801038a:	f43f aeb3 	beq.w	80100f4 <HAL_UART_IRQHandler+0x74>
 801038e:	2900      	cmp	r1, #0
 8010390:	f43f aeb0 	beq.w	80100f4 <HAL_UART_IRQHandler+0x74>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010394:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8010398:	f422 7290 	bic.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801039c:	e843 2000 	strex	r0, r2, [r3]
 80103a0:	2800      	cmp	r0, #0
 80103a2:	d1f7      	bne.n	8010394 <HAL_UART_IRQHandler+0x314>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 80103a4:	4d11      	ldr	r5, [pc, #68]	; (80103ec <HAL_UART_IRQHandler+0x36c>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80103a6:	f103 0208 	add.w	r2, r3, #8
 80103aa:	e852 2f00 	ldrex	r2, [r2]
 80103ae:	402a      	ands	r2, r5
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80103b0:	f103 0608 	add.w	r6, r3, #8
 80103b4:	e846 2000 	strex	r0, r2, [r6]
 80103b8:	2800      	cmp	r0, #0
 80103ba:	d1f4      	bne.n	80103a6 <HAL_UART_IRQHandler+0x326>
        huart->RxState = HAL_UART_STATE_READY;
 80103bc:	2220      	movs	r2, #32
        huart->RxISR = NULL;
 80103be:	6720      	str	r0, [r4, #112]	; 0x70
        huart->RxState = HAL_UART_STATE_READY;
 80103c0:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80103c4:	66e0      	str	r0, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80103c6:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80103ca:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80103ce:	e843 2000 	strex	r0, r2, [r3]
 80103d2:	2800      	cmp	r0, #0
 80103d4:	d1f7      	bne.n	80103c6 <HAL_UART_IRQHandler+0x346>
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 80103d6:	4620      	mov	r0, r4
 80103d8:	f001 fd0c 	bl	8011df4 <HAL_UARTEx_RxEventCallback>
}
 80103dc:	bd70      	pop	{r4, r5, r6, pc}
        HAL_UART_ErrorCallback(huart);
 80103de:	4620      	mov	r0, r4
 80103e0:	f001 fd68 	bl	8011eb4 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 80103e4:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
}
 80103e8:	bd70      	pop	{r4, r5, r6, pc}
 80103ea:	bf00      	nop
 80103ec:	effffffe 	.word	0xeffffffe

080103f0 <UART_DMARxHalfCplt>:
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 80103f0:	6b80      	ldr	r0, [r0, #56]	; 0x38
{
 80103f2:	b508      	push	{r3, lr}
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80103f4:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80103f6:	2b01      	cmp	r3, #1
 80103f8:	d002      	beq.n	8010400 <UART_DMARxHalfCplt+0x10>
    HAL_UART_RxHalfCpltCallback(huart);
 80103fa:	f7ff fdcb 	bl	800ff94 <HAL_UART_RxHalfCpltCallback>
}
 80103fe:	bd08      	pop	{r3, pc}
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize / 2U);
 8010400:	f8b0 105c 	ldrh.w	r1, [r0, #92]	; 0x5c
 8010404:	0849      	lsrs	r1, r1, #1
 8010406:	f001 fcf5 	bl	8011df4 <HAL_UARTEx_RxEventCallback>
}
 801040a:	bd08      	pop	{r3, pc}

0801040c <UART_DMAReceiveCplt>:
{
 801040c:	b508      	push	{r3, lr}
  if (hdma->Init.Mode != DMA_CIRCULAR)
 801040e:	69c3      	ldr	r3, [r0, #28]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8010410:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
 8010412:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8010416:	d029      	beq.n	801046c <UART_DMAReceiveCplt+0x60>
    huart->RxXferCount = 0U;
 8010418:	2200      	movs	r2, #0
 801041a:	6803      	ldr	r3, [r0, #0]
 801041c:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010420:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8010424:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010428:	e843 2100 	strex	r1, r2, [r3]
 801042c:	2900      	cmp	r1, #0
 801042e:	d1f7      	bne.n	8010420 <UART_DMAReceiveCplt+0x14>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010430:	f103 0208 	add.w	r2, r3, #8
 8010434:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8010438:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801043c:	f103 0c08 	add.w	ip, r3, #8
 8010440:	e84c 2100 	strex	r1, r2, [ip]
 8010444:	2900      	cmp	r1, #0
 8010446:	d1f3      	bne.n	8010430 <UART_DMAReceiveCplt+0x24>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010448:	f103 0208 	add.w	r2, r3, #8
 801044c:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8010450:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010454:	f103 0c08 	add.w	ip, r3, #8
 8010458:	e84c 2100 	strex	r1, r2, [ip]
 801045c:	2900      	cmp	r1, #0
 801045e:	d1f3      	bne.n	8010448 <UART_DMAReceiveCplt+0x3c>
    huart->RxState = HAL_UART_STATE_READY;
 8010460:	2220      	movs	r2, #32
 8010462:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
    if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8010466:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 8010468:	2a01      	cmp	r2, #1
 801046a:	d005      	beq.n	8010478 <UART_DMAReceiveCplt+0x6c>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 801046c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 801046e:	2b01      	cmp	r3, #1
 8010470:	d013      	beq.n	801049a <UART_DMAReceiveCplt+0x8e>
    HAL_UART_RxCpltCallback(huart);
 8010472:	f7ff fd8d 	bl	800ff90 <HAL_UART_RxCpltCallback>
}
 8010476:	bd08      	pop	{r3, pc}
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010478:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 801047c:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010480:	e843 2100 	strex	r1, r2, [r3]
 8010484:	2900      	cmp	r1, #0
 8010486:	d0f1      	beq.n	801046c <UART_DMAReceiveCplt+0x60>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010488:	e853 2f00 	ldrex	r2, [r3]
 801048c:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010490:	e843 2100 	strex	r1, r2, [r3]
 8010494:	2900      	cmp	r1, #0
 8010496:	d1ef      	bne.n	8010478 <UART_DMAReceiveCplt+0x6c>
 8010498:	e7e8      	b.n	801046c <UART_DMAReceiveCplt+0x60>
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 801049a:	f8b0 105c 	ldrh.w	r1, [r0, #92]	; 0x5c
 801049e:	f001 fca9 	bl	8011df4 <HAL_UARTEx_RxEventCallback>
}
 80104a2:	bd08      	pop	{r3, pc}

080104a4 <UART_SetConfig>:
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80104a4:	6901      	ldr	r1, [r0, #16]
 80104a6:	6882      	ldr	r2, [r0, #8]
  if (UART_INSTANCE_LOWPOWER(huart))
 80104a8:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80104aa:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80104ac:	49c0      	ldr	r1, [pc, #768]	; (80107b0 <UART_SetConfig+0x30c>)
{
 80104ae:	b530      	push	{r4, r5, lr}
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80104b0:	6945      	ldr	r5, [r0, #20]
{
 80104b2:	4604      	mov	r4, r0
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80104b4:	69c0      	ldr	r0, [r0, #28]
{
 80104b6:	b087      	sub	sp, #28
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80104b8:	432a      	orrs	r2, r5
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80104ba:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80104bc:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80104be:	4029      	ands	r1, r5
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80104c0:	4dbc      	ldr	r5, [pc, #752]	; (80107b4 <UART_SetConfig+0x310>)
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80104c2:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80104c4:	68e1      	ldr	r1, [r4, #12]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80104c6:	42ab      	cmp	r3, r5
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80104c8:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80104ca:	685a      	ldr	r2, [r3, #4]
 80104cc:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 80104d0:	ea42 0201 	orr.w	r2, r2, r1
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 80104d4:	69a1      	ldr	r1, [r4, #24]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80104d6:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80104d8:	f000 80e0 	beq.w	801069c <UART_SetConfig+0x1f8>
    tmpreg |= huart->Init.OneBitSampling;
 80104dc:	6a22      	ldr	r2, [r4, #32]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80104de:	689d      	ldr	r5, [r3, #8]
    tmpreg |= huart->Init.OneBitSampling;
 80104e0:	4311      	orrs	r1, r2
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80104e2:	4ab5      	ldr	r2, [pc, #724]	; (80107b8 <UART_SetConfig+0x314>)
 80104e4:	402a      	ands	r2, r5
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 80104e6:	6a65      	ldr	r5, [r4, #36]	; 0x24
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80104e8:	4311      	orrs	r1, r2
 80104ea:	6099      	str	r1, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 80104ec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80104ee:	f022 020f 	bic.w	r2, r2, #15
 80104f2:	432a      	orrs	r2, r5
 80104f4:	62da      	str	r2, [r3, #44]	; 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 80104f6:	4ab1      	ldr	r2, [pc, #708]	; (80107bc <UART_SetConfig+0x318>)
 80104f8:	4293      	cmp	r3, r2
 80104fa:	d023      	beq.n	8010544 <UART_SetConfig+0xa0>
 80104fc:	4ab0      	ldr	r2, [pc, #704]	; (80107c0 <UART_SetConfig+0x31c>)
 80104fe:	4293      	cmp	r3, r2
 8010500:	d076      	beq.n	80105f0 <UART_SetConfig+0x14c>
 8010502:	4ab0      	ldr	r2, [pc, #704]	; (80107c4 <UART_SetConfig+0x320>)
 8010504:	4293      	cmp	r3, r2
 8010506:	f000 818f 	beq.w	8010828 <UART_SetConfig+0x384>
 801050a:	4aaf      	ldr	r2, [pc, #700]	; (80107c8 <UART_SetConfig+0x324>)
 801050c:	4293      	cmp	r3, r2
 801050e:	f000 81e1 	beq.w	80108d4 <UART_SetConfig+0x430>
 8010512:	4aae      	ldr	r2, [pc, #696]	; (80107cc <UART_SetConfig+0x328>)
 8010514:	4293      	cmp	r3, r2
 8010516:	f000 8121 	beq.w	801075c <UART_SetConfig+0x2b8>
 801051a:	4aad      	ldr	r2, [pc, #692]	; (80107d0 <UART_SetConfig+0x32c>)
 801051c:	4293      	cmp	r3, r2
 801051e:	f000 81e3 	beq.w	80108e8 <UART_SetConfig+0x444>
 8010522:	4aac      	ldr	r2, [pc, #688]	; (80107d4 <UART_SetConfig+0x330>)
 8010524:	4293      	cmp	r3, r2
 8010526:	f000 8234 	beq.w	8010992 <UART_SetConfig+0x4ee>
 801052a:	4aab      	ldr	r2, [pc, #684]	; (80107d8 <UART_SetConfig+0x334>)
 801052c:	4293      	cmp	r3, r2
 801052e:	f000 81e7 	beq.w	8010900 <UART_SetConfig+0x45c>
        ret = HAL_ERROR;
 8010532:	2001      	movs	r0, #1
  huart->RxISR = NULL;
 8010534:	2300      	movs	r3, #0
  huart->NbRxDataToProcess = 1;
 8010536:	f04f 1201 	mov.w	r2, #65537	; 0x10001
  huart->RxISR = NULL;
 801053a:	6723      	str	r3, [r4, #112]	; 0x70
  huart->NbRxDataToProcess = 1;
 801053c:	66a2      	str	r2, [r4, #104]	; 0x68
  huart->TxISR = NULL;
 801053e:	6763      	str	r3, [r4, #116]	; 0x74
}
 8010540:	b007      	add	sp, #28
 8010542:	bd30      	pop	{r4, r5, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 8010544:	4ba5      	ldr	r3, [pc, #660]	; (80107dc <UART_SetConfig+0x338>)
 8010546:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010548:	f003 0338 	and.w	r3, r3, #56	; 0x38
 801054c:	2b28      	cmp	r3, #40	; 0x28
 801054e:	d8f0      	bhi.n	8010532 <UART_SetConfig+0x8e>
 8010550:	4aa3      	ldr	r2, [pc, #652]	; (80107e0 <UART_SetConfig+0x33c>)
 8010552:	5cd3      	ldrb	r3, [r2, r3]
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8010554:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8010558:	d055      	beq.n	8010606 <UART_SetConfig+0x162>
    switch (clocksource)
 801055a:	2b20      	cmp	r3, #32
 801055c:	f200 814a 	bhi.w	80107f4 <UART_SetConfig+0x350>
 8010560:	2b20      	cmp	r3, #32
 8010562:	d8e6      	bhi.n	8010532 <UART_SetConfig+0x8e>
 8010564:	a201      	add	r2, pc, #4	; (adr r2, 801056c <UART_SetConfig+0xc8>)
 8010566:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801056a:	bf00      	nop
 801056c:	080107ab 	.word	0x080107ab
 8010570:	080107a5 	.word	0x080107a5
 8010574:	08010533 	.word	0x08010533
 8010578:	08010533 	.word	0x08010533
 801057c:	08010795 	.word	0x08010795
 8010580:	08010533 	.word	0x08010533
 8010584:	08010533 	.word	0x08010533
 8010588:	08010533 	.word	0x08010533
 801058c:	08010787 	.word	0x08010787
 8010590:	08010533 	.word	0x08010533
 8010594:	08010533 	.word	0x08010533
 8010598:	08010533 	.word	0x08010533
 801059c:	08010533 	.word	0x08010533
 80105a0:	08010533 	.word	0x08010533
 80105a4:	08010533 	.word	0x08010533
 80105a8:	08010533 	.word	0x08010533
 80105ac:	08010771 	.word	0x08010771
 80105b0:	08010533 	.word	0x08010533
 80105b4:	08010533 	.word	0x08010533
 80105b8:	08010533 	.word	0x08010533
 80105bc:	08010533 	.word	0x08010533
 80105c0:	08010533 	.word	0x08010533
 80105c4:	08010533 	.word	0x08010533
 80105c8:	08010533 	.word	0x08010533
 80105cc:	08010533 	.word	0x08010533
 80105d0:	08010533 	.word	0x08010533
 80105d4:	08010533 	.word	0x08010533
 80105d8:	08010533 	.word	0x08010533
 80105dc:	08010533 	.word	0x08010533
 80105e0:	08010533 	.word	0x08010533
 80105e4:	08010533 	.word	0x08010533
 80105e8:	08010533 	.word	0x08010533
 80105ec:	08010915 	.word	0x08010915
  UART_GETCLOCKSOURCE(huart, clocksource);
 80105f0:	4b7a      	ldr	r3, [pc, #488]	; (80107dc <UART_SetConfig+0x338>)
 80105f2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80105f4:	f003 0307 	and.w	r3, r3, #7
 80105f8:	2b05      	cmp	r3, #5
 80105fa:	d89a      	bhi.n	8010532 <UART_SetConfig+0x8e>
 80105fc:	4a79      	ldr	r2, [pc, #484]	; (80107e4 <UART_SetConfig+0x340>)
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80105fe:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8010602:	5cd3      	ldrb	r3, [r2, r3]
 8010604:	d1a9      	bne.n	801055a <UART_SetConfig+0xb6>
    switch (clocksource)
 8010606:	2b20      	cmp	r3, #32
 8010608:	f200 8145 	bhi.w	8010896 <UART_SetConfig+0x3f2>
 801060c:	2b20      	cmp	r3, #32
 801060e:	d890      	bhi.n	8010532 <UART_SetConfig+0x8e>
 8010610:	a201      	add	r2, pc, #4	; (adr r2, 8010618 <UART_SetConfig+0x174>)
 8010612:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8010616:	bf00      	nop
 8010618:	0801097f 	.word	0x0801097f
 801061c:	08010979 	.word	0x08010979
 8010620:	08010533 	.word	0x08010533
 8010624:	08010533 	.word	0x08010533
 8010628:	08010985 	.word	0x08010985
 801062c:	08010533 	.word	0x08010533
 8010630:	08010533 	.word	0x08010533
 8010634:	08010533 	.word	0x08010533
 8010638:	08010967 	.word	0x08010967
 801063c:	08010533 	.word	0x08010533
 8010640:	08010533 	.word	0x08010533
 8010644:	08010533 	.word	0x08010533
 8010648:	08010533 	.word	0x08010533
 801064c:	08010533 	.word	0x08010533
 8010650:	08010533 	.word	0x08010533
 8010654:	08010533 	.word	0x08010533
 8010658:	08010953 	.word	0x08010953
 801065c:	08010533 	.word	0x08010533
 8010660:	08010533 	.word	0x08010533
 8010664:	08010533 	.word	0x08010533
 8010668:	08010533 	.word	0x08010533
 801066c:	08010533 	.word	0x08010533
 8010670:	08010533 	.word	0x08010533
 8010674:	08010533 	.word	0x08010533
 8010678:	08010533 	.word	0x08010533
 801067c:	08010533 	.word	0x08010533
 8010680:	08010533 	.word	0x08010533
 8010684:	08010533 	.word	0x08010533
 8010688:	08010533 	.word	0x08010533
 801068c:	08010533 	.word	0x08010533
 8010690:	08010533 	.word	0x08010533
 8010694:	08010533 	.word	0x08010533
 8010698:	0801098f 	.word	0x0801098f
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 801069c:	6898      	ldr	r0, [r3, #8]
 801069e:	4a46      	ldr	r2, [pc, #280]	; (80107b8 <UART_SetConfig+0x314>)
 80106a0:	4002      	ands	r2, r0
  UART_GETCLOCKSOURCE(huart, clocksource);
 80106a2:	484e      	ldr	r0, [pc, #312]	; (80107dc <UART_SetConfig+0x338>)
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80106a4:	430a      	orrs	r2, r1
 80106a6:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 80106a8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80106aa:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80106ac:	f022 020f 	bic.w	r2, r2, #15
 80106b0:	430a      	orrs	r2, r1
 80106b2:	62da      	str	r2, [r3, #44]	; 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 80106b4:	6d83      	ldr	r3, [r0, #88]	; 0x58
 80106b6:	f003 0307 	and.w	r3, r3, #7
 80106ba:	2b05      	cmp	r3, #5
 80106bc:	f63f af39 	bhi.w	8010532 <UART_SetConfig+0x8e>
 80106c0:	4a49      	ldr	r2, [pc, #292]	; (80107e8 <UART_SetConfig+0x344>)
 80106c2:	5cd3      	ldrb	r3, [r2, r3]
    switch (clocksource)
 80106c4:	2b20      	cmp	r3, #32
 80106c6:	f200 80b9 	bhi.w	801083c <UART_SetConfig+0x398>
 80106ca:	2b01      	cmp	r3, #1
 80106cc:	f67f af31 	bls.w	8010532 <UART_SetConfig+0x8e>
 80106d0:	3b02      	subs	r3, #2
 80106d2:	2b1e      	cmp	r3, #30
 80106d4:	f63f af2d 	bhi.w	8010532 <UART_SetConfig+0x8e>
 80106d8:	a201      	add	r2, pc, #4	; (adr r2, 80106e0 <UART_SetConfig+0x23c>)
 80106da:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80106de:	bf00      	nop
 80106e0:	08010949 	.word	0x08010949
 80106e4:	08010533 	.word	0x08010533
 80106e8:	0801093f 	.word	0x0801093f
 80106ec:	08010533 	.word	0x08010533
 80106f0:	08010533 	.word	0x08010533
 80106f4:	08010533 	.word	0x08010533
 80106f8:	0801092d 	.word	0x0801092d
 80106fc:	08010533 	.word	0x08010533
 8010700:	08010533 	.word	0x08010533
 8010704:	08010533 	.word	0x08010533
 8010708:	08010533 	.word	0x08010533
 801070c:	08010533 	.word	0x08010533
 8010710:	08010533 	.word	0x08010533
 8010714:	08010533 	.word	0x08010533
 8010718:	08010919 	.word	0x08010919
 801071c:	08010533 	.word	0x08010533
 8010720:	08010533 	.word	0x08010533
 8010724:	08010533 	.word	0x08010533
 8010728:	08010533 	.word	0x08010533
 801072c:	08010533 	.word	0x08010533
 8010730:	08010533 	.word	0x08010533
 8010734:	08010533 	.word	0x08010533
 8010738:	08010533 	.word	0x08010533
 801073c:	08010533 	.word	0x08010533
 8010740:	08010533 	.word	0x08010533
 8010744:	08010533 	.word	0x08010533
 8010748:	08010533 	.word	0x08010533
 801074c:	08010533 	.word	0x08010533
 8010750:	08010533 	.word	0x08010533
 8010754:	08010533 	.word	0x08010533
 8010758:	0801094f 	.word	0x0801094f
  UART_GETCLOCKSOURCE(huart, clocksource);
 801075c:	4b1f      	ldr	r3, [pc, #124]	; (80107dc <UART_SetConfig+0x338>)
 801075e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010760:	f003 0307 	and.w	r3, r3, #7
 8010764:	2b05      	cmp	r3, #5
 8010766:	f63f aee4 	bhi.w	8010532 <UART_SetConfig+0x8e>
 801076a:	4a20      	ldr	r2, [pc, #128]	; (80107ec <UART_SetConfig+0x348>)
 801076c:	5cd3      	ldrb	r3, [r2, r3]
 801076e:	e6f1      	b.n	8010554 <UART_SetConfig+0xb0>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8010770:	4b1a      	ldr	r3, [pc, #104]	; (80107dc <UART_SetConfig+0x338>)
 8010772:	681a      	ldr	r2, [r3, #0]
 8010774:	0692      	lsls	r2, r2, #26
 8010776:	f140 80c1 	bpl.w	80108fc <UART_SetConfig+0x458>
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 801077a:	681b      	ldr	r3, [r3, #0]
 801077c:	481c      	ldr	r0, [pc, #112]	; (80107f0 <UART_SetConfig+0x34c>)
 801077e:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 8010782:	40d8      	lsrs	r0, r3
    if (pclk != 0U)
 8010784:	e03b      	b.n	80107fe <UART_SetConfig+0x35a>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8010786:	a803      	add	r0, sp, #12
 8010788:	f7fe ffc0 	bl	800f70c <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 801078c:	9804      	ldr	r0, [sp, #16]
    if (pclk != 0U)
 801078e:	b938      	cbnz	r0, 80107a0 <UART_SetConfig+0x2fc>
          pclk = (uint32_t) HSI_VALUE;
 8010790:	2000      	movs	r0, #0
 8010792:	e6cf      	b.n	8010534 <UART_SetConfig+0x90>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8010794:	4668      	mov	r0, sp
 8010796:	f7fe ff0d 	bl	800f5b4 <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 801079a:	9801      	ldr	r0, [sp, #4]
    if (pclk != 0U)
 801079c:	2800      	cmp	r0, #0
 801079e:	d0f7      	beq.n	8010790 <UART_SetConfig+0x2ec>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80107a0:	6a65      	ldr	r5, [r4, #36]	; 0x24
 80107a2:	e02c      	b.n	80107fe <UART_SetConfig+0x35a>
        pclk = HAL_RCC_GetPCLK2Freq();
 80107a4:	f7fe f844 	bl	800e830 <HAL_RCC_GetPCLK2Freq>
        break;
 80107a8:	e7f1      	b.n	801078e <UART_SetConfig+0x2ea>
        pclk = HAL_RCC_GetPCLK1Freq();
 80107aa:	f7fd fff9 	bl	800e7a0 <HAL_RCC_GetPCLK1Freq>
        break;
 80107ae:	e7ee      	b.n	801078e <UART_SetConfig+0x2ea>
 80107b0:	cfff69f3 	.word	0xcfff69f3
 80107b4:	58000c00 	.word	0x58000c00
 80107b8:	11fff4ff 	.word	0x11fff4ff
 80107bc:	40011000 	.word	0x40011000
 80107c0:	40004400 	.word	0x40004400
 80107c4:	40004800 	.word	0x40004800
 80107c8:	40004c00 	.word	0x40004c00
 80107cc:	40005000 	.word	0x40005000
 80107d0:	40011400 	.word	0x40011400
 80107d4:	40007800 	.word	0x40007800
 80107d8:	40007c00 	.word	0x40007c00
 80107dc:	58024400 	.word	0x58024400
 80107e0:	2400827c 	.word	0x2400827c
 80107e4:	240082a8 	.word	0x240082a8
 80107e8:	240082b0 	.word	0x240082b0
 80107ec:	240082a8 	.word	0x240082a8
 80107f0:	03d09000 	.word	0x03d09000
    switch (clocksource)
 80107f4:	2b40      	cmp	r3, #64	; 0x40
 80107f6:	f47f ae9c 	bne.w	8010532 <UART_SetConfig+0x8e>
 80107fa:	f44f 4000 	mov.w	r0, #32768	; 0x8000
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80107fe:	4b6c      	ldr	r3, [pc, #432]	; (80109b0 <UART_SetConfig+0x50c>)
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8010800:	f64f 71ef 	movw	r1, #65519	; 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8010804:	6862      	ldr	r2, [r4, #4]
 8010806:	f833 3015 	ldrh.w	r3, [r3, r5, lsl #1]
 801080a:	fbb0 f3f3 	udiv	r3, r0, r3
 801080e:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 8010812:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8010816:	f1a3 0210 	sub.w	r2, r3, #16
 801081a:	428a      	cmp	r2, r1
 801081c:	f63f ae89 	bhi.w	8010532 <UART_SetConfig+0x8e>
        huart->Instance->BRR = (uint16_t)usartdiv;
 8010820:	6822      	ldr	r2, [r4, #0]
 8010822:	2000      	movs	r0, #0
 8010824:	60d3      	str	r3, [r2, #12]
 8010826:	e685      	b.n	8010534 <UART_SetConfig+0x90>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8010828:	4b62      	ldr	r3, [pc, #392]	; (80109b4 <UART_SetConfig+0x510>)
 801082a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801082c:	f003 0307 	and.w	r3, r3, #7
 8010830:	2b05      	cmp	r3, #5
 8010832:	f63f ae7e 	bhi.w	8010532 <UART_SetConfig+0x8e>
 8010836:	4a60      	ldr	r2, [pc, #384]	; (80109b8 <UART_SetConfig+0x514>)
 8010838:	5cd3      	ldrb	r3, [r2, r3]
 801083a:	e68b      	b.n	8010554 <UART_SetConfig+0xb0>
    switch (clocksource)
 801083c:	2b40      	cmp	r3, #64	; 0x40
 801083e:	f47f ae78 	bne.w	8010532 <UART_SetConfig+0x8e>
 8010842:	f44f 4000 	mov.w	r0, #32768	; 0x8000
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8010846:	4b5a      	ldr	r3, [pc, #360]	; (80109b0 <UART_SetConfig+0x50c>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8010848:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 801084a:	f833 2011 	ldrh.w	r2, [r3, r1, lsl #1]
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 801084e:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8010852:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8010856:	4299      	cmp	r1, r3
 8010858:	f63f ae6b 	bhi.w	8010532 <UART_SetConfig+0x8e>
 801085c:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 8010860:	f63f ae67 	bhi.w	8010532 <UART_SetConfig+0x8e>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8010864:	2300      	movs	r3, #0
 8010866:	4619      	mov	r1, r3
 8010868:	f7f8 fc4a 	bl	8009100 <__aeabi_uldivmod>
 801086c:	462a      	mov	r2, r5
 801086e:	0209      	lsls	r1, r1, #8
 8010870:	0203      	lsls	r3, r0, #8
 8010872:	ea41 6110 	orr.w	r1, r1, r0, lsr #24
 8010876:	0868      	lsrs	r0, r5, #1
 8010878:	1818      	adds	r0, r3, r0
 801087a:	f04f 0300 	mov.w	r3, #0
 801087e:	f141 0100 	adc.w	r1, r1, #0
 8010882:	f7f8 fc3d 	bl	8009100 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8010886:	4a4d      	ldr	r2, [pc, #308]	; (80109bc <UART_SetConfig+0x518>)
 8010888:	f5a0 7140 	sub.w	r1, r0, #768	; 0x300
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 801088c:	4603      	mov	r3, r0
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 801088e:	4291      	cmp	r1, r2
 8010890:	f63f ae4f 	bhi.w	8010532 <UART_SetConfig+0x8e>
 8010894:	e7c4      	b.n	8010820 <UART_SetConfig+0x37c>
    switch (clocksource)
 8010896:	2b40      	cmp	r3, #64	; 0x40
 8010898:	f47f ae4b 	bne.w	8010532 <UART_SetConfig+0x8e>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 801089c:	4b44      	ldr	r3, [pc, #272]	; (80109b0 <UART_SetConfig+0x50c>)
 801089e:	6862      	ldr	r2, [r4, #4]
 80108a0:	f833 1015 	ldrh.w	r1, [r3, r5, lsl #1]
 80108a4:	0853      	lsrs	r3, r2, #1
 80108a6:	fbb0 f0f1 	udiv	r0, r0, r1
 80108aa:	eb03 0040 	add.w	r0, r3, r0, lsl #1
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80108ae:	f64f 73ef 	movw	r3, #65519	; 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80108b2:	fbb0 f0f2 	udiv	r0, r0, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80108b6:	f1a0 0210 	sub.w	r2, r0, #16
 80108ba:	429a      	cmp	r2, r3
 80108bc:	f63f ae39 	bhi.w	8010532 <UART_SetConfig+0x8e>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 80108c0:	f020 030f 	bic.w	r3, r0, #15
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 80108c4:	f3c0 0042 	ubfx	r0, r0, #1, #3
        huart->Instance->BRR = brrtemp;
 80108c8:	6822      	ldr	r2, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 80108ca:	b29b      	uxth	r3, r3
        huart->Instance->BRR = brrtemp;
 80108cc:	4303      	orrs	r3, r0
 80108ce:	2000      	movs	r0, #0
 80108d0:	60d3      	str	r3, [r2, #12]
 80108d2:	e62f      	b.n	8010534 <UART_SetConfig+0x90>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80108d4:	4b37      	ldr	r3, [pc, #220]	; (80109b4 <UART_SetConfig+0x510>)
 80108d6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80108d8:	f003 0307 	and.w	r3, r3, #7
 80108dc:	2b05      	cmp	r3, #5
 80108de:	f63f ae28 	bhi.w	8010532 <UART_SetConfig+0x8e>
 80108e2:	4a37      	ldr	r2, [pc, #220]	; (80109c0 <UART_SetConfig+0x51c>)
 80108e4:	5cd3      	ldrb	r3, [r2, r3]
 80108e6:	e635      	b.n	8010554 <UART_SetConfig+0xb0>
 80108e8:	4b32      	ldr	r3, [pc, #200]	; (80109b4 <UART_SetConfig+0x510>)
 80108ea:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80108ec:	f003 0338 	and.w	r3, r3, #56	; 0x38
 80108f0:	2b28      	cmp	r3, #40	; 0x28
 80108f2:	f63f ae1e 	bhi.w	8010532 <UART_SetConfig+0x8e>
 80108f6:	4a33      	ldr	r2, [pc, #204]	; (80109c4 <UART_SetConfig+0x520>)
 80108f8:	5cd3      	ldrb	r3, [r2, r3]
 80108fa:	e62b      	b.n	8010554 <UART_SetConfig+0xb0>
          pclk = (uint32_t) HSI_VALUE;
 80108fc:	4832      	ldr	r0, [pc, #200]	; (80109c8 <UART_SetConfig+0x524>)
 80108fe:	e77e      	b.n	80107fe <UART_SetConfig+0x35a>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8010900:	4b2c      	ldr	r3, [pc, #176]	; (80109b4 <UART_SetConfig+0x510>)
 8010902:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010904:	f003 0307 	and.w	r3, r3, #7
 8010908:	2b05      	cmp	r3, #5
 801090a:	f63f ae12 	bhi.w	8010532 <UART_SetConfig+0x8e>
 801090e:	4a2f      	ldr	r2, [pc, #188]	; (80109cc <UART_SetConfig+0x528>)
 8010910:	5cd3      	ldrb	r3, [r2, r3]
 8010912:	e61f      	b.n	8010554 <UART_SetConfig+0xb0>
        pclk = (uint32_t) CSI_VALUE;
 8010914:	482e      	ldr	r0, [pc, #184]	; (80109d0 <UART_SetConfig+0x52c>)
 8010916:	e772      	b.n	80107fe <UART_SetConfig+0x35a>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8010918:	4b26      	ldr	r3, [pc, #152]	; (80109b4 <UART_SetConfig+0x510>)
 801091a:	681a      	ldr	r2, [r3, #0]
 801091c:	0690      	lsls	r0, r2, #26
 801091e:	d542      	bpl.n	80109a6 <UART_SetConfig+0x502>
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 8010920:	681b      	ldr	r3, [r3, #0]
 8010922:	4829      	ldr	r0, [pc, #164]	; (80109c8 <UART_SetConfig+0x524>)
 8010924:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 8010928:	40d8      	lsrs	r0, r3
    if (pclk != 0U)
 801092a:	e78c      	b.n	8010846 <UART_SetConfig+0x3a2>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 801092c:	a803      	add	r0, sp, #12
 801092e:	f7fe feed 	bl	800f70c <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 8010932:	9804      	ldr	r0, [sp, #16]
    if (pclk != 0U)
 8010934:	2800      	cmp	r0, #0
 8010936:	f43f af2b 	beq.w	8010790 <UART_SetConfig+0x2ec>
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 801093a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 801093c:	e783      	b.n	8010846 <UART_SetConfig+0x3a2>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 801093e:	4668      	mov	r0, sp
 8010940:	f7fe fe38 	bl	800f5b4 <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 8010944:	9801      	ldr	r0, [sp, #4]
        break;
 8010946:	e7f5      	b.n	8010934 <UART_SetConfig+0x490>
        pclk = HAL_RCCEx_GetD3PCLK1Freq();
 8010948:	f7fe fe22 	bl	800f590 <HAL_RCCEx_GetD3PCLK1Freq>
        break;
 801094c:	e7f2      	b.n	8010934 <UART_SetConfig+0x490>
        pclk = (uint32_t) CSI_VALUE;
 801094e:	4820      	ldr	r0, [pc, #128]	; (80109d0 <UART_SetConfig+0x52c>)
 8010950:	e779      	b.n	8010846 <UART_SetConfig+0x3a2>
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8010952:	4b18      	ldr	r3, [pc, #96]	; (80109b4 <UART_SetConfig+0x510>)
 8010954:	681a      	ldr	r2, [r3, #0]
 8010956:	0691      	lsls	r1, r2, #26
 8010958:	d527      	bpl.n	80109aa <UART_SetConfig+0x506>
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 801095a:	681b      	ldr	r3, [r3, #0]
 801095c:	481a      	ldr	r0, [pc, #104]	; (80109c8 <UART_SetConfig+0x524>)
 801095e:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 8010962:	40d8      	lsrs	r0, r3
    if (pclk != 0U)
 8010964:	e79a      	b.n	801089c <UART_SetConfig+0x3f8>
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8010966:	a803      	add	r0, sp, #12
 8010968:	f7fe fed0 	bl	800f70c <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 801096c:	9804      	ldr	r0, [sp, #16]
    if (pclk != 0U)
 801096e:	2800      	cmp	r0, #0
 8010970:	f43f af0e 	beq.w	8010790 <UART_SetConfig+0x2ec>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8010974:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8010976:	e791      	b.n	801089c <UART_SetConfig+0x3f8>
        pclk = HAL_RCC_GetPCLK2Freq();
 8010978:	f7fd ff5a 	bl	800e830 <HAL_RCC_GetPCLK2Freq>
        break;
 801097c:	e7f7      	b.n	801096e <UART_SetConfig+0x4ca>
        pclk = HAL_RCC_GetPCLK1Freq();
 801097e:	f7fd ff0f 	bl	800e7a0 <HAL_RCC_GetPCLK1Freq>
        break;
 8010982:	e7f4      	b.n	801096e <UART_SetConfig+0x4ca>
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8010984:	4668      	mov	r0, sp
 8010986:	f7fe fe15 	bl	800f5b4 <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 801098a:	9801      	ldr	r0, [sp, #4]
        break;
 801098c:	e7ef      	b.n	801096e <UART_SetConfig+0x4ca>
        pclk = (uint32_t) CSI_VALUE;
 801098e:	4810      	ldr	r0, [pc, #64]	; (80109d0 <UART_SetConfig+0x52c>)
 8010990:	e784      	b.n	801089c <UART_SetConfig+0x3f8>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8010992:	4b08      	ldr	r3, [pc, #32]	; (80109b4 <UART_SetConfig+0x510>)
 8010994:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010996:	f003 0307 	and.w	r3, r3, #7
 801099a:	2b05      	cmp	r3, #5
 801099c:	f63f adc9 	bhi.w	8010532 <UART_SetConfig+0x8e>
 80109a0:	4a0c      	ldr	r2, [pc, #48]	; (80109d4 <UART_SetConfig+0x530>)
 80109a2:	5cd3      	ldrb	r3, [r2, r3]
 80109a4:	e5d6      	b.n	8010554 <UART_SetConfig+0xb0>
          pclk = (uint32_t) HSI_VALUE;
 80109a6:	4808      	ldr	r0, [pc, #32]	; (80109c8 <UART_SetConfig+0x524>)
 80109a8:	e74d      	b.n	8010846 <UART_SetConfig+0x3a2>
          pclk = (uint32_t) HSI_VALUE;
 80109aa:	4807      	ldr	r0, [pc, #28]	; (80109c8 <UART_SetConfig+0x524>)
 80109ac:	e776      	b.n	801089c <UART_SetConfig+0x3f8>
 80109ae:	bf00      	nop
 80109b0:	240082b8 	.word	0x240082b8
 80109b4:	58024400 	.word	0x58024400
 80109b8:	240082a8 	.word	0x240082a8
 80109bc:	000ffcff 	.word	0x000ffcff
 80109c0:	240082a8 	.word	0x240082a8
 80109c4:	2400827c 	.word	0x2400827c
 80109c8:	03d09000 	.word	0x03d09000
 80109cc:	240082a8 	.word	0x240082a8
 80109d0:	003d0900 	.word	0x003d0900
 80109d4:	240082a8 	.word	0x240082a8

080109d8 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80109d8:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80109da:	07da      	lsls	r2, r3, #31
{
 80109dc:	b410      	push	{r4}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80109de:	d506      	bpl.n	80109ee <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 80109e0:	6801      	ldr	r1, [r0, #0]
 80109e2:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 80109e4:	684a      	ldr	r2, [r1, #4]
 80109e6:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80109ea:	4322      	orrs	r2, r4
 80109ec:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 80109ee:	079c      	lsls	r4, r3, #30
 80109f0:	d506      	bpl.n	8010a00 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 80109f2:	6801      	ldr	r1, [r0, #0]
 80109f4:	6b04      	ldr	r4, [r0, #48]	; 0x30
 80109f6:	684a      	ldr	r2, [r1, #4]
 80109f8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80109fc:	4322      	orrs	r2, r4
 80109fe:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8010a00:	0759      	lsls	r1, r3, #29
 8010a02:	d506      	bpl.n	8010a12 <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8010a04:	6801      	ldr	r1, [r0, #0]
 8010a06:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8010a08:	684a      	ldr	r2, [r1, #4]
 8010a0a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8010a0e:	4322      	orrs	r2, r4
 8010a10:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8010a12:	071a      	lsls	r2, r3, #28
 8010a14:	d506      	bpl.n	8010a24 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8010a16:	6801      	ldr	r1, [r0, #0]
 8010a18:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8010a1a:	684a      	ldr	r2, [r1, #4]
 8010a1c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8010a20:	4322      	orrs	r2, r4
 8010a22:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8010a24:	06dc      	lsls	r4, r3, #27
 8010a26:	d506      	bpl.n	8010a36 <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8010a28:	6801      	ldr	r1, [r0, #0]
 8010a2a:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 8010a2c:	688a      	ldr	r2, [r1, #8]
 8010a2e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8010a32:	4322      	orrs	r2, r4
 8010a34:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8010a36:	0699      	lsls	r1, r3, #26
 8010a38:	d506      	bpl.n	8010a48 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8010a3a:	6801      	ldr	r1, [r0, #0]
 8010a3c:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8010a3e:	688a      	ldr	r2, [r1, #8]
 8010a40:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8010a44:	4322      	orrs	r2, r4
 8010a46:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8010a48:	065a      	lsls	r2, r3, #25
 8010a4a:	d50a      	bpl.n	8010a62 <UART_AdvFeatureConfig+0x8a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8010a4c:	6801      	ldr	r1, [r0, #0]
 8010a4e:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8010a50:	684a      	ldr	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8010a52:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8010a56:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 8010a5a:	ea42 0204 	orr.w	r2, r2, r4
 8010a5e:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8010a60:	d00b      	beq.n	8010a7a <UART_AdvFeatureConfig+0xa2>
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8010a62:	061b      	lsls	r3, r3, #24
 8010a64:	d506      	bpl.n	8010a74 <UART_AdvFeatureConfig+0x9c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8010a66:	6802      	ldr	r2, [r0, #0]
 8010a68:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 8010a6a:	6853      	ldr	r3, [r2, #4]
 8010a6c:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8010a70:	430b      	orrs	r3, r1
 8010a72:	6053      	str	r3, [r2, #4]
}
 8010a74:	f85d 4b04 	ldr.w	r4, [sp], #4
 8010a78:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8010a7a:	684a      	ldr	r2, [r1, #4]
 8010a7c:	6c84      	ldr	r4, [r0, #72]	; 0x48
 8010a7e:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 8010a82:	4322      	orrs	r2, r4
 8010a84:	604a      	str	r2, [r1, #4]
 8010a86:	e7ec      	b.n	8010a62 <UART_AdvFeatureConfig+0x8a>

08010a88 <UART_WaitOnFlagUntilTimeout>:
{
 8010a88:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8010a8c:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8010a90:	4607      	mov	r7, r0
 8010a92:	460e      	mov	r6, r1
 8010a94:	4615      	mov	r5, r2
 8010a96:	4699      	mov	r9, r3
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8010a98:	6804      	ldr	r4, [r0, #0]
 8010a9a:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
 8010a9e:	d10a      	bne.n	8010ab6 <UART_WaitOnFlagUntilTimeout+0x2e>
 8010aa0:	69e3      	ldr	r3, [r4, #28]
 8010aa2:	ea36 0303 	bics.w	r3, r6, r3
 8010aa6:	bf0c      	ite	eq
 8010aa8:	2301      	moveq	r3, #1
 8010aaa:	2300      	movne	r3, #0
 8010aac:	429d      	cmp	r5, r3
 8010aae:	d0f7      	beq.n	8010aa0 <UART_WaitOnFlagUntilTimeout+0x18>
  return HAL_OK;
 8010ab0:	2000      	movs	r0, #0
}
 8010ab2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8010ab6:	69e3      	ldr	r3, [r4, #28]
 8010ab8:	ea36 0303 	bics.w	r3, r6, r3
 8010abc:	bf0c      	ite	eq
 8010abe:	2301      	moveq	r3, #1
 8010ac0:	2300      	movne	r3, #0
 8010ac2:	42ab      	cmp	r3, r5
 8010ac4:	d1f4      	bne.n	8010ab0 <UART_WaitOnFlagUntilTimeout+0x28>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8010ac6:	f7fa f921 	bl	800ad0c <HAL_GetTick>
 8010aca:	eba0 0009 	sub.w	r0, r0, r9
 8010ace:	4540      	cmp	r0, r8
 8010ad0:	d833      	bhi.n	8010b3a <UART_WaitOnFlagUntilTimeout+0xb2>
 8010ad2:	f1b8 0f00 	cmp.w	r8, #0
 8010ad6:	d030      	beq.n	8010b3a <UART_WaitOnFlagUntilTimeout+0xb2>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 8010ad8:	683c      	ldr	r4, [r7, #0]
 8010ada:	6823      	ldr	r3, [r4, #0]
 8010adc:	4622      	mov	r2, r4
 8010ade:	0759      	lsls	r1, r3, #29
 8010ae0:	d5db      	bpl.n	8010a9a <UART_WaitOnFlagUntilTimeout+0x12>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 8010ae2:	69e3      	ldr	r3, [r4, #28]
 8010ae4:	051b      	lsls	r3, r3, #20
 8010ae6:	d5d8      	bpl.n	8010a9a <UART_WaitOnFlagUntilTimeout+0x12>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8010ae8:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8010aec:	6223      	str	r3, [r4, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010aee:	e854 3f00 	ldrex	r3, [r4]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 8010af2:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010af6:	e844 3100 	strex	r1, r3, [r4]
 8010afa:	b139      	cbz	r1, 8010b0c <UART_WaitOnFlagUntilTimeout+0x84>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010afc:	e852 3f00 	ldrex	r3, [r2]
 8010b00:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010b04:	e842 3100 	strex	r1, r3, [r2]
 8010b08:	2900      	cmp	r1, #0
 8010b0a:	d1f7      	bne.n	8010afc <UART_WaitOnFlagUntilTimeout+0x74>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010b0c:	f102 0308 	add.w	r3, r2, #8
 8010b10:	e853 3f00 	ldrex	r3, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8010b14:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010b18:	f102 0008 	add.w	r0, r2, #8
 8010b1c:	e840 3100 	strex	r1, r3, [r0]
 8010b20:	2900      	cmp	r1, #0
 8010b22:	d1f3      	bne.n	8010b0c <UART_WaitOnFlagUntilTimeout+0x84>
          huart->gState = HAL_UART_STATE_READY;
 8010b24:	2320      	movs	r3, #32
          return HAL_TIMEOUT;
 8010b26:	2003      	movs	r0, #3
          __HAL_UNLOCK(huart);
 8010b28:	f887 1080 	strb.w	r1, [r7, #128]	; 0x80
          huart->gState = HAL_UART_STATE_READY;
 8010b2c:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
          huart->RxState = HAL_UART_STATE_READY;
 8010b30:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8010b34:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
          return HAL_TIMEOUT;
 8010b38:	e7bb      	b.n	8010ab2 <UART_WaitOnFlagUntilTimeout+0x2a>
 8010b3a:	683a      	ldr	r2, [r7, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010b3c:	e852 3f00 	ldrex	r3, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 8010b40:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010b44:	e842 3100 	strex	r1, r3, [r2]
 8010b48:	2900      	cmp	r1, #0
 8010b4a:	d1f7      	bne.n	8010b3c <UART_WaitOnFlagUntilTimeout+0xb4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010b4c:	f102 0308 	add.w	r3, r2, #8
 8010b50:	e853 3f00 	ldrex	r3, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8010b54:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010b58:	f102 0008 	add.w	r0, r2, #8
 8010b5c:	e840 3100 	strex	r1, r3, [r0]
 8010b60:	2900      	cmp	r1, #0
 8010b62:	d1f3      	bne.n	8010b4c <UART_WaitOnFlagUntilTimeout+0xc4>
        huart->gState = HAL_UART_STATE_READY;
 8010b64:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
 8010b66:	2003      	movs	r0, #3
        __HAL_UNLOCK(huart);
 8010b68:	f887 1080 	strb.w	r1, [r7, #128]	; 0x80
        huart->gState = HAL_UART_STATE_READY;
 8010b6c:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
        huart->RxState = HAL_UART_STATE_READY;
 8010b70:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
        return HAL_TIMEOUT;
 8010b74:	e79d      	b.n	8010ab2 <UART_WaitOnFlagUntilTimeout+0x2a>
 8010b76:	bf00      	nop

08010b78 <HAL_UART_Transmit>:
{
 8010b78:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8010b7c:	461e      	mov	r6, r3
  if (huart->gState == HAL_UART_STATE_READY)
 8010b7e:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 8010b82:	b083      	sub	sp, #12
  if (huart->gState == HAL_UART_STATE_READY)
 8010b84:	2b20      	cmp	r3, #32
 8010b86:	f040 8095 	bne.w	8010cb4 <HAL_UART_Transmit+0x13c>
    if ((pData == NULL) || (Size == 0U))
 8010b8a:	4689      	mov	r9, r1
 8010b8c:	2900      	cmp	r1, #0
 8010b8e:	d04c      	beq.n	8010c2a <HAL_UART_Transmit+0xb2>
 8010b90:	fab2 f782 	clz	r7, r2
 8010b94:	4614      	mov	r4, r2
 8010b96:	097f      	lsrs	r7, r7, #5
 8010b98:	2a00      	cmp	r2, #0
 8010b9a:	d046      	beq.n	8010c2a <HAL_UART_Transmit+0xb2>
    __HAL_LOCK(huart);
 8010b9c:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8010ba0:	4605      	mov	r5, r0
 8010ba2:	2b01      	cmp	r3, #1
 8010ba4:	f000 8086 	beq.w	8010cb4 <HAL_UART_Transmit+0x13c>
 8010ba8:	2301      	movs	r3, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8010baa:	f8c0 708c 	str.w	r7, [r0, #140]	; 0x8c
    __HAL_LOCK(huart);
 8010bae:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8010bb2:	2321      	movs	r3, #33	; 0x21
 8010bb4:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    tickstart = HAL_GetTick();
 8010bb8:	f7fa f8a8 	bl	800ad0c <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8010bbc:	68ab      	ldr	r3, [r5, #8]
    tickstart = HAL_GetTick();
 8010bbe:	4680      	mov	r8, r0
    huart->TxXferSize  = Size;
 8010bc0:	f8a5 4054 	strh.w	r4, [r5, #84]	; 0x54
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8010bc4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->TxXferCount = Size;
 8010bc8:	f8a5 4056 	strh.w	r4, [r5, #86]	; 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8010bcc:	f000 8096 	beq.w	8010cfc <HAL_UART_Transmit+0x184>
    while (huart->TxXferCount > 0U)
 8010bd0:	f8b5 3056 	ldrh.w	r3, [r5, #86]	; 0x56
    __HAL_UNLOCK(huart);
 8010bd4:	2200      	movs	r2, #0
    while (huart->TxXferCount > 0U)
 8010bd6:	b29b      	uxth	r3, r3
    __HAL_UNLOCK(huart);
 8010bd8:	f885 2080 	strb.w	r2, [r5, #128]	; 0x80
    while (huart->TxXferCount > 0U)
 8010bdc:	b1b3      	cbz	r3, 8010c0c <HAL_UART_Transmit+0x94>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8010bde:	682c      	ldr	r4, [r5, #0]
 8010be0:	1c71      	adds	r1, r6, #1
 8010be2:	d126      	bne.n	8010c32 <HAL_UART_Transmit+0xba>
 8010be4:	69e2      	ldr	r2, [r4, #28]
 8010be6:	0612      	lsls	r2, r2, #24
 8010be8:	d5fc      	bpl.n	8010be4 <HAL_UART_Transmit+0x6c>
      if (pdata8bits == NULL)
 8010bea:	f1b9 0f00 	cmp.w	r9, #0
 8010bee:	d05c      	beq.n	8010caa <HAL_UART_Transmit+0x132>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8010bf0:	f819 3b01 	ldrb.w	r3, [r9], #1
 8010bf4:	62a3      	str	r3, [r4, #40]	; 0x28
      huart->TxXferCount--;
 8010bf6:	f8b5 3056 	ldrh.w	r3, [r5, #86]	; 0x56
 8010bfa:	3b01      	subs	r3, #1
 8010bfc:	b29b      	uxth	r3, r3
 8010bfe:	f8a5 3056 	strh.w	r3, [r5, #86]	; 0x56
    while (huart->TxXferCount > 0U)
 8010c02:	f8b5 3056 	ldrh.w	r3, [r5, #86]	; 0x56
 8010c06:	b29b      	uxth	r3, r3
 8010c08:	2b00      	cmp	r3, #0
 8010c0a:	d1e9      	bne.n	8010be0 <HAL_UART_Transmit+0x68>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8010c0c:	4643      	mov	r3, r8
 8010c0e:	2200      	movs	r2, #0
 8010c10:	2140      	movs	r1, #64	; 0x40
 8010c12:	4628      	mov	r0, r5
 8010c14:	9600      	str	r6, [sp, #0]
 8010c16:	f7ff ff37 	bl	8010a88 <UART_WaitOnFlagUntilTimeout>
 8010c1a:	2800      	cmp	r0, #0
 8010c1c:	d175      	bne.n	8010d0a <HAL_UART_Transmit+0x192>
    huart->gState = HAL_UART_STATE_READY;
 8010c1e:	2320      	movs	r3, #32
 8010c20:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
}
 8010c24:	b003      	add	sp, #12
 8010c26:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      return  HAL_ERROR;
 8010c2a:	2001      	movs	r0, #1
}
 8010c2c:	b003      	add	sp, #12
 8010c2e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8010c32:	69e3      	ldr	r3, [r4, #28]
 8010c34:	061b      	lsls	r3, r3, #24
 8010c36:	d4d8      	bmi.n	8010bea <HAL_UART_Transmit+0x72>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8010c38:	f7fa f868 	bl	800ad0c <HAL_GetTick>
 8010c3c:	eba0 0008 	sub.w	r0, r0, r8
 8010c40:	4286      	cmp	r6, r0
 8010c42:	d33b      	bcc.n	8010cbc <HAL_UART_Transmit+0x144>
 8010c44:	2e00      	cmp	r6, #0
 8010c46:	d039      	beq.n	8010cbc <HAL_UART_Transmit+0x144>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 8010c48:	682c      	ldr	r4, [r5, #0]
 8010c4a:	6822      	ldr	r2, [r4, #0]
 8010c4c:	4623      	mov	r3, r4
 8010c4e:	0752      	lsls	r2, r2, #29
 8010c50:	d5c6      	bpl.n	8010be0 <HAL_UART_Transmit+0x68>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 8010c52:	69e2      	ldr	r2, [r4, #28]
 8010c54:	0510      	lsls	r0, r2, #20
 8010c56:	d5c3      	bpl.n	8010be0 <HAL_UART_Transmit+0x68>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8010c58:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8010c5c:	6222      	str	r2, [r4, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010c5e:	e854 2f00 	ldrex	r2, [r4]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 8010c62:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010c66:	e844 2100 	strex	r1, r2, [r4]
 8010c6a:	b139      	cbz	r1, 8010c7c <HAL_UART_Transmit+0x104>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010c6c:	e853 2f00 	ldrex	r2, [r3]
 8010c70:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010c74:	e843 2100 	strex	r1, r2, [r3]
 8010c78:	2900      	cmp	r1, #0
 8010c7a:	d1f7      	bne.n	8010c6c <HAL_UART_Transmit+0xf4>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010c7c:	f103 0208 	add.w	r2, r3, #8
 8010c80:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8010c84:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010c88:	f103 0008 	add.w	r0, r3, #8
 8010c8c:	e840 2100 	strex	r1, r2, [r0]
 8010c90:	2900      	cmp	r1, #0
 8010c92:	d1f3      	bne.n	8010c7c <HAL_UART_Transmit+0x104>
          huart->gState = HAL_UART_STATE_READY;
 8010c94:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
 8010c96:	2003      	movs	r0, #3
          __HAL_UNLOCK(huart);
 8010c98:	f885 1080 	strb.w	r1, [r5, #128]	; 0x80
          huart->gState = HAL_UART_STATE_READY;
 8010c9c:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
          huart->RxState = HAL_UART_STATE_READY;
 8010ca0:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8010ca4:	f8c5 308c 	str.w	r3, [r5, #140]	; 0x8c
          return HAL_TIMEOUT;
 8010ca8:	e7c0      	b.n	8010c2c <HAL_UART_Transmit+0xb4>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8010caa:	f837 3b02 	ldrh.w	r3, [r7], #2
 8010cae:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8010cb2:	e79f      	b.n	8010bf4 <HAL_UART_Transmit+0x7c>
    return HAL_BUSY;
 8010cb4:	2002      	movs	r0, #2
}
 8010cb6:	b003      	add	sp, #12
 8010cb8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8010cbc:	682b      	ldr	r3, [r5, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010cbe:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 8010cc2:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010cc6:	e843 2100 	strex	r1, r2, [r3]
 8010cca:	2900      	cmp	r1, #0
 8010ccc:	d1f7      	bne.n	8010cbe <HAL_UART_Transmit+0x146>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010cce:	f103 0208 	add.w	r2, r3, #8
 8010cd2:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8010cd6:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010cda:	f103 0008 	add.w	r0, r3, #8
 8010cde:	e840 2100 	strex	r1, r2, [r0]
 8010ce2:	2900      	cmp	r1, #0
 8010ce4:	d1f3      	bne.n	8010cce <HAL_UART_Transmit+0x156>
        huart->gState = HAL_UART_STATE_READY;
 8010ce6:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
 8010ce8:	2003      	movs	r0, #3
        __HAL_UNLOCK(huart);
 8010cea:	f885 1080 	strb.w	r1, [r5, #128]	; 0x80
        huart->gState = HAL_UART_STATE_READY;
 8010cee:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
        huart->RxState = HAL_UART_STATE_READY;
 8010cf2:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
}
 8010cf6:	b003      	add	sp, #12
 8010cf8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8010cfc:	692b      	ldr	r3, [r5, #16]
 8010cfe:	2b00      	cmp	r3, #0
 8010d00:	f47f af66 	bne.w	8010bd0 <HAL_UART_Transmit+0x58>
 8010d04:	464f      	mov	r7, r9
      pdata8bits  = NULL;
 8010d06:	4699      	mov	r9, r3
 8010d08:	e762      	b.n	8010bd0 <HAL_UART_Transmit+0x58>
      return HAL_TIMEOUT;
 8010d0a:	2003      	movs	r0, #3
 8010d0c:	e78e      	b.n	8010c2c <HAL_UART_Transmit+0xb4>
 8010d0e:	bf00      	nop

08010d10 <HAL_UART_Init>:
  if (huart == NULL)
 8010d10:	2800      	cmp	r0, #0
 8010d12:	d066      	beq.n	8010de2 <HAL_UART_Init+0xd2>
  if (huart->gState == HAL_UART_STATE_RESET)
 8010d14:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 8010d18:	b570      	push	{r4, r5, r6, lr}
 8010d1a:	4604      	mov	r4, r0
 8010d1c:	b082      	sub	sp, #8
  if (huart->gState == HAL_UART_STATE_RESET)
 8010d1e:	2b00      	cmp	r3, #0
 8010d20:	d04c      	beq.n	8010dbc <HAL_UART_Init+0xac>
  __HAL_UART_DISABLE(huart);
 8010d22:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8010d24:	2324      	movs	r3, #36	; 0x24
  if (UART_SetConfig(huart) == HAL_ERROR)
 8010d26:	4620      	mov	r0, r4
  huart->gState = HAL_UART_STATE_BUSY;
 8010d28:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 8010d2c:	6813      	ldr	r3, [r2, #0]
 8010d2e:	f023 0301 	bic.w	r3, r3, #1
 8010d32:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 8010d34:	f7ff fbb6 	bl	80104a4 <UART_SetConfig>
 8010d38:	2801      	cmp	r0, #1
 8010d3a:	d03c      	beq.n	8010db6 <HAL_UART_Init+0xa6>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8010d3c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8010d3e:	2b00      	cmp	r3, #0
 8010d40:	d135      	bne.n	8010dae <HAL_UART_Init+0x9e>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8010d42:	6823      	ldr	r3, [r4, #0]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8010d44:	2500      	movs	r5, #0
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8010d46:	6859      	ldr	r1, [r3, #4]
 8010d48:	f421 4190 	bic.w	r1, r1, #18432	; 0x4800
 8010d4c:	6059      	str	r1, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8010d4e:	6899      	ldr	r1, [r3, #8]
 8010d50:	f021 012a 	bic.w	r1, r1, #42	; 0x2a
 8010d54:	6099      	str	r1, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8010d56:	6819      	ldr	r1, [r3, #0]
 8010d58:	f041 0101 	orr.w	r1, r1, #1
 8010d5c:	6019      	str	r1, [r3, #0]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8010d5e:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
  tickstart = HAL_GetTick();
 8010d62:	f7f9 ffd3 	bl	800ad0c <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8010d66:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 8010d68:	4606      	mov	r6, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8010d6a:	681a      	ldr	r2, [r3, #0]
 8010d6c:	0712      	lsls	r2, r2, #28
 8010d6e:	d40e      	bmi.n	8010d8e <HAL_UART_Init+0x7e>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8010d70:	681b      	ldr	r3, [r3, #0]
 8010d72:	075b      	lsls	r3, r3, #29
 8010d74:	d427      	bmi.n	8010dc6 <HAL_UART_Init+0xb6>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8010d76:	2300      	movs	r3, #0
  huart->gState = HAL_UART_STATE_READY;
 8010d78:	2220      	movs	r2, #32
  return HAL_OK;
 8010d7a:	4618      	mov	r0, r3
  huart->gState = HAL_UART_STATE_READY;
 8010d7c:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8010d80:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_READY;
 8010d84:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8010d88:	66e3      	str	r3, [r4, #108]	; 0x6c
}
 8010d8a:	b002      	add	sp, #8
 8010d8c:	bd70      	pop	{r4, r5, r6, pc}
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8010d8e:	f06f 417e 	mvn.w	r1, #4261412864	; 0xfe000000
 8010d92:	4603      	mov	r3, r0
 8010d94:	462a      	mov	r2, r5
 8010d96:	4620      	mov	r0, r4
 8010d98:	9100      	str	r1, [sp, #0]
 8010d9a:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8010d9e:	f7ff fe73 	bl	8010a88 <UART_WaitOnFlagUntilTimeout>
 8010da2:	b9e0      	cbnz	r0, 8010dde <HAL_UART_Init+0xce>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8010da4:	6823      	ldr	r3, [r4, #0]
 8010da6:	681b      	ldr	r3, [r3, #0]
 8010da8:	075b      	lsls	r3, r3, #29
 8010daa:	d40c      	bmi.n	8010dc6 <HAL_UART_Init+0xb6>
 8010dac:	e7e3      	b.n	8010d76 <HAL_UART_Init+0x66>
    UART_AdvFeatureConfig(huart);
 8010dae:	4620      	mov	r0, r4
 8010db0:	f7ff fe12 	bl	80109d8 <UART_AdvFeatureConfig>
 8010db4:	e7c5      	b.n	8010d42 <HAL_UART_Init+0x32>
    return HAL_ERROR;
 8010db6:	2001      	movs	r0, #1
}
 8010db8:	b002      	add	sp, #8
 8010dba:	bd70      	pop	{r4, r5, r6, pc}
    huart->Lock = HAL_UNLOCKED;
 8010dbc:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    HAL_UART_MspInit(huart);
 8010dc0:	f7f9 fcda 	bl	800a778 <HAL_UART_MspInit>
 8010dc4:	e7ad      	b.n	8010d22 <HAL_UART_Init+0x12>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8010dc6:	f06f 407e 	mvn.w	r0, #4261412864	; 0xfe000000
 8010dca:	4633      	mov	r3, r6
 8010dcc:	2200      	movs	r2, #0
 8010dce:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8010dd2:	9000      	str	r0, [sp, #0]
 8010dd4:	4620      	mov	r0, r4
 8010dd6:	f7ff fe57 	bl	8010a88 <UART_WaitOnFlagUntilTimeout>
 8010dda:	2800      	cmp	r0, #0
 8010ddc:	d0cb      	beq.n	8010d76 <HAL_UART_Init+0x66>
      return HAL_TIMEOUT;
 8010dde:	2003      	movs	r0, #3
 8010de0:	e7d3      	b.n	8010d8a <HAL_UART_Init+0x7a>
    return HAL_ERROR;
 8010de2:	2001      	movs	r0, #1
}
 8010de4:	4770      	bx	lr
 8010de6:	bf00      	nop

08010de8 <UART_Start_Receive_DMA>:
{
 8010de8:	b570      	push	{r4, r5, r6, lr}
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8010dea:	2322      	movs	r3, #34	; 0x22
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8010dec:	2500      	movs	r5, #0
{
 8010dee:	4604      	mov	r4, r0
  huart->pRxBuffPtr = pData;
 8010df0:	6581      	str	r1, [r0, #88]	; 0x58
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8010df2:	f8c0 508c 	str.w	r5, [r0, #140]	; 0x8c
  huart->RxXferSize = Size;
 8010df6:	f8a0 205c 	strh.w	r2, [r0, #92]	; 0x5c
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8010dfa:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  if (huart->hdmarx != NULL)
 8010dfe:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8010e00:	b168      	cbz	r0, 8010e1e <UART_Start_Receive_DMA+0x36>
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 8010e02:	4e20      	ldr	r6, [pc, #128]	; (8010e84 <UART_Start_Receive_DMA+0x9c>)
    if (HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size) != HAL_OK)
 8010e04:	4613      	mov	r3, r2
 8010e06:	460a      	mov	r2, r1
 8010e08:	6821      	ldr	r1, [r4, #0]
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 8010e0a:	63c6      	str	r6, [r0, #60]	; 0x3c
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 8010e0c:	4e1e      	ldr	r6, [pc, #120]	; (8010e88 <UART_Start_Receive_DMA+0xa0>)
    if (HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size) != HAL_OK)
 8010e0e:	3124      	adds	r1, #36	; 0x24
    huart->hdmarx->XferAbortCallback = NULL;
 8010e10:	6505      	str	r5, [r0, #80]	; 0x50
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 8010e12:	6406      	str	r6, [r0, #64]	; 0x40
    huart->hdmarx->XferErrorCallback = UART_DMAError;
 8010e14:	4e1d      	ldr	r6, [pc, #116]	; (8010e8c <UART_Start_Receive_DMA+0xa4>)
 8010e16:	64c6      	str	r6, [r0, #76]	; 0x4c
    if (HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size) != HAL_OK)
 8010e18:	f7fa fdca 	bl	800b9b0 <HAL_DMA_Start_IT>
 8010e1c:	bb40      	cbnz	r0, 8010e70 <UART_Start_Receive_DMA+0x88>
  __HAL_UNLOCK(huart);
 8010e1e:	2200      	movs	r2, #0
  if (huart->Init.Parity != UART_PARITY_NONE)
 8010e20:	6923      	ldr	r3, [r4, #16]
  __HAL_UNLOCK(huart);
 8010e22:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
  if (huart->Init.Parity != UART_PARITY_NONE)
 8010e26:	b14b      	cbz	r3, 8010e3c <UART_Start_Receive_DMA+0x54>
 8010e28:	6823      	ldr	r3, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010e2a:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8010e2e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010e32:	e843 2100 	strex	r1, r2, [r3]
 8010e36:	2900      	cmp	r1, #0
 8010e38:	d1f7      	bne.n	8010e2a <UART_Start_Receive_DMA+0x42>
 8010e3a:	e000      	b.n	8010e3e <UART_Start_Receive_DMA+0x56>
 8010e3c:	6823      	ldr	r3, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010e3e:	f103 0208 	add.w	r2, r3, #8
 8010e42:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8010e46:	f042 0201 	orr.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010e4a:	f103 0008 	add.w	r0, r3, #8
 8010e4e:	e840 2100 	strex	r1, r2, [r0]
 8010e52:	2900      	cmp	r1, #0
 8010e54:	d1f3      	bne.n	8010e3e <UART_Start_Receive_DMA+0x56>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010e56:	f103 0208 	add.w	r2, r3, #8
 8010e5a:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8010e5e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010e62:	f103 0108 	add.w	r1, r3, #8
 8010e66:	e841 2000 	strex	r0, r2, [r1]
 8010e6a:	2800      	cmp	r0, #0
 8010e6c:	d1f3      	bne.n	8010e56 <UART_Start_Receive_DMA+0x6e>
}
 8010e6e:	bd70      	pop	{r4, r5, r6, pc}
      huart->ErrorCode = HAL_UART_ERROR_DMA;
 8010e70:	2210      	movs	r2, #16
      huart->RxState = HAL_UART_STATE_READY;
 8010e72:	2320      	movs	r3, #32
      return HAL_ERROR;
 8010e74:	2001      	movs	r0, #1
      __HAL_UNLOCK(huart);
 8010e76:	f884 5080 	strb.w	r5, [r4, #128]	; 0x80
      huart->ErrorCode = HAL_UART_ERROR_DMA;
 8010e7a:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
      huart->RxState = HAL_UART_STATE_READY;
 8010e7e:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
}
 8010e82:	bd70      	pop	{r4, r5, r6, pc}
 8010e84:	0801040d 	.word	0x0801040d
 8010e88:	080103f1 	.word	0x080103f1
 8010e8c:	0800ff99 	.word	0x0800ff99

08010e90 <HAL_UARTEx_WakeupCallback>:
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
 8010e90:	4770      	bx	lr
 8010e92:	bf00      	nop

08010e94 <HAL_UARTEx_RxFifoFullCallback>:
 8010e94:	4770      	bx	lr
 8010e96:	bf00      	nop

08010e98 <HAL_UARTEx_TxFifoEmptyCallback>:
 8010e98:	4770      	bx	lr
 8010e9a:	bf00      	nop

08010e9c <HAL_UARTEx_EnableFifoMode>:

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
 8010e9c:	f890 2080 	ldrb.w	r2, [r0, #128]	; 0x80
 8010ea0:	2a01      	cmp	r2, #1
 8010ea2:	d02f      	beq.n	8010f04 <HAL_UARTEx_EnableFifoMode+0x68>

  huart->gState = HAL_UART_STATE_BUSY;

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8010ea4:	6802      	ldr	r2, [r0, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8010ea6:	2124      	movs	r1, #36	; 0x24
 8010ea8:	4603      	mov	r3, r0
{
 8010eaa:	b430      	push	{r4, r5}
  huart->gState = HAL_UART_STATE_BUSY;
 8010eac:	f8c0 1084 	str.w	r1, [r0, #132]	; 0x84
  /* Disable UART */
  __HAL_UART_DISABLE(huart);

  /* Enable FIFO mode */
  SET_BIT(tmpcr1, USART_CR1_FIFOEN);
  huart->FifoMode = UART_FIFOMODE_ENABLE;
 8010eb0:	f04f 5400 	mov.w	r4, #536870912	; 0x20000000
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8010eb4:	6811      	ldr	r1, [r2, #0]
  __HAL_UART_DISABLE(huart);
 8010eb6:	6810      	ldr	r0, [r2, #0]
  SET_BIT(tmpcr1, USART_CR1_FIFOEN);
 8010eb8:	4321      	orrs	r1, r4
  {
    rx_fifo_depth = RX_FIFO_DEPTH;
    tx_fifo_depth = TX_FIFO_DEPTH;
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8010eba:	4d13      	ldr	r5, [pc, #76]	; (8010f08 <HAL_UARTEx_EnableFifoMode+0x6c>)
  __HAL_UART_DISABLE(huart);
 8010ebc:	f020 0001 	bic.w	r0, r0, #1
 8010ec0:	6010      	str	r0, [r2, #0]
  huart->FifoMode = UART_FIFOMODE_ENABLE;
 8010ec2:	665c      	str	r4, [r3, #100]	; 0x64
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8010ec4:	6011      	str	r1, [r2, #0]
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 8010ec6:	6890      	ldr	r0, [r2, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8010ec8:	6892      	ldr	r2, [r2, #8]
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8010eca:	f3c0 6042 	ubfx	r0, r0, #25, #3
                               (uint16_t)denominator[tx_fifo_threshold];
 8010ece:	4c0f      	ldr	r4, [pc, #60]	; (8010f0c <HAL_UARTEx_EnableFifoMode+0x70>)
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8010ed0:	ea4f 7c52 	mov.w	ip, r2, lsr #29
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8010ed4:	5c2a      	ldrb	r2, [r5, r0]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8010ed6:	f815 100c 	ldrb.w	r1, [r5, ip]
                               (uint16_t)denominator[rx_fifo_threshold];
 8010eda:	5c20      	ldrb	r0, [r4, r0]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8010edc:	0112      	lsls	r2, r2, #4
                               (uint16_t)denominator[tx_fifo_threshold];
 8010ede:	f814 500c 	ldrb.w	r5, [r4, ip]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8010ee2:	0109      	lsls	r1, r1, #4
  huart->gState = HAL_UART_STATE_READY;
 8010ee4:	2420      	movs	r4, #32
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8010ee6:	fbb1 f1f5 	udiv	r1, r1, r5
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8010eea:	fbb2 f2f0 	udiv	r2, r2, r0
  __HAL_UNLOCK(huart);
 8010eee:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 8010ef0:	f8c3 4084 	str.w	r4, [r3, #132]	; 0x84
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8010ef4:	f8a3 106a 	strh.w	r1, [r3, #106]	; 0x6a
  __HAL_UNLOCK(huart);
 8010ef8:	f883 0080 	strb.w	r0, [r3, #128]	; 0x80
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8010efc:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
}
 8010f00:	bc30      	pop	{r4, r5}
 8010f02:	4770      	bx	lr
  __HAL_LOCK(huart);
 8010f04:	2002      	movs	r0, #2
}
 8010f06:	4770      	bx	lr
 8010f08:	240082d8 	.word	0x240082d8
 8010f0c:	240082d0 	.word	0x240082d0

08010f10 <HAL_UARTEx_DisableFifoMode>:
  __HAL_LOCK(huart);
 8010f10:	f890 2080 	ldrb.w	r2, [r0, #128]	; 0x80
 8010f14:	2a01      	cmp	r2, #1
 8010f16:	d017      	beq.n	8010f48 <HAL_UARTEx_DisableFifoMode+0x38>
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8010f18:	6802      	ldr	r2, [r0, #0]
 8010f1a:	4603      	mov	r3, r0
  huart->gState = HAL_UART_STATE_BUSY;
 8010f1c:	2024      	movs	r0, #36	; 0x24
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 8010f1e:	2100      	movs	r1, #0
{
 8010f20:	b430      	push	{r4, r5}
  huart->gState = HAL_UART_STATE_BUSY;
 8010f22:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
  huart->gState = HAL_UART_STATE_READY;
 8010f26:	2520      	movs	r5, #32
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8010f28:	6810      	ldr	r0, [r2, #0]
  __HAL_UART_DISABLE(huart);
 8010f2a:	6814      	ldr	r4, [r2, #0]
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
 8010f2c:	f020 5000 	bic.w	r0, r0, #536870912	; 0x20000000
  __HAL_UART_DISABLE(huart);
 8010f30:	f024 0401 	bic.w	r4, r4, #1
 8010f34:	6014      	str	r4, [r2, #0]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 8010f36:	6659      	str	r1, [r3, #100]	; 0x64
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8010f38:	6010      	str	r0, [r2, #0]
  return HAL_OK;
 8010f3a:	4608      	mov	r0, r1
  huart->gState = HAL_UART_STATE_READY;
 8010f3c:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8010f40:	f883 1080 	strb.w	r1, [r3, #128]	; 0x80
}
 8010f44:	bc30      	pop	{r4, r5}
 8010f46:	4770      	bx	lr
  __HAL_LOCK(huart);
 8010f48:	2002      	movs	r0, #2
}
 8010f4a:	4770      	bx	lr

08010f4c <HAL_UARTEx_SetTxFifoThreshold>:
  __HAL_LOCK(huart);
 8010f4c:	f890 2080 	ldrb.w	r2, [r0, #128]	; 0x80
 8010f50:	2a01      	cmp	r2, #1
 8010f52:	d037      	beq.n	8010fc4 <HAL_UARTEx_SetTxFifoThreshold+0x78>
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8010f54:	6802      	ldr	r2, [r0, #0]
 8010f56:	4603      	mov	r3, r0
  huart->gState = HAL_UART_STATE_BUSY;
 8010f58:	2024      	movs	r0, #36	; 0x24
{
 8010f5a:	b530      	push	{r4, r5, lr}
  huart->gState = HAL_UART_STATE_BUSY;
 8010f5c:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8010f60:	6814      	ldr	r4, [r2, #0]
  __HAL_UART_DISABLE(huart);
 8010f62:	6810      	ldr	r0, [r2, #0]
 8010f64:	f020 0001 	bic.w	r0, r0, #1
 8010f68:	6010      	str	r0, [r2, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 8010f6a:	6890      	ldr	r0, [r2, #8]
 8010f6c:	f020 4060 	bic.w	r0, r0, #3758096384	; 0xe0000000
 8010f70:	4301      	orrs	r1, r0
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8010f72:	6e58      	ldr	r0, [r3, #100]	; 0x64
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 8010f74:	6091      	str	r1, [r2, #8]
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8010f76:	b310      	cbz	r0, 8010fbe <HAL_UARTEx_SetTxFifoThreshold+0x72>
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 8010f78:	6891      	ldr	r1, [r2, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8010f7a:	6890      	ldr	r0, [r2, #8]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8010f7c:	f3c1 6c42 	ubfx	ip, r1, #25, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8010f80:	4911      	ldr	r1, [pc, #68]	; (8010fc8 <HAL_UARTEx_SetTxFifoThreshold+0x7c>)
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8010f82:	ea4f 7e50 	mov.w	lr, r0, lsr #29
                               (uint16_t)denominator[tx_fifo_threshold];
 8010f86:	4d11      	ldr	r5, [pc, #68]	; (8010fcc <HAL_UARTEx_SetTxFifoThreshold+0x80>)
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8010f88:	f811 000e 	ldrb.w	r0, [r1, lr]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8010f8c:	f811 100c 	ldrb.w	r1, [r1, ip]
                               (uint16_t)denominator[tx_fifo_threshold];
 8010f90:	f815 e00e 	ldrb.w	lr, [r5, lr]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8010f94:	0100      	lsls	r0, r0, #4
                               (uint16_t)denominator[rx_fifo_threshold];
 8010f96:	f815 500c 	ldrb.w	r5, [r5, ip]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8010f9a:	0109      	lsls	r1, r1, #4
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8010f9c:	fbb0 f0fe 	udiv	r0, r0, lr
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8010fa0:	fbb1 f1f5 	udiv	r1, r1, r5
 8010fa4:	f8a3 1068 	strh.w	r1, [r3, #104]	; 0x68
  huart->gState = HAL_UART_STATE_READY;
 8010fa8:	2520      	movs	r5, #32
  __HAL_UNLOCK(huart);
 8010faa:	2100      	movs	r1, #0
 8010fac:	f8a3 006a 	strh.w	r0, [r3, #106]	; 0x6a
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8010fb0:	6014      	str	r4, [r2, #0]
  return HAL_OK;
 8010fb2:	4608      	mov	r0, r1
  huart->gState = HAL_UART_STATE_READY;
 8010fb4:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8010fb8:	f883 1080 	strb.w	r1, [r3, #128]	; 0x80
}
 8010fbc:	bd30      	pop	{r4, r5, pc}
    huart->NbRxDataToProcess = 1U;
 8010fbe:	2101      	movs	r1, #1
    huart->NbTxDataToProcess = 1U;
 8010fc0:	4608      	mov	r0, r1
 8010fc2:	e7ef      	b.n	8010fa4 <HAL_UARTEx_SetTxFifoThreshold+0x58>
  __HAL_LOCK(huart);
 8010fc4:	2002      	movs	r0, #2
}
 8010fc6:	4770      	bx	lr
 8010fc8:	240082d8 	.word	0x240082d8
 8010fcc:	240082d0 	.word	0x240082d0

08010fd0 <HAL_UARTEx_SetRxFifoThreshold>:
  __HAL_LOCK(huart);
 8010fd0:	f890 2080 	ldrb.w	r2, [r0, #128]	; 0x80
 8010fd4:	2a01      	cmp	r2, #1
 8010fd6:	d037      	beq.n	8011048 <HAL_UARTEx_SetRxFifoThreshold+0x78>
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8010fd8:	6802      	ldr	r2, [r0, #0]
 8010fda:	4603      	mov	r3, r0
  huart->gState = HAL_UART_STATE_BUSY;
 8010fdc:	2024      	movs	r0, #36	; 0x24
{
 8010fde:	b530      	push	{r4, r5, lr}
  huart->gState = HAL_UART_STATE_BUSY;
 8010fe0:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8010fe4:	6814      	ldr	r4, [r2, #0]
  __HAL_UART_DISABLE(huart);
 8010fe6:	6810      	ldr	r0, [r2, #0]
 8010fe8:	f020 0001 	bic.w	r0, r0, #1
 8010fec:	6010      	str	r0, [r2, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8010fee:	6890      	ldr	r0, [r2, #8]
 8010ff0:	f020 6060 	bic.w	r0, r0, #234881024	; 0xe000000
 8010ff4:	4301      	orrs	r1, r0
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8010ff6:	6e58      	ldr	r0, [r3, #100]	; 0x64
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8010ff8:	6091      	str	r1, [r2, #8]
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8010ffa:	b310      	cbz	r0, 8011042 <HAL_UARTEx_SetRxFifoThreshold+0x72>
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 8010ffc:	6891      	ldr	r1, [r2, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8010ffe:	6890      	ldr	r0, [r2, #8]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8011000:	f3c1 6c42 	ubfx	ip, r1, #25, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8011004:	4911      	ldr	r1, [pc, #68]	; (801104c <HAL_UARTEx_SetRxFifoThreshold+0x7c>)
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8011006:	ea4f 7e50 	mov.w	lr, r0, lsr #29
                               (uint16_t)denominator[tx_fifo_threshold];
 801100a:	4d11      	ldr	r5, [pc, #68]	; (8011050 <HAL_UARTEx_SetRxFifoThreshold+0x80>)
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 801100c:	f811 000e 	ldrb.w	r0, [r1, lr]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8011010:	f811 100c 	ldrb.w	r1, [r1, ip]
                               (uint16_t)denominator[tx_fifo_threshold];
 8011014:	f815 e00e 	ldrb.w	lr, [r5, lr]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8011018:	0100      	lsls	r0, r0, #4
                               (uint16_t)denominator[rx_fifo_threshold];
 801101a:	f815 500c 	ldrb.w	r5, [r5, ip]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 801101e:	0109      	lsls	r1, r1, #4
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8011020:	fbb0 f0fe 	udiv	r0, r0, lr
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8011024:	fbb1 f1f5 	udiv	r1, r1, r5
 8011028:	f8a3 1068 	strh.w	r1, [r3, #104]	; 0x68
  huart->gState = HAL_UART_STATE_READY;
 801102c:	2520      	movs	r5, #32
  __HAL_UNLOCK(huart);
 801102e:	2100      	movs	r1, #0
 8011030:	f8a3 006a 	strh.w	r0, [r3, #106]	; 0x6a
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8011034:	6014      	str	r4, [r2, #0]
  return HAL_OK;
 8011036:	4608      	mov	r0, r1
  huart->gState = HAL_UART_STATE_READY;
 8011038:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
  __HAL_UNLOCK(huart);
 801103c:	f883 1080 	strb.w	r1, [r3, #128]	; 0x80
}
 8011040:	bd30      	pop	{r4, r5, pc}
    huart->NbRxDataToProcess = 1U;
 8011042:	2101      	movs	r1, #1
    huart->NbTxDataToProcess = 1U;
 8011044:	4608      	mov	r0, r1
 8011046:	e7ef      	b.n	8011028 <HAL_UARTEx_SetRxFifoThreshold+0x58>
  __HAL_LOCK(huart);
 8011048:	2002      	movs	r0, #2
}
 801104a:	4770      	bx	lr
 801104c:	240082d8 	.word	0x240082d8
 8011050:	240082d0 	.word	0x240082d0

08011054 <HAL_UARTEx_ReceiveToIdle_DMA>:
{
 8011054:	b570      	push	{r4, r5, r6, lr}
  if (huart->RxState == HAL_UART_STATE_READY)
 8011056:	f8d0 6088 	ldr.w	r6, [r0, #136]	; 0x88
 801105a:	2e20      	cmp	r6, #32
 801105c:	d112      	bne.n	8011084 <HAL_UARTEx_ReceiveToIdle_DMA+0x30>
    if ((pData == NULL) || (Size == 0U))
 801105e:	b179      	cbz	r1, 8011080 <HAL_UARTEx_ReceiveToIdle_DMA+0x2c>
 8011060:	b172      	cbz	r2, 8011080 <HAL_UARTEx_ReceiveToIdle_DMA+0x2c>
    __HAL_LOCK(huart);
 8011062:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8011066:	4604      	mov	r4, r0
 8011068:	2b01      	cmp	r3, #1
 801106a:	d00b      	beq.n	8011084 <HAL_UARTEx_ReceiveToIdle_DMA+0x30>
 801106c:	2301      	movs	r3, #1
 801106e:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->ReceptionType = HAL_UART_RECEPTION_TOIDLE;
 8011072:	66c3      	str	r3, [r0, #108]	; 0x6c
    status =  UART_Start_Receive_DMA(huart, pData, Size);
 8011074:	f7ff feb8 	bl	8010de8 <UART_Start_Receive_DMA>
    if (status == HAL_OK)
 8011078:	b918      	cbnz	r0, 8011082 <HAL_UARTEx_ReceiveToIdle_DMA+0x2e>
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 801107a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 801107c:	2b01      	cmp	r3, #1
 801107e:	d003      	beq.n	8011088 <HAL_UARTEx_ReceiveToIdle_DMA+0x34>
      return HAL_ERROR;
 8011080:	2001      	movs	r0, #1
}
 8011082:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
 8011084:	2002      	movs	r0, #2
}
 8011086:	bd70      	pop	{r4, r5, r6, pc}
        __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8011088:	6822      	ldr	r2, [r4, #0]
 801108a:	2310      	movs	r3, #16
 801108c:	6213      	str	r3, [r2, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801108e:	e852 3f00 	ldrex	r3, [r2]
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8011092:	f043 0310 	orr.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8011096:	e842 3100 	strex	r1, r3, [r2]
 801109a:	2900      	cmp	r1, #0
 801109c:	d1f7      	bne.n	801108e <HAL_UARTEx_ReceiveToIdle_DMA+0x3a>
}
 801109e:	bd70      	pop	{r4, r5, r6, pc}

080110a0 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 80110a0:	b084      	sub	sp, #16
 80110a2:	4684      	mov	ip, r0
 80110a4:	b500      	push	{lr}
 80110a6:	b083      	sub	sp, #12
 80110a8:	f10d 0e14 	add.w	lr, sp, #20
 80110ac:	e88e 000e 	stmia.w	lr, {r1, r2, r3}
  HAL_StatusTypeDef ret;
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80110b0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80110b2:	2b01      	cmp	r3, #1
 80110b4:	d13e      	bne.n	8011134 <USB_CoreInit+0x94>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80110b6:	6b82      	ldr	r2, [r0, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 80110b8:	f1a3 1342 	sub.w	r3, r3, #4325442	; 0x420042

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
    if (cfg.use_external_vbus == 1U)
 80110bc:	9911      	ldr	r1, [sp, #68]	; 0x44
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80110be:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
    if (cfg.use_external_vbus == 1U)
 80110c2:	2901      	cmp	r1, #1
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80110c4:	6382      	str	r2, [r0, #56]	; 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 80110c6:	68c2      	ldr	r2, [r0, #12]
 80110c8:	ea03 0302 	and.w	r3, r3, r2
 80110cc:	60c3      	str	r3, [r0, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 80110ce:	68c3      	ldr	r3, [r0, #12]
 80110d0:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 80110d4:	60c3      	str	r3, [r0, #12]
    if (cfg.use_external_vbus == 1U)
 80110d6:	d07c      	beq.n	80111d2 <USB_CoreInit+0x132>
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
  __IO uint32_t count = 0U;
 80110d8:	2300      	movs	r3, #0
  /* Wait for AHB master IDLE state. */
  do
  {
    count++;

    if (count > 200000U)
 80110da:	4a40      	ldr	r2, [pc, #256]	; (80111dc <USB_CoreInit+0x13c>)
  __IO uint32_t count = 0U;
 80110dc:	9300      	str	r3, [sp, #0]
 80110de:	e003      	b.n	80110e8 <USB_CoreInit+0x48>
    {
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80110e0:	f8dc 3010 	ldr.w	r3, [ip, #16]
 80110e4:	2b00      	cmp	r3, #0
 80110e6:	db41      	blt.n	801116c <USB_CoreInit+0xcc>
    count++;
 80110e8:	9b00      	ldr	r3, [sp, #0]
 80110ea:	3301      	adds	r3, #1
 80110ec:	9300      	str	r3, [sp, #0]
    if (count > 200000U)
 80110ee:	9b00      	ldr	r3, [sp, #0]
 80110f0:	4293      	cmp	r3, r2
 80110f2:	d9f5      	bls.n	80110e0 <USB_CoreInit+0x40>
      return HAL_TIMEOUT;
 80110f4:	2003      	movs	r0, #3
  if (cfg.dma_enable == 1U)
 80110f6:	9b08      	ldr	r3, [sp, #32]
 80110f8:	2b01      	cmp	r3, #1
 80110fa:	d116      	bne.n	801112a <USB_CoreInit+0x8a>
    USBx->GDFIFOCFG &= ~(0xFFFFU << 16);
 80110fc:	f8dc 205c 	ldr.w	r2, [ip, #92]	; 0x5c
    USBx->GDFIFOCFG |= 0x3EEU << 16;
 8011100:	4b37      	ldr	r3, [pc, #220]	; (80111e0 <USB_CoreInit+0x140>)
    USBx->GDFIFOCFG &= ~(0xFFFFU << 16);
 8011102:	b292      	uxth	r2, r2
 8011104:	f8cc 205c 	str.w	r2, [ip, #92]	; 0x5c
    USBx->GDFIFOCFG |= 0x3EEU << 16;
 8011108:	f8dc 205c 	ldr.w	r2, [ip, #92]	; 0x5c
 801110c:	4313      	orrs	r3, r2
 801110e:	f8cc 305c 	str.w	r3, [ip, #92]	; 0x5c
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 8011112:	f8dc 3008 	ldr.w	r3, [ip, #8]
 8011116:	f043 0306 	orr.w	r3, r3, #6
 801111a:	f8cc 3008 	str.w	r3, [ip, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 801111e:	f8dc 3008 	ldr.w	r3, [ip, #8]
 8011122:	f043 0320 	orr.w	r3, r3, #32
 8011126:	f8cc 3008 	str.w	r3, [ip, #8]
}
 801112a:	b003      	add	sp, #12
 801112c:	f85d eb04 	ldr.w	lr, [sp], #4
 8011130:	b004      	add	sp, #16
 8011132:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8011134:	68c3      	ldr	r3, [r0, #12]
  __IO uint32_t count = 0U;
 8011136:	2100      	movs	r1, #0
    if (count > 200000U)
 8011138:	4a28      	ldr	r2, [pc, #160]	; (80111dc <USB_CoreInit+0x13c>)
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 801113a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801113e:	60c3      	str	r3, [r0, #12]
  __IO uint32_t count = 0U;
 8011140:	9101      	str	r1, [sp, #4]
 8011142:	e003      	b.n	801114c <USB_CoreInit+0xac>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8011144:	f8dc 3010 	ldr.w	r3, [ip, #16]
 8011148:	2b00      	cmp	r3, #0
 801114a:	db2c      	blt.n	80111a6 <USB_CoreInit+0x106>
    count++;
 801114c:	9b01      	ldr	r3, [sp, #4]
 801114e:	3301      	adds	r3, #1
 8011150:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8011152:	9b01      	ldr	r3, [sp, #4]
 8011154:	4293      	cmp	r3, r2
 8011156:	d9f5      	bls.n	8011144 <USB_CoreInit+0xa4>
      return HAL_TIMEOUT;
 8011158:	2003      	movs	r0, #3
    if (cfg.battery_charging_enable == 0U)
 801115a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801115c:	b9e3      	cbnz	r3, 8011198 <USB_CoreInit+0xf8>
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 801115e:	f8dc 3038 	ldr.w	r3, [ip, #56]	; 0x38
 8011162:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8011166:	f8cc 3038 	str.w	r3, [ip, #56]	; 0x38
 801116a:	e7c4      	b.n	80110f6 <USB_CoreInit+0x56>

  /* Core Soft Reset */
  count = 0U;
 801116c:	2300      	movs	r3, #0

  do
  {
    count++;

    if (count > 200000U)
 801116e:	4a1b      	ldr	r2, [pc, #108]	; (80111dc <USB_CoreInit+0x13c>)
  count = 0U;
 8011170:	9300      	str	r3, [sp, #0]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8011172:	f8dc 3010 	ldr.w	r3, [ip, #16]
 8011176:	f043 0301 	orr.w	r3, r3, #1
 801117a:	f8cc 3010 	str.w	r3, [ip, #16]
 801117e:	e004      	b.n	801118a <USB_CoreInit+0xea>
    {
      return HAL_TIMEOUT;
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 8011180:	f8dc 0010 	ldr.w	r0, [ip, #16]
 8011184:	f010 0001 	ands.w	r0, r0, #1
 8011188:	d0b5      	beq.n	80110f6 <USB_CoreInit+0x56>
    count++;
 801118a:	9b00      	ldr	r3, [sp, #0]
 801118c:	3301      	adds	r3, #1
 801118e:	9300      	str	r3, [sp, #0]
    if (count > 200000U)
 8011190:	9b00      	ldr	r3, [sp, #0]
 8011192:	4293      	cmp	r3, r2
 8011194:	d9f4      	bls.n	8011180 <USB_CoreInit+0xe0>
 8011196:	e7ad      	b.n	80110f4 <USB_CoreInit+0x54>
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8011198:	f8dc 3038 	ldr.w	r3, [ip, #56]	; 0x38
 801119c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80111a0:	f8cc 3038 	str.w	r3, [ip, #56]	; 0x38
 80111a4:	e7a7      	b.n	80110f6 <USB_CoreInit+0x56>
  count = 0U;
 80111a6:	2300      	movs	r3, #0
    if (count > 200000U)
 80111a8:	4a0c      	ldr	r2, [pc, #48]	; (80111dc <USB_CoreInit+0x13c>)
  count = 0U;
 80111aa:	9301      	str	r3, [sp, #4]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 80111ac:	f8dc 3010 	ldr.w	r3, [ip, #16]
 80111b0:	f043 0301 	orr.w	r3, r3, #1
 80111b4:	f8cc 3010 	str.w	r3, [ip, #16]
 80111b8:	e004      	b.n	80111c4 <USB_CoreInit+0x124>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 80111ba:	f8dc 0010 	ldr.w	r0, [ip, #16]
 80111be:	f010 0001 	ands.w	r0, r0, #1
 80111c2:	d0ca      	beq.n	801115a <USB_CoreInit+0xba>
    count++;
 80111c4:	9b01      	ldr	r3, [sp, #4]
 80111c6:	3301      	adds	r3, #1
 80111c8:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 80111ca:	9b01      	ldr	r3, [sp, #4]
 80111cc:	4293      	cmp	r3, r2
 80111ce:	d9f4      	bls.n	80111ba <USB_CoreInit+0x11a>
 80111d0:	e7c2      	b.n	8011158 <USB_CoreInit+0xb8>
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 80111d2:	68c3      	ldr	r3, [r0, #12]
 80111d4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80111d8:	60c3      	str	r3, [r0, #12]
 80111da:	e77d      	b.n	80110d8 <USB_CoreInit+0x38>
 80111dc:	00030d40 	.word	0x00030d40
 80111e0:	03ee0000 	.word	0x03ee0000

080111e4 <USB_SetTurnaroundTime>:
  if (speed == USBD_FS_SPEED)
 80111e4:	2a02      	cmp	r2, #2
{
 80111e6:	4603      	mov	r3, r0
  if (speed == USBD_FS_SPEED)
 80111e8:	d00b      	beq.n	8011202 <USB_SetTurnaroundTime+0x1e>
 80111ea:	f44f 5c10 	mov.w	ip, #9216	; 0x2400
  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 80111ee:	68d9      	ldr	r1, [r3, #12]
}
 80111f0:	2000      	movs	r0, #0
  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 80111f2:	f421 5170 	bic.w	r1, r1, #15360	; 0x3c00
 80111f6:	60d9      	str	r1, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 80111f8:	68da      	ldr	r2, [r3, #12]
 80111fa:	ea42 020c 	orr.w	r2, r2, ip
 80111fe:	60da      	str	r2, [r3, #12]
}
 8011200:	4770      	bx	lr
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 8011202:	4a23      	ldr	r2, [pc, #140]	; (8011290 <USB_SetTurnaroundTime+0xac>)
 8011204:	4823      	ldr	r0, [pc, #140]	; (8011294 <USB_SetTurnaroundTime+0xb0>)
 8011206:	440a      	add	r2, r1
 8011208:	4282      	cmp	r2, r0
 801120a:	d92c      	bls.n	8011266 <USB_SetTurnaroundTime+0x82>
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 801120c:	4a22      	ldr	r2, [pc, #136]	; (8011298 <USB_SetTurnaroundTime+0xb4>)
 801120e:	4823      	ldr	r0, [pc, #140]	; (801129c <USB_SetTurnaroundTime+0xb8>)
 8011210:	440a      	add	r2, r1
 8011212:	4282      	cmp	r2, r0
 8011214:	d92a      	bls.n	801126c <USB_SetTurnaroundTime+0x88>
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 8011216:	4a22      	ldr	r2, [pc, #136]	; (80112a0 <USB_SetTurnaroundTime+0xbc>)
 8011218:	4822      	ldr	r0, [pc, #136]	; (80112a4 <USB_SetTurnaroundTime+0xc0>)
 801121a:	440a      	add	r2, r1
 801121c:	4282      	cmp	r2, r0
 801121e:	d928      	bls.n	8011272 <USB_SetTurnaroundTime+0x8e>
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 8011220:	4a21      	ldr	r2, [pc, #132]	; (80112a8 <USB_SetTurnaroundTime+0xc4>)
 8011222:	4822      	ldr	r0, [pc, #136]	; (80112ac <USB_SetTurnaroundTime+0xc8>)
 8011224:	440a      	add	r2, r1
 8011226:	4282      	cmp	r2, r0
 8011228:	d326      	bcc.n	8011278 <USB_SetTurnaroundTime+0x94>
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 801122a:	4a21      	ldr	r2, [pc, #132]	; (80112b0 <USB_SetTurnaroundTime+0xcc>)
 801122c:	4821      	ldr	r0, [pc, #132]	; (80112b4 <USB_SetTurnaroundTime+0xd0>)
 801122e:	440a      	add	r2, r1
 8011230:	4282      	cmp	r2, r0
 8011232:	d924      	bls.n	801127e <USB_SetTurnaroundTime+0x9a>
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 8011234:	4a20      	ldr	r2, [pc, #128]	; (80112b8 <USB_SetTurnaroundTime+0xd4>)
 8011236:	4821      	ldr	r0, [pc, #132]	; (80112bc <USB_SetTurnaroundTime+0xd8>)
 8011238:	440a      	add	r2, r1
 801123a:	4282      	cmp	r2, r0
 801123c:	d322      	bcc.n	8011284 <USB_SetTurnaroundTime+0xa0>
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 801123e:	4a20      	ldr	r2, [pc, #128]	; (80112c0 <USB_SetTurnaroundTime+0xdc>)
 8011240:	4820      	ldr	r0, [pc, #128]	; (80112c4 <USB_SetTurnaroundTime+0xe0>)
 8011242:	440a      	add	r2, r1
 8011244:	4282      	cmp	r2, r0
 8011246:	d3d0      	bcc.n	80111ea <USB_SetTurnaroundTime+0x6>
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 8011248:	4a1f      	ldr	r2, [pc, #124]	; (80112c8 <USB_SetTurnaroundTime+0xe4>)
 801124a:	4820      	ldr	r0, [pc, #128]	; (80112cc <USB_SetTurnaroundTime+0xe8>)
 801124c:	440a      	add	r2, r1
 801124e:	4282      	cmp	r2, r0
 8011250:	d31b      	bcc.n	801128a <USB_SetTurnaroundTime+0xa6>
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 8011252:	4a1f      	ldr	r2, [pc, #124]	; (80112d0 <USB_SetTurnaroundTime+0xec>)
 8011254:	481f      	ldr	r0, [pc, #124]	; (80112d4 <USB_SetTurnaroundTime+0xf0>)
 8011256:	440a      	add	r2, r1
 8011258:	4282      	cmp	r2, r0
 801125a:	bf34      	ite	cc
 801125c:	f44f 5ce0 	movcc.w	ip, #7168	; 0x1c00
 8011260:	f44f 5cc0 	movcs.w	ip, #6144	; 0x1800
 8011264:	e7c3      	b.n	80111ee <USB_SetTurnaroundTime+0xa>
 8011266:	f44f 5c70 	mov.w	ip, #15360	; 0x3c00
 801126a:	e7c0      	b.n	80111ee <USB_SetTurnaroundTime+0xa>
 801126c:	f44f 5c60 	mov.w	ip, #14336	; 0x3800
 8011270:	e7bd      	b.n	80111ee <USB_SetTurnaroundTime+0xa>
 8011272:	f44f 5c50 	mov.w	ip, #13312	; 0x3400
 8011276:	e7ba      	b.n	80111ee <USB_SetTurnaroundTime+0xa>
 8011278:	f44f 5c40 	mov.w	ip, #12288	; 0x3000
 801127c:	e7b7      	b.n	80111ee <USB_SetTurnaroundTime+0xa>
 801127e:	f44f 5c30 	mov.w	ip, #11264	; 0x2c00
 8011282:	e7b4      	b.n	80111ee <USB_SetTurnaroundTime+0xa>
 8011284:	f44f 5c20 	mov.w	ip, #10240	; 0x2800
 8011288:	e7b1      	b.n	80111ee <USB_SetTurnaroundTime+0xa>
 801128a:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
 801128e:	e7ae      	b.n	80111ee <USB_SetTurnaroundTime+0xa>
 8011290:	ff275340 	.word	0xff275340
 8011294:	000c34ff 	.word	0x000c34ff
 8011298:	ff1b1e40 	.word	0xff1b1e40
 801129c:	000f423f 	.word	0x000f423f
 80112a0:	ff0bdc00 	.word	0xff0bdc00
 80112a4:	00124f7f 	.word	0x00124f7f
 80112a8:	fef98c80 	.word	0xfef98c80
 80112ac:	0013d620 	.word	0x0013d620
 80112b0:	fee5b660 	.word	0xfee5b660
 80112b4:	0016e35f 	.word	0x0016e35f
 80112b8:	feced300 	.word	0xfeced300
 80112bc:	001b7740 	.word	0x001b7740
 80112c0:	feb35bc0 	.word	0xfeb35bc0
 80112c4:	002191c0 	.word	0x002191c0
 80112c8:	fe91ca00 	.word	0xfe91ca00
 80112cc:	00387520 	.word	0x00387520
 80112d0:	fe5954e0 	.word	0xfe5954e0
 80112d4:	00419ce0 	.word	0x00419ce0

080112d8 <USB_EnableGlobalInt>:
{
 80112d8:	4603      	mov	r3, r0
}
 80112da:	2000      	movs	r0, #0
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 80112dc:	689a      	ldr	r2, [r3, #8]
 80112de:	f042 0201 	orr.w	r2, r2, #1
 80112e2:	609a      	str	r2, [r3, #8]
}
 80112e4:	4770      	bx	lr
 80112e6:	bf00      	nop

080112e8 <USB_DisableGlobalInt>:
{
 80112e8:	4603      	mov	r3, r0
}
 80112ea:	2000      	movs	r0, #0
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 80112ec:	689a      	ldr	r2, [r3, #8]
 80112ee:	f022 0201 	bic.w	r2, r2, #1
 80112f2:	609a      	str	r2, [r3, #8]
}
 80112f4:	4770      	bx	lr
 80112f6:	bf00      	nop

080112f8 <USB_SetCurrentMode>:
{
 80112f8:	b538      	push	{r3, r4, r5, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 80112fa:	68c3      	ldr	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 80112fc:	2901      	cmp	r1, #1
{
 80112fe:	4605      	mov	r5, r0
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8011300:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 8011304:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 8011306:	d017      	beq.n	8011338 <USB_SetCurrentMode+0x40>
  else if (mode == USB_DEVICE_MODE)
 8011308:	b9a1      	cbnz	r1, 8011334 <USB_SetCurrentMode+0x3c>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 801130a:	68c3      	ldr	r3, [r0, #12]
  uint32_t ms = 0U;
 801130c:	460c      	mov	r4, r1
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 801130e:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8011312:	60c3      	str	r3, [r0, #12]
 8011314:	e001      	b.n	801131a <USB_SetCurrentMode+0x22>
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < 50U));
 8011316:	2c32      	cmp	r4, #50	; 0x32
 8011318:	d00c      	beq.n	8011334 <USB_SetCurrentMode+0x3c>
      HAL_Delay(1U);
 801131a:	2001      	movs	r0, #1
      ms++;
 801131c:	4404      	add	r4, r0
      HAL_Delay(1U);
 801131e:	f7f9 fcfb 	bl	800ad18 <HAL_Delay>
  return ((USBx->GINTSTS) & 0x1U);
 8011322:	696b      	ldr	r3, [r5, #20]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < 50U));
 8011324:	07db      	lsls	r3, r3, #31
 8011326:	d4f6      	bmi.n	8011316 <USB_SetCurrentMode+0x1e>
    return HAL_ERROR;
 8011328:	f1a4 0032 	sub.w	r0, r4, #50	; 0x32
 801132c:	fab0 f080 	clz	r0, r0
 8011330:	0940      	lsrs	r0, r0, #5
}
 8011332:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8011334:	2001      	movs	r0, #1
}
 8011336:	bd38      	pop	{r3, r4, r5, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 8011338:	68c3      	ldr	r3, [r0, #12]
  uint32_t ms = 0U;
 801133a:	2400      	movs	r4, #0
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 801133c:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8011340:	60c3      	str	r3, [r0, #12]
 8011342:	e001      	b.n	8011348 <USB_SetCurrentMode+0x50>
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < 50U));
 8011344:	2c32      	cmp	r4, #50	; 0x32
 8011346:	d0f5      	beq.n	8011334 <USB_SetCurrentMode+0x3c>
      HAL_Delay(1U);
 8011348:	2001      	movs	r0, #1
      ms++;
 801134a:	4404      	add	r4, r0
      HAL_Delay(1U);
 801134c:	f7f9 fce4 	bl	800ad18 <HAL_Delay>
  return ((USBx->GINTSTS) & 0x1U);
 8011350:	696b      	ldr	r3, [r5, #20]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < 50U));
 8011352:	07da      	lsls	r2, r3, #31
 8011354:	d5f6      	bpl.n	8011344 <USB_SetCurrentMode+0x4c>
    return HAL_ERROR;
 8011356:	f1a4 0032 	sub.w	r0, r4, #50	; 0x32
 801135a:	fab0 f080 	clz	r0, r0
 801135e:	0940      	lsrs	r0, r0, #5
 8011360:	e7e7      	b.n	8011332 <USB_SetCurrentMode+0x3a>
 8011362:	bf00      	nop

08011364 <USB_DevInit>:
{
 8011364:	b084      	sub	sp, #16
 8011366:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801136a:	b083      	sub	sp, #12
 801136c:	ac0b      	add	r4, sp, #44	; 0x2c
 801136e:	9d15      	ldr	r5, [sp, #84]	; 0x54
 8011370:	e884 000e 	stmia.w	r4, {r1, r2, r3}
    USBx->DIEPTXF[i] = 0U;
 8011374:	2300      	movs	r3, #0
 8011376:	460c      	mov	r4, r1
 8011378:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
 801137c:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
 8011380:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
 8011384:	f8c0 3110 	str.w	r3, [r0, #272]	; 0x110
 8011388:	f8c0 3114 	str.w	r3, [r0, #276]	; 0x114
 801138c:	f8c0 3118 	str.w	r3, [r0, #280]	; 0x118
 8011390:	f8c0 311c 	str.w	r3, [r0, #284]	; 0x11c
 8011394:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120
 8011398:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
 801139c:	f8c0 3128 	str.w	r3, [r0, #296]	; 0x128
 80113a0:	f8c0 312c 	str.w	r3, [r0, #300]	; 0x12c
 80113a4:	f8c0 3130 	str.w	r3, [r0, #304]	; 0x130
 80113a8:	f8c0 3134 	str.w	r3, [r0, #308]	; 0x134
 80113ac:	f8c0 3138 	str.w	r3, [r0, #312]	; 0x138
 80113b0:	f8c0 313c 	str.w	r3, [r0, #316]	; 0x13c
  if (cfg.vbus_sensing_enable == 0U)
 80113b4:	2d00      	cmp	r5, #0
 80113b6:	f040 80aa 	bne.w	801150e <USB_DevInit+0x1aa>
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 80113ba:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 80113be:	f500 6c00 	add.w	ip, r0, #2048	; 0x800
 80113c2:	f043 0302 	orr.w	r3, r3, #2
 80113c6:	f8cc 3004 	str.w	r3, [ip, #4]
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
 80113ca:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80113cc:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80113d0:	6383      	str	r3, [r0, #56]	; 0x38
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
 80113d2:	6803      	ldr	r3, [r0, #0]
 80113d4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80113d8:	6003      	str	r3, [r0, #0]
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
 80113da:	6803      	ldr	r3, [r0, #0]
 80113dc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80113e0:	6003      	str	r3, [r0, #0]
  USBx_PCGCCTL = 0U;
 80113e2:	2300      	movs	r3, #0
 80113e4:	f8c0 3e00 	str.w	r3, [r0, #3584]	; 0xe00
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 80113e8:	f8dc 3000 	ldr.w	r3, [ip]
 80113ec:	f8cc 3000 	str.w	r3, [ip]
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80113f0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80113f2:	2b01      	cmp	r3, #1
 80113f4:	f000 80b5 	beq.w	8011562 <USB_DevInit+0x1fe>
  USBx_DEVICE->DCFG |= speed;
 80113f8:	f8dc 3000 	ldr.w	r3, [ip]
 80113fc:	f043 0303 	orr.w	r3, r3, #3
 8011400:	f8cc 3000 	str.w	r3, [ip]
  __IO uint32_t count = 0U;
 8011404:	2300      	movs	r3, #0
    if (count > 200000U)
 8011406:	4a5e      	ldr	r2, [pc, #376]	; (8011580 <USB_DevInit+0x21c>)
  __IO uint32_t count = 0U;
 8011408:	9300      	str	r3, [sp, #0]
 801140a:	e003      	b.n	8011414 <USB_DevInit+0xb0>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 801140c:	6903      	ldr	r3, [r0, #16]
 801140e:	2b00      	cmp	r3, #0
 8011410:	f2c0 8094 	blt.w	801153c <USB_DevInit+0x1d8>
    count++;
 8011414:	9b00      	ldr	r3, [sp, #0]
 8011416:	3301      	adds	r3, #1
 8011418:	9300      	str	r3, [sp, #0]
    if (count > 200000U)
 801141a:	9b00      	ldr	r3, [sp, #0]
 801141c:	4293      	cmp	r3, r2
 801141e:	d9f5      	bls.n	801140c <USB_DevInit+0xa8>
    ret = HAL_ERROR;
 8011420:	2101      	movs	r1, #1
  __IO uint32_t count = 0U;
 8011422:	2300      	movs	r3, #0
    if (count > 200000U)
 8011424:	4a56      	ldr	r2, [pc, #344]	; (8011580 <USB_DevInit+0x21c>)
  __IO uint32_t count = 0U;
 8011426:	9301      	str	r3, [sp, #4]
 8011428:	e002      	b.n	8011430 <USB_DevInit+0xcc>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 801142a:	6903      	ldr	r3, [r0, #16]
 801142c:	2b00      	cmp	r3, #0
 801142e:	db75      	blt.n	801151c <USB_DevInit+0x1b8>
    count++;
 8011430:	9b01      	ldr	r3, [sp, #4]
 8011432:	3301      	adds	r3, #1
 8011434:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8011436:	9b01      	ldr	r3, [sp, #4]
 8011438:	4293      	cmp	r3, r2
 801143a:	d9f6      	bls.n	801142a <USB_DevInit+0xc6>
    ret = HAL_ERROR;
 801143c:	2101      	movs	r1, #1
  USBx_DEVICE->DIEPMSK = 0U;
 801143e:	2200      	movs	r2, #0
 8011440:	f8cc 2010 	str.w	r2, [ip, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 8011444:	f8cc 2014 	str.w	r2, [ip, #20]
  USBx_DEVICE->DAINTMSK = 0U;
 8011448:	f8cc 201c 	str.w	r2, [ip, #28]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 801144c:	b1dc      	cbz	r4, 8011486 <USB_DevInit+0x122>
 801144e:	f500 6310 	add.w	r3, r0, #2304	; 0x900
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 8011452:	f04f 4890 	mov.w	r8, #1207959552	; 0x48000000
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8011456:	f04f 6900 	mov.w	r9, #134217728	; 0x8000000
      USBx_INEP(i)->DIEPCTL = 0U;
 801145a:	4617      	mov	r7, r2
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 801145c:	f64f 3e7f 	movw	lr, #64383	; 0xfb7f
 8011460:	e007      	b.n	8011472 <USB_DevInit+0x10e>
      USBx_INEP(i)->DIEPCTL = 0U;
 8011462:	601f      	str	r7, [r3, #0]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8011464:	3201      	adds	r2, #1
    USBx_INEP(i)->DIEPTSIZ = 0U;
 8011466:	611f      	str	r7, [r3, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 8011468:	f8c3 e008 	str.w	lr, [r3, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 801146c:	3320      	adds	r3, #32
 801146e:	4294      	cmp	r4, r2
 8011470:	d030      	beq.n	80114d4 <USB_DevInit+0x170>
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8011472:	681e      	ldr	r6, [r3, #0]
 8011474:	2e00      	cmp	r6, #0
 8011476:	daf4      	bge.n	8011462 <USB_DevInit+0xfe>
      if (i == 0U)
 8011478:	b112      	cbz	r2, 8011480 <USB_DevInit+0x11c>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 801147a:	f8c3 8000 	str.w	r8, [r3]
 801147e:	e7f1      	b.n	8011464 <USB_DevInit+0x100>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8011480:	f8c3 9000 	str.w	r9, [r3]
 8011484:	e7ee      	b.n	8011464 <USB_DevInit+0x100>
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8011486:	f8dc 3010 	ldr.w	r3, [ip, #16]
  USBx->GINTMSK = 0U;
 801148a:	2200      	movs	r2, #0
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 801148c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8011490:	f8cc 3010 	str.w	r3, [ip, #16]
  USBx->GINTSTS = 0xBFFFFFFFU;
 8011494:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
  USBx->GINTMSK = 0U;
 8011498:	6182      	str	r2, [r0, #24]
  USBx->GINTSTS = 0xBFFFFFFFU;
 801149a:	6143      	str	r3, [r0, #20]
  if (cfg.dma_enable == 0U)
 801149c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801149e:	b91b      	cbnz	r3, 80114a8 <USB_DevInit+0x144>
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 80114a0:	6983      	ldr	r3, [r0, #24]
 80114a2:	f043 0310 	orr.w	r3, r3, #16
 80114a6:	6183      	str	r3, [r0, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 80114a8:	6982      	ldr	r2, [r0, #24]
 80114aa:	4b36      	ldr	r3, [pc, #216]	; (8011584 <USB_DevInit+0x220>)
 80114ac:	4313      	orrs	r3, r2
  if (cfg.Sof_enable != 0U)
 80114ae:	9a11      	ldr	r2, [sp, #68]	; 0x44
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 80114b0:	6183      	str	r3, [r0, #24]
  if (cfg.Sof_enable != 0U)
 80114b2:	b11a      	cbz	r2, 80114bc <USB_DevInit+0x158>
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 80114b4:	6983      	ldr	r3, [r0, #24]
 80114b6:	f043 0308 	orr.w	r3, r3, #8
 80114ba:	6183      	str	r3, [r0, #24]
  if (cfg.vbus_sensing_enable == 1U)
 80114bc:	2d01      	cmp	r5, #1
 80114be:	d103      	bne.n	80114c8 <USB_DevInit+0x164>
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 80114c0:	6982      	ldr	r2, [r0, #24]
 80114c2:	4b31      	ldr	r3, [pc, #196]	; (8011588 <USB_DevInit+0x224>)
 80114c4:	4313      	orrs	r3, r2
 80114c6:	6183      	str	r3, [r0, #24]
}
 80114c8:	4608      	mov	r0, r1
 80114ca:	b003      	add	sp, #12
 80114cc:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80114d0:	b004      	add	sp, #16
 80114d2:	4770      	bx	lr
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80114d4:	2200      	movs	r2, #0
 80114d6:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 80114da:	f04f 4890 	mov.w	r8, #1207959552	; 0x48000000
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 80114de:	f04f 6900 	mov.w	r9, #134217728	; 0x8000000
      USBx_OUTEP(i)->DOEPCTL = 0U;
 80114e2:	4617      	mov	r7, r2
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 80114e4:	f64f 3e7f 	movw	lr, #64383	; 0xfb7f
 80114e8:	e007      	b.n	80114fa <USB_DevInit+0x196>
      USBx_OUTEP(i)->DOEPCTL = 0U;
 80114ea:	601f      	str	r7, [r3, #0]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80114ec:	3201      	adds	r2, #1
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 80114ee:	611f      	str	r7, [r3, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 80114f0:	f8c3 e008 	str.w	lr, [r3, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 80114f4:	3320      	adds	r3, #32
 80114f6:	4294      	cmp	r4, r2
 80114f8:	d0c5      	beq.n	8011486 <USB_DevInit+0x122>
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 80114fa:	681e      	ldr	r6, [r3, #0]
 80114fc:	2e00      	cmp	r6, #0
 80114fe:	daf4      	bge.n	80114ea <USB_DevInit+0x186>
      if (i == 0U)
 8011500:	b112      	cbz	r2, 8011508 <USB_DevInit+0x1a4>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 8011502:	f8c3 8000 	str.w	r8, [r3]
 8011506:	e7f1      	b.n	80114ec <USB_DevInit+0x188>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8011508:	f8c3 9000 	str.w	r9, [r3]
 801150c:	e7ee      	b.n	80114ec <USB_DevInit+0x188>
    USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
 801150e:	6b83      	ldr	r3, [r0, #56]	; 0x38
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 8011510:	f500 6c00 	add.w	ip, r0, #2048	; 0x800
    USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
 8011514:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8011518:	6383      	str	r3, [r0, #56]	; 0x38
 801151a:	e762      	b.n	80113e2 <USB_DevInit+0x7e>
  count = 0U;
 801151c:	2300      	movs	r3, #0
    if (count > 200000U)
 801151e:	4a18      	ldr	r2, [pc, #96]	; (8011580 <USB_DevInit+0x21c>)
  count = 0U;
 8011520:	9301      	str	r3, [sp, #4]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8011522:	2310      	movs	r3, #16
 8011524:	6103      	str	r3, [r0, #16]
 8011526:	e002      	b.n	801152e <USB_DevInit+0x1ca>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8011528:	6903      	ldr	r3, [r0, #16]
 801152a:	06db      	lsls	r3, r3, #27
 801152c:	d587      	bpl.n	801143e <USB_DevInit+0xda>
    count++;
 801152e:	9b01      	ldr	r3, [sp, #4]
 8011530:	3301      	adds	r3, #1
 8011532:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 8011534:	9b01      	ldr	r3, [sp, #4]
 8011536:	4293      	cmp	r3, r2
 8011538:	d9f6      	bls.n	8011528 <USB_DevInit+0x1c4>
 801153a:	e77f      	b.n	801143c <USB_DevInit+0xd8>
  count = 0U;
 801153c:	2300      	movs	r3, #0
    if (count > 200000U)
 801153e:	4a10      	ldr	r2, [pc, #64]	; (8011580 <USB_DevInit+0x21c>)
  count = 0U;
 8011540:	9300      	str	r3, [sp, #0]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8011542:	f44f 6384 	mov.w	r3, #1056	; 0x420
 8011546:	6103      	str	r3, [r0, #16]
 8011548:	e004      	b.n	8011554 <USB_DevInit+0x1f0>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 801154a:	6901      	ldr	r1, [r0, #16]
 801154c:	f011 0120 	ands.w	r1, r1, #32
 8011550:	f43f af67 	beq.w	8011422 <USB_DevInit+0xbe>
    count++;
 8011554:	9b00      	ldr	r3, [sp, #0]
 8011556:	3301      	adds	r3, #1
 8011558:	9300      	str	r3, [sp, #0]
    if (count > 200000U)
 801155a:	9b00      	ldr	r3, [sp, #0]
 801155c:	4293      	cmp	r3, r2
 801155e:	d9f4      	bls.n	801154a <USB_DevInit+0x1e6>
 8011560:	e75e      	b.n	8011420 <USB_DevInit+0xbc>
    if (cfg.speed == USBD_HS_SPEED)
 8011562:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8011564:	b923      	cbnz	r3, 8011570 <USB_DevInit+0x20c>
  USBx_DEVICE->DCFG |= speed;
 8011566:	f8dc 3000 	ldr.w	r3, [ip]
 801156a:	f8cc 3000 	str.w	r3, [ip]
  return HAL_OK;
 801156e:	e749      	b.n	8011404 <USB_DevInit+0xa0>
  USBx_DEVICE->DCFG |= speed;
 8011570:	f8dc 3000 	ldr.w	r3, [ip]
 8011574:	f043 0301 	orr.w	r3, r3, #1
 8011578:	f8cc 3000 	str.w	r3, [ip]
  return HAL_OK;
 801157c:	e742      	b.n	8011404 <USB_DevInit+0xa0>
 801157e:	bf00      	nop
 8011580:	00030d40 	.word	0x00030d40
 8011584:	803c3800 	.word	0x803c3800
 8011588:	40000004 	.word	0x40000004

0801158c <USB_FlushTxFifo>:
{
 801158c:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 801158e:	2300      	movs	r3, #0
    if (count > 200000U)
 8011590:	4a12      	ldr	r2, [pc, #72]	; (80115dc <USB_FlushTxFifo+0x50>)
  __IO uint32_t count = 0U;
 8011592:	9301      	str	r3, [sp, #4]
 8011594:	e002      	b.n	801159c <USB_FlushTxFifo+0x10>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8011596:	6903      	ldr	r3, [r0, #16]
 8011598:	2b00      	cmp	r3, #0
 801159a:	db08      	blt.n	80115ae <USB_FlushTxFifo+0x22>
    count++;
 801159c:	9b01      	ldr	r3, [sp, #4]
 801159e:	3301      	adds	r3, #1
 80115a0:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 80115a2:	9b01      	ldr	r3, [sp, #4]
 80115a4:	4293      	cmp	r3, r2
 80115a6:	d9f6      	bls.n	8011596 <USB_FlushTxFifo+0xa>
      return HAL_TIMEOUT;
 80115a8:	2003      	movs	r0, #3
}
 80115aa:	b002      	add	sp, #8
 80115ac:	4770      	bx	lr
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 80115ae:	0189      	lsls	r1, r1, #6
  count = 0U;
 80115b0:	2300      	movs	r3, #0
    if (count > 200000U)
 80115b2:	4a0a      	ldr	r2, [pc, #40]	; (80115dc <USB_FlushTxFifo+0x50>)
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 80115b4:	f041 0120 	orr.w	r1, r1, #32
  count = 0U;
 80115b8:	9301      	str	r3, [sp, #4]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 80115ba:	6101      	str	r1, [r0, #16]
 80115bc:	e003      	b.n	80115c6 <USB_FlushTxFifo+0x3a>
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 80115be:	6903      	ldr	r3, [r0, #16]
 80115c0:	f013 0320 	ands.w	r3, r3, #32
 80115c4:	d006      	beq.n	80115d4 <USB_FlushTxFifo+0x48>
    count++;
 80115c6:	9b01      	ldr	r3, [sp, #4]
 80115c8:	3301      	adds	r3, #1
 80115ca:	9301      	str	r3, [sp, #4]
    if (count > 200000U)
 80115cc:	9b01      	ldr	r3, [sp, #4]
 80115ce:	4293      	cmp	r3, r2
 80115d0:	d9f5      	bls.n	80115be <USB_FlushTxFifo+0x32>
 80115d2:	e7e9      	b.n	80115a8 <USB_FlushTxFifo+0x1c>
  return HAL_OK;
 80115d4:	4618      	mov	r0, r3
}
 80115d6:	b002      	add	sp, #8
 80115d8:	4770      	bx	lr
 80115da:	bf00      	nop
 80115dc:	00030d40 	.word	0x00030d40

080115e0 <USB_GetDevSpeed>:
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 80115e0:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 80115e4:	f013 0006 	ands.w	r0, r3, #6
 80115e8:	d004      	beq.n	80115f4 <USB_GetDevSpeed+0x14>
    speed = 0xFU;
 80115ea:	f013 0f02 	tst.w	r3, #2
 80115ee:	bf14      	ite	ne
 80115f0:	2002      	movne	r0, #2
 80115f2:	200f      	moveq	r0, #15
}
 80115f4:	4770      	bx	lr
 80115f6:	bf00      	nop

080115f8 <USB_ActivateEndpoint>:
{
 80115f8:	b430      	push	{r4, r5}
  if (ep->is_in == 1U)
 80115fa:	784b      	ldrb	r3, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 80115fc:	780a      	ldrb	r2, [r1, #0]
  if (ep->is_in == 1U)
 80115fe:	2b01      	cmp	r3, #1
 8011600:	d020      	beq.n	8011644 <USB_ActivateEndpoint+0x4c>
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 8011602:	f002 0c0f 	and.w	ip, r2, #15
 8011606:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 801160a:	f8d0 481c 	ldr.w	r4, [r0, #2076]	; 0x81c
    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 801160e:	eb00 1242 	add.w	r2, r0, r2, lsl #5
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 8011612:	fa03 f30c 	lsl.w	r3, r3, ip
 8011616:	4323      	orrs	r3, r4
 8011618:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 801161c:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8011620:	041b      	lsls	r3, r3, #16
 8011622:	d40c      	bmi.n	801163e <USB_ActivateEndpoint+0x46>
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8011624:	68cb      	ldr	r3, [r1, #12]
 8011626:	f8d2 4b00 	ldr.w	r4, [r2, #2816]	; 0xb00
 801162a:	f3c3 030a 	ubfx	r3, r3, #0, #11
                                    ((uint32_t)ep->type << 18) |
 801162e:	7908      	ldrb	r0, [r1, #4]
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8011630:	4914      	ldr	r1, [pc, #80]	; (8011684 <USB_ActivateEndpoint+0x8c>)
 8011632:	4323      	orrs	r3, r4
 8011634:	ea43 4380 	orr.w	r3, r3, r0, lsl #18
 8011638:	4319      	orrs	r1, r3
 801163a:	f8c2 1b00 	str.w	r1, [r2, #2816]	; 0xb00
}
 801163e:	2000      	movs	r0, #0
 8011640:	bc30      	pop	{r4, r5}
 8011642:	4770      	bx	lr
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 8011644:	f500 6400 	add.w	r4, r0, #2048	; 0x800
 8011648:	f002 050f 	and.w	r5, r2, #15
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 801164c:	eb00 1042 	add.w	r0, r0, r2, lsl #5
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 8011650:	40ab      	lsls	r3, r5
 8011652:	69e5      	ldr	r5, [r4, #28]
 8011654:	432b      	orrs	r3, r5
 8011656:	61e3      	str	r3, [r4, #28]
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8011658:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 801165c:	041c      	lsls	r4, r3, #16
 801165e:	d4ee      	bmi.n	801163e <USB_ActivateEndpoint+0x46>
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 8011660:	68cb      	ldr	r3, [r1, #12]
 8011662:	f8d0 5900 	ldr.w	r5, [r0, #2304]	; 0x900
 8011666:	f3c3 030a 	ubfx	r3, r3, #0, #11
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 801166a:	790c      	ldrb	r4, [r1, #4]
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 801166c:	4905      	ldr	r1, [pc, #20]	; (8011684 <USB_ActivateEndpoint+0x8c>)
 801166e:	432b      	orrs	r3, r5
 8011670:	ea43 4384 	orr.w	r3, r3, r4, lsl #18
 8011674:	ea43 5282 	orr.w	r2, r3, r2, lsl #22
 8011678:	4311      	orrs	r1, r2
}
 801167a:	bc30      	pop	{r4, r5}
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 801167c:	f8c0 1900 	str.w	r1, [r0, #2304]	; 0x900
}
 8011680:	2000      	movs	r0, #0
 8011682:	4770      	bx	lr
 8011684:	10008000 	.word	0x10008000

08011688 <USB_DeactivateEndpoint>:
  if (ep->is_in == 1U)
 8011688:	784a      	ldrb	r2, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 801168a:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 801168c:	2a01      	cmp	r2, #1
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 801168e:	eb00 1c43 	add.w	ip, r0, r3, lsl #5
  if (ep->is_in == 1U)
 8011692:	d02a      	beq.n	80116ea <USB_DeactivateEndpoint+0x62>
    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8011694:	f8dc 2b00 	ldr.w	r2, [ip, #2816]	; 0xb00
 8011698:	2a00      	cmp	r2, #0
 801169a:	db19      	blt.n	80116d0 <USB_DeactivateEndpoint+0x48>
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 801169c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80116a0:	f003 030f 	and.w	r3, r3, #15
 80116a4:	f8d0 183c 	ldr.w	r1, [r0, #2108]	; 0x83c
 80116a8:	fa02 f303 	lsl.w	r3, r2, r3
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 80116ac:	4a23      	ldr	r2, [pc, #140]	; (801173c <USB_DeactivateEndpoint+0xb4>)
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 80116ae:	ea21 0103 	bic.w	r1, r1, r3
 80116b2:	f8c0 183c 	str.w	r1, [r0, #2108]	; 0x83c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 80116b6:	f8d0 181c 	ldr.w	r1, [r0, #2076]	; 0x81c
 80116ba:	ea21 0303 	bic.w	r3, r1, r3
 80116be:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
}
 80116c2:	2000      	movs	r0, #0
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 80116c4:	f8dc 3b00 	ldr.w	r3, [ip, #2816]	; 0xb00
 80116c8:	401a      	ands	r2, r3
 80116ca:	f8cc 2b00 	str.w	r2, [ip, #2816]	; 0xb00
}
 80116ce:	4770      	bx	lr
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 80116d0:	f8dc 2b00 	ldr.w	r2, [ip, #2816]	; 0xb00
 80116d4:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 80116d8:	f8cc 2b00 	str.w	r2, [ip, #2816]	; 0xb00
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
 80116dc:	f8dc 2b00 	ldr.w	r2, [ip, #2816]	; 0xb00
 80116e0:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 80116e4:	f8cc 2b00 	str.w	r2, [ip, #2816]	; 0xb00
 80116e8:	e7d8      	b.n	801169c <USB_DeactivateEndpoint+0x14>
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 80116ea:	f8dc 2900 	ldr.w	r2, [ip, #2304]	; 0x900
 80116ee:	2a00      	cmp	r2, #0
 80116f0:	da0b      	bge.n	801170a <USB_DeactivateEndpoint+0x82>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
 80116f2:	f8dc 2900 	ldr.w	r2, [ip, #2304]	; 0x900
 80116f6:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 80116fa:	f8cc 2900 	str.w	r2, [ip, #2304]	; 0x900
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
 80116fe:	f8dc 2900 	ldr.w	r2, [ip, #2304]	; 0x900
 8011702:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8011706:	f8cc 2900 	str.w	r2, [ip, #2304]	; 0x900
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 801170a:	f003 020f 	and.w	r2, r3, #15
 801170e:	2301      	movs	r3, #1
 8011710:	f8d0 183c 	ldr.w	r1, [r0, #2108]	; 0x83c
 8011714:	4093      	lsls	r3, r2
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 8011716:	4a0a      	ldr	r2, [pc, #40]	; (8011740 <USB_DeactivateEndpoint+0xb8>)
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8011718:	ea21 0103 	bic.w	r1, r1, r3
 801171c:	f8c0 183c 	str.w	r1, [r0, #2108]	; 0x83c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8011720:	f8d0 181c 	ldr.w	r1, [r0, #2076]	; 0x81c
 8011724:	ea21 0303 	bic.w	r3, r1, r3
 8011728:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
}
 801172c:	2000      	movs	r0, #0
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 801172e:	f8dc 3900 	ldr.w	r3, [ip, #2304]	; 0x900
 8011732:	401a      	ands	r2, r3
 8011734:	f8cc 2900 	str.w	r2, [ip, #2304]	; 0x900
}
 8011738:	4770      	bx	lr
 801173a:	bf00      	nop
 801173c:	eff37800 	.word	0xeff37800
 8011740:	ec337800 	.word	0xec337800

08011744 <USB_EPStartXfer>:
{
 8011744:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (ep->is_in == 1U)
 8011748:	784b      	ldrb	r3, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 801174a:	f891 c000 	ldrb.w	ip, [r1]
  if (ep->is_in == 1U)
 801174e:	2b01      	cmp	r3, #1
 8011750:	d052      	beq.n	80117f8 <USB_EPStartXfer+0xb4>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 8011752:	eb00 1c4c 	add.w	ip, r0, ip, lsl #5
 8011756:	4c84      	ldr	r4, [pc, #528]	; (8011968 <USB_EPStartXfer+0x224>)
 8011758:	f8dc 5b10 	ldr.w	r5, [ip, #2832]	; 0xb10
 801175c:	f50c 6330 	add.w	r3, ip, #2816	; 0xb00
 8011760:	402c      	ands	r4, r5
 8011762:	611c      	str	r4, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8011764:	4c81      	ldr	r4, [pc, #516]	; (801196c <USB_EPStartXfer+0x228>)
 8011766:	691d      	ldr	r5, [r3, #16]
 8011768:	402c      	ands	r4, r5
 801176a:	611c      	str	r4, [r3, #16]
    if (ep->xfer_len == 0U)
 801176c:	698c      	ldr	r4, [r1, #24]
 801176e:	b38c      	cbz	r4, 80117d4 <USB_EPStartXfer+0x90>
      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 8011770:	68cd      	ldr	r5, [r1, #12]
    if (dma == 1U)
 8011772:	2a01      	cmp	r2, #1
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8011774:	4e7e      	ldr	r6, [pc, #504]	; (8011970 <USB_EPStartXfer+0x22c>)
      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 8011776:	442c      	add	r4, r5
 8011778:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
 801177c:	fbb4 f4f5 	udiv	r4, r4, r5
 8011780:	b2a4      	uxth	r4, r4
      ep->xfer_size = ep->maxpacket * pktcnt;
 8011782:	fb04 f505 	mul.w	r5, r4, r5
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8011786:	ea06 44c4 	and.w	r4, r6, r4, lsl #19
 801178a:	691e      	ldr	r6, [r3, #16]
      ep->xfer_size = ep->maxpacket * pktcnt;
 801178c:	61cd      	str	r5, [r1, #28]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
 801178e:	f3c5 0512 	ubfx	r5, r5, #0, #19
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8011792:	ea44 0406 	orr.w	r4, r4, r6
 8011796:	611c      	str	r4, [r3, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
 8011798:	691c      	ldr	r4, [r3, #16]
 801179a:	ea45 0504 	orr.w	r5, r5, r4
 801179e:	611d      	str	r5, [r3, #16]
    if (dma == 1U)
 80117a0:	d025      	beq.n	80117ee <USB_EPStartXfer+0xaa>
    if (ep->type == EP_TYPE_ISOC)
 80117a2:	790b      	ldrb	r3, [r1, #4]
 80117a4:	2b01      	cmp	r3, #1
 80117a6:	d10c      	bne.n	80117c2 <USB_EPStartXfer+0x7e>
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 80117a8:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 80117ac:	f413 7f80 	tst.w	r3, #256	; 0x100
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 80117b0:	f8dc 3b00 	ldr.w	r3, [ip, #2816]	; 0xb00
 80117b4:	bf0c      	ite	eq
 80117b6:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 80117ba:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
 80117be:	f8cc 3b00 	str.w	r3, [ip, #2816]	; 0xb00
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 80117c2:	f8dc 3b00 	ldr.w	r3, [ip, #2816]	; 0xb00
 80117c6:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80117ca:	f8cc 3b00 	str.w	r3, [ip, #2816]	; 0xb00
}
 80117ce:	2000      	movs	r0, #0
 80117d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 80117d4:	68cc      	ldr	r4, [r1, #12]
    if (dma == 1U)
 80117d6:	2a01      	cmp	r2, #1
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 80117d8:	691d      	ldr	r5, [r3, #16]
 80117da:	f3c4 0412 	ubfx	r4, r4, #0, #19
 80117de:	ea44 0405 	orr.w	r4, r4, r5
 80117e2:	611c      	str	r4, [r3, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 80117e4:	691c      	ldr	r4, [r3, #16]
 80117e6:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 80117ea:	611c      	str	r4, [r3, #16]
    if (dma == 1U)
 80117ec:	d1d9      	bne.n	80117a2 <USB_EPStartXfer+0x5e>
      if ((uint32_t)ep->xfer_buff != 0U)
 80117ee:	690a      	ldr	r2, [r1, #16]
 80117f0:	2a00      	cmp	r2, #0
 80117f2:	d0d6      	beq.n	80117a2 <USB_EPStartXfer+0x5e>
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 80117f4:	615a      	str	r2, [r3, #20]
 80117f6:	e7d4      	b.n	80117a2 <USB_EPStartXfer+0x5e>
    if (ep->xfer_len == 0U)
 80117f8:	698d      	ldr	r5, [r1, #24]
 80117fa:	2d00      	cmp	r5, #0
 80117fc:	d03d      	beq.n	801187a <USB_EPStartXfer+0x136>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80117fe:	eb00 144c 	add.w	r4, r0, ip, lsl #5
 8011802:	4e59      	ldr	r6, [pc, #356]	; (8011968 <USB_EPStartXfer+0x224>)
                                     (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 8011804:	f8d1 e00c 	ldr.w	lr, [r1, #12]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8011808:	f8d4 8910 	ldr.w	r8, [r4, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 801180c:	4f57      	ldr	r7, [pc, #348]	; (801196c <USB_EPStartXfer+0x228>)
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 801180e:	ea08 0606 	and.w	r6, r8, r6
 8011812:	f8c4 6910 	str.w	r6, [r4, #2320]	; 0x910
                                     (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 8011816:	eb05 060e 	add.w	r6, r5, lr
 801181a:	3e01      	subs	r6, #1
 801181c:	fbb6 fefe 	udiv	lr, r6, lr
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8011820:	f8d4 6910 	ldr.w	r6, [r4, #2320]	; 0x910
 8011824:	4037      	ands	r7, r6
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT &
 8011826:	4e52      	ldr	r6, [pc, #328]	; (8011970 <USB_EPStartXfer+0x22c>)
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8011828:	f8c4 7910 	str.w	r7, [r4, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT &
 801182c:	ea06 46ce 	and.w	r6, r6, lr, lsl #19
 8011830:	f8d4 7910 	ldr.w	r7, [r4, #2320]	; 0x910
 8011834:	433e      	orrs	r6, r7
 8011836:	f8c4 6910 	str.w	r6, [r4, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 801183a:	f3c5 0612 	ubfx	r6, r5, #0, #19
 801183e:	f8d4 7910 	ldr.w	r7, [r4, #2320]	; 0x910
 8011842:	433e      	orrs	r6, r7
 8011844:	f8c4 6910 	str.w	r6, [r4, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8011848:	f504 6610 	add.w	r6, r4, #2304	; 0x900
      if (ep->type == EP_TYPE_ISOC)
 801184c:	f891 e004 	ldrb.w	lr, [r1, #4]
 8011850:	f1be 0f01 	cmp.w	lr, #1
 8011854:	d057      	beq.n	8011906 <USB_EPStartXfer+0x1c2>
    if (dma == 1U)
 8011856:	2a01      	cmp	r2, #1
 8011858:	d072      	beq.n	8011940 <USB_EPStartXfer+0x1fc>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 801185a:	f8d4 2900 	ldr.w	r2, [r4, #2304]	; 0x900
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 801185e:	f00c 0c0f 	and.w	ip, ip, #15
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8011862:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 8011866:	fa03 f30c 	lsl.w	r3, r3, ip
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 801186a:	f8c4 2900 	str.w	r2, [r4, #2304]	; 0x900
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 801186e:	f8d0 2834 	ldr.w	r2, [r0, #2100]	; 0x834
 8011872:	4313      	orrs	r3, r2
 8011874:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
  return HAL_OK;
 8011878:	e7a9      	b.n	80117ce <USB_EPStartXfer+0x8a>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 801187a:	eb00 134c 	add.w	r3, r0, ip, lsl #5
 801187e:	4e3b      	ldr	r6, [pc, #236]	; (801196c <USB_EPStartXfer+0x228>)
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8011880:	4c39      	ldr	r4, [pc, #228]	; (8011968 <USB_EPStartXfer+0x224>)
    if (dma == 1U)
 8011882:	2a01      	cmp	r2, #1
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8011884:	f8d3 7910 	ldr.w	r7, [r3, #2320]	; 0x910
 8011888:	ea06 0607 	and.w	r6, r6, r7
 801188c:	f8c3 6910 	str.w	r6, [r3, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8011890:	f8d3 6910 	ldr.w	r6, [r3, #2320]	; 0x910
 8011894:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
 8011898:	f8c3 6910 	str.w	r6, [r3, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 801189c:	f8d3 6910 	ldr.w	r6, [r3, #2320]	; 0x910
 80118a0:	ea04 0406 	and.w	r4, r4, r6
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80118a4:	f503 6610 	add.w	r6, r3, #2304	; 0x900
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80118a8:	f8c3 4910 	str.w	r4, [r3, #2320]	; 0x910
      if (ep->type == EP_TYPE_ISOC)
 80118ac:	f891 e004 	ldrb.w	lr, [r1, #4]
    if (dma == 1U)
 80118b0:	d03a      	beq.n	8011928 <USB_EPStartXfer+0x1e4>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80118b2:	f8d3 4900 	ldr.w	r4, [r3, #2304]	; 0x900
      if (ep->type != EP_TYPE_ISOC)
 80118b6:	f1be 0f01 	cmp.w	lr, #1
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80118ba:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 80118be:	f8c3 4900 	str.w	r4, [r3, #2304]	; 0x900
      if (ep->type != EP_TYPE_ISOC)
 80118c2:	d184      	bne.n	80117ce <USB_EPStartXfer+0x8a>
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 80118c4:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 80118c8:	f413 7f80 	tst.w	r3, #256	; 0x100
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 80118cc:	6833      	ldr	r3, [r6, #0]
 80118ce:	bf0c      	ite	eq
 80118d0:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 80118d4:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
 80118d8:	6033      	str	r3, [r6, #0]
  if (dma == 0U)
 80118da:	2a00      	cmp	r2, #0
 80118dc:	f47f af77 	bne.w	80117ce <USB_EPStartXfer+0x8a>
    count32b = ((uint32_t)len + 3U) / 4U;
 80118e0:	b2ad      	uxth	r5, r5
 80118e2:	3503      	adds	r5, #3
    for (i = 0U; i < count32b; i++)
 80118e4:	08ad      	lsrs	r5, r5, #2
 80118e6:	f43f af72 	beq.w	80117ce <USB_EPStartXfer+0x8a>
        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
 80118ea:	690b      	ldr	r3, [r1, #16]
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 80118ec:	eb00 3c0c 	add.w	ip, r0, ip, lsl #12
 80118f0:	eb03 0185 	add.w	r1, r3, r5, lsl #2
 80118f4:	f50c 5c80 	add.w	ip, ip, #4096	; 0x1000
 80118f8:	f853 2b04 	ldr.w	r2, [r3], #4
    for (i = 0U; i < count32b; i++)
 80118fc:	428b      	cmp	r3, r1
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 80118fe:	f8cc 2000 	str.w	r2, [ip]
    for (i = 0U; i < count32b; i++)
 8011902:	d1f9      	bne.n	80118f8 <USB_EPStartXfer+0x1b4>
 8011904:	e763      	b.n	80117ce <USB_EPStartXfer+0x8a>
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 8011906:	6933      	ldr	r3, [r6, #16]
    if (dma == 1U)
 8011908:	2a01      	cmp	r2, #1
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 801190a:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 801190e:	6133      	str	r3, [r6, #16]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 8011910:	6933      	ldr	r3, [r6, #16]
 8011912:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8011916:	6133      	str	r3, [r6, #16]
    if (dma == 1U)
 8011918:	d017      	beq.n	801194a <USB_EPStartXfer+0x206>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 801191a:	f8d4 3900 	ldr.w	r3, [r4, #2304]	; 0x900
 801191e:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8011922:	f8c4 3900 	str.w	r3, [r4, #2304]	; 0x900
      if (ep->type != EP_TYPE_ISOC)
 8011926:	e7cd      	b.n	80118c4 <USB_EPStartXfer+0x180>
      if ((uint32_t)ep->dma_addr != 0U)
 8011928:	694b      	ldr	r3, [r1, #20]
 801192a:	b963      	cbnz	r3, 8011946 <USB_EPStartXfer+0x202>
      if (ep->type == EP_TYPE_ISOC)
 801192c:	f1be 0f01 	cmp.w	lr, #1
 8011930:	d00e      	beq.n	8011950 <USB_EPStartXfer+0x20c>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8011932:	6833      	ldr	r3, [r6, #0]
}
 8011934:	2000      	movs	r0, #0
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8011936:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 801193a:	6033      	str	r3, [r6, #0]
}
 801193c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((uint32_t)ep->dma_addr != 0U)
 8011940:	694b      	ldr	r3, [r1, #20]
 8011942:	2b00      	cmp	r3, #0
 8011944:	d0f5      	beq.n	8011932 <USB_EPStartXfer+0x1ee>
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8011946:	6173      	str	r3, [r6, #20]
 8011948:	e7f0      	b.n	801192c <USB_EPStartXfer+0x1e8>
      if ((uint32_t)ep->dma_addr != 0U)
 801194a:	694b      	ldr	r3, [r1, #20]
 801194c:	2b00      	cmp	r3, #0
 801194e:	d1fa      	bne.n	8011946 <USB_EPStartXfer+0x202>
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8011950:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8011954:	f413 7f80 	tst.w	r3, #256	; 0x100
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8011958:	6833      	ldr	r3, [r6, #0]
 801195a:	bf0c      	ite	eq
 801195c:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8011960:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
 8011964:	6033      	str	r3, [r6, #0]
 8011966:	e7e4      	b.n	8011932 <USB_EPStartXfer+0x1ee>
 8011968:	fff80000 	.word	0xfff80000
 801196c:	e007ffff 	.word	0xe007ffff
 8011970:	1ff80000 	.word	0x1ff80000

08011974 <USB_EP0StartXfer>:
{
 8011974:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (ep->is_in == 1U)
 8011976:	784c      	ldrb	r4, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 8011978:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 801197a:	2c01      	cmp	r4, #1
 801197c:	d027      	beq.n	80119ce <USB_EP0StartXfer+0x5a>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 801197e:	eb00 1043 	add.w	r0, r0, r3, lsl #5
 8011982:	4c57      	ldr	r4, [pc, #348]	; (8011ae0 <USB_EP0StartXfer+0x16c>)
 8011984:	f8d0 5b10 	ldr.w	r5, [r0, #2832]	; 0xb10
 8011988:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
 801198c:	402c      	ands	r4, r5
 801198e:	611c      	str	r4, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8011990:	4c54      	ldr	r4, [pc, #336]	; (8011ae4 <USB_EP0StartXfer+0x170>)
 8011992:	691d      	ldr	r5, [r3, #16]
 8011994:	402c      	ands	r4, r5
 8011996:	611c      	str	r4, [r3, #16]
    if (ep->xfer_len > 0U)
 8011998:	698c      	ldr	r4, [r1, #24]
 801199a:	b9ac      	cbnz	r4, 80119c8 <USB_EP0StartXfer+0x54>
      if (ep->xfer_len > ep->maxpacket)
 801199c:	68cc      	ldr	r4, [r1, #12]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 801199e:	691d      	ldr	r5, [r3, #16]
    if (dma == 1U)
 80119a0:	2a01      	cmp	r2, #1
    ep->xfer_size = ep->maxpacket;
 80119a2:	61cc      	str	r4, [r1, #28]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size);
 80119a4:	f3c4 0412 	ubfx	r4, r4, #0, #19
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 80119a8:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 80119ac:	611d      	str	r5, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size);
 80119ae:	691d      	ldr	r5, [r3, #16]
 80119b0:	ea44 0405 	orr.w	r4, r4, r5
 80119b4:	611c      	str	r4, [r3, #16]
    if (dma == 1U)
 80119b6:	d049      	beq.n	8011a4c <USB_EP0StartXfer+0xd8>
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 80119b8:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 80119bc:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80119c0:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 80119c4:	2000      	movs	r0, #0
 80119c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      ep->xfer_len = ep->maxpacket;
 80119c8:	68cc      	ldr	r4, [r1, #12]
 80119ca:	618c      	str	r4, [r1, #24]
 80119cc:	e7e7      	b.n	801199e <USB_EP0StartXfer+0x2a>
    if (ep->xfer_len == 0U)
 80119ce:	698c      	ldr	r4, [r1, #24]
 80119d0:	2c00      	cmp	r4, #0
 80119d2:	d040      	beq.n	8011a56 <USB_EP0StartXfer+0xe2>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80119d4:	eb00 1543 	add.w	r5, r0, r3, lsl #5
 80119d8:	4f41      	ldr	r7, [pc, #260]	; (8011ae0 <USB_EP0StartXfer+0x16c>)
      if (ep->xfer_len > ep->maxpacket)
 80119da:	f8d1 e00c 	ldr.w	lr, [r1, #12]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80119de:	f8d5 c910 	ldr.w	ip, [r5, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80119e2:	4e40      	ldr	r6, [pc, #256]	; (8011ae4 <USB_EP0StartXfer+0x170>)
      if (ep->xfer_len > ep->maxpacket)
 80119e4:	4574      	cmp	r4, lr
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80119e6:	ea0c 0707 	and.w	r7, ip, r7
 80119ea:	f505 6c10 	add.w	ip, r5, #2304	; 0x900
 80119ee:	f8c5 7910 	str.w	r7, [r5, #2320]	; 0x910
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80119f2:	f8d5 7910 	ldr.w	r7, [r5, #2320]	; 0x910
 80119f6:	ea06 0607 	and.w	r6, r6, r7
 80119fa:	f8c5 6910 	str.w	r6, [r5, #2320]	; 0x910
      if (ep->xfer_len > ep->maxpacket)
 80119fe:	d958      	bls.n	8011ab2 <USB_EP0StartXfer+0x13e>
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8011a00:	f8dc 4010 	ldr.w	r4, [ip, #16]
    if (dma == 1U)
 8011a04:	2a01      	cmp	r2, #1
        ep->xfer_len = ep->maxpacket;
 8011a06:	f8c1 e018 	str.w	lr, [r1, #24]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8011a0a:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 8011a0e:	f8cc 4010 	str.w	r4, [ip, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 8011a12:	f3ce 0412 	ubfx	r4, lr, #0, #19
 8011a16:	f8dc 6010 	ldr.w	r6, [ip, #16]
 8011a1a:	ea44 0406 	orr.w	r4, r4, r6
 8011a1e:	f8cc 4010 	str.w	r4, [ip, #16]
    if (dma == 1U)
 8011a22:	d03a      	beq.n	8011a9a <USB_EP0StartXfer+0x126>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8011a24:	f8d5 2900 	ldr.w	r2, [r5, #2304]	; 0x900
 8011a28:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8011a2c:	f8c5 2900 	str.w	r2, [r5, #2304]	; 0x900
      if (ep->xfer_len > 0U)
 8011a30:	f1be 0f00 	cmp.w	lr, #0
 8011a34:	d0c6      	beq.n	80119c4 <USB_EP0StartXfer+0x50>
        USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 8011a36:	f003 010f 	and.w	r1, r3, #15
 8011a3a:	2301      	movs	r3, #1
 8011a3c:	f8d0 2834 	ldr.w	r2, [r0, #2100]	; 0x834
 8011a40:	408b      	lsls	r3, r1
 8011a42:	4313      	orrs	r3, r2
 8011a44:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
}
 8011a48:	2000      	movs	r0, #0
 8011a4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if ((uint32_t)ep->xfer_buff != 0U)
 8011a4c:	690a      	ldr	r2, [r1, #16]
 8011a4e:	2a00      	cmp	r2, #0
 8011a50:	d0b2      	beq.n	80119b8 <USB_EP0StartXfer+0x44>
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 8011a52:	615a      	str	r2, [r3, #20]
 8011a54:	e7b0      	b.n	80119b8 <USB_EP0StartXfer+0x44>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8011a56:	eb00 1043 	add.w	r0, r0, r3, lsl #5
 8011a5a:	4b22      	ldr	r3, [pc, #136]	; (8011ae4 <USB_EP0StartXfer+0x170>)
    if (dma == 1U)
 8011a5c:	2a01      	cmp	r2, #1
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8011a5e:	f8d0 4910 	ldr.w	r4, [r0, #2320]	; 0x910
 8011a62:	f500 6c10 	add.w	ip, r0, #2304	; 0x900
 8011a66:	ea03 0304 	and.w	r3, r3, r4
 8011a6a:	f8cc 3010 	str.w	r3, [ip, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8011a6e:	f8dc 3010 	ldr.w	r3, [ip, #16]
 8011a72:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8011a76:	f8cc 3010 	str.w	r3, [ip, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8011a7a:	4b19      	ldr	r3, [pc, #100]	; (8011ae0 <USB_EP0StartXfer+0x16c>)
 8011a7c:	f8dc 4010 	ldr.w	r4, [ip, #16]
 8011a80:	ea03 0304 	and.w	r3, r3, r4
 8011a84:	f8cc 3010 	str.w	r3, [ip, #16]
    if (dma == 1U)
 8011a88:	d007      	beq.n	8011a9a <USB_EP0StartXfer+0x126>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8011a8a:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8011a8e:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8011a92:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 8011a96:	2000      	movs	r0, #0
 8011a98:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if ((uint32_t)ep->dma_addr != 0U)
 8011a9a:	694b      	ldr	r3, [r1, #20]
 8011a9c:	b10b      	cbz	r3, 8011aa2 <USB_EP0StartXfer+0x12e>
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8011a9e:	f8cc 3014 	str.w	r3, [ip, #20]
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8011aa2:	f8dc 3000 	ldr.w	r3, [ip]
}
 8011aa6:	2000      	movs	r0, #0
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8011aa8:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8011aac:	f8cc 3000 	str.w	r3, [ip]
}
 8011ab0:	bdf0      	pop	{r4, r5, r6, r7, pc}
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8011ab2:	f8dc 6010 	ldr.w	r6, [ip, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 8011ab6:	f3c4 0412 	ubfx	r4, r4, #0, #19
    if (dma == 1U)
 8011aba:	2a01      	cmp	r2, #1
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8011abc:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
 8011ac0:	f8cc 6010 	str.w	r6, [ip, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 8011ac4:	f8dc 6010 	ldr.w	r6, [ip, #16]
 8011ac8:	ea44 0406 	orr.w	r4, r4, r6
 8011acc:	f8cc 4010 	str.w	r4, [ip, #16]
    if (dma == 1U)
 8011ad0:	d0e3      	beq.n	8011a9a <USB_EP0StartXfer+0x126>
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8011ad2:	f8d5 2900 	ldr.w	r2, [r5, #2304]	; 0x900
 8011ad6:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8011ada:	f8c5 2900 	str.w	r2, [r5, #2304]	; 0x900
      if (ep->xfer_len > 0U)
 8011ade:	e7aa      	b.n	8011a36 <USB_EP0StartXfer+0xc2>
 8011ae0:	fff80000 	.word	0xfff80000
 8011ae4:	e007ffff 	.word	0xe007ffff

08011ae8 <USB_EPStopXfer>:
  __IO uint32_t count = 0U;
 8011ae8:	2300      	movs	r3, #0
{
 8011aea:	b082      	sub	sp, #8
  __IO uint32_t count = 0U;
 8011aec:	9301      	str	r3, [sp, #4]
  if (ep->is_in == 1U)
 8011aee:	784b      	ldrb	r3, [r1, #1]
 8011af0:	2b01      	cmp	r3, #1
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8011af2:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 8011af4:	d020      	beq.n	8011b38 <USB_EPStopXfer+0x50>
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8011af6:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
 8011afa:	eb00 1043 	add.w	r0, r0, r3, lsl #5
 8011afe:	6803      	ldr	r3, [r0, #0]
 8011b00:	2b00      	cmp	r3, #0
 8011b02:	db02      	blt.n	8011b0a <USB_EPStopXfer+0x22>
  HAL_StatusTypeDef ret = HAL_OK;
 8011b04:	2000      	movs	r0, #0
}
 8011b06:	b002      	add	sp, #8
 8011b08:	4770      	bx	lr
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
 8011b0a:	6803      	ldr	r3, [r0, #0]
        if (count > 10000U)
 8011b0c:	f242 7210 	movw	r2, #10000	; 0x2710
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
 8011b10:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8011b14:	6003      	str	r3, [r0, #0]
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
 8011b16:	6803      	ldr	r3, [r0, #0]
 8011b18:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8011b1c:	6003      	str	r3, [r0, #0]
 8011b1e:	e002      	b.n	8011b26 <USB_EPStopXfer+0x3e>
      } while (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) ==  USB_OTG_DOEPCTL_EPENA);
 8011b20:	6803      	ldr	r3, [r0, #0]
 8011b22:	2b00      	cmp	r3, #0
 8011b24:	daee      	bge.n	8011b04 <USB_EPStopXfer+0x1c>
        count++;
 8011b26:	9b01      	ldr	r3, [sp, #4]
 8011b28:	3301      	adds	r3, #1
 8011b2a:	9301      	str	r3, [sp, #4]
        if (count > 10000U)
 8011b2c:	9b01      	ldr	r3, [sp, #4]
 8011b2e:	4293      	cmp	r3, r2
 8011b30:	d9f6      	bls.n	8011b20 <USB_EPStopXfer+0x38>
          ret = HAL_ERROR;
 8011b32:	2001      	movs	r0, #1
}
 8011b34:	b002      	add	sp, #8
 8011b36:	4770      	bx	lr
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8011b38:	f500 6010 	add.w	r0, r0, #2304	; 0x900
 8011b3c:	eb00 1343 	add.w	r3, r0, r3, lsl #5
 8011b40:	681a      	ldr	r2, [r3, #0]
 8011b42:	2a00      	cmp	r2, #0
 8011b44:	dade      	bge.n	8011b04 <USB_EPStopXfer+0x1c>
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
 8011b46:	681a      	ldr	r2, [r3, #0]
        if (count > 10000U)
 8011b48:	f242 7110 	movw	r1, #10000	; 0x2710
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
 8011b4c:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 8011b50:	601a      	str	r2, [r3, #0]
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_EPDIS);
 8011b52:	681a      	ldr	r2, [r3, #0]
 8011b54:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8011b58:	601a      	str	r2, [r3, #0]
 8011b5a:	e002      	b.n	8011b62 <USB_EPStopXfer+0x7a>
      } while (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) ==  USB_OTG_DIEPCTL_EPENA);
 8011b5c:	681a      	ldr	r2, [r3, #0]
 8011b5e:	2a00      	cmp	r2, #0
 8011b60:	dad0      	bge.n	8011b04 <USB_EPStopXfer+0x1c>
        count++;
 8011b62:	9a01      	ldr	r2, [sp, #4]
 8011b64:	3201      	adds	r2, #1
 8011b66:	9201      	str	r2, [sp, #4]
        if (count > 10000U)
 8011b68:	9a01      	ldr	r2, [sp, #4]
 8011b6a:	428a      	cmp	r2, r1
 8011b6c:	d9f6      	bls.n	8011b5c <USB_EPStopXfer+0x74>
 8011b6e:	e7e0      	b.n	8011b32 <USB_EPStopXfer+0x4a>

08011b70 <USB_WritePacket>:
{
 8011b70:	b410      	push	{r4}
 8011b72:	f89d 4004 	ldrb.w	r4, [sp, #4]
  if (dma == 0U)
 8011b76:	b964      	cbnz	r4, 8011b92 <USB_WritePacket+0x22>
    count32b = ((uint32_t)len + 3U) / 4U;
 8011b78:	3303      	adds	r3, #3
    for (i = 0U; i < count32b; i++)
 8011b7a:	089b      	lsrs	r3, r3, #2
 8011b7c:	d009      	beq.n	8011b92 <USB_WritePacket+0x22>
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8011b7e:	3201      	adds	r2, #1
 8011b80:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8011b84:	eb00 3002 	add.w	r0, r0, r2, lsl #12
 8011b88:	f851 2b04 	ldr.w	r2, [r1], #4
    for (i = 0U; i < count32b; i++)
 8011b8c:	428b      	cmp	r3, r1
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8011b8e:	6002      	str	r2, [r0, #0]
    for (i = 0U; i < count32b; i++)
 8011b90:	d1fa      	bne.n	8011b88 <USB_WritePacket+0x18>
}
 8011b92:	2000      	movs	r0, #0
 8011b94:	f85d 4b04 	ldr.w	r4, [sp], #4
 8011b98:	4770      	bx	lr
 8011b9a:	bf00      	nop

08011b9c <USB_ReadPacket>:
  for (i = 0U; i < count32b; i++)
 8011b9c:	ea5f 0c92 	movs.w	ip, r2, lsr #2
{
 8011ba0:	b570      	push	{r4, r5, r6, lr}
 8011ba2:	4605      	mov	r5, r0
  uint16_t remaining_bytes = len % 4U;
 8011ba4:	f002 0603 	and.w	r6, r2, #3
  for (i = 0U; i < count32b; i++)
 8011ba8:	d01c      	beq.n	8011be4 <USB_ReadPacket+0x48>
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 8011baa:	f500 5e80 	add.w	lr, r0, #4096	; 0x1000
  uint8_t *pDest = dest;
 8011bae:	460a      	mov	r2, r1
  for (i = 0U; i < count32b; i++)
 8011bb0:	2300      	movs	r3, #0
 8011bb2:	3301      	adds	r3, #1
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 8011bb4:	f8de 4000 	ldr.w	r4, [lr]
  for (i = 0U; i < count32b; i++)
 8011bb8:	459c      	cmp	ip, r3
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 8011bba:	f842 4b04 	str.w	r4, [r2], #4
  for (i = 0U; i < count32b; i++)
 8011bbe:	d1f8      	bne.n	8011bb2 <USB_ReadPacket+0x16>
    pDest++;
 8011bc0:	eb01 008c 	add.w	r0, r1, ip, lsl #2
  if (remaining_bytes != 0U)
 8011bc4:	b16e      	cbz	r6, 8011be2 <USB_ReadPacket+0x46>
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 8011bc6:	f505 5580 	add.w	r5, r5, #4096	; 0x1000
      remaining_bytes--;
 8011bca:	1e73      	subs	r3, r6, #1
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 8011bcc:	682a      	ldr	r2, [r5, #0]
      remaining_bytes--;
 8011bce:	b29b      	uxth	r3, r3
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 8011bd0:	7002      	strb	r2, [r0, #0]
    } while (remaining_bytes != 0U);
 8011bd2:	b12b      	cbz	r3, 8011be0 <USB_ReadPacket+0x44>
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 8011bd4:	0a11      	lsrs	r1, r2, #8
    } while (remaining_bytes != 0U);
 8011bd6:	2b01      	cmp	r3, #1
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 8011bd8:	7041      	strb	r1, [r0, #1]
    } while (remaining_bytes != 0U);
 8011bda:	d001      	beq.n	8011be0 <USB_ReadPacket+0x44>
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 8011bdc:	0c12      	lsrs	r2, r2, #16
 8011bde:	7082      	strb	r2, [r0, #2]
      pDest++;
 8011be0:	4430      	add	r0, r6
}
 8011be2:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t *pDest = dest;
 8011be4:	4608      	mov	r0, r1
 8011be6:	e7ed      	b.n	8011bc4 <USB_ReadPacket+0x28>

08011be8 <USB_EPSetStall>:
  if (ep->is_in == 1U)
 8011be8:	784a      	ldrb	r2, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 8011bea:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 8011bec:	2a01      	cmp	r2, #1
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 8011bee:	eb00 1043 	add.w	r0, r0, r3, lsl #5
  if (ep->is_in == 1U)
 8011bf2:	d00c      	beq.n	8011c0e <USB_EPSetStall+0x26>
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 8011bf4:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	; 0xb00
 8011bf8:	b10b      	cbz	r3, 8011bfe <USB_EPSetStall+0x16>
 8011bfa:	2a00      	cmp	r2, #0
 8011bfc:	da14      	bge.n	8011c28 <USB_EPSetStall+0x40>
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 8011bfe:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8011c02:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8011c06:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 8011c0a:	2000      	movs	r0, #0
 8011c0c:	4770      	bx	lr
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 8011c0e:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
 8011c12:	2a00      	cmp	r2, #0
 8011c14:	db00      	blt.n	8011c18 <USB_EPSetStall+0x30>
 8011c16:	b973      	cbnz	r3, 8011c36 <USB_EPSetStall+0x4e>
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 8011c18:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8011c1c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8011c20:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 8011c24:	2000      	movs	r0, #0
 8011c26:	4770      	bx	lr
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 8011c28:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8011c2c:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8011c30:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 8011c34:	e7e3      	b.n	8011bfe <USB_EPSetStall+0x16>
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 8011c36:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8011c3a:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8011c3e:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 8011c42:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8011c46:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8011c4a:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
 8011c4e:	e7e9      	b.n	8011c24 <USB_EPSetStall+0x3c>

08011c50 <USB_EPClearStall>:
  if (ep->is_in == 1U)
 8011c50:	784a      	ldrb	r2, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 8011c52:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 8011c54:	2a01      	cmp	r2, #1
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8011c56:	eb00 1043 	add.w	r0, r0, r3, lsl #5
  if (ep->is_in == 1U)
 8011c5a:	d013      	beq.n	8011c84 <USB_EPClearStall+0x34>
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8011c5c:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8011c60:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8011c64:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8011c68:	790b      	ldrb	r3, [r1, #4]
 8011c6a:	3b02      	subs	r3, #2
 8011c6c:	2b01      	cmp	r3, #1
 8011c6e:	d901      	bls.n	8011c74 <USB_EPClearStall+0x24>
}
 8011c70:	2000      	movs	r0, #0
 8011c72:	4770      	bx	lr
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8011c74:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8011c78:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8011c7c:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 8011c80:	2000      	movs	r0, #0
 8011c82:	4770      	bx	lr
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8011c84:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8011c88:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8011c8c:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8011c90:	790b      	ldrb	r3, [r1, #4]
 8011c92:	3b02      	subs	r3, #2
 8011c94:	2b01      	cmp	r3, #1
 8011c96:	d8eb      	bhi.n	8011c70 <USB_EPClearStall+0x20>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8011c98:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8011c9c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8011ca0:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 8011ca4:	2000      	movs	r0, #0
 8011ca6:	4770      	bx	lr

08011ca8 <USB_SetDevAddress>:
{
 8011ca8:	4603      	mov	r3, r0
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 8011caa:	0109      	lsls	r1, r1, #4
}
 8011cac:	2000      	movs	r0, #0
  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 8011cae:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 8011cb2:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 8011cb6:	f422 62fe 	bic.w	r2, r2, #2032	; 0x7f0
 8011cba:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 8011cbe:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
 8011cc2:	4311      	orrs	r1, r2
 8011cc4:	f8c3 1800 	str.w	r1, [r3, #2048]	; 0x800
}
 8011cc8:	4770      	bx	lr
 8011cca:	bf00      	nop

08011ccc <USB_DevConnect>:
{
 8011ccc:	4603      	mov	r3, r0
}
 8011cce:	2000      	movs	r0, #0
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 8011cd0:	f8d3 2e00 	ldr.w	r2, [r3, #3584]	; 0xe00
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 8011cd4:	f503 6100 	add.w	r1, r3, #2048	; 0x800
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 8011cd8:	f022 0203 	bic.w	r2, r2, #3
 8011cdc:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 8011ce0:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 8011ce4:	f023 0302 	bic.w	r3, r3, #2
 8011ce8:	604b      	str	r3, [r1, #4]
}
 8011cea:	4770      	bx	lr

08011cec <USB_DevDisconnect>:
{
 8011cec:	4603      	mov	r3, r0
}
 8011cee:	2000      	movs	r0, #0
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 8011cf0:	f8d3 2e00 	ldr.w	r2, [r3, #3584]	; 0xe00
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 8011cf4:	f503 6100 	add.w	r1, r3, #2048	; 0x800
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 8011cf8:	f022 0203 	bic.w	r2, r2, #3
 8011cfc:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 8011d00:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 8011d04:	f043 0302 	orr.w	r3, r3, #2
 8011d08:	604b      	str	r3, [r1, #4]
}
 8011d0a:	4770      	bx	lr

08011d0c <USB_ReadInterrupts>:
  tmpreg = USBx->GINTSTS;
 8011d0c:	6942      	ldr	r2, [r0, #20]
  tmpreg &= USBx->GINTMSK;
 8011d0e:	6980      	ldr	r0, [r0, #24]
}
 8011d10:	4010      	ands	r0, r2
 8011d12:	4770      	bx	lr

08011d14 <USB_ReadDevAllOutEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 8011d14:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8011d18:	f8d0 081c 	ldr.w	r0, [r0, #2076]	; 0x81c
 8011d1c:	4018      	ands	r0, r3
}
 8011d1e:	0c00      	lsrs	r0, r0, #16
 8011d20:	4770      	bx	lr
 8011d22:	bf00      	nop

08011d24 <USB_ReadDevAllInEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 8011d24:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8011d28:	f8d0 081c 	ldr.w	r0, [r0, #2076]	; 0x81c
 8011d2c:	4018      	ands	r0, r3
}
 8011d2e:	b280      	uxth	r0, r0
 8011d30:	4770      	bx	lr
 8011d32:	bf00      	nop

08011d34 <USB_ReadDevOutEPInterrupt>:
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 8011d34:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  tmpreg &= USBx_DEVICE->DOEPMSK;
 8011d38:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 8011d3c:	f8d1 2b08 	ldr.w	r2, [r1, #2824]	; 0xb08
  tmpreg &= USBx_DEVICE->DOEPMSK;
 8011d40:	6940      	ldr	r0, [r0, #20]
}
 8011d42:	4010      	ands	r0, r2
 8011d44:	4770      	bx	lr
 8011d46:	bf00      	nop

08011d48 <USB_ReadDevInEPInterrupt>:
  msk = USBx_DEVICE->DIEPMSK;
 8011d48:	f8d0 2810 	ldr.w	r2, [r0, #2064]	; 0x810
  emp = USBx_DEVICE->DIEPEMPMSK;
 8011d4c:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 8011d50:	eb00 1041 	add.w	r0, r0, r1, lsl #5
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 8011d54:	f001 010f 	and.w	r1, r1, #15
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 8011d58:	f8d0 0908 	ldr.w	r0, [r0, #2312]	; 0x908
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 8011d5c:	40cb      	lsrs	r3, r1
 8011d5e:	01db      	lsls	r3, r3, #7
 8011d60:	b2db      	uxtb	r3, r3
 8011d62:	4313      	orrs	r3, r2
}
 8011d64:	4018      	ands	r0, r3
 8011d66:	4770      	bx	lr

08011d68 <USB_GetMode>:
  return ((USBx->GINTSTS) & 0x1U);
 8011d68:	6940      	ldr	r0, [r0, #20]
}
 8011d6a:	f000 0001 	and.w	r0, r0, #1
 8011d6e:	4770      	bx	lr

08011d70 <USB_ActivateSetup>:
{
 8011d70:	4603      	mov	r3, r0
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8011d72:	4a09      	ldr	r2, [pc, #36]	; (8011d98 <USB_ActivateSetup+0x28>)
}
 8011d74:	2000      	movs	r0, #0
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8011d76:	f503 6100 	add.w	r1, r3, #2048	; 0x800
{
 8011d7a:	b410      	push	{r4}
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8011d7c:	f8d3 4900 	ldr.w	r4, [r3, #2304]	; 0x900
 8011d80:	4022      	ands	r2, r4
}
 8011d82:	f85d 4b04 	ldr.w	r4, [sp], #4
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8011d86:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8011d8a:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 8011d8e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8011d92:	604b      	str	r3, [r1, #4]
}
 8011d94:	4770      	bx	lr
 8011d96:	bf00      	nop
 8011d98:	fffff800 	.word	0xfffff800

08011d9c <USB_EP0_OutStart>:
  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 8011d9c:	4b14      	ldr	r3, [pc, #80]	; (8011df0 <USB_EP0_OutStart+0x54>)
{
 8011d9e:	b410      	push	{r4}
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 8011da0:	6c04      	ldr	r4, [r0, #64]	; 0x40
  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 8011da2:	429c      	cmp	r4, r3
 8011da4:	d81a      	bhi.n	8011ddc <USB_EP0_OutStart+0x40>
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8011da6:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8011daa:	2300      	movs	r3, #0
  if (dma == 1U)
 8011dac:	2901      	cmp	r1, #1
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8011dae:	6103      	str	r3, [r0, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8011db0:	6903      	ldr	r3, [r0, #16]
 8011db2:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8011db6:	6103      	str	r3, [r0, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 8011db8:	6903      	ldr	r3, [r0, #16]
 8011dba:	f043 0318 	orr.w	r3, r3, #24
 8011dbe:	6103      	str	r3, [r0, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 8011dc0:	6903      	ldr	r3, [r0, #16]
 8011dc2:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
 8011dc6:	6103      	str	r3, [r0, #16]
  if (dma == 1U)
 8011dc8:	d104      	bne.n	8011dd4 <USB_EP0_OutStart+0x38>
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 8011dca:	6142      	str	r2, [r0, #20]
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
 8011dcc:	6803      	ldr	r3, [r0, #0]
 8011dce:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 8011dd2:	6003      	str	r3, [r0, #0]
}
 8011dd4:	2000      	movs	r0, #0
 8011dd6:	f85d 4b04 	ldr.w	r4, [sp], #4
 8011dda:	4770      	bx	lr
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8011ddc:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8011de0:	f500 6030 	add.w	r0, r0, #2816	; 0xb00
 8011de4:	2b00      	cmp	r3, #0
 8011de6:	dae0      	bge.n	8011daa <USB_EP0_OutStart+0xe>
}
 8011de8:	2000      	movs	r0, #0
 8011dea:	f85d 4b04 	ldr.w	r4, [sp], #4
 8011dee:	4770      	bx	lr
 8011df0:	4f54300a 	.word	0x4f54300a

08011df4 <HAL_UARTEx_RxEventCallback>:
  Fuzzer_t *pAFLfuzzer = (Fuzzer_t *)AFLfuzzerRegion;
#endif

	BaseType_t xHigherPriorityTaskWoken = pdFALSE;

	if(huart==&huart4)
 8011df4:	4a10      	ldr	r2, [pc, #64]	; (8011e38 <HAL_UARTEx_RxEventCallback+0x44>)
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 8011df6:	2300      	movs	r3, #0
{
 8011df8:	b510      	push	{r4, lr}
	if(huart==&huart4)
 8011dfa:	4282      	cmp	r2, r0
{
 8011dfc:	b084      	sub	sp, #16
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 8011dfe:	9303      	str	r3, [sp, #12]
	if(huart==&huart4)
 8011e00:	d001      	beq.n	8011e06 <HAL_UARTEx_RxEventCallback+0x12>
		//xTaskNotifyFromISR(AFLfuzzer.xTaskTarget,0,eSetValueWithOverwrite, &xHigherPriorityTaskWoken); //notify that data arrived
	}

    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );

}
 8011e02:	b004      	add	sp, #16
 8011e04:	bd10      	pop	{r4, pc}
		modbusRxCount = Size;  //MODBUS_MAX_FRAME_SIZE - DMA1_Channel5->CNDTR;
 8011e06:	4a0d      	ldr	r2, [pc, #52]	; (8011e3c <HAL_UARTEx_RxEventCallback+0x48>)
		xTaskNotifyIndexedFromISR(AFLfuzzer.xTaskFuzzer,2,1,eSetValueWithOverwrite, &xHigherPriorityTaskWoken);
 8011e08:	ac03      	add	r4, sp, #12
 8011e0a:	480d      	ldr	r0, [pc, #52]	; (8011e40 <HAL_UARTEx_RxEventCallback+0x4c>)
 8011e0c:	9300      	str	r3, [sp, #0]
 8011e0e:	2303      	movs	r3, #3
 8011e10:	f8d0 086c 	ldr.w	r0, [r0, #2156]	; 0x86c
 8011e14:	9401      	str	r4, [sp, #4]
		modbusRxCount = Size;  //MODBUS_MAX_FRAME_SIZE - DMA1_Channel5->CNDTR;
 8011e16:	8011      	strh	r1, [r2, #0]
		xTaskNotifyIndexedFromISR(AFLfuzzer.xTaskFuzzer,2,1,eSetValueWithOverwrite, &xHigherPriorityTaskWoken);
 8011e18:	2201      	movs	r2, #1
 8011e1a:	2102      	movs	r1, #2
 8011e1c:	f7f1 fc9c 	bl	8003758 <xTaskGenericNotifyFromISR>
    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 8011e20:	9b03      	ldr	r3, [sp, #12]
 8011e22:	2b00      	cmp	r3, #0
 8011e24:	d0ed      	beq.n	8011e02 <HAL_UARTEx_RxEventCallback+0xe>
 8011e26:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8011e2a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8011e2e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
}
 8011e32:	b004      	add	sp, #16
 8011e34:	bd10      	pop	{r4, pc}
 8011e36:	bf00      	nop
 8011e38:	2401196c 	.word	0x2401196c
 8011e3c:	24031300 	.word	0x24031300
 8011e40:	24026000 	.word	0x24026000

08011e44 <HAL_UART_TxCpltCallback>:
#endif

	BaseType_t xHigherPriorityTaskWoken = pdFALSE;


  if(huart==&huart4)
 8011e44:	4b17      	ldr	r3, [pc, #92]	; (8011ea4 <HAL_UART_TxCpltCallback+0x60>)
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 8011e46:	2200      	movs	r2, #0
{
 8011e48:	b530      	push	{r4, r5, lr}
  if(huart==&huart4)
 8011e4a:	4298      	cmp	r0, r3
{
 8011e4c:	b085      	sub	sp, #20
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 8011e4e:	9203      	str	r2, [sp, #12]
  if(huart==&huart4)
 8011e50:	d001      	beq.n	8011e56 <HAL_UART_TxCpltCallback+0x12>

  }

  portYIELD_FROM_ISR( xHigherPriorityTaskWoken );

}
 8011e52:	b005      	add	sp, #20
 8011e54:	bd30      	pop	{r4, r5, pc}
 8011e56:	4604      	mov	r4, r0
	  while(HAL_UARTEx_ReceiveToIdle_DMA(&huart4, modbusRxTxBuffer, MODBUS_MAX_FRAME_SIZE) != HAL_OK)
 8011e58:	4d13      	ldr	r5, [pc, #76]	; (8011ea8 <HAL_UART_TxCpltCallback+0x64>)
 8011e5a:	e001      	b.n	8011e60 <HAL_UART_TxCpltCallback+0x1c>
	 	  					HAL_UART_DMAStop(&huart4);
 8011e5c:	f7fd ff74 	bl	800fd48 <HAL_UART_DMAStop>
	  while(HAL_UARTEx_ReceiveToIdle_DMA(&huart4, modbusRxTxBuffer, MODBUS_MAX_FRAME_SIZE) != HAL_OK)
 8011e60:	4629      	mov	r1, r5
 8011e62:	f44f 7280 	mov.w	r2, #256	; 0x100
 8011e66:	4620      	mov	r0, r4
 8011e68:	f7ff f8f4 	bl	8011054 <HAL_UARTEx_ReceiveToIdle_DMA>
 8011e6c:	4601      	mov	r1, r0
	 	  					HAL_UART_DMAStop(&huart4);
 8011e6e:	4620      	mov	r0, r4
	  while(HAL_UARTEx_ReceiveToIdle_DMA(&huart4, modbusRxTxBuffer, MODBUS_MAX_FRAME_SIZE) != HAL_OK)
 8011e70:	2900      	cmp	r1, #0
 8011e72:	d1f3      	bne.n	8011e5c <HAL_UART_TxCpltCallback+0x18>
	    modbusRxCount = 0;
 8011e74:	4a0d      	ldr	r2, [pc, #52]	; (8011eac <HAL_UART_TxCpltCallback+0x68>)
	    xTaskNotifyIndexedFromISR(AFLfuzzer.xTaskFuzzer,0,FAULT_NONE_RTOS,eSetValueWithOverwrite, &xHigherPriorityTaskWoken);
 8011e76:	ac03      	add	r4, sp, #12
 8011e78:	480d      	ldr	r0, [pc, #52]	; (8011eb0 <HAL_UART_TxCpltCallback+0x6c>)
 8011e7a:	2303      	movs	r3, #3
 8011e7c:	f8d0 086c 	ldr.w	r0, [r0, #2156]	; 0x86c
 8011e80:	e9cd 1400 	strd	r1, r4, [sp]
	    modbusRxCount = 0;
 8011e84:	8011      	strh	r1, [r2, #0]
	    xTaskNotifyIndexedFromISR(AFLfuzzer.xTaskFuzzer,0,FAULT_NONE_RTOS,eSetValueWithOverwrite, &xHigherPriorityTaskWoken);
 8011e86:	2208      	movs	r2, #8
 8011e88:	f7f1 fc66 	bl	8003758 <xTaskGenericNotifyFromISR>
  portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 8011e8c:	9b03      	ldr	r3, [sp, #12]
 8011e8e:	2b00      	cmp	r3, #0
 8011e90:	d0df      	beq.n	8011e52 <HAL_UART_TxCpltCallback+0xe>
 8011e92:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8011e96:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8011e9a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
}
 8011e9e:	b005      	add	sp, #20
 8011ea0:	bd30      	pop	{r4, r5, pc}
 8011ea2:	bf00      	nop
 8011ea4:	2401196c 	.word	0x2401196c
 8011ea8:	24031200 	.word	0x24031200
 8011eac:	24031300 	.word	0x24031300
 8011eb0:	24026000 	.word	0x24026000

08011eb4 <HAL_UART_ErrorCallback>:



void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 8011eb4:	b538      	push	{r3, r4, r5, lr}

	 if(huart==&huart4)
 8011eb6:	4b0e      	ldr	r3, [pc, #56]	; (8011ef0 <HAL_UART_ErrorCallback+0x3c>)
 8011eb8:	4298      	cmp	r0, r3
 8011eba:	d000      	beq.n	8011ebe <HAL_UART_ErrorCallback+0xa>

  portYIELD_FROM_ISR( xHigherPriorityTaskWoken );

*/

}
 8011ebc:	bd38      	pop	{r3, r4, r5, pc}
 8011ebe:	4604      	mov	r4, r0
	   while(HAL_UARTEx_ReceiveToIdle_DMA(&huart4, modbusRxTxBuffer, MODBUS_MAX_FRAME_SIZE) != HAL_OK)
 8011ec0:	4d0c      	ldr	r5, [pc, #48]	; (8011ef4 <HAL_UART_ErrorCallback+0x40>)
	   HAL_UART_DMAStop(&huart4);
 8011ec2:	f7fd ff41 	bl	800fd48 <HAL_UART_DMAStop>
	   while(HAL_UARTEx_ReceiveToIdle_DMA(&huart4, modbusRxTxBuffer, MODBUS_MAX_FRAME_SIZE) != HAL_OK)
 8011ec6:	e007      	b.n	8011ed8 <HAL_UART_ErrorCallback+0x24>
	  	   HAL_UART_Abort(&huart4);
 8011ec8:	f7fd ffd0 	bl	800fe6c <HAL_UART_Abort>
	  	   HAL_UART_DeInit(&huart4);
 8011ecc:	4620      	mov	r0, r4
 8011ece:	f7fd ff1d 	bl	800fd0c <HAL_UART_DeInit>
	  	   HAL_UART_Init(&huart4);
 8011ed2:	4620      	mov	r0, r4
 8011ed4:	f7fe ff1c 	bl	8010d10 <HAL_UART_Init>
	   while(HAL_UARTEx_ReceiveToIdle_DMA(&huart4, modbusRxTxBuffer, MODBUS_MAX_FRAME_SIZE) != HAL_OK)
 8011ed8:	f44f 7280 	mov.w	r2, #256	; 0x100
 8011edc:	4629      	mov	r1, r5
 8011ede:	4620      	mov	r0, r4
 8011ee0:	f7ff f8b8 	bl	8011054 <HAL_UARTEx_ReceiveToIdle_DMA>
 8011ee4:	4603      	mov	r3, r0
	  	   HAL_UART_Abort(&huart4);
 8011ee6:	4620      	mov	r0, r4
	   while(HAL_UARTEx_ReceiveToIdle_DMA(&huart4, modbusRxTxBuffer, MODBUS_MAX_FRAME_SIZE) != HAL_OK)
 8011ee8:	2b00      	cmp	r3, #0
 8011eea:	d1ed      	bne.n	8011ec8 <HAL_UART_ErrorCallback+0x14>
}
 8011eec:	bd38      	pop	{r3, r4, r5, pc}
 8011eee:	bf00      	nop
 8011ef0:	2401196c 	.word	0x2401196c
 8011ef4:	24031200 	.word	0x24031200

08011ef8 <modbusSlaveHandler>:
    memcpy(&modbusMemory[address], value, len);
}


void modbusSlaveHandler()
{
 8011ef8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	HAL_UART_Transmit_DMA(&huart4, modbusRxTxBuffer, bytesNum);
}

uint8_t modbusSlaveCheckFrameSize(void)
{
    if(modbusRxCount > MODBUS_MIN_FRAME_SIZE)
 8011efc:	4c7a      	ldr	r4, [pc, #488]	; (80120e8 <modbusSlaveHandler+0x1f0>)
 8011efe:	f7f7 fefd 	bl	8009cfc <__sanitizer_cov_trace_pc>
 8011f02:	08e3      	lsrs	r3, r4, #3
 8011f04:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 8011f08:	f993 3000 	ldrsb.w	r3, [r3]
 8011f0c:	b113      	cbz	r3, 8011f14 <modbusSlaveHandler+0x1c>
 8011f0e:	2b01      	cmp	r3, #1
 8011f10:	f340 81df 	ble.w	80122d2 <modbusSlaveHandler+0x3da>
 8011f14:	8825      	ldrh	r5, [r4, #0]
 8011f16:	2d05      	cmp	r5, #5
 8011f18:	d812      	bhi.n	8011f40 <modbusSlaveHandler+0x48>
     SytemCall_2(); // configures serial por to recive data
 8011f1a:	f7f7 feef 	bl	8009cfc <__sanitizer_cov_trace_pc>
 8011f1e:	f7f6 f87f 	bl	8008020 <MPU_SytemCall_2>
     modbusRxCount = 0;
 8011f22:	08e3      	lsrs	r3, r4, #3
 8011f24:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 8011f28:	f993 3000 	ldrsb.w	r3, [r3]
 8011f2c:	b113      	cbz	r3, 8011f34 <modbusSlaveHandler+0x3c>
 8011f2e:	2b01      	cmp	r3, #1
 8011f30:	f340 81cc 	ble.w	80122cc <modbusSlaveHandler+0x3d4>
 8011f34:	2300      	movs	r3, #0
 8011f36:	8023      	strh	r3, [r4, #0]
}
 8011f38:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8011f3c:	f7f7 bede 	b.w	8009cfc <__sanitizer_cov_trace_pc>
    return 0;
}

uint8_t modbusSlaveCheckID(void)
{
    if(modbusRxTxBuffer[0] == MODBUS_SLAVE_ADDRESS)
 8011f40:	4e6a      	ldr	r6, [pc, #424]	; (80120ec <modbusSlaveHandler+0x1f4>)
 8011f42:	f7f7 fedb 	bl	8009cfc <__sanitizer_cov_trace_pc>
 8011f46:	08f3      	lsrs	r3, r6, #3
 8011f48:	f006 0207 	and.w	r2, r6, #7
 8011f4c:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 8011f50:	f993 3000 	ldrsb.w	r3, [r3]
 8011f54:	429a      	cmp	r2, r3
 8011f56:	db02      	blt.n	8011f5e <modbusSlaveHandler+0x66>
 8011f58:	2b00      	cmp	r3, #0
 8011f5a:	f040 81bd 	bne.w	80122d8 <modbusSlaveHandler+0x3e0>
 8011f5e:	7833      	ldrb	r3, [r6, #0]
 8011f60:	2b01      	cmp	r3, #1
 8011f62:	d1da      	bne.n	8011f1a <modbusSlaveHandler+0x22>
    return MODBUS_MIN_FRAME_SIZE;
}

uint16_t modbusSlaveParseFrame(void)
{
    uint8_t command = modbusRxTxBuffer[1];
 8011f64:	f7f7 feca 	bl	8009cfc <__sanitizer_cov_trace_pc>
 8011f68:	4861      	ldr	r0, [pc, #388]	; (80120f0 <modbusSlaveHandler+0x1f8>)
 8011f6a:	08c3      	lsrs	r3, r0, #3
 8011f6c:	f000 0207 	and.w	r2, r0, #7
 8011f70:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 8011f74:	f993 3000 	ldrsb.w	r3, [r3]
 8011f78:	429a      	cmp	r2, r3
 8011f7a:	db02      	blt.n	8011f82 <modbusSlaveHandler+0x8a>
 8011f7c:	b10b      	cbz	r3, 8011f82 <modbusSlaveHandler+0x8a>
 8011f7e:	f7f7 fae3 	bl	8009548 <__asan_report_load1>
 8011f82:	7877      	ldrb	r7, [r6, #1]
    uint16_t answerLen = 0;
    if(command == 0x03)
 8011f84:	2f03      	cmp	r7, #3
 8011f86:	f000 80b9 	beq.w	80120fc <modbusSlaveHandler+0x204>
            }
            modbusRxTxBuffer[2] = regNum << 1;
            answerLen =  MODBUS_MIN_FRAME_SIZE + modbusRxTxBuffer[2];
        }
    }
    else if (command == 0x06)
 8011f8a:	f7f7 feb7 	bl	8009cfc <__sanitizer_cov_trace_pc>
 8011f8e:	2f06      	cmp	r7, #6
 8011f90:	f000 81a5 	beq.w	80122de <modbusSlaveHandler+0x3e6>
        {
            modbusMemory[startAddr] = modbusRxTxBuffer[4] << 8 | modbusRxTxBuffer[5];
            answerLen = modbusRxCount;
        }
    }
    else if(command == 0x10)
 8011f94:	f7f7 feb2 	bl	8009cfc <__sanitizer_cov_trace_pc>
 8011f98:	2f10      	cmp	r7, #16
 8011f9a:	f040 821e 	bne.w	80123da <modbusSlaveHandler+0x4e2>
    {
        uint16_t startAddr = modbusRxTxBuffer[2] << 8 | modbusRxTxBuffer[3];
 8011f9e:	4f55      	ldr	r7, [pc, #340]	; (80120f4 <modbusSlaveHandler+0x1fc>)
 8011fa0:	f7f7 feac 	bl	8009cfc <__sanitizer_cov_trace_pc>
 8011fa4:	08fa      	lsrs	r2, r7, #3
 8011fa6:	1c7b      	adds	r3, r7, #1
 8011fa8:	f102 52dc 	add.w	r2, r2, #461373440	; 0x1b800000
 8011fac:	f992 0000 	ldrsb.w	r0, [r2]
 8011fb0:	08da      	lsrs	r2, r3, #3
 8011fb2:	f102 52dc 	add.w	r2, r2, #461373440	; 0x1b800000
 8011fb6:	f992 1000 	ldrsb.w	r1, [r2]
 8011fba:	f007 0207 	and.w	r2, r7, #7
 8011fbe:	4282      	cmp	r2, r0
 8011fc0:	bfb4      	ite	lt
 8011fc2:	2200      	movlt	r2, #0
 8011fc4:	2201      	movge	r2, #1
 8011fc6:	2800      	cmp	r0, #0
 8011fc8:	bf08      	it	eq
 8011fca:	2200      	moveq	r2, #0
 8011fcc:	2a00      	cmp	r2, #0
 8011fce:	f040 8284 	bne.w	80124da <modbusSlaveHandler+0x5e2>
 8011fd2:	f003 0307 	and.w	r3, r3, #7
 8011fd6:	428b      	cmp	r3, r1
 8011fd8:	bfb4      	ite	lt
 8011fda:	2300      	movlt	r3, #0
 8011fdc:	2301      	movge	r3, #1
 8011fde:	2900      	cmp	r1, #0
 8011fe0:	bf08      	it	eq
 8011fe2:	2300      	moveq	r3, #0
 8011fe4:	2b00      	cmp	r3, #0
 8011fe6:	f040 8278 	bne.w	80124da <modbusSlaveHandler+0x5e2>
 8011fea:	1cb8      	adds	r0, r7, #2
 8011fec:	f8b6 9002 	ldrh.w	r9, [r6, #2]
 8011ff0:	08c3      	lsrs	r3, r0, #3
 8011ff2:	f000 0207 	and.w	r2, r0, #7
 8011ff6:	fa99 f999 	rev16.w	r9, r9
 8011ffa:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 8011ffe:	fa1f f989 	uxth.w	r9, r9
        uint16_t regNum = modbusRxTxBuffer[4] << 8 | modbusRxTxBuffer[5];
 8012002:	f993 1000 	ldrsb.w	r1, [r3]
 8012006:	1cfb      	adds	r3, r7, #3
 8012008:	428a      	cmp	r2, r1
 801200a:	bfb4      	ite	lt
 801200c:	2200      	movlt	r2, #0
 801200e:	2201      	movge	r2, #1
 8012010:	2900      	cmp	r1, #0
 8012012:	ea4f 01d3 	mov.w	r1, r3, lsr #3
 8012016:	bf08      	it	eq
 8012018:	2200      	moveq	r2, #0
 801201a:	f101 51dc 	add.w	r1, r1, #461373440	; 0x1b800000
 801201e:	f991 1000 	ldrsb.w	r1, [r1]
 8012022:	2a00      	cmp	r2, #0
 8012024:	f040 8256 	bne.w	80124d4 <modbusSlaveHandler+0x5dc>
 8012028:	f003 0307 	and.w	r3, r3, #7
 801202c:	428b      	cmp	r3, r1
 801202e:	bfb4      	ite	lt
 8012030:	2300      	movlt	r3, #0
 8012032:	2301      	movge	r3, #1
 8012034:	2900      	cmp	r1, #0
 8012036:	bf08      	it	eq
 8012038:	2300      	moveq	r3, #0
 801203a:	2b00      	cmp	r3, #0
 801203c:	f040 824a 	bne.w	80124d4 <modbusSlaveHandler+0x5dc>
 8012040:	88b5      	ldrh	r5, [r6, #4]
 8012042:	ba6d      	rev16	r5, r5
 8012044:	b2ad      	uxth	r5, r5
        if(((startAddr + regNum) > MODBUS_SLAVE_REGISTERS_NUM) || (regNum > 126))
 8012046:	eb09 0305 	add.w	r3, r9, r5
 801204a:	2b80      	cmp	r3, #128	; 0x80
 801204c:	f300 81f4 	bgt.w	8012438 <modbusSlaveHandler+0x540>
 8012050:	f7f7 fe54 	bl	8009cfc <__sanitizer_cov_trace_pc>
 8012054:	2d7e      	cmp	r5, #126	; 0x7e
 8012056:	f200 81ef 	bhi.w	8012438 <modbusSlaveHandler+0x540>
            answerLen = modbusSlaveErrorSet(0x02);
        else
        {
            for(uint16_t reg = 0; reg < regNum; reg++)
 801205a:	f7f7 fe4f 	bl	8009cfc <__sanitizer_cov_trace_pc>
 801205e:	2d00      	cmp	r5, #0
 8012060:	d03e      	beq.n	80120e0 <modbusSlaveHandler+0x1e8>
 8012062:	f105 38ff 	add.w	r8, r5, #4294967295	; 0xffffffff
 8012066:	4d21      	ldr	r5, [pc, #132]	; (80120ec <modbusSlaveHandler+0x1f4>)
 8012068:	fa1f f888 	uxth.w	r8, r8
 801206c:	eb07 0848 	add.w	r8, r7, r8, lsl #1
 8012070:	4f21      	ldr	r7, [pc, #132]	; (80120f8 <modbusSlaveHandler+0x200>)
 8012072:	eb07 0749 	add.w	r7, r7, r9, lsl #1
            {
                modbusMemory[startAddr + reg] = modbusRxTxBuffer[7 + (reg << 1)] << 8 | modbusRxTxBuffer[8 + (reg << 1)];
 8012076:	f7f7 fe41 	bl	8009cfc <__sanitizer_cov_trace_pc>
 801207a:	1de8      	adds	r0, r5, #7
 801207c:	08c3      	lsrs	r3, r0, #3
 801207e:	f000 0207 	and.w	r2, r0, #7
 8012082:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 8012086:	f993 3000 	ldrsb.w	r3, [r3]
 801208a:	429a      	cmp	r2, r3
 801208c:	db02      	blt.n	8012094 <modbusSlaveHandler+0x19c>
 801208e:	2b00      	cmp	r3, #0
 8012090:	f040 8206 	bne.w	80124a0 <modbusSlaveHandler+0x5a8>
 8012094:	f105 0008 	add.w	r0, r5, #8
 8012098:	f995 3007 	ldrsb.w	r3, [r5, #7]
 801209c:	08c2      	lsrs	r2, r0, #3
 801209e:	f000 0107 	and.w	r1, r0, #7
 80120a2:	021b      	lsls	r3, r3, #8
 80120a4:	f102 52dc 	add.w	r2, r2, #461373440	; 0x1b800000
 80120a8:	f992 2000 	ldrsb.w	r2, [r2]
 80120ac:	4291      	cmp	r1, r2
 80120ae:	db02      	blt.n	80120b6 <modbusSlaveHandler+0x1be>
 80120b0:	2a00      	cmp	r2, #0
 80120b2:	f040 820a 	bne.w	80124ca <modbusSlaveHandler+0x5d2>
 80120b6:	08fa      	lsrs	r2, r7, #3
 80120b8:	f102 52dc 	add.w	r2, r2, #461373440	; 0x1b800000
 80120bc:	f992 1000 	ldrsb.w	r1, [r2]
 80120c0:	7a2a      	ldrb	r2, [r5, #8]
 80120c2:	4313      	orrs	r3, r2
 80120c4:	f007 0207 	and.w	r2, r7, #7
 80120c8:	3201      	adds	r2, #1
 80120ca:	b29b      	uxth	r3, r3
 80120cc:	428a      	cmp	r2, r1
 80120ce:	db02      	blt.n	80120d6 <modbusSlaveHandler+0x1de>
 80120d0:	2900      	cmp	r1, #0
 80120d2:	f040 81fc 	bne.w	80124ce <modbusSlaveHandler+0x5d6>
            for(uint16_t reg = 0; reg < regNum; reg++)
 80120d6:	3502      	adds	r5, #2
                modbusMemory[startAddr + reg] = modbusRxTxBuffer[7 + (reg << 1)] << 8 | modbusRxTxBuffer[8 + (reg << 1)];
 80120d8:	f827 3b02 	strh.w	r3, [r7], #2
            for(uint16_t reg = 0; reg < regNum; reg++)
 80120dc:	4545      	cmp	r5, r8
 80120de:	d1ca      	bne.n	8012076 <modbusSlaveHandler+0x17e>
            answerLen = modbusSlaveErrorSet(0x02);
 80120e0:	2507      	movs	r5, #7
 80120e2:	2706      	movs	r7, #6
 80120e4:	e0c2      	b.n	801226c <modbusSlaveHandler+0x374>
 80120e6:	bf00      	nop
 80120e8:	24031300 	.word	0x24031300
 80120ec:	24031200 	.word	0x24031200
 80120f0:	24031201 	.word	0x24031201
 80120f4:	24031202 	.word	0x24031202
 80120f8:	24031100 	.word	0x24031100
        uint16_t startAddr = modbusRxTxBuffer[2] << 8 | modbusRxTxBuffer[3];
 80120fc:	4fcb      	ldr	r7, [pc, #812]	; (801242c <modbusSlaveHandler+0x534>)
 80120fe:	f7f7 fdfd 	bl	8009cfc <__sanitizer_cov_trace_pc>
 8012102:	08fa      	lsrs	r2, r7, #3
 8012104:	1c7b      	adds	r3, r7, #1
 8012106:	f102 52dc 	add.w	r2, r2, #461373440	; 0x1b800000
 801210a:	f992 0000 	ldrsb.w	r0, [r2]
 801210e:	08da      	lsrs	r2, r3, #3
 8012110:	f102 52dc 	add.w	r2, r2, #461373440	; 0x1b800000
 8012114:	f992 1000 	ldrsb.w	r1, [r2]
 8012118:	f007 0207 	and.w	r2, r7, #7
 801211c:	4282      	cmp	r2, r0
 801211e:	bfb4      	ite	lt
 8012120:	2200      	movlt	r2, #0
 8012122:	2201      	movge	r2, #1
 8012124:	2800      	cmp	r0, #0
 8012126:	bf08      	it	eq
 8012128:	2200      	moveq	r2, #0
 801212a:	2a00      	cmp	r2, #0
 801212c:	f040 81c0 	bne.w	80124b0 <modbusSlaveHandler+0x5b8>
 8012130:	f003 0307 	and.w	r3, r3, #7
 8012134:	428b      	cmp	r3, r1
 8012136:	bfb4      	ite	lt
 8012138:	2300      	movlt	r3, #0
 801213a:	2301      	movge	r3, #1
 801213c:	2900      	cmp	r1, #0
 801213e:	bf08      	it	eq
 8012140:	2300      	moveq	r3, #0
 8012142:	2b00      	cmp	r3, #0
 8012144:	f040 81b4 	bne.w	80124b0 <modbusSlaveHandler+0x5b8>
 8012148:	1cb8      	adds	r0, r7, #2
 801214a:	f8b6 a002 	ldrh.w	sl, [r6, #2]
 801214e:	08c3      	lsrs	r3, r0, #3
 8012150:	f000 0207 	and.w	r2, r0, #7
 8012154:	fa9a fa9a 	rev16.w	sl, sl
 8012158:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 801215c:	fa1f fa8a 	uxth.w	sl, sl
        uint16_t regNum = modbusRxTxBuffer[4] << 8 | modbusRxTxBuffer[5];
 8012160:	f993 1000 	ldrsb.w	r1, [r3]
 8012164:	1cfb      	adds	r3, r7, #3
 8012166:	428a      	cmp	r2, r1
 8012168:	bfb4      	ite	lt
 801216a:	2200      	movlt	r2, #0
 801216c:	2201      	movge	r2, #1
 801216e:	2900      	cmp	r1, #0
 8012170:	ea4f 01d3 	mov.w	r1, r3, lsr #3
 8012174:	bf08      	it	eq
 8012176:	2200      	moveq	r2, #0
 8012178:	f101 51dc 	add.w	r1, r1, #461373440	; 0x1b800000
 801217c:	f991 1000 	ldrsb.w	r1, [r1]
 8012180:	2a00      	cmp	r2, #0
 8012182:	f040 8192 	bne.w	80124aa <modbusSlaveHandler+0x5b2>
 8012186:	f003 0307 	and.w	r3, r3, #7
 801218a:	428b      	cmp	r3, r1
 801218c:	bfb4      	ite	lt
 801218e:	2300      	movlt	r3, #0
 8012190:	2301      	movge	r3, #1
 8012192:	2900      	cmp	r1, #0
 8012194:	bf08      	it	eq
 8012196:	2300      	moveq	r3, #0
 8012198:	2b00      	cmp	r3, #0
 801219a:	f040 8186 	bne.w	80124aa <modbusSlaveHandler+0x5b2>
 801219e:	f8b6 8004 	ldrh.w	r8, [r6, #4]
 80121a2:	fa98 f898 	rev16.w	r8, r8
 80121a6:	fa1f f888 	uxth.w	r8, r8
        if(((startAddr + regNum) > MODBUS_SLAVE_REGISTERS_NUM) || (regNum > 126))
 80121aa:	eb0a 0308 	add.w	r3, sl, r8
 80121ae:	2b80      	cmp	r3, #128	; 0x80
 80121b0:	f300 8129 	bgt.w	8012406 <modbusSlaveHandler+0x50e>
 80121b4:	f7f7 fda2 	bl	8009cfc <__sanitizer_cov_trace_pc>
 80121b8:	f1b8 0f7e 	cmp.w	r8, #126	; 0x7e
 80121bc:	f200 8123 	bhi.w	8012406 <modbusSlaveHandler+0x50e>
            for(uint16_t reg = 0; reg < regNum; reg++)
 80121c0:	f7f7 fd9c 	bl	8009cfc <__sanitizer_cov_trace_pc>
 80121c4:	f1b8 0f00 	cmp.w	r8, #0
 80121c8:	d03c      	beq.n	8012244 <modbusSlaveHandler+0x34c>
 80121ca:	f108 39ff 	add.w	r9, r8, #4294967295	; 0xffffffff
 80121ce:	4b98      	ldr	r3, [pc, #608]	; (8012430 <modbusSlaveHandler+0x538>)
 80121d0:	1ebd      	subs	r5, r7, #2
 80121d2:	fa1f f989 	uxth.w	r9, r9
 80121d6:	eb03 0a4a 	add.w	sl, r3, sl, lsl #1
 80121da:	eb07 0949 	add.w	r9, r7, r9, lsl #1
                modbusRxTxBuffer[3 + (reg << 1)] = (uint8_t)(modbusMemory[startAddr + reg] >> 8);
 80121de:	f7f7 fd8d 	bl	8009cfc <__sanitizer_cov_trace_pc>
 80121e2:	ea4f 03da 	mov.w	r3, sl, lsr #3
 80121e6:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 80121ea:	f993 2000 	ldrsb.w	r2, [r3]
 80121ee:	f00a 0307 	and.w	r3, sl, #7
 80121f2:	3301      	adds	r3, #1
 80121f4:	4293      	cmp	r3, r2
 80121f6:	db02      	blt.n	80121fe <modbusSlaveHandler+0x306>
 80121f8:	2a00      	cmp	r2, #0
 80121fa:	f040 8153 	bne.w	80124a4 <modbusSlaveHandler+0x5ac>
 80121fe:	1ce8      	adds	r0, r5, #3
 8012200:	f83a 3b02 	ldrh.w	r3, [sl], #2
 8012204:	08c2      	lsrs	r2, r0, #3
 8012206:	f000 0c07 	and.w	ip, r0, #7
 801220a:	0a19      	lsrs	r1, r3, #8
 801220c:	f102 52dc 	add.w	r2, r2, #461373440	; 0x1b800000
 8012210:	f992 2000 	ldrsb.w	r2, [r2]
 8012214:	4594      	cmp	ip, r2
 8012216:	db02      	blt.n	801221e <modbusSlaveHandler+0x326>
 8012218:	2a00      	cmp	r2, #0
 801221a:	f040 814d 	bne.w	80124b8 <modbusSlaveHandler+0x5c0>
                modbusRxTxBuffer[4 + (reg << 1)] = (uint8_t)(modbusMemory[startAddr + reg]);
 801221e:	1d28      	adds	r0, r5, #4
                modbusRxTxBuffer[3 + (reg << 1)] = (uint8_t)(modbusMemory[startAddr + reg] >> 8);
 8012220:	70e9      	strb	r1, [r5, #3]
                modbusRxTxBuffer[4 + (reg << 1)] = (uint8_t)(modbusMemory[startAddr + reg]);
 8012222:	b2db      	uxtb	r3, r3
 8012224:	08c2      	lsrs	r2, r0, #3
 8012226:	f000 0107 	and.w	r1, r0, #7
 801222a:	f102 52dc 	add.w	r2, r2, #461373440	; 0x1b800000
 801222e:	f992 2000 	ldrsb.w	r2, [r2]
 8012232:	4291      	cmp	r1, r2
 8012234:	db02      	blt.n	801223c <modbusSlaveHandler+0x344>
 8012236:	2a00      	cmp	r2, #0
 8012238:	f040 8140 	bne.w	80124bc <modbusSlaveHandler+0x5c4>
 801223c:	712b      	strb	r3, [r5, #4]
            for(uint16_t reg = 0; reg < regNum; reg++)
 801223e:	3502      	adds	r5, #2
 8012240:	45a9      	cmp	r9, r5
 8012242:	d1cc      	bne.n	80121de <modbusSlaveHandler+0x2e6>
            modbusRxTxBuffer[2] = regNum << 1;
 8012244:	f7f7 fd5a 	bl	8009cfc <__sanitizer_cov_trace_pc>
 8012248:	08fa      	lsrs	r2, r7, #3
 801224a:	f007 0707 	and.w	r7, r7, #7
 801224e:	ea4f 0348 	mov.w	r3, r8, lsl #1
 8012252:	f102 52dc 	add.w	r2, r2, #461373440	; 0x1b800000
 8012256:	b2db      	uxtb	r3, r3
 8012258:	f992 2000 	ldrsb.w	r2, [r2]
 801225c:	4297      	cmp	r7, r2
 801225e:	db02      	blt.n	8012266 <modbusSlaveHandler+0x36e>
 8012260:	2a00      	cmp	r2, #0
 8012262:	f040 812d 	bne.w	80124c0 <modbusSlaveHandler+0x5c8>
    else
    {
        answerLen = modbusSlaveErrorSet(0x01);
    }
    uint16_t crc = modbusSlaveGetCRC(modbusRxTxBuffer, answerLen - 2);
    modbusRxTxBuffer[answerLen - 2] = crc;
 8012266:	1cdf      	adds	r7, r3, #3
    modbusRxTxBuffer[answerLen - 1] = crc >> 8;
 8012268:	1d1d      	adds	r5, r3, #4
            modbusRxTxBuffer[2] = regNum << 1;
 801226a:	70b3      	strb	r3, [r6, #2]
    modbusRxTxBuffer[answerLen - 2] = crc;
 801226c:	f7f7 fd46 	bl	8009cfc <__sanitizer_cov_trace_pc>
 8012270:	19f0      	adds	r0, r6, r7
 8012272:	08c3      	lsrs	r3, r0, #3
 8012274:	f000 0207 	and.w	r2, r0, #7
 8012278:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 801227c:	f993 3000 	ldrsb.w	r3, [r3]
 8012280:	429a      	cmp	r2, r3
 8012282:	db02      	blt.n	801228a <modbusSlaveHandler+0x392>
 8012284:	2b00      	cmp	r3, #0
 8012286:	f040 811e 	bne.w	80124c6 <modbusSlaveHandler+0x5ce>
 801228a:	23ff      	movs	r3, #255	; 0xff
    modbusRxTxBuffer[answerLen - 1] = crc >> 8;
 801228c:	1970      	adds	r0, r6, r5
    modbusRxTxBuffer[answerLen - 2] = crc;
 801228e:	55f3      	strb	r3, [r6, r7]
    modbusRxTxBuffer[answerLen - 1] = crc >> 8;
 8012290:	08c3      	lsrs	r3, r0, #3
 8012292:	f000 0207 	and.w	r2, r0, #7
 8012296:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 801229a:	f993 3000 	ldrsb.w	r3, [r3]
 801229e:	429a      	cmp	r2, r3
 80122a0:	db02      	blt.n	80122a8 <modbusSlaveHandler+0x3b0>
 80122a2:	2b00      	cmp	r3, #0
 80122a4:	f040 80ed 	bne.w	8012482 <modbusSlaveHandler+0x58a>
 80122a8:	23ff      	movs	r3, #255	; 0xff
 80122aa:	5573      	strb	r3, [r6, r5]
     SytemCall_2(); // configures serial por to recive data
 80122ac:	f7f5 feb8 	bl	8008020 <MPU_SytemCall_2>
     modbusRxCount = 0;
 80122b0:	08e3      	lsrs	r3, r4, #3
 80122b2:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 80122b6:	f993 3000 	ldrsb.w	r3, [r3]
 80122ba:	2b00      	cmp	r3, #0
 80122bc:	f43f ae3a 	beq.w	8011f34 <modbusSlaveHandler+0x3c>
 80122c0:	2b01      	cmp	r3, #1
 80122c2:	f73f ae37 	bgt.w	8011f34 <modbusSlaveHandler+0x3c>
 80122c6:	485b      	ldr	r0, [pc, #364]	; (8012434 <modbusSlaveHandler+0x53c>)
 80122c8:	f7f7 f93a 	bl	8009540 <__asan_report_store2>
 80122cc:	4859      	ldr	r0, [pc, #356]	; (8012434 <modbusSlaveHandler+0x53c>)
 80122ce:	f7f7 f937 	bl	8009540 <__asan_report_store2>
    if(modbusRxCount > MODBUS_MIN_FRAME_SIZE)
 80122d2:	4620      	mov	r0, r4
 80122d4:	f7f7 f93c 	bl	8009550 <__asan_report_load2>
    if(modbusRxTxBuffer[0] == MODBUS_SLAVE_ADDRESS)
 80122d8:	4630      	mov	r0, r6
 80122da:	f7f7 f935 	bl	8009548 <__asan_report_load1>
        uint16_t startAddr = modbusRxTxBuffer[2] << 8 | modbusRxTxBuffer[3];
 80122de:	4f53      	ldr	r7, [pc, #332]	; (801242c <modbusSlaveHandler+0x534>)
 80122e0:	f7f7 fd0c 	bl	8009cfc <__sanitizer_cov_trace_pc>
 80122e4:	ea4f 09d7 	mov.w	r9, r7, lsr #3
 80122e8:	f007 0a07 	and.w	sl, r7, #7
 80122ec:	1c7b      	adds	r3, r7, #1
 80122ee:	f109 59dc 	add.w	r9, r9, #461373440	; 0x1b800000
 80122f2:	f999 2000 	ldrsb.w	r2, [r9]
 80122f6:	4592      	cmp	sl, r2
 80122f8:	bfb4      	ite	lt
 80122fa:	2100      	movlt	r1, #0
 80122fc:	2101      	movge	r1, #1
 80122fe:	2a00      	cmp	r2, #0
 8012300:	ea4f 02d3 	mov.w	r2, r3, lsr #3
 8012304:	bf08      	it	eq
 8012306:	2100      	moveq	r1, #0
 8012308:	f102 52dc 	add.w	r2, r2, #461373440	; 0x1b800000
 801230c:	f992 2000 	ldrsb.w	r2, [r2]
 8012310:	2900      	cmp	r1, #0
 8012312:	f040 80b0 	bne.w	8012476 <modbusSlaveHandler+0x57e>
 8012316:	f003 0307 	and.w	r3, r3, #7
 801231a:	4293      	cmp	r3, r2
 801231c:	bfb4      	ite	lt
 801231e:	2300      	movlt	r3, #0
 8012320:	2301      	movge	r3, #1
 8012322:	2a00      	cmp	r2, #0
 8012324:	bf08      	it	eq
 8012326:	2300      	moveq	r3, #0
 8012328:	2b00      	cmp	r3, #0
 801232a:	f040 80a4 	bne.w	8012476 <modbusSlaveHandler+0x57e>
 801232e:	f8b6 8002 	ldrh.w	r8, [r6, #2]
 8012332:	fa98 f898 	rev16.w	r8, r8
 8012336:	fa1f f888 	uxth.w	r8, r8
        if(startAddr > MODBUS_SLAVE_REGISTERS_NUM)
 801233a:	f1b8 0f80 	cmp.w	r8, #128	; 0x80
 801233e:	f200 808d 	bhi.w	801245c <modbusSlaveHandler+0x564>
            modbusMemory[startAddr] = modbusRxTxBuffer[4] << 8 | modbusRxTxBuffer[5];
 8012342:	f7f7 fcdb 	bl	8009cfc <__sanitizer_cov_trace_pc>
 8012346:	1cb8      	adds	r0, r7, #2
 8012348:	3703      	adds	r7, #3
 801234a:	08c3      	lsrs	r3, r0, #3
 801234c:	f000 0107 	and.w	r1, r0, #7
 8012350:	08fa      	lsrs	r2, r7, #3
 8012352:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 8012356:	f102 52dc 	add.w	r2, r2, #461373440	; 0x1b800000
 801235a:	f993 3000 	ldrsb.w	r3, [r3]
 801235e:	f992 c000 	ldrsb.w	ip, [r2]
 8012362:	4299      	cmp	r1, r3
 8012364:	bfb4      	ite	lt
 8012366:	2200      	movlt	r2, #0
 8012368:	2201      	movge	r2, #1
 801236a:	2b00      	cmp	r3, #0
 801236c:	bf08      	it	eq
 801236e:	2200      	moveq	r2, #0
 8012370:	2a00      	cmp	r2, #0
 8012372:	f040 808d 	bne.w	8012490 <modbusSlaveHandler+0x598>
 8012376:	f007 0207 	and.w	r2, r7, #7
 801237a:	4562      	cmp	r2, ip
 801237c:	bfb4      	ite	lt
 801237e:	2200      	movlt	r2, #0
 8012380:	2201      	movge	r2, #1
 8012382:	f1bc 0f00 	cmp.w	ip, #0
 8012386:	bf08      	it	eq
 8012388:	2200      	moveq	r2, #0
 801238a:	2a00      	cmp	r2, #0
 801238c:	f040 8080 	bne.w	8012490 <modbusSlaveHandler+0x598>
 8012390:	88b2      	ldrh	r2, [r6, #4]
 8012392:	4299      	cmp	r1, r3
 8012394:	ba52      	rev16	r2, r2
 8012396:	db01      	blt.n	801239c <modbusSlaveHandler+0x4a4>
 8012398:	2b00      	cmp	r3, #0
 801239a:	d170      	bne.n	801247e <modbusSlaveHandler+0x586>
 801239c:	08fb      	lsrs	r3, r7, #3
 801239e:	f007 0707 	and.w	r7, r7, #7
 80123a2:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 80123a6:	f993 3000 	ldrsb.w	r3, [r3]
 80123aa:	429f      	cmp	r7, r3
 80123ac:	db01      	blt.n	80123b2 <modbusSlaveHandler+0x4ba>
 80123ae:	2b00      	cmp	r3, #0
 80123b0:	d171      	bne.n	8012496 <modbusSlaveHandler+0x59e>
 80123b2:	491f      	ldr	r1, [pc, #124]	; (8012430 <modbusSlaveHandler+0x538>)
 80123b4:	eb01 0048 	add.w	r0, r1, r8, lsl #1
 80123b8:	08c3      	lsrs	r3, r0, #3
 80123ba:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 80123be:	f993 7000 	ldrsb.w	r7, [r3]
 80123c2:	f000 0307 	and.w	r3, r0, #7
 80123c6:	3301      	adds	r3, #1
 80123c8:	42bb      	cmp	r3, r7
 80123ca:	db01      	blt.n	80123d0 <modbusSlaveHandler+0x4d8>
 80123cc:	2f00      	cmp	r7, #0
 80123ce:	d165      	bne.n	801249c <modbusSlaveHandler+0x5a4>
    modbusRxTxBuffer[answerLen - 2] = crc;
 80123d0:	1eaf      	subs	r7, r5, #2
            modbusMemory[startAddr] = modbusRxTxBuffer[4] << 8 | modbusRxTxBuffer[5];
 80123d2:	f821 2018 	strh.w	r2, [r1, r8, lsl #1]
    modbusRxTxBuffer[answerLen - 1] = crc >> 8;
 80123d6:	3d01      	subs	r5, #1
 80123d8:	e748      	b.n	801226c <modbusSlaveHandler+0x374>
    modbusRxTxBuffer[1] |= 0x80;
 80123da:	f7f7 fc8f 	bl	8009cfc <__sanitizer_cov_trace_pc>
    modbusRxTxBuffer[2] = error;
 80123de:	4813      	ldr	r0, [pc, #76]	; (801242c <modbusSlaveHandler+0x534>)
    modbusRxTxBuffer[1] |= 0x80;
 80123e0:	f067 077f 	orn	r7, r7, #127	; 0x7f
    modbusRxTxBuffer[2] = error;
 80123e4:	08c3      	lsrs	r3, r0, #3
 80123e6:	f000 0207 	and.w	r2, r0, #7
    modbusRxTxBuffer[1] |= 0x80;
 80123ea:	7077      	strb	r7, [r6, #1]
    modbusRxTxBuffer[2] = error;
 80123ec:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 80123f0:	f993 3000 	ldrsb.w	r3, [r3]
 80123f4:	429a      	cmp	r2, r3
 80123f6:	db01      	blt.n	80123fc <modbusSlaveHandler+0x504>
 80123f8:	2b00      	cmp	r3, #0
 80123fa:	d144      	bne.n	8012486 <modbusSlaveHandler+0x58e>
 80123fc:	2301      	movs	r3, #1
 80123fe:	2504      	movs	r5, #4
 8012400:	2703      	movs	r7, #3
 8012402:	70b3      	strb	r3, [r6, #2]
    return MODBUS_MIN_FRAME_SIZE;
 8012404:	e732      	b.n	801226c <modbusSlaveHandler+0x374>
    modbusRxTxBuffer[1] |= 0x80;
 8012406:	f7f7 fc79 	bl	8009cfc <__sanitizer_cov_trace_pc>
 801240a:	2283      	movs	r2, #131	; 0x83
    modbusRxTxBuffer[2] = error;
 801240c:	08fb      	lsrs	r3, r7, #3
 801240e:	f007 0707 	and.w	r7, r7, #7
    modbusRxTxBuffer[1] |= 0x80;
 8012412:	7072      	strb	r2, [r6, #1]
    modbusRxTxBuffer[2] = error;
 8012414:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 8012418:	f993 3000 	ldrsb.w	r3, [r3]
 801241c:	429f      	cmp	r7, r3
 801241e:	db00      	blt.n	8012422 <modbusSlaveHandler+0x52a>
 8012420:	bb9b      	cbnz	r3, 801248a <modbusSlaveHandler+0x592>
 8012422:	2302      	movs	r3, #2
            answerLen = modbusSlaveErrorSet(0x02);
 8012424:	2504      	movs	r5, #4
 8012426:	2703      	movs	r7, #3
    modbusRxTxBuffer[2] = error;
 8012428:	70b3      	strb	r3, [r6, #2]
            answerLen = modbusSlaveErrorSet(0x02);
 801242a:	e71f      	b.n	801226c <modbusSlaveHandler+0x374>
 801242c:	24031202 	.word	0x24031202
 8012430:	24031100 	.word	0x24031100
 8012434:	24031300 	.word	0x24031300
    modbusRxTxBuffer[1] |= 0x80;
 8012438:	f7f7 fc60 	bl	8009cfc <__sanitizer_cov_trace_pc>
 801243c:	2290      	movs	r2, #144	; 0x90
    modbusRxTxBuffer[2] = error;
 801243e:	08fb      	lsrs	r3, r7, #3
 8012440:	f007 0707 	and.w	r7, r7, #7
    modbusRxTxBuffer[1] |= 0x80;
 8012444:	7072      	strb	r2, [r6, #1]
    modbusRxTxBuffer[2] = error;
 8012446:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 801244a:	f993 3000 	ldrsb.w	r3, [r3]
 801244e:	429f      	cmp	r7, r3
 8012450:	dbe7      	blt.n	8012422 <modbusSlaveHandler+0x52a>
 8012452:	2b00      	cmp	r3, #0
 8012454:	d0e5      	beq.n	8012422 <modbusSlaveHandler+0x52a>
 8012456:	4823      	ldr	r0, [pc, #140]	; (80124e4 <modbusSlaveHandler+0x5ec>)
 8012458:	f7f7 f86e 	bl	8009538 <__asan_report_store1>
    modbusRxTxBuffer[1] |= 0x80;
 801245c:	f7f7 fc4e 	bl	8009cfc <__sanitizer_cov_trace_pc>
 8012460:	2386      	movs	r3, #134	; 0x86
 8012462:	7073      	strb	r3, [r6, #1]
    modbusRxTxBuffer[2] = error;
 8012464:	f999 3000 	ldrsb.w	r3, [r9]
 8012468:	459a      	cmp	sl, r3
 801246a:	dbda      	blt.n	8012422 <modbusSlaveHandler+0x52a>
 801246c:	2b00      	cmp	r3, #0
 801246e:	d0d8      	beq.n	8012422 <modbusSlaveHandler+0x52a>
 8012470:	4638      	mov	r0, r7
 8012472:	f7f7 f861 	bl	8009538 <__asan_report_store1>
 8012476:	2102      	movs	r1, #2
 8012478:	4638      	mov	r0, r7
 801247a:	f7f7 f86d 	bl	8009558 <__asan_report_load_n>
            modbusMemory[startAddr] = modbusRxTxBuffer[4] << 8 | modbusRxTxBuffer[5];
 801247e:	f7f7 f863 	bl	8009548 <__asan_report_load1>
    modbusRxTxBuffer[answerLen - 1] = crc >> 8;
 8012482:	f7f7 f859 	bl	8009538 <__asan_report_store1>
    modbusRxTxBuffer[2] = error;
 8012486:	f7f7 f857 	bl	8009538 <__asan_report_store1>
 801248a:	4816      	ldr	r0, [pc, #88]	; (80124e4 <modbusSlaveHandler+0x5ec>)
 801248c:	f7f7 f854 	bl	8009538 <__asan_report_store1>
 8012490:	2102      	movs	r1, #2
 8012492:	f7f7 f861 	bl	8009558 <__asan_report_load_n>
            modbusMemory[startAddr] = modbusRxTxBuffer[4] << 8 | modbusRxTxBuffer[5];
 8012496:	4814      	ldr	r0, [pc, #80]	; (80124e8 <modbusSlaveHandler+0x5f0>)
 8012498:	f7f7 f856 	bl	8009548 <__asan_report_load1>
 801249c:	f7f7 f850 	bl	8009540 <__asan_report_store2>
                modbusMemory[startAddr + reg] = modbusRxTxBuffer[7 + (reg << 1)] << 8 | modbusRxTxBuffer[8 + (reg << 1)];
 80124a0:	f7f7 f852 	bl	8009548 <__asan_report_load1>
                modbusRxTxBuffer[3 + (reg << 1)] = (uint8_t)(modbusMemory[startAddr + reg] >> 8);
 80124a4:	4650      	mov	r0, sl
 80124a6:	f7f7 f853 	bl	8009550 <__asan_report_load2>
 80124aa:	2102      	movs	r1, #2
 80124ac:	f7f7 f854 	bl	8009558 <__asan_report_load_n>
 80124b0:	2102      	movs	r1, #2
 80124b2:	4638      	mov	r0, r7
 80124b4:	f7f7 f850 	bl	8009558 <__asan_report_load_n>
 80124b8:	f7f7 f83e 	bl	8009538 <__asan_report_store1>
                modbusRxTxBuffer[4 + (reg << 1)] = (uint8_t)(modbusMemory[startAddr + reg]);
 80124bc:	f7f7 f83c 	bl	8009538 <__asan_report_store1>
            modbusRxTxBuffer[2] = regNum << 1;
 80124c0:	4808      	ldr	r0, [pc, #32]	; (80124e4 <modbusSlaveHandler+0x5ec>)
 80124c2:	f7f7 f839 	bl	8009538 <__asan_report_store1>
    modbusRxTxBuffer[answerLen - 2] = crc;
 80124c6:	f7f7 f837 	bl	8009538 <__asan_report_store1>
                modbusMemory[startAddr + reg] = modbusRxTxBuffer[7 + (reg << 1)] << 8 | modbusRxTxBuffer[8 + (reg << 1)];
 80124ca:	f7f7 f83d 	bl	8009548 <__asan_report_load1>
 80124ce:	4638      	mov	r0, r7
 80124d0:	f7f7 f836 	bl	8009540 <__asan_report_store2>
 80124d4:	2102      	movs	r1, #2
 80124d6:	f7f7 f83f 	bl	8009558 <__asan_report_load_n>
 80124da:	2102      	movs	r1, #2
 80124dc:	4638      	mov	r0, r7
 80124de:	f7f7 f83b 	bl	8009558 <__asan_report_load_n>
 80124e2:	bf00      	nop
 80124e4:	24031202 	.word	0x24031202
 80124e8:	24031205 	.word	0x24031205

080124ec <SytemCall_1_code>:
{
 80124ec:	b538      	push	{r3, r4, r5, lr}
	modbusRxCount = 0;
 80124ee:	f7f7 fc05 	bl	8009cfc <__sanitizer_cov_trace_pc>
 80124f2:	4a16      	ldr	r2, [pc, #88]	; (801254c <SytemCall_1_code+0x60>)
 80124f4:	08d3      	lsrs	r3, r2, #3
 80124f6:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
 80124fa:	f993 3000 	ldrsb.w	r3, [r3]
 80124fe:	b10b      	cbz	r3, 8012504 <SytemCall_1_code+0x18>
 8012500:	2b01      	cmp	r3, #1
 8012502:	dd20      	ble.n	8012546 <SytemCall_1_code+0x5a>
	HAL_UART_Abort(&huart4);
 8012504:	4812      	ldr	r0, [pc, #72]	; (8012550 <SytemCall_1_code+0x64>)
	modbusRxCount = 0;
 8012506:	2300      	movs	r3, #0
	while(HAL_UARTEx_ReceiveToIdle_DMA(&huart4, modbusRxTxBuffer, MODBUS_MAX_FRAME_SIZE) != HAL_OK)
 8012508:	4d12      	ldr	r5, [pc, #72]	; (8012554 <SytemCall_1_code+0x68>)
 801250a:	4604      	mov	r4, r0
	modbusRxCount = 0;
 801250c:	8013      	strh	r3, [r2, #0]
	HAL_UART_Abort(&huart4);
 801250e:	f7fd fcad 	bl	800fe6c <HAL_UART_Abort>
	HAL_UART_DeInit(&huart4);
 8012512:	4620      	mov	r0, r4
 8012514:	f7fd fbfa 	bl	800fd0c <HAL_UART_DeInit>
	HAL_UART_Init(&huart4);
 8012518:	4620      	mov	r0, r4
 801251a:	f7fe fbf9 	bl	8010d10 <HAL_UART_Init>
	while(HAL_UARTEx_ReceiveToIdle_DMA(&huart4, modbusRxTxBuffer, MODBUS_MAX_FRAME_SIZE) != HAL_OK)
 801251e:	e004      	b.n	801252a <SytemCall_1_code+0x3e>
		  HAL_UART_DMAStop(&huart4);
 8012520:	f7f7 fbec 	bl	8009cfc <__sanitizer_cov_trace_pc>
 8012524:	4620      	mov	r0, r4
 8012526:	f7fd fc0f 	bl	800fd48 <HAL_UART_DMAStop>
	while(HAL_UARTEx_ReceiveToIdle_DMA(&huart4, modbusRxTxBuffer, MODBUS_MAX_FRAME_SIZE) != HAL_OK)
 801252a:	f7f7 fbe7 	bl	8009cfc <__sanitizer_cov_trace_pc>
 801252e:	f44f 7280 	mov.w	r2, #256	; 0x100
 8012532:	4629      	mov	r1, r5
 8012534:	4620      	mov	r0, r4
 8012536:	f7fe fd8d 	bl	8011054 <HAL_UARTEx_ReceiveToIdle_DMA>
 801253a:	2800      	cmp	r0, #0
 801253c:	d1f0      	bne.n	8012520 <SytemCall_1_code+0x34>
}
 801253e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8012542:	f7f7 bbdb 	b.w	8009cfc <__sanitizer_cov_trace_pc>
	modbusRxCount = 0;
 8012546:	4610      	mov	r0, r2
 8012548:	f7f6 fffa 	bl	8009540 <__asan_report_store2>
 801254c:	24031300 	.word	0x24031300
 8012550:	2401196c 	.word	0x2401196c
 8012554:	24031200 	.word	0x24031200

08012558 <SytemCall_2_code>:
{
 8012558:	b538      	push	{r3, r4, r5, lr}
	while(HAL_UARTEx_ReceiveToIdle_DMA(&huart4, modbusRxTxBuffer, MODBUS_MAX_FRAME_SIZE) != HAL_OK)
 801255a:	4d0b      	ldr	r5, [pc, #44]	; (8012588 <SytemCall_2_code+0x30>)
 801255c:	4c0b      	ldr	r4, [pc, #44]	; (801258c <SytemCall_2_code+0x34>)
 801255e:	e004      	b.n	801256a <SytemCall_2_code+0x12>
	 					HAL_UART_DMAStop(&huart4);
 8012560:	f7f7 fbcc 	bl	8009cfc <__sanitizer_cov_trace_pc>
 8012564:	4620      	mov	r0, r4
 8012566:	f7fd fbef 	bl	800fd48 <HAL_UART_DMAStop>
	while(HAL_UARTEx_ReceiveToIdle_DMA(&huart4, modbusRxTxBuffer, MODBUS_MAX_FRAME_SIZE) != HAL_OK)
 801256a:	f7f7 fbc7 	bl	8009cfc <__sanitizer_cov_trace_pc>
 801256e:	f44f 7280 	mov.w	r2, #256	; 0x100
 8012572:	4629      	mov	r1, r5
 8012574:	4620      	mov	r0, r4
 8012576:	f7fe fd6d 	bl	8011054 <HAL_UARTEx_ReceiveToIdle_DMA>
 801257a:	2800      	cmp	r0, #0
 801257c:	d1f0      	bne.n	8012560 <SytemCall_2_code+0x8>
}
 801257e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8012582:	f7f7 bbbb 	b.w	8009cfc <__sanitizer_cov_trace_pc>
 8012586:	bf00      	nop
 8012588:	24031200 	.word	0x24031200
 801258c:	2401196c 	.word	0x2401196c

08012590 <_sub_D_00099_0>:
 8012590:	b508      	push	{r3, lr}
 8012592:	f7f7 fbb3 	bl	8009cfc <__sanitizer_cov_trace_pc>
 8012596:	2101      	movs	r1, #1
 8012598:	4802      	ldr	r0, [pc, #8]	; (80125a4 <_sub_D_00099_0+0x14>)
 801259a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 801259e:	f7f6 bff5 	b.w	800958c <__asan_unregister_globals>
 80125a2:	bf00      	nop
 80125a4:	24008020 	.word	0x24008020

080125a8 <_sub_I_00099_1>:
 80125a8:	b508      	push	{r3, lr}
 80125aa:	f7f7 fba7 	bl	8009cfc <__sanitizer_cov_trace_pc>
 80125ae:	f7f6 ffd7 	bl	8009560 <__asan_init>
 80125b2:	f7f6 ffe9 	bl	8009588 <__asan_version_mismatch_check_v8>
 80125b6:	2101      	movs	r1, #1
 80125b8:	4802      	ldr	r0, [pc, #8]	; (80125c4 <_sub_I_00099_1+0x1c>)
 80125ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80125be:	f7f6 bfe7 	b.w	8009590 <__asan_register_globals>
 80125c2:	bf00      	nop
 80125c4:	24008020 	.word	0x24008020

080125c8 <targetTask>:
#endif


//this is the Modbus task
static void targetTask( void * pvParameters )
{
 80125c8:	b530      	push	{r4, r5, lr}
   //uint16_t *paflbitmap =  (uint16_t *)DTCMRAMORIGIN;
   Fuzzer_t *pAFLfuzzer = (Fuzzer_t *)AFLfuzzerRegion;
   #endif


    AFLfuzzer.xTypeEx = EX_NO_EX;
 80125ca:	4c10      	ldr	r4, [pc, #64]	; (801260c <targetTask+0x44>)
{
 80125cc:	b083      	sub	sp, #12
    AFLfuzzer.xTypeEx = EX_NO_EX;
 80125ce:	2500      	movs	r5, #0
 80125d0:	f884 5874 	strb.w	r5, [r4, #2164]	; 0x874
     * you need a physical connection between UART2 TX (PD5) -> UART4 RX (PD0)
     * reference to physical connectors of Nucleo-H743 https://os.mbed.com/platforms/ST-Nucleo-H743ZI/
     * ****/


    SytemCall_1(); //modbusSlaveHardwareInit();  // this only starts receiving data, the HW is initialized in
 80125d4:	f7f5 fd14 	bl	8008000 <MPU_SytemCall_1>

    xTaskNotifyIndexed(AFLfuzzer.xTaskFuzzer,2,1,eSetValueWithOverwrite); //notify the fuzzer task the target is ready
 80125d8:	2303      	movs	r3, #3
 80125da:	2201      	movs	r2, #1
 80125dc:	2102      	movs	r1, #2
 80125de:	f8d4 086c 	ldr.w	r0, [r4, #2156]	; 0x86c
 80125e2:	9500      	str	r5, [sp, #0]
 80125e4:	f7f5 fefa 	bl	80083dc <MPU_xTaskGenericNotify>

    while(1)
    {


    	ulTaskNotifyTake(pdTRUE, portMAX_DELAY); //wait for data coming from USART
 80125e8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80125ec:	2101      	movs	r1, #1
 80125ee:	2000      	movs	r0, #0
 80125f0:	f7f5 ff34 	bl	800845c <MPU_ulTaskGenericNotifyTake>
        modbusSlaveHandler(); //entry point of DMA Modbus library
 80125f4:	f7ff fc80 	bl	8011ef8 <modbusSlaveHandler>
        xTaskNotifyIndexed(AFLfuzzer.xTaskFuzzer,0,FAULT_NONE_RTOS,eSetValueWithOverwrite);//notify that the test finished
 80125f8:	2303      	movs	r3, #3
 80125fa:	2208      	movs	r2, #8
 80125fc:	2100      	movs	r1, #0
 80125fe:	f8d4 086c 	ldr.w	r0, [r4, #2156]	; 0x86c
 8012602:	9500      	str	r5, [sp, #0]
 8012604:	f7f5 feea 	bl	80083dc <MPU_xTaskGenericNotify>
    while(1)
 8012608:	e7ee      	b.n	80125e8 <targetTask+0x20>
 801260a:	bf00      	nop
 801260c:	24026000 	.word	0x24026000

08012610 <fuzzerTask>:

uint16_t *indexdifP;
uint8_t  bufferDMA[550];

static void fuzzerTask( void * pvParameters )
{
 8012610:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//uint16_t *paflbitmap =  (uint16_t *)DTCMRAMORIGIN;
    Fuzzer_t *pAFLfuzzer = (Fuzzer_t *)AFLfuzzerRegion;
    uint16_t *paflbitmap =  pAFLfuzzer->aflbmp;
    #endif

    indexdifP = &AFLfuzzer.indexdif;
 8012614:	4b4c      	ldr	r3, [pc, #304]	; (8012748 <fuzzerTask+0x138>)
    		   AFLfuzzer.receiving = false;
	           HAL_UART_Receive_IT(&huart3, AFLfuzzer.inputAFL.uxBuffer, 4);
	           //HAL_UARTEx_ReceiveToIdle_DMA(&huart3, bufferDMA, MAX_BUFFER_INPUT);
    #endif
	MX_USB_DEVICE_Init();
	error_cnt = 0;
 8012616:	2600      	movs	r6, #0
	 * 1: Notification from USB USART driver to the fuzzer task when data has arrived
	 * 2: Notification from target to fuzzer to signal readiness to execute the test
	 * ********/

	/**Lets poison the AFLfuzzer structure**/
	uint32_t *HelperShadow =  (uint32_t *)( ((uint32_t)pAFLfuzzer>>3) + McuASAN_CONFIG_APP_MEM_OFFSET);
 8012618:	4f4c      	ldr	r7, [pc, #304]	; (801274c <fuzzerTask+0x13c>)
	uint32_t HelperShadowSize = AFLINPUTREGION_SIZE>>3;
	memset((void *)HelperShadow, 0xff,HelperShadowSize);
	// the only section that should be accessible by the target is the input buffer, so lets un-poison it
	HelperShadow =  (uint32_t *)( ((uint32_t)(&AFLfuzzer.inputAFL.uxBuffer)>>3) + McuASAN_CONFIG_APP_MEM_OFFSET);
	HelperShadowSize = MAX_BUFFER_INPUT>>3;
	memset((void *)HelperShadow, 0x00,HelperShadowSize);
 801261a:	f44f 7480 	mov.w	r4, #256	; 0x100
    indexdifP = &AFLfuzzer.indexdif;
 801261e:	4a4c      	ldr	r2, [pc, #304]	; (8012750 <fuzzerTask+0x140>)
   TaskParameters_t targetTaskParameters =
 8012620:	46b3      	mov	fp, r6
	HelperShadow =  (uint32_t *)( ((uint32_t)(&AFLfuzzer.inputAFL.uxBuffer)>>3) + McuASAN_CONFIG_APP_MEM_OFFSET);
 8012622:	f507 45c0 	add.w	r5, r7, #24576	; 0x6000
   TaskParameters_t targetTaskParameters =
 8012626:	f8df 9158 	ldr.w	r9, [pc, #344]	; 8012780 <fuzzerTask+0x170>
 801262a:	f8df 8158 	ldr.w	r8, [pc, #344]	; 8012784 <fuzzerTask+0x174>
{
 801262e:	ed2d 8b04 	vpush	{d8-d9}
 8012632:	b0ad      	sub	sp, #180	; 0xb4
    indexdifP = &AFLfuzzer.indexdif;
 8012634:	601a      	str	r2, [r3, #0]
	MX_USB_DEVICE_Init();
 8012636:	f001 fa09 	bl	8013a4c <MX_USB_DEVICE_Init>
	error_cnt = 0;
 801263a:	4b46      	ldr	r3, [pc, #280]	; (8012754 <fuzzerTask+0x144>)
	uint32_t *HelperShadow =  (uint32_t *)( ((uint32_t)pAFLfuzzer>>3) + McuASAN_CONFIG_APP_MEM_OFFSET);
 801263c:	08f8      	lsrs	r0, r7, #3
	memset((void *)HelperShadow, 0xff,HelperShadowSize);
 801263e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8012642:	21ff      	movs	r1, #255	; 0xff
	error_cnt = 0;
 8012644:	601e      	str	r6, [r3, #0]
	memset((void *)HelperShadow, 0xff,HelperShadowSize);
 8012646:	f100 50dc 	add.w	r0, r0, #461373440	; 0x1b800000
 801264a:	f001 fe61 	bl	8014310 <memset>
	memset((void *)HelperShadow, 0x00,HelperShadowSize);
 801264e:	4622      	mov	r2, r4
	HelperShadow =  (uint32_t *)( ((uint32_t)(&AFLfuzzer.inputAFL.uxBuffer)>>3) + McuASAN_CONFIG_APP_MEM_OFFSET);
 8012650:	08e8      	lsrs	r0, r5, #3
	memset((void *)HelperShadow, 0x00,HelperShadowSize);
 8012652:	4631      	mov	r1, r6
 8012654:	f100 50dc 	add.w	r0, r0, #461373440	; 0x1b800000
 8012658:	f001 fe5a 	bl	8014310 <memset>

	//the address of the fuzzer  needs access as well
	HelperShadow =  (uint32_t *)( ((uint32_t)(&AFLfuzzer.xTaskFuzzer)>>3) + McuASAN_CONFIG_APP_MEM_OFFSET);
 801265c:	f605 036c 	addw	r3, r5, #2156	; 0x86c
	HelperShadowSize = MAX_BUFFER_INPUT>>3;
	memset((void *)HelperShadow, 0x00,4);

	//these redzones are MPU protected
	memset(redzone1,0xaa,sizeof(redzone1));
 8012660:	4622      	mov	r2, r4
 8012662:	21aa      	movs	r1, #170	; 0xaa
	HelperShadow =  (uint32_t *)( ((uint32_t)(&AFLfuzzer.xTaskFuzzer)>>3) + McuASAN_CONFIG_APP_MEM_OFFSET);
 8012664:	08db      	lsrs	r3, r3, #3
	memset(redzone1,0xaa,sizeof(redzone1));
 8012666:	483c      	ldr	r0, [pc, #240]	; (8012758 <fuzzerTask+0x148>)
	HelperShadow =  (uint32_t *)( ((uint32_t)(&AFLfuzzer.xTaskFuzzer)>>3) + McuASAN_CONFIG_APP_MEM_OFFSET);
 8012668:	f103 53dc 	add.w	r3, r3, #461373440	; 0x1b800000
	memset((void *)HelperShadow, 0x00,4);
 801266c:	601e      	str	r6, [r3, #0]
	memset(redzone1,0xaa,sizeof(redzone1));
 801266e:	f001 fe4f 	bl	8014310 <memset>
	memset(redzone2,0xbb,sizeof(redzone2));
 8012672:	4622      	mov	r2, r4
 8012674:	21bb      	movs	r1, #187	; 0xbb
 8012676:	4839      	ldr	r0, [pc, #228]	; (801275c <fuzzerTask+0x14c>)
 8012678:	f001 fe4a 	bl	8014310 <memset>
	memset(redzone3,0xbb,sizeof(redzone3));
 801267c:	4622      	mov	r2, r4
 801267e:	21bb      	movs	r1, #187	; 0xbb
 8012680:	4837      	ldr	r0, [pc, #220]	; (8012760 <fuzzerTask+0x150>)
 8012682:	f001 fe45 	bl	8014310 <memset>
   TaskParameters_t targetTaskParameters =
 8012686:	2298      	movs	r2, #152	; 0x98
 8012688:	4631      	mov	r1, r6
 801268a:	a806      	add	r0, sp, #24
 801268c:	f001 fe40 	bl	8014310 <memset>
 8012690:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
 8012694:	f44f 7280 	mov.w	r2, #256	; 0x100
   xTaskCreateRestricted( &( targetTaskParameters ), &AFLfuzzer.xTaskTarget );
 8012698:	f505 6107 	add.w	r1, r5, #2160	; 0x870
   TaskParameters_t targetTaskParameters =
 801269c:	930c      	str	r3, [sp, #48]	; 0x30
   xTaskCreateRestricted( &( targetTaskParameters ), &AFLfuzzer.xTaskTarget );
 801269e:	a804      	add	r0, sp, #16
   TaskParameters_t targetTaskParameters =
 80126a0:	9312      	str	r3, [sp, #72]	; 0x48
 80126a2:	9318      	str	r3, [sp, #96]	; 0x60
 80126a4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80126a8:	9417      	str	r4, [sp, #92]	; 0x5c
 80126aa:	930b      	str	r3, [sp, #44]	; 0x2c
 80126ac:	9311      	str	r3, [sp, #68]	; 0x44
 80126ae:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80126b2:	970a      	str	r7, [sp, #40]	; 0x28
 80126b4:	f8ad 3018 	strh.w	r3, [sp, #24]
 80126b8:	2314      	movs	r3, #20
 80126ba:	f8cd 9010 	str.w	r9, [sp, #16]
 80126be:	9308      	str	r3, [sp, #32]
 80126c0:	4b28      	ldr	r3, [pc, #160]	; (8012764 <fuzzerTask+0x154>)
 80126c2:	f8cd 8014 	str.w	r8, [sp, #20]
 80126c6:	9309      	str	r3, [sp, #36]	; 0x24
 80126c8:	4b27      	ldr	r3, [pc, #156]	; (8012768 <fuzzerTask+0x158>)
 80126ca:	930d      	str	r3, [sp, #52]	; 0x34
 80126cc:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 80126d0:	9310      	str	r3, [sp, #64]	; 0x40
 80126d2:	4b26      	ldr	r3, [pc, #152]	; (801276c <fuzzerTask+0x15c>)
 80126d4:	9313      	str	r3, [sp, #76]	; 0x4c
 80126d6:	4b26      	ldr	r3, [pc, #152]	; (8012770 <fuzzerTask+0x160>)
 80126d8:	9316      	str	r3, [sp, #88]	; 0x58
 80126da:	4b26      	ldr	r3, [pc, #152]	; (8012774 <fuzzerTask+0x164>)
 80126dc:	9319      	str	r3, [sp, #100]	; 0x64
 80126de:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
 80126e2:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
 80126e6:	e9cd 231a 	strd	r2, r3, [sp, #104]	; 0x68
 80126ea:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80126ee:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
 80126f2:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
   xTaskCreateRestricted( &( targetTaskParameters ), &AFLfuzzer.xTaskTarget );
 80126f6:	f7f0 fbf3 	bl	8002ee0 <xTaskCreateRestricted>

	numberofcycles = 0;
	spawnNewTarget(); // we pass 0 since we don't need to delete the semaphore the first time
	// wait for the target task notification when ready
	ulTaskNotifyTakeIndexed(2,pdTRUE, TARGET_TIMEOUT/2);
 80126fa:	220a      	movs	r2, #10
 80126fc:	2101      	movs	r1, #1
 80126fe:	2002      	movs	r0, #2
 8012700:	f7f5 feac 	bl	800845c <MPU_ulTaskGenericNotifyTake>

	for( ; ; )
	{

		// we will wait for a notification on index 1 when fuzzing data has arrived through USB-CDC
		ulTaskNotifyTakeIndexed(1,pdTRUE, portMAX_DELAY);
 8012704:	2101      	movs	r1, #1
 8012706:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   xTaskCreateRestricted( &( targetTaskParameters ), &AFLfuzzer.xTaskTarget );
 801270a:	f8df a070 	ldr.w	sl, [pc, #112]	; 801277c <fuzzerTask+0x16c>
		ulTaskNotifyTakeIndexed(1,pdTRUE, portMAX_DELAY);
 801270e:	4608      	mov	r0, r1
 8012710:	f7f5 fea4 	bl	800845c <MPU_ulTaskGenericNotifyTake>
		{

			//send the payload through USART2 TX  pin PD5
			HAL_UART_Transmit(&huart2,&AFLfuzzer.inputAFL.uxBuffer[4] , AFLfuzzer.inputAFL.u32availablenopad-4, 100);
 8012714:	f8d5 280c 	ldr.w	r2, [r5, #2060]	; 0x80c
 8012718:	2364      	movs	r3, #100	; 0x64
 801271a:	f6aa 016c 	subw	r1, sl, #2156	; 0x86c
 801271e:	3a04      	subs	r2, #4
 8012720:	4815      	ldr	r0, [pc, #84]	; (8012778 <fuzzerTask+0x168>)
 8012722:	b292      	uxth	r2, r2
 8012724:	f7fe fa28 	bl	8010b78 <HAL_UART_Transmit>
   TaskParameters_t targetTaskParameters =
 8012728:	ed9f 9b03 	vldr	d9, [pc, #12]	; 8012738 <fuzzerTask+0x128>
 801272c:	ed9f 8b04 	vldr	d8, [pc, #16]	; 8012740 <fuzzerTask+0x130>
			while(ulTaskNotifyTakeIndexed(2,pdTRUE, TARGET_TIMEOUT) != 1) //check if data was received by the target through USART on index 2
 8012730:	e06f      	b.n	8012812 <fuzzerTask+0x202>
 8012732:	bf00      	nop
 8012734:	f3af 8000 	nop.w
 8012738:	00002000 	.word	0x00002000
 801273c:	03000000 	.word	0x03000000
 8012740:	00000100 	.word	0x00000100
 8012744:	03000000 	.word	0x03000000
 8012748:	24031004 	.word	0x24031004
 801274c:	24020000 	.word	0x24020000
 8012750:	24026862 	.word	0x24026862
 8012754:	24031000 	.word	0x24031000
 8012758:	24031400 	.word	0x24031400
 801275c:	24031500 	.word	0x24031500
 8012760:	24031600 	.word	0x24031600
 8012764:	24032000 	.word	0x24032000
 8012768:	24036000 	.word	0x24036000
 801276c:	24031100 	.word	0x24031100
 8012770:	24031200 	.word	0x24031200
 8012774:	24031300 	.word	0x24031300
 8012778:	2401184c 	.word	0x2401184c
 801277c:	24026870 	.word	0x24026870
 8012780:	080125c9 	.word	0x080125c9
 8012784:	2400833c 	.word	0x2400833c
			{
				//if we do not receive  a confirmation we delete and recreate the target
				// the target will reconfigure USART4 in RX DMA mode
				 vTaskDelete(AFLfuzzer.xTaskTarget);
 8012788:	f8d5 0870 	ldr.w	r0, [r5, #2160]	; 0x870
 801278c:	f7f5 fcd4 	bl	8008138 <MPU_vTaskDelete>
				 taskYIELD(); //lets the kernel clean the TCB
 8012790:	df01      	svc	1
   TaskParameters_t targetTaskParameters =
 8012792:	2298      	movs	r2, #152	; 0x98
 8012794:	2100      	movs	r1, #0
 8012796:	a806      	add	r0, sp, #24
				 numberofcycles = 0;
 8012798:	2600      	movs	r6, #0
   TaskParameters_t targetTaskParameters =
 801279a:	f001 fdb9 	bl	8014310 <memset>
 801279e:	4bb8      	ldr	r3, [pc, #736]	; (8012a80 <fuzzerTask+0x470>)
   xTaskCreateRestricted( &( targetTaskParameters ), &AFLfuzzer.xTaskTarget );
 80127a0:	4651      	mov	r1, sl
 80127a2:	a804      	add	r0, sp, #16
   TaskParameters_t targetTaskParameters =
 80127a4:	e9cd 3709 	strd	r3, r7, [sp, #36]	; 0x24
 80127a8:	4bb6      	ldr	r3, [pc, #728]	; (8012a84 <fuzzerTask+0x474>)
 80127aa:	930d      	str	r3, [sp, #52]	; 0x34
 80127ac:	4bb6      	ldr	r3, [pc, #728]	; (8012a88 <fuzzerTask+0x478>)
 80127ae:	9313      	str	r3, [sp, #76]	; 0x4c
 80127b0:	4bb6      	ldr	r3, [pc, #728]	; (8012a8c <fuzzerTask+0x47c>)
 80127b2:	9316      	str	r3, [sp, #88]	; 0x58
 80127b4:	4bb6      	ldr	r3, [pc, #728]	; (8012a90 <fuzzerTask+0x480>)
 80127b6:	9319      	str	r3, [sp, #100]	; 0x64
 80127b8:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
 80127bc:	930c      	str	r3, [sp, #48]	; 0x30
 80127be:	9312      	str	r3, [sp, #72]	; 0x48
 80127c0:	9318      	str	r3, [sp, #96]	; 0x60
 80127c2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80127c6:	930b      	str	r3, [sp, #44]	; 0x2c
 80127c8:	9311      	str	r3, [sp, #68]	; 0x44
 80127ca:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80127ce:	f8ad 3018 	strh.w	r3, [sp, #24]
 80127d2:	2314      	movs	r3, #20
 80127d4:	9308      	str	r3, [sp, #32]
 80127d6:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 80127da:	9310      	str	r3, [sp, #64]	; 0x40
 80127dc:	f44f 7380 	mov.w	r3, #256	; 0x100
 80127e0:	e9cd 9804 	strd	r9, r8, [sp, #16]
 80127e4:	9317      	str	r3, [sp, #92]	; 0x5c
 80127e6:	ed8d 9b0e 	vstr	d9, [sp, #56]	; 0x38
 80127ea:	ed8d 8b14 	vstr	d8, [sp, #80]	; 0x50
 80127ee:	ed8d 8b1a 	vstr	d8, [sp, #104]	; 0x68
   xTaskCreateRestricted( &( targetTaskParameters ), &AFLfuzzer.xTaskTarget );
 80127f2:	f7f0 fb75 	bl	8002ee0 <xTaskCreateRestricted>
				 spawnNewTarget();
				 // wait for the target task notification when ready
				 ulTaskNotifyTakeIndexed(2,pdTRUE, TARGET_TIMEOUT/2);
 80127f6:	220a      	movs	r2, #10
 80127f8:	2101      	movs	r1, #1
 80127fa:	2002      	movs	r0, #2
 80127fc:	f7f5 fe2e 	bl	800845c <MPU_ulTaskGenericNotifyTake>
				 //send the payload through USART TX  pin PD5
				 HAL_UART_Transmit(&huart2,&AFLfuzzer.inputAFL.uxBuffer[4] , AFLfuzzer.inputAFL.u32availablenopad-4, 100);
 8012800:	f8d5 280c 	ldr.w	r2, [r5, #2060]	; 0x80c
 8012804:	2364      	movs	r3, #100	; 0x64
 8012806:	49a3      	ldr	r1, [pc, #652]	; (8012a94 <fuzzerTask+0x484>)
 8012808:	3a04      	subs	r2, #4
 801280a:	48a3      	ldr	r0, [pc, #652]	; (8012a98 <fuzzerTask+0x488>)
 801280c:	b292      	uxth	r2, r2
 801280e:	f7fe f9b3 	bl	8010b78 <HAL_UART_Transmit>
			while(ulTaskNotifyTakeIndexed(2,pdTRUE, TARGET_TIMEOUT) != 1) //check if data was received by the target through USART on index 2
 8012812:	2214      	movs	r2, #20
 8012814:	2101      	movs	r1, #1
 8012816:	2002      	movs	r0, #2
 8012818:	f7f5 fe20 	bl	800845c <MPU_ulTaskGenericNotifyTake>
 801281c:	2801      	cmp	r0, #1
 801281e:	d1b3      	bne.n	8012788 <fuzzerTask+0x178>
				 refreshtarget = 0;

			}


			AFLfuzzer.previousGuard = 0;
 8012820:	4604      	mov	r4, r0
			memset(paflbitmap, 0, AFL_BITMAP_SIZE_BYTES);
 8012822:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8012826:	2100      	movs	r1, #0
 8012828:	489c      	ldr	r0, [pc, #624]	; (8012a9c <fuzzerTask+0x48c>)
			AFLfuzzer.previousGuard = 0;
 801282a:	f8a5 b858 	strh.w	fp, [r5, #2136]	; 0x858
			memset(paflbitmap, 0, AFL_BITMAP_SIZE_BYTES);
 801282e:	f001 fd6f 	bl	8014310 <memset>
			memset(AFLfuzzer.afldiff,0,AFL_BITMAP_SIZE_BYTES/4);
 8012832:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8012836:	2100      	movs	r1, #0
 8012838:	4899      	ldr	r0, [pc, #612]	; (8012aa0 <fuzzerTask+0x490>)
 801283a:	f001 fd69 	bl	8014310 <memset>


			// notify the MODBUS task (target) that data has arrived through USART
			// we need this synchronization back and forward for robustness when working with real peripherals
			// and channels that can trigger hardware errors and hang during fuzzing
			 xTaskNotify(AFLfuzzer.xTaskTarget,0,eSetValueWithOverwrite);
 801283e:	2200      	movs	r2, #0
 8012840:	f8cd b000 	str.w	fp, [sp]
 8012844:	2303      	movs	r3, #3
 8012846:	4611      	mov	r1, r2
 8012848:	f8d5 0870 	ldr.w	r0, [r5, #2160]	; 0x870
			AFLfuzzer.indexdif = 0;
 801284c:	f8a5 b862 	strh.w	fp, [r5, #2146]	; 0x862
			 xTaskNotify(AFLfuzzer.xTaskTarget,0,eSetValueWithOverwrite);
 8012850:	f7f5 fdc4 	bl	80083dc <MPU_xTaskGenericNotify>

			 //we will wait on Index 0 for notification from target task when testing finished
			 notificationvalue = ulTaskNotifyTakeIndexed(0,pdTRUE, TARGET_TIMEOUT);
 8012854:	2214      	movs	r2, #20
 8012856:	4621      	mov	r1, r4
 8012858:	2000      	movs	r0, #0
 801285a:	f7f5 fdff 	bl	800845c <MPU_ulTaskGenericNotifyTake>

			 if (notificationvalue == 0) // TIMEOUT
 801285e:	4682      	mov	sl, r0
 8012860:	2800      	cmp	r0, #0
 8012862:	f000 8097 	beq.w	8012994 <fuzzerTask+0x384>
				 // wait for the target task notification when ready
				 ulTaskNotifyTakeIndexed(2,pdTRUE, TARGET_TIMEOUT/2);


			 }
			 else if(notificationvalue == FAULT_ASAN)
 8012866:	2809      	cmp	r0, #9
 8012868:	f000 8130 	beq.w	8012acc <fuzzerTask+0x4bc>
				  printf("ASAN violation %s \n", (char *)EX_str[AFLfuzzer.xTypeEx]);
				  vTaskDelete(AFLfuzzer.xTaskTarget);
				  taskYIELD();
				  refreshtarget = 1;
			 }
			 else if(notificationvalue == FAULT_CRASH)
 801286c:	2802      	cmp	r0, #2
 801286e:	f000 80f5 	beq.w	8012a5c <fuzzerTask+0x44c>
				 numberofcycles = 0;
				 refreshtarget = 1;


			 }
			 else if (notificationvalue == FAULT_NONE_RTOS)
 8012872:	2808      	cmp	r0, #8
 8012874:	f000 80ea 	beq.w	8012a4c <fuzzerTask+0x43c>
				 // we need this because 0 means timeout for the RTOS notification system
				notificationvalue = FAULT_NONE;
				AFLfuzzer.aflheader[0] = notificationvalue;

#if PERSISTENT_MODE
				numberofcycles++;
 8012878:	3601      	adds	r6, #1
			 ulTaskNotifyTakeIndexed(1,pdTRUE, 10);


#if PERSISTENT_MODE
				numberofcycles++;
				if(numberofcycles>=FUZZING_CYCLES_IN_PROCESS && refreshtarget==0)
 801287a:	f5b6 7f7a 	cmp.w	r6, #1000	; 0x3e8
 801287e:	f04f 0300 	mov.w	r3, #0
 8012882:	bf34      	ite	cc
 8012884:	f04f 0a00 	movcc.w	sl, #0
 8012888:	f04f 0a01 	movcs.w	sl, #1
 801288c:	9303      	str	r3, [sp, #12]
			 AFLfuzzer.aflheader[1] = (AFLfuzzer.indexdif * sizeof(tuple_t)  + 4 );
 801288e:	f8b5 4862 	ldrh.w	r4, [r5, #2146]	; 0x862
			 uint32_t uwCRCValue = HAL_CRC_Calculate(&hcrc, (uint32_t *)AFLfuzzer.aflheader, 2);
 8012892:	2202      	movs	r2, #2
 8012894:	4983      	ldr	r1, [pc, #524]	; (8012aa4 <fuzzerTask+0x494>)
			 AFLfuzzer.aflheader[1] = (AFLfuzzer.indexdif * sizeof(tuple_t)  + 4 );
 8012896:	3401      	adds	r4, #1
			 uint32_t uwCRCValue = HAL_CRC_Calculate(&hcrc, (uint32_t *)AFLfuzzer.aflheader, 2);
 8012898:	4883      	ldr	r0, [pc, #524]	; (8012aa8 <fuzzerTask+0x498>)
			 AFLfuzzer.aflheader[1] = (AFLfuzzer.indexdif * sizeof(tuple_t)  + 4 );
 801289a:	fa04 f302 	lsl.w	r3, r4, r2
 801289e:	f8c5 3818 	str.w	r3, [r5, #2072]	; 0x818
			 uint32_t uwCRCValue = HAL_CRC_Calculate(&hcrc, (uint32_t *)AFLfuzzer.aflheader, 2);
 80128a2:	f7f8 fba5 	bl	800aff0 <HAL_CRC_Calculate>
			 uwCRCValue = HAL_CRC_Accumulate(&hcrc, (uint32_t *)auxdiff, AFLfuzzer.indexdif);
 80128a6:	f8b5 2862 	ldrh.w	r2, [r5, #2146]	; 0x862
 80128aa:	4980      	ldr	r1, [pc, #512]	; (8012aac <fuzzerTask+0x49c>)
 80128ac:	487e      	ldr	r0, [pc, #504]	; (8012aa8 <fuzzerTask+0x498>)
 80128ae:	f7f8 fb5d 	bl	800af6c <HAL_CRC_Accumulate>
			 crcbytes->vuint32 = ~uwCRCValue; //write the CRC at the end of the buffer
 80128b2:	4b7b      	ldr	r3, [pc, #492]	; (8012aa0 <fuzzerTask+0x490>)
 80128b4:	43c0      	mvns	r0, r0
			 CDC_Transmit_FS((uint8_t *)AFLfuzzer.aflheader, 8);
 80128b6:	2108      	movs	r1, #8
			 crcbytes->vuint32 = ~uwCRCValue; //write the CRC at the end of the buffer
 80128b8:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
			 CDC_Transmit_FS((uint8_t *)AFLfuzzer.aflheader, 8);
 80128bc:	4879      	ldr	r0, [pc, #484]	; (8012aa4 <fuzzerTask+0x494>)
			 AFLfuzzer.bTXcomplete = false;
 80128be:	f885 b865 	strb.w	fp, [r5, #2149]	; 0x865
			 CDC_Transmit_FS((uint8_t *)AFLfuzzer.aflheader, 8);
 80128c2:	f001 f949 	bl	8013b58 <CDC_Transmit_FS>
			 ulTaskNotifyTakeIndexed(1,pdTRUE, 10);
 80128c6:	2101      	movs	r1, #1
 80128c8:	220a      	movs	r2, #10
 80128ca:	4608      	mov	r0, r1
 80128cc:	f7f5 fdc6 	bl	800845c <MPU_ulTaskGenericNotifyTake>
			 CDC_Transmit_FS((uint8_t *)auxdiff, AFLfuzzer.aflheader[1]);
 80128d0:	f8b5 1818 	ldrh.w	r1, [r5, #2072]	; 0x818
 80128d4:	4875      	ldr	r0, [pc, #468]	; (8012aac <fuzzerTask+0x49c>)
			 AFLfuzzer.bTXcomplete = false;
 80128d6:	f885 b865 	strb.w	fp, [r5, #2149]	; 0x865
			 CDC_Transmit_FS((uint8_t *)auxdiff, AFLfuzzer.aflheader[1]);
 80128da:	f001 f93d 	bl	8013b58 <CDC_Transmit_FS>
			 ulTaskNotifyTakeIndexed(1,pdTRUE, 10);
 80128de:	2101      	movs	r1, #1
 80128e0:	220a      	movs	r2, #10
 80128e2:	4608      	mov	r0, r1
 80128e4:	f7f5 fdba 	bl	800845c <MPU_ulTaskGenericNotifyTake>
				if(numberofcycles>=FUZZING_CYCLES_IN_PROCESS && refreshtarget==0)
 80128e8:	f1ba 0f00 	cmp.w	sl, #0
 80128ec:	f040 809e 	bne.w	8012a2c <fuzzerTask+0x41c>
#if PERSISTENT_MODE
				}
#endif


			 if(refreshtarget)
 80128f0:	9b03      	ldr	r3, [sp, #12]
 80128f2:	2b00      	cmp	r3, #0
 80128f4:	d03d      	beq.n	8012972 <fuzzerTask+0x362>
   TaskParameters_t targetTaskParameters =
 80128f6:	2298      	movs	r2, #152	; 0x98
 80128f8:	2100      	movs	r1, #0
 80128fa:	a806      	add	r0, sp, #24
 80128fc:	f001 fd08 	bl	8014310 <memset>
 8012900:	4b5f      	ldr	r3, [pc, #380]	; (8012a80 <fuzzerTask+0x470>)
 8012902:	f44f 7280 	mov.w	r2, #256	; 0x100
   xTaskCreateRestricted( &( targetTaskParameters ), &AFLfuzzer.xTaskTarget );
 8012906:	496a      	ldr	r1, [pc, #424]	; (8012ab0 <fuzzerTask+0x4a0>)
 8012908:	a804      	add	r0, sp, #16
   TaskParameters_t targetTaskParameters =
 801290a:	e9cd 3709 	strd	r3, r7, [sp, #36]	; 0x24
 801290e:	4b5d      	ldr	r3, [pc, #372]	; (8012a84 <fuzzerTask+0x474>)
 8012910:	930d      	str	r3, [sp, #52]	; 0x34
 8012912:	4b5d      	ldr	r3, [pc, #372]	; (8012a88 <fuzzerTask+0x478>)
 8012914:	9313      	str	r3, [sp, #76]	; 0x4c
 8012916:	4b5d      	ldr	r3, [pc, #372]	; (8012a8c <fuzzerTask+0x47c>)
 8012918:	9316      	str	r3, [sp, #88]	; 0x58
 801291a:	4b5d      	ldr	r3, [pc, #372]	; (8012a90 <fuzzerTask+0x480>)
 801291c:	9319      	str	r3, [sp, #100]	; 0x64
 801291e:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
 8012922:	930c      	str	r3, [sp, #48]	; 0x30
 8012924:	9312      	str	r3, [sp, #72]	; 0x48
 8012926:	9318      	str	r3, [sp, #96]	; 0x60
 8012928:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 801292c:	930b      	str	r3, [sp, #44]	; 0x2c
 801292e:	9311      	str	r3, [sp, #68]	; 0x44
 8012930:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8012934:	f8ad 3018 	strh.w	r3, [sp, #24]
 8012938:	2314      	movs	r3, #20
 801293a:	9308      	str	r3, [sp, #32]
 801293c:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 8012940:	9310      	str	r3, [sp, #64]	; 0x40
 8012942:	f44f 7380 	mov.w	r3, #256	; 0x100
 8012946:	9317      	str	r3, [sp, #92]	; 0x5c
 8012948:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
 801294c:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
 8012950:	e9cd 231a 	strd	r2, r3, [sp, #104]	; 0x68
 8012954:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8012958:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
 801295c:	e9cd 9804 	strd	r9, r8, [sp, #16]
 8012960:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
   xTaskCreateRestricted( &( targetTaskParameters ), &AFLfuzzer.xTaskTarget );
 8012964:	f7f0 fabc 	bl	8002ee0 <xTaskCreateRestricted>
			 {

				refreshtarget= 0;
				spawnNewTarget();
				ulTaskNotifyTakeIndexed(2,pdTRUE, TARGET_TIMEOUT/2);
 8012968:	220a      	movs	r2, #10
 801296a:	2101      	movs	r1, #1
 801296c:	2002      	movs	r0, #2
 801296e:	f7f5 fd75 	bl	800845c <MPU_ulTaskGenericNotifyTake>


			 AFLfuzzer.bRXcomplete = false;
			 AFLfuzzer.inputLength = 0;
			 AFLfuzzer.previousGuard = 0;
			 RingZeroes(&AFLfuzzer.inputAFL);
 8012972:	4850      	ldr	r0, [pc, #320]	; (8012ab4 <fuzzerTask+0x4a4>)
			 AFLfuzzer.bRXcomplete = false;
 8012974:	f885 b864 	strb.w	fp, [r5, #2148]	; 0x864
			 AFLfuzzer.inputLength = 0;
 8012978:	f8c5 b824 	str.w	fp, [r5, #2084]	; 0x824
			 AFLfuzzer.previousGuard = 0;
 801297c:	f8a5 b858 	strh.w	fp, [r5, #2136]	; 0x858
			 RingZeroes(&AFLfuzzer.inputAFL);
 8012980:	f7f7 fc24 	bl	800a1cc <RingZeroes>
		     AFLfuzzer.timespan = HAL_GetTick() - AFLfuzzer.timespan;
 8012984:	f7f8 f9c2 	bl	800ad0c <HAL_GetTick>
 8012988:	f8d5 382c 	ldr.w	r3, [r5, #2092]	; 0x82c
 801298c:	1ac0      	subs	r0, r0, r3
 801298e:	f8c5 082c 	str.w	r0, [r5, #2092]	; 0x82c
		ulTaskNotifyTakeIndexed(1,pdTRUE, portMAX_DELAY);
 8012992:	e6b7      	b.n	8012704 <fuzzerTask+0xf4>
				 AFLfuzzer.aflheader[0] = FAULT_TMOUT;
 8012994:	f8c5 4814 	str.w	r4, [r5, #2068]	; 0x814
				 printf("Target timeout, starting a new target process...\n");
 8012998:	4847      	ldr	r0, [pc, #284]	; (8012ab8 <fuzzerTask+0x4a8>)
 801299a:	f001 fe27 	bl	80145ec <puts>
				 vTaskDelete(AFLfuzzer.xTaskTarget);
 801299e:	f8d5 0870 	ldr.w	r0, [r5, #2160]	; 0x870
 80129a2:	f7f5 fbc9 	bl	8008138 <MPU_vTaskDelete>
				 taskYIELD(); //lets the kernel clean the TCB
 80129a6:	df01      	svc	1
   TaskParameters_t targetTaskParameters =
 80129a8:	2298      	movs	r2, #152	; 0x98
 80129aa:	4651      	mov	r1, sl
 80129ac:	a806      	add	r0, sp, #24
 80129ae:	4626      	mov	r6, r4
 80129b0:	f001 fcae 	bl	8014310 <memset>
 80129b4:	4b32      	ldr	r3, [pc, #200]	; (8012a80 <fuzzerTask+0x470>)
 80129b6:	f44f 7280 	mov.w	r2, #256	; 0x100
   xTaskCreateRestricted( &( targetTaskParameters ), &AFLfuzzer.xTaskTarget );
 80129ba:	493d      	ldr	r1, [pc, #244]	; (8012ab0 <fuzzerTask+0x4a0>)
 80129bc:	a804      	add	r0, sp, #16
 80129be:	f8cd a00c 	str.w	sl, [sp, #12]
   TaskParameters_t targetTaskParameters =
 80129c2:	e9cd 3709 	strd	r3, r7, [sp, #36]	; 0x24
 80129c6:	4b2f      	ldr	r3, [pc, #188]	; (8012a84 <fuzzerTask+0x474>)
 80129c8:	930d      	str	r3, [sp, #52]	; 0x34
 80129ca:	4b2f      	ldr	r3, [pc, #188]	; (8012a88 <fuzzerTask+0x478>)
 80129cc:	9313      	str	r3, [sp, #76]	; 0x4c
 80129ce:	4b2f      	ldr	r3, [pc, #188]	; (8012a8c <fuzzerTask+0x47c>)
 80129d0:	9316      	str	r3, [sp, #88]	; 0x58
 80129d2:	4b2f      	ldr	r3, [pc, #188]	; (8012a90 <fuzzerTask+0x480>)
 80129d4:	9319      	str	r3, [sp, #100]	; 0x64
 80129d6:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
 80129da:	930c      	str	r3, [sp, #48]	; 0x30
 80129dc:	9312      	str	r3, [sp, #72]	; 0x48
 80129de:	9318      	str	r3, [sp, #96]	; 0x60
 80129e0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80129e4:	930b      	str	r3, [sp, #44]	; 0x2c
 80129e6:	9311      	str	r3, [sp, #68]	; 0x44
 80129e8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80129ec:	f8ad 3018 	strh.w	r3, [sp, #24]
 80129f0:	2314      	movs	r3, #20
 80129f2:	9308      	str	r3, [sp, #32]
 80129f4:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 80129f8:	9310      	str	r3, [sp, #64]	; 0x40
 80129fa:	f44f 7380 	mov.w	r3, #256	; 0x100
 80129fe:	9317      	str	r3, [sp, #92]	; 0x5c
 8012a00:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
 8012a04:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
 8012a08:	e9cd 231a 	strd	r2, r3, [sp, #104]	; 0x68
 8012a0c:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8012a10:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
 8012a14:	e9cd 9804 	strd	r9, r8, [sp, #16]
 8012a18:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
   xTaskCreateRestricted( &( targetTaskParameters ), &AFLfuzzer.xTaskTarget );
 8012a1c:	f7f0 fa60 	bl	8002ee0 <xTaskCreateRestricted>
				 ulTaskNotifyTakeIndexed(2,pdTRUE, TARGET_TIMEOUT/2);
 8012a20:	4621      	mov	r1, r4
 8012a22:	220a      	movs	r2, #10
 8012a24:	2002      	movs	r0, #2
 8012a26:	f7f5 fd19 	bl	800845c <MPU_ulTaskGenericNotifyTake>
 8012a2a:	e730      	b.n	801288e <fuzzerTask+0x27e>
 8012a2c:	4c23      	ldr	r4, [pc, #140]	; (8012abc <fuzzerTask+0x4ac>)
						 if(AFLfuzzer.allocs[i])
 8012a2e:	f854 0f04 	ldr.w	r0, [r4, #4]!
 8012a32:	b108      	cbz	r0, 8012a38 <fuzzerTask+0x428>
							 free(AFLfuzzer.allocs[i]);
 8012a34:	f001 fc56 	bl	80142e4 <free>
					while(i<McuASAN_MAX_NUMBER_ALLOCS)
 8012a38:	4b21      	ldr	r3, [pc, #132]	; (8012ac0 <fuzzerTask+0x4b0>)
 8012a3a:	42a3      	cmp	r3, r4
 8012a3c:	d1f7      	bne.n	8012a2e <fuzzerTask+0x41e>
					vTaskDelete(AFLfuzzer.xTaskTarget);
 8012a3e:	f8d5 0870 	ldr.w	r0, [r5, #2160]	; 0x870
 8012a42:	f7f5 fb79 	bl	8008138 <MPU_vTaskDelete>
				    taskYIELD();
 8012a46:	df01      	svc	1
					numberofcycles=0;
 8012a48:	2600      	movs	r6, #0
 8012a4a:	e754      	b.n	80128f6 <fuzzerTask+0x2e6>
				numberofcycles++;
 8012a4c:	1c73      	adds	r3, r6, #1
				AFLfuzzer.aflheader[0] = notificationvalue;
 8012a4e:	f8c5 b814 	str.w	fp, [r5, #2068]	; 0x814
				if(numberofcycles>=FUZZING_CYCLES_IN_PROCESS && refreshtarget==0)
 8012a52:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8012a56:	d258      	bcs.n	8012b0a <fuzzerTask+0x4fa>
				numberofcycles++;
 8012a58:	3602      	adds	r6, #2
 8012a5a:	e70e      	b.n	801287a <fuzzerTask+0x26a>
				 printf("T. crash at: 0x%x, %s \n", (unsigned int)AFLfuzzer.PCcrash, (char *)EX_str[AFLfuzzer.xTypeEx]);
 8012a5c:	f895 3874 	ldrb.w	r3, [r5, #2164]	; 0x874
 8012a60:	4626      	mov	r6, r4
 8012a62:	4a18      	ldr	r2, [pc, #96]	; (8012ac4 <fuzzerTask+0x4b4>)
 8012a64:	f04f 0a00 	mov.w	sl, #0
				 AFLfuzzer.aflheader[0] = notificationvalue;
 8012a68:	f8c5 0814 	str.w	r0, [r5, #2068]	; 0x814
				 printf("T. crash at: 0x%x, %s \n", (unsigned int)AFLfuzzer.PCcrash, (char *)EX_str[AFLfuzzer.xTypeEx]);
 8012a6c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8012a70:	f8d5 1868 	ldr.w	r1, [r5, #2152]	; 0x868
 8012a74:	4814      	ldr	r0, [pc, #80]	; (8012ac8 <fuzzerTask+0x4b8>)
 8012a76:	f001 fd33 	bl	80144e0 <iprintf>
				 refreshtarget = 1;
 8012a7a:	9403      	str	r4, [sp, #12]
 8012a7c:	e707      	b.n	801288e <fuzzerTask+0x27e>
 8012a7e:	bf00      	nop
 8012a80:	24032000 	.word	0x24032000
 8012a84:	24036000 	.word	0x24036000
 8012a88:	24031100 	.word	0x24031100
 8012a8c:	24031200 	.word	0x24031200
 8012a90:	24031300 	.word	0x24031300
 8012a94:	24026004 	.word	0x24026004
 8012a98:	2401184c 	.word	0x2401184c
 8012a9c:	24020000 	.word	0x24020000
 8012aa0:	24024000 	.word	0x24024000
 8012aa4:	24026814 	.word	0x24026814
 8012aa8:	240116ac 	.word	0x240116ac
 8012aac:	24024004 	.word	0x24024004
 8012ab0:	24026870 	.word	0x24026870
 8012ab4:	24026000 	.word	0x24026000
 8012ab8:	24008344 	.word	0x24008344
 8012abc:	2402682c 	.word	0x2402682c
 8012ac0:	24026854 	.word	0x24026854
 8012ac4:	24008060 	.word	0x24008060
 8012ac8:	2400838c 	.word	0x2400838c
 8012acc:	4c18      	ldr	r4, [pc, #96]	; (8012b30 <fuzzerTask+0x520>)
					 if(AFLfuzzer.allocs[i])
 8012ace:	f854 0f04 	ldr.w	r0, [r4, #4]!
 8012ad2:	b108      	cbz	r0, 8012ad8 <fuzzerTask+0x4c8>
						 free(AFLfuzzer.allocs[i]);
 8012ad4:	f001 fc06 	bl	80142e4 <free>
				 while(i<McuASAN_MAX_NUMBER_ALLOCS) //clean malloc allocations if any
 8012ad8:	4b16      	ldr	r3, [pc, #88]	; (8012b34 <fuzzerTask+0x524>)
 8012ada:	429c      	cmp	r4, r3
 8012adc:	d1f7      	bne.n	8012ace <fuzzerTask+0x4be>
				  printf("ASAN violation %s \n", (char *)EX_str[AFLfuzzer.xTypeEx]);
 8012ade:	f895 3874 	ldrb.w	r3, [r5, #2164]	; 0x874
 8012ae2:	4a15      	ldr	r2, [pc, #84]	; (8012b38 <fuzzerTask+0x528>)
 8012ae4:	4815      	ldr	r0, [pc, #84]	; (8012b3c <fuzzerTask+0x52c>)
 8012ae6:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
				  AFLfuzzer.aflheader[0] = notificationvalue;
 8012aea:	2302      	movs	r3, #2
 8012aec:	f8c5 3814 	str.w	r3, [r5, #2068]	; 0x814
				  printf("ASAN violation %s \n", (char *)EX_str[AFLfuzzer.xTypeEx]);
 8012af0:	f001 fcf6 	bl	80144e0 <iprintf>
				  vTaskDelete(AFLfuzzer.xTaskTarget);
 8012af4:	f8d5 0870 	ldr.w	r0, [r5, #2160]	; 0x870
 8012af8:	f7f5 fb1e 	bl	8008138 <MPU_vTaskDelete>
				  taskYIELD();
 8012afc:	df01      	svc	1
				  refreshtarget = 1;
 8012afe:	2301      	movs	r3, #1
				numberofcycles++;
 8012b00:	3601      	adds	r6, #1
 8012b02:	f04f 0a00 	mov.w	sl, #0
				  refreshtarget = 1;
 8012b06:	9303      	str	r3, [sp, #12]
 8012b08:	e6c1      	b.n	801288e <fuzzerTask+0x27e>
 8012b0a:	4c09      	ldr	r4, [pc, #36]	; (8012b30 <fuzzerTask+0x520>)
						 if(AFLfuzzer.allocs[i])
 8012b0c:	f854 0f04 	ldr.w	r0, [r4, #4]!
 8012b10:	b108      	cbz	r0, 8012b16 <fuzzerTask+0x506>
							 free(AFLfuzzer.allocs[i]);
 8012b12:	f001 fbe7 	bl	80142e4 <free>
					while(i<McuASAN_MAX_NUMBER_ALLOCS)
 8012b16:	4b07      	ldr	r3, [pc, #28]	; (8012b34 <fuzzerTask+0x524>)
 8012b18:	42a3      	cmp	r3, r4
 8012b1a:	d1f7      	bne.n	8012b0c <fuzzerTask+0x4fc>
					vTaskDelete(AFLfuzzer.xTaskTarget);
 8012b1c:	f8d5 0870 	ldr.w	r0, [r5, #2160]	; 0x870
 8012b20:	f7f5 fb0a 	bl	8008138 <MPU_vTaskDelete>
				    taskYIELD();
 8012b24:	df01      	svc	1
 8012b26:	2601      	movs	r6, #1
 8012b28:	f04f 0a00 	mov.w	sl, #0
				    refreshtarget = 1;
 8012b2c:	9603      	str	r6, [sp, #12]
 8012b2e:	e6ae      	b.n	801288e <fuzzerTask+0x27e>
 8012b30:	2402682c 	.word	0x2402682c
 8012b34:	24026854 	.word	0x24026854
 8012b38:	24008060 	.word	0x24008060
 8012b3c:	24008378 	.word	0x24008378

08012b40 <vStartMPUDemo>:
	}
}


void vStartMPUDemo( void )
{
 8012b40:	b500      	push	{lr}
 8012b42:	b0a9      	sub	sp, #164	; 0xa4

Fuzzer_t *pAFLfuzzer = (Fuzzer_t *)AFLfuzzerRegion;

TaskParameters_t fuzzerTaskParameters =
 8012b44:	2100      	movs	r1, #0
 8012b46:	2298      	movs	r2, #152	; 0x98
 8012b48:	a802      	add	r0, sp, #8
 8012b4a:	f001 fbe1 	bl	8014310 <memset>
 8012b4e:	4809      	ldr	r0, [pc, #36]	; (8012b74 <vStartMPUDemo+0x34>)
 8012b50:	4909      	ldr	r1, [pc, #36]	; (8012b78 <vStartMPUDemo+0x38>)
 8012b52:	f44f 6c80 	mov.w	ip, #1024	; 0x400
 8012b56:	4a09      	ldr	r2, [pc, #36]	; (8012b7c <vStartMPUDemo+0x3c>)
 8012b58:	4b09      	ldr	r3, [pc, #36]	; (8012b80 <vStartMPUDemo+0x40>)
 8012b5a:	f8ad c008 	strh.w	ip, [sp, #8]
 8012b5e:	e9cd 0100 	strd	r0, r1, [sp]
							{ 0, 0, 0 },
					}
};

	/* Create the fuzzer task */
	xTaskCreateRestricted( &( fuzzerTaskParameters ), &AFLfuzzer.xTaskFuzzer );
 8012b62:	4908      	ldr	r1, [pc, #32]	; (8012b84 <vStartMPUDemo+0x44>)
 8012b64:	4668      	mov	r0, sp
TaskParameters_t fuzzerTaskParameters =
 8012b66:	e9cd 2304 	strd	r2, r3, [sp, #16]
	xTaskCreateRestricted( &( fuzzerTaskParameters ), &AFLfuzzer.xTaskFuzzer );
 8012b6a:	f7f0 f9b9 	bl	8002ee0 <xTaskCreateRestricted>
	//spawnNewTarget();

}
 8012b6e:	b029      	add	sp, #164	; 0xa4
 8012b70:	f85d fb04 	ldr.w	pc, [sp], #4
 8012b74:	08012611 	.word	0x08012611
 8012b78:	240083a4 	.word	0x240083a4
 8012b7c:	80000014 	.word	0x80000014
 8012b80:	24030000 	.word	0x24030000
 8012b84:	2402686c 	.word	0x2402686c

08012b88 <USBD_CDC_EP0_RxReady>:
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8012b88:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
 8012b8c:	eb00 0083 	add.w	r0, r0, r3, lsl #2
{
 8012b90:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8012b92:	f8d0 42c0 	ldr.w	r4, [r0, #704]	; 0x2c0

  if (hcdc == NULL)
 8012b96:	b194      	cbz	r4, 8012bbe <USBD_CDC_EP0_RxReady+0x36>
  {
    return (uint8_t)USBD_FAIL;
  }

  if ((pdev->pUserData[pdev->classId] != NULL) && (hcdc->CmdOpCode != 0xFFU))
 8012b98:	f8d0 32c4 	ldr.w	r3, [r0, #708]	; 0x2c4
 8012b9c:	b16b      	cbz	r3, 8012bba <USBD_CDC_EP0_RxReady+0x32>
 8012b9e:	f894 0200 	ldrb.w	r0, [r4, #512]	; 0x200
 8012ba2:	28ff      	cmp	r0, #255	; 0xff
 8012ba4:	d009      	beq.n	8012bba <USBD_CDC_EP0_RxReady+0x32>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(hcdc->CmdOpCode,
 8012ba6:	689b      	ldr	r3, [r3, #8]
 8012ba8:	4621      	mov	r1, r4
 8012baa:	f894 2201 	ldrb.w	r2, [r4, #513]	; 0x201
 8012bae:	4798      	blx	r3
                                                                     (uint8_t *)hcdc->data,
                                                                     (uint16_t)hcdc->CmdLength);
    hcdc->CmdOpCode = 0xFFU;
 8012bb0:	23ff      	movs	r3, #255	; 0xff
  }

  return (uint8_t)USBD_OK;
 8012bb2:	2000      	movs	r0, #0
    hcdc->CmdOpCode = 0xFFU;
 8012bb4:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
}
 8012bb8:	bd10      	pop	{r4, pc}
  return (uint8_t)USBD_OK;
 8012bba:	2000      	movs	r0, #0
}
 8012bbc:	bd10      	pop	{r4, pc}
    return (uint8_t)USBD_FAIL;
 8012bbe:	2003      	movs	r0, #3
}
 8012bc0:	bd10      	pop	{r4, pc}
 8012bc2:	bf00      	nop

08012bc4 <USBD_CDC_GetDeviceQualifierDescriptor>:
  *         return Device Qualifier descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
uint8_t *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length)
{
 8012bc4:	4603      	mov	r3, r0
  *length = (uint16_t)sizeof(USBD_CDC_DeviceQualifierDesc);
 8012bc6:	220a      	movs	r2, #10

  return USBD_CDC_DeviceQualifierDesc;
}
 8012bc8:	4801      	ldr	r0, [pc, #4]	; (8012bd0 <USBD_CDC_GetDeviceQualifierDescriptor+0xc>)
  *length = (uint16_t)sizeof(USBD_CDC_DeviceQualifierDesc);
 8012bca:	801a      	strh	r2, [r3, #0]
}
 8012bcc:	4770      	bx	lr
 8012bce:	bf00      	nop
 8012bd0:	24008114 	.word	0x24008114

08012bd4 <USBD_CDC_GetFSCfgDesc>:
{
 8012bd4:	b570      	push	{r4, r5, r6, lr}
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8012bd6:	2182      	movs	r1, #130	; 0x82
{
 8012bd8:	4606      	mov	r6, r0
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8012bda:	480f      	ldr	r0, [pc, #60]	; (8012c18 <USBD_CDC_GetFSCfgDesc+0x44>)
 8012bdc:	f000 fbf4 	bl	80133c8 <USBD_GetEpDesc>
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8012be0:	2101      	movs	r1, #1
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8012be2:	4605      	mov	r5, r0
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8012be4:	480c      	ldr	r0, [pc, #48]	; (8012c18 <USBD_CDC_GetFSCfgDesc+0x44>)
 8012be6:	f000 fbef 	bl	80133c8 <USBD_GetEpDesc>
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8012bea:	2181      	movs	r1, #129	; 0x81
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8012bec:	4604      	mov	r4, r0
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8012bee:	480a      	ldr	r0, [pc, #40]	; (8012c18 <USBD_CDC_GetFSCfgDesc+0x44>)
 8012bf0:	f000 fbea 	bl	80133c8 <USBD_GetEpDesc>
  if (pEpCmdDesc != NULL)
 8012bf4:	b10d      	cbz	r5, 8012bfa <USBD_CDC_GetFSCfgDesc+0x26>
    pEpCmdDesc->bInterval = CDC_FS_BINTERVAL;
 8012bf6:	2210      	movs	r2, #16
 8012bf8:	71aa      	strb	r2, [r5, #6]
  if (pEpOutDesc != NULL)
 8012bfa:	b11c      	cbz	r4, 8012c04 <USBD_CDC_GetFSCfgDesc+0x30>
    pEpOutDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8012bfc:	2100      	movs	r1, #0
 8012bfe:	2240      	movs	r2, #64	; 0x40
 8012c00:	7161      	strb	r1, [r4, #5]
 8012c02:	7122      	strb	r2, [r4, #4]
  if (pEpInDesc != NULL)
 8012c04:	b118      	cbz	r0, 8012c0e <USBD_CDC_GetFSCfgDesc+0x3a>
    pEpInDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8012c06:	2100      	movs	r1, #0
 8012c08:	2240      	movs	r2, #64	; 0x40
 8012c0a:	7141      	strb	r1, [r0, #5]
 8012c0c:	7102      	strb	r2, [r0, #4]
  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8012c0e:	2343      	movs	r3, #67	; 0x43
}
 8012c10:	4801      	ldr	r0, [pc, #4]	; (8012c18 <USBD_CDC_GetFSCfgDesc+0x44>)
  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8012c12:	8033      	strh	r3, [r6, #0]
}
 8012c14:	bd70      	pop	{r4, r5, r6, pc}
 8012c16:	bf00      	nop
 8012c18:	240080d0 	.word	0x240080d0

08012c1c <USBD_CDC_GetHSCfgDesc>:
{
 8012c1c:	b570      	push	{r4, r5, r6, lr}
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8012c1e:	2182      	movs	r1, #130	; 0x82
{
 8012c20:	4606      	mov	r6, r0
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8012c22:	480f      	ldr	r0, [pc, #60]	; (8012c60 <USBD_CDC_GetHSCfgDesc+0x44>)
 8012c24:	f000 fbd0 	bl	80133c8 <USBD_GetEpDesc>
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8012c28:	2101      	movs	r1, #1
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8012c2a:	4605      	mov	r5, r0
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8012c2c:	480c      	ldr	r0, [pc, #48]	; (8012c60 <USBD_CDC_GetHSCfgDesc+0x44>)
 8012c2e:	f000 fbcb 	bl	80133c8 <USBD_GetEpDesc>
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8012c32:	2181      	movs	r1, #129	; 0x81
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8012c34:	4604      	mov	r4, r0
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8012c36:	480a      	ldr	r0, [pc, #40]	; (8012c60 <USBD_CDC_GetHSCfgDesc+0x44>)
 8012c38:	f000 fbc6 	bl	80133c8 <USBD_GetEpDesc>
  if (pEpCmdDesc != NULL)
 8012c3c:	b10d      	cbz	r5, 8012c42 <USBD_CDC_GetHSCfgDesc+0x26>
    pEpCmdDesc->bInterval = CDC_HS_BINTERVAL;
 8012c3e:	2210      	movs	r2, #16
 8012c40:	71aa      	strb	r2, [r5, #6]
  if (pEpOutDesc != NULL)
 8012c42:	b11c      	cbz	r4, 8012c4c <USBD_CDC_GetHSCfgDesc+0x30>
    pEpOutDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 8012c44:	2100      	movs	r1, #0
 8012c46:	2202      	movs	r2, #2
 8012c48:	7121      	strb	r1, [r4, #4]
 8012c4a:	7162      	strb	r2, [r4, #5]
  if (pEpInDesc != NULL)
 8012c4c:	b118      	cbz	r0, 8012c56 <USBD_CDC_GetHSCfgDesc+0x3a>
    pEpInDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 8012c4e:	2100      	movs	r1, #0
 8012c50:	2202      	movs	r2, #2
 8012c52:	7101      	strb	r1, [r0, #4]
 8012c54:	7142      	strb	r2, [r0, #5]
  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8012c56:	2343      	movs	r3, #67	; 0x43
}
 8012c58:	4801      	ldr	r0, [pc, #4]	; (8012c60 <USBD_CDC_GetHSCfgDesc+0x44>)
  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8012c5a:	8033      	strh	r3, [r6, #0]
}
 8012c5c:	bd70      	pop	{r4, r5, r6, pc}
 8012c5e:	bf00      	nop
 8012c60:	240080d0 	.word	0x240080d0

08012c64 <USBD_CDC_DataOut>:
{
 8012c64:	b538      	push	{r3, r4, r5, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8012c66:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
 8012c6a:	33b0      	adds	r3, #176	; 0xb0
 8012c6c:	f850 5023 	ldr.w	r5, [r0, r3, lsl #2]
  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8012c70:	b195      	cbz	r5, 8012c98 <USBD_CDC_DataOut+0x34>
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 8012c72:	4604      	mov	r4, r0
 8012c74:	f001 fa00 	bl	8014078 <USBD_LL_GetRxDataSize>
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 8012c78:	f505 7103 	add.w	r1, r5, #524	; 0x20c
 8012c7c:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 8012c80:	f8c5 020c 	str.w	r0, [r5, #524]	; 0x20c
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 8012c84:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 8012c88:	f8d5 0204 	ldr.w	r0, [r5, #516]	; 0x204
 8012c8c:	f8d4 32c4 	ldr.w	r3, [r4, #708]	; 0x2c4
 8012c90:	68db      	ldr	r3, [r3, #12]
 8012c92:	4798      	blx	r3
  return (uint8_t)USBD_OK;
 8012c94:	2000      	movs	r0, #0
}
 8012c96:	bd38      	pop	{r3, r4, r5, pc}
    return (uint8_t)USBD_FAIL;
 8012c98:	2003      	movs	r0, #3
}
 8012c9a:	bd38      	pop	{r3, r4, r5, pc}

08012c9c <USBD_CDC_DataIn>:
  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8012c9c:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
 8012ca0:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
{
 8012ca4:	b570      	push	{r4, r5, r6, lr}
  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8012ca6:	f8dc 52c0 	ldr.w	r5, [ip, #704]	; 0x2c0
 8012caa:	b36d      	cbz	r5, 8012d08 <USBD_CDC_DataIn+0x6c>
  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 8012cac:	f001 0e0f 	and.w	lr, r1, #15
 8012cb0:	460a      	mov	r2, r1
 8012cb2:	eb0e 068e 	add.w	r6, lr, lr, lsl #2
 8012cb6:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 8012cba:	69b3      	ldr	r3, [r6, #24]
 8012cbc:	b96b      	cbnz	r3, 8012cda <USBD_CDC_DataIn+0x3e>
    if (((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt != NULL)
 8012cbe:	f8dc 32c4 	ldr.w	r3, [ip, #708]	; 0x2c4
    hcdc->TxState = 0U;
 8012cc2:	2400      	movs	r4, #0
    if (((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt != NULL)
 8012cc4:	691b      	ldr	r3, [r3, #16]
    hcdc->TxState = 0U;
 8012cc6:	f8c5 4214 	str.w	r4, [r5, #532]	; 0x214
    if (((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt != NULL)
 8012cca:	b1db      	cbz	r3, 8012d04 <USBD_CDC_DataIn+0x68>
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt(hcdc->TxBuffer, &hcdc->TxLength, epnum);
 8012ccc:	f505 7104 	add.w	r1, r5, #528	; 0x210
 8012cd0:	f8d5 0208 	ldr.w	r0, [r5, #520]	; 0x208
 8012cd4:	4798      	blx	r3
  return (uint8_t)USBD_OK;
 8012cd6:	4620      	mov	r0, r4
}
 8012cd8:	bd70      	pop	{r4, r5, r6, pc}
      ((pdev->ep_in[epnum & 0xFU].total_length % hpcd->IN_ep[epnum & 0xFU].maxpacket) == 0U))
 8012cda:	f8d0 42c8 	ldr.w	r4, [r0, #712]	; 0x2c8
 8012cde:	eb0e 0ece 	add.w	lr, lr, lr, lsl #3
 8012ce2:	eb04 0e8e 	add.w	lr, r4, lr, lsl #2
 8012ce6:	f8de 4048 	ldr.w	r4, [lr, #72]	; 0x48
 8012cea:	fbb3 fef4 	udiv	lr, r3, r4
 8012cee:	fb04 341e 	mls	r4, r4, lr, r3
  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 8012cf2:	2c00      	cmp	r4, #0
 8012cf4:	d1e3      	bne.n	8012cbe <USBD_CDC_DataIn+0x22>
    (void)USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 8012cf6:	4623      	mov	r3, r4
 8012cf8:	4622      	mov	r2, r4
    pdev->ep_in[epnum & 0xFU].total_length = 0U;
 8012cfa:	61b4      	str	r4, [r6, #24]
    (void)USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 8012cfc:	f001 f9a0 	bl	8014040 <USBD_LL_Transmit>
  return (uint8_t)USBD_OK;
 8012d00:	4620      	mov	r0, r4
}
 8012d02:	bd70      	pop	{r4, r5, r6, pc}
  return (uint8_t)USBD_OK;
 8012d04:	4618      	mov	r0, r3
}
 8012d06:	bd70      	pop	{r4, r5, r6, pc}
    return (uint8_t)USBD_FAIL;
 8012d08:	2003      	movs	r0, #3
}
 8012d0a:	bd70      	pop	{r4, r5, r6, pc}

08012d0c <USBD_CDC_Setup>:
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8012d0c:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
 8012d10:	eb00 0383 	add.w	r3, r0, r3, lsl #2
{
 8012d14:	b5f0      	push	{r4, r5, r6, r7, lr}
 8012d16:	4604      	mov	r4, r0
 8012d18:	b083      	sub	sp, #12
  uint8_t ifalt = 0U;
 8012d1a:	2000      	movs	r0, #0
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8012d1c:	f8d3 72c0 	ldr.w	r7, [r3, #704]	; 0x2c0
  uint8_t ifalt = 0U;
 8012d20:	f88d 0005 	strb.w	r0, [sp, #5]
  uint16_t status_info = 0U;
 8012d24:	f8ad 0006 	strh.w	r0, [sp, #6]
  if (hcdc == NULL)
 8012d28:	2f00      	cmp	r7, #0
 8012d2a:	d066      	beq.n	8012dfa <USBD_CDC_Setup+0xee>
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8012d2c:	f891 c000 	ldrb.w	ip, [r1]
 8012d30:	460d      	mov	r5, r1
 8012d32:	f01c 0660 	ands.w	r6, ip, #96	; 0x60
 8012d36:	d01d      	beq.n	8012d74 <USBD_CDC_Setup+0x68>
 8012d38:	2e20      	cmp	r6, #32
 8012d3a:	d007      	beq.n	8012d4c <USBD_CDC_Setup+0x40>
          USBD_CtlError(pdev, req);
 8012d3c:	4629      	mov	r1, r5
 8012d3e:	4620      	mov	r0, r4
          ret = USBD_FAIL;
 8012d40:	2603      	movs	r6, #3
          USBD_CtlError(pdev, req);
 8012d42:	f000 fe05 	bl	8013950 <USBD_CtlError>
}
 8012d46:	4630      	mov	r0, r6
 8012d48:	b003      	add	sp, #12
 8012d4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (req->wLength != 0U)
 8012d4c:	88ca      	ldrh	r2, [r1, #6]
 8012d4e:	b37a      	cbz	r2, 8012db0 <USBD_CDC_Setup+0xa4>
        if ((req->bmRequest & 0x80U) != 0U)
 8012d50:	f01c 0f80 	tst.w	ip, #128	; 0x80
 8012d54:	d155      	bne.n	8012e02 <USBD_CDC_Setup+0xf6>
          hcdc->CmdOpCode = req->bRequest;
 8012d56:	784b      	ldrb	r3, [r1, #1]
          hcdc->CmdLength = (uint8_t)MIN(req->wLength, USB_MAX_EP0_SIZE);
 8012d58:	2a3f      	cmp	r2, #63	; 0x3f
          hcdc->CmdOpCode = req->bRequest;
 8012d5a:	f887 3200 	strb.w	r3, [r7, #512]	; 0x200
          hcdc->CmdLength = (uint8_t)MIN(req->wLength, USB_MAX_EP0_SIZE);
 8012d5e:	d960      	bls.n	8012e22 <USBD_CDC_Setup+0x116>
 8012d60:	2340      	movs	r3, #64	; 0x40
 8012d62:	461a      	mov	r2, r3
          (void)USBD_CtlPrepareRx(pdev, (uint8_t *)hcdc->data, hcdc->CmdLength);
 8012d64:	4639      	mov	r1, r7
 8012d66:	4620      	mov	r0, r4
          hcdc->CmdLength = (uint8_t)MIN(req->wLength, USB_MAX_EP0_SIZE);
 8012d68:	f887 3201 	strb.w	r3, [r7, #513]	; 0x201
  USBD_StatusTypeDef ret = USBD_OK;
 8012d6c:	2600      	movs	r6, #0
          (void)USBD_CtlPrepareRx(pdev, (uint8_t *)hcdc->data, hcdc->CmdLength);
 8012d6e:	f000 fe3d 	bl	80139ec <USBD_CtlPrepareRx>
 8012d72:	e7e8      	b.n	8012d46 <USBD_CDC_Setup+0x3a>
      switch (req->bRequest)
 8012d74:	784b      	ldrb	r3, [r1, #1]
 8012d76:	2b0b      	cmp	r3, #11
 8012d78:	d8e0      	bhi.n	8012d3c <USBD_CDC_Setup+0x30>
 8012d7a:	a201      	add	r2, pc, #4	; (adr r2, 8012d80 <USBD_CDC_Setup+0x74>)
 8012d7c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012d80:	08012de3 	.word	0x08012de3
 8012d84:	08012d47 	.word	0x08012d47
 8012d88:	08012d3d 	.word	0x08012d3d
 8012d8c:	08012d3d 	.word	0x08012d3d
 8012d90:	08012d3d 	.word	0x08012d3d
 8012d94:	08012d3d 	.word	0x08012d3d
 8012d98:	08012d3d 	.word	0x08012d3d
 8012d9c:	08012d3d 	.word	0x08012d3d
 8012da0:	08012d3d 	.word	0x08012d3d
 8012da4:	08012d3d 	.word	0x08012d3d
 8012da8:	08012dcd 	.word	0x08012dcd
 8012dac:	08012dc3 	.word	0x08012dc3
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8012db0:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
  USBD_StatusTypeDef ret = USBD_OK;
 8012db4:	4616      	mov	r6, r2
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8012db6:	7848      	ldrb	r0, [r1, #1]
 8012db8:	689b      	ldr	r3, [r3, #8]
 8012dba:	4798      	blx	r3
}
 8012dbc:	4630      	mov	r0, r6
 8012dbe:	b003      	add	sp, #12
 8012dc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
          if (pdev->dev_state != USBD_STATE_CONFIGURED)
 8012dc2:	f894 329c 	ldrb.w	r3, [r4, #668]	; 0x29c
 8012dc6:	2b03      	cmp	r3, #3
 8012dc8:	d0bd      	beq.n	8012d46 <USBD_CDC_Setup+0x3a>
 8012dca:	e7b7      	b.n	8012d3c <USBD_CDC_Setup+0x30>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8012dcc:	f894 329c 	ldrb.w	r3, [r4, #668]	; 0x29c
 8012dd0:	2b03      	cmp	r3, #3
 8012dd2:	d1b3      	bne.n	8012d3c <USBD_CDC_Setup+0x30>
            (void)USBD_CtlSendData(pdev, &ifalt, 1U);
 8012dd4:	2201      	movs	r2, #1
 8012dd6:	f10d 0105 	add.w	r1, sp, #5
 8012dda:	4620      	mov	r0, r4
 8012ddc:	f000 fdee 	bl	80139bc <USBD_CtlSendData>
 8012de0:	e7b1      	b.n	8012d46 <USBD_CDC_Setup+0x3a>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8012de2:	f894 229c 	ldrb.w	r2, [r4, #668]	; 0x29c
 8012de6:	2a03      	cmp	r2, #3
 8012de8:	d1a8      	bne.n	8012d3c <USBD_CDC_Setup+0x30>
            (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
 8012dea:	2202      	movs	r2, #2
 8012dec:	f10d 0106 	add.w	r1, sp, #6
 8012df0:	4620      	mov	r0, r4
  USBD_StatusTypeDef ret = USBD_OK;
 8012df2:	461e      	mov	r6, r3
            (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
 8012df4:	f000 fde2 	bl	80139bc <USBD_CtlSendData>
 8012df8:	e7a5      	b.n	8012d46 <USBD_CDC_Setup+0x3a>
    return (uint8_t)USBD_FAIL;
 8012dfa:	2603      	movs	r6, #3
}
 8012dfc:	4630      	mov	r0, r6
 8012dfe:	b003      	add	sp, #12
 8012e00:	bdf0      	pop	{r4, r5, r6, r7, pc}
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8012e02:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8012e06:	4639      	mov	r1, r7
  USBD_StatusTypeDef ret = USBD_OK;
 8012e08:	4606      	mov	r6, r0
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8012e0a:	7868      	ldrb	r0, [r5, #1]
 8012e0c:	689b      	ldr	r3, [r3, #8]
 8012e0e:	4798      	blx	r3
          len = MIN(CDC_REQ_MAX_DATA_SIZE, req->wLength);
 8012e10:	88ea      	ldrh	r2, [r5, #6]
          (void)USBD_CtlSendData(pdev, (uint8_t *)hcdc->data, len);
 8012e12:	4639      	mov	r1, r7
 8012e14:	4620      	mov	r0, r4
 8012e16:	2a07      	cmp	r2, #7
 8012e18:	bf28      	it	cs
 8012e1a:	2207      	movcs	r2, #7
 8012e1c:	f000 fdce 	bl	80139bc <USBD_CtlSendData>
 8012e20:	e791      	b.n	8012d46 <USBD_CDC_Setup+0x3a>
 8012e22:	b2d3      	uxtb	r3, r2
 8012e24:	e79e      	b.n	8012d64 <USBD_CDC_Setup+0x58>
 8012e26:	bf00      	nop

08012e28 <USBD_CDC_DeInit>:
{
 8012e28:	b538      	push	{r3, r4, r5, lr}
 8012e2a:	4604      	mov	r4, r0
  pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 0U;
 8012e2c:	2500      	movs	r5, #0
  (void)USBD_LL_CloseEP(pdev, CDCInEpAdd);
 8012e2e:	2181      	movs	r1, #129	; 0x81
 8012e30:	f001 f8ba 	bl	8013fa8 <USBD_LL_CloseEP>
  (void)USBD_LL_CloseEP(pdev, CDCOutEpAdd);
 8012e34:	2101      	movs	r1, #1
 8012e36:	4620      	mov	r0, r4
  pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 0U;
 8012e38:	8725      	strh	r5, [r4, #56]	; 0x38
  (void)USBD_LL_CloseEP(pdev, CDCOutEpAdd);
 8012e3a:	f001 f8b5 	bl	8013fa8 <USBD_LL_CloseEP>
  (void)USBD_LL_CloseEP(pdev, CDCCmdEpAdd);
 8012e3e:	2182      	movs	r1, #130	; 0x82
 8012e40:	4620      	mov	r0, r4
  pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 0U;
 8012e42:	f8a4 5178 	strh.w	r5, [r4, #376]	; 0x178
  (void)USBD_LL_CloseEP(pdev, CDCCmdEpAdd);
 8012e46:	f001 f8af 	bl	8013fa8 <USBD_LL_CloseEP>
  pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = 0U;
 8012e4a:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 0U;
 8012e4e:	64e5      	str	r5, [r4, #76]	; 0x4c
  if (pdev->pClassDataCmsit[pdev->classId] != NULL)
 8012e50:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8012e54:	f8d3 22c0 	ldr.w	r2, [r3, #704]	; 0x2c0
 8012e58:	b18a      	cbz	r2, 8012e7e <USBD_CDC_DeInit+0x56>
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->DeInit();
 8012e5a:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8012e5e:	685b      	ldr	r3, [r3, #4]
 8012e60:	4798      	blx	r3
    (void)USBD_free(pdev->pClassDataCmsit[pdev->classId]);
 8012e62:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
 8012e66:	33b0      	adds	r3, #176	; 0xb0
 8012e68:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
 8012e6c:	f001 f90c 	bl	8014088 <USBD_static_free>
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 8012e70:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
 8012e74:	33b0      	adds	r3, #176	; 0xb0
 8012e76:	f844 5023 	str.w	r5, [r4, r3, lsl #2]
    pdev->pClassData = NULL;
 8012e7a:	f8c4 52bc 	str.w	r5, [r4, #700]	; 0x2bc
}
 8012e7e:	2000      	movs	r0, #0
 8012e80:	bd38      	pop	{r3, r4, r5, pc}
 8012e82:	bf00      	nop

08012e84 <USBD_CDC_Init>:
{
 8012e84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8012e88:	4604      	mov	r4, r0
  hcdc = (USBD_CDC_HandleTypeDef *)USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 8012e8a:	f44f 7007 	mov.w	r0, #540	; 0x21c
 8012e8e:	f001 f8f7 	bl	8014080 <USBD_static_malloc>
  if (hcdc == NULL)
 8012e92:	4605      	mov	r5, r0
 8012e94:	2800      	cmp	r0, #0
 8012e96:	d05b      	beq.n	8012f50 <USBD_CDC_Init+0xcc>
  (void)USBD_memset(hcdc, 0, sizeof(USBD_CDC_HandleTypeDef));
 8012e98:	f44f 7207 	mov.w	r2, #540	; 0x21c
 8012e9c:	2100      	movs	r1, #0
 8012e9e:	f001 fa37 	bl	8014310 <memset>
  pdev->pClassDataCmsit[pdev->classId] = (void *)hcdc;
 8012ea2:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
 8012ea6:	33b0      	adds	r3, #176	; 0xb0
 8012ea8:	f844 5023 	str.w	r5, [r4, r3, lsl #2]
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8012eac:	7c23      	ldrb	r3, [r4, #16]
  pdev->pClassData = pdev->pClassDataCmsit[pdev->classId];
 8012eae:	f8c4 52bc 	str.w	r5, [r4, #700]	; 0x2bc
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8012eb2:	b3cb      	cbz	r3, 8012f28 <USBD_CDC_Init+0xa4>
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 8012eb4:	2340      	movs	r3, #64	; 0x40
 8012eb6:	2202      	movs	r2, #2
 8012eb8:	2181      	movs	r1, #129	; 0x81
 8012eba:	4620      	mov	r0, r4
 8012ebc:	f001 f862 	bl	8013f84 <USBD_LL_OpenEP>
    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 8012ec0:	2601      	movs	r6, #1
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 8012ec2:	2340      	movs	r3, #64	; 0x40
 8012ec4:	4631      	mov	r1, r6
 8012ec6:	2202      	movs	r2, #2
    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 8012ec8:	8726      	strh	r6, [r4, #56]	; 0x38
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 8012eca:	4620      	mov	r0, r4
 8012ecc:	f001 f85a 	bl	8013f84 <USBD_LL_OpenEP>
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_FS_BINTERVAL;
 8012ed0:	2310      	movs	r3, #16
  (void)USBD_LL_OpenEP(pdev, CDCCmdEpAdd, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 8012ed2:	2203      	movs	r2, #3
 8012ed4:	2182      	movs	r1, #130	; 0x82
    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 8012ed6:	f8a4 6178 	strh.w	r6, [r4, #376]	; 0x178
  (void)USBD_LL_OpenEP(pdev, CDCCmdEpAdd, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 8012eda:	4620      	mov	r0, r4
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_FS_BINTERVAL;
 8012edc:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
  (void)USBD_LL_OpenEP(pdev, CDCCmdEpAdd, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 8012ee0:	2308      	movs	r3, #8
 8012ee2:	f001 f84f 	bl	8013f84 <USBD_LL_OpenEP>
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 8012ee6:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
  hcdc->RxBuffer = NULL;
 8012eea:	2600      	movs	r6, #0
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 1U;
 8012eec:	f04f 0801 	mov.w	r8, #1
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 8012ef0:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 1U;
 8012ef4:	f8a4 804c 	strh.w	r8, [r4, #76]	; 0x4c
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 8012ef8:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
  hcdc->RxBuffer = NULL;
 8012efc:	f8c5 6204 	str.w	r6, [r5, #516]	; 0x204
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 8012f00:	681b      	ldr	r3, [r3, #0]
 8012f02:	4798      	blx	r3
  if (hcdc->RxBuffer == NULL)
 8012f04:	f8d5 2204 	ldr.w	r2, [r5, #516]	; 0x204
  hcdc->TxState = 0U;
 8012f08:	f8c5 6214 	str.w	r6, [r5, #532]	; 0x214
  hcdc->RxState = 0U;
 8012f0c:	f8c5 6218 	str.w	r6, [r5, #536]	; 0x218
  if (hcdc->RxBuffer == NULL)
 8012f10:	b33a      	cbz	r2, 8012f62 <USBD_CDC_Init+0xde>
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8012f12:	7c27      	ldrb	r7, [r4, #16]
 8012f14:	b99f      	cbnz	r7, 8012f3e <USBD_CDC_Init+0xba>
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8012f16:	f44f 7300 	mov.w	r3, #512	; 0x200
 8012f1a:	4641      	mov	r1, r8
 8012f1c:	4620      	mov	r0, r4
 8012f1e:	f001 f89d 	bl	801405c <USBD_LL_PrepareReceive>
}
 8012f22:	4638      	mov	r0, r7
 8012f24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 8012f28:	f44f 7300 	mov.w	r3, #512	; 0x200
 8012f2c:	2202      	movs	r2, #2
 8012f2e:	2181      	movs	r1, #129	; 0x81
 8012f30:	4620      	mov	r0, r4
 8012f32:	f001 f827 	bl	8013f84 <USBD_LL_OpenEP>
    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 8012f36:	2601      	movs	r6, #1
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 8012f38:	f44f 7300 	mov.w	r3, #512	; 0x200
 8012f3c:	e7c2      	b.n	8012ec4 <USBD_CDC_Init+0x40>
  return (uint8_t)USBD_OK;
 8012f3e:	4637      	mov	r7, r6
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8012f40:	2340      	movs	r3, #64	; 0x40
 8012f42:	4641      	mov	r1, r8
 8012f44:	4620      	mov	r0, r4
 8012f46:	f001 f889 	bl	801405c <USBD_LL_PrepareReceive>
}
 8012f4a:	4638      	mov	r0, r7
 8012f4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 8012f50:	f8d4 32d4 	ldr.w	r3, [r4, #724]	; 0x2d4
    return (uint8_t)USBD_EMEM;
 8012f54:	2702      	movs	r7, #2
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 8012f56:	33b0      	adds	r3, #176	; 0xb0
 8012f58:	f844 0023 	str.w	r0, [r4, r3, lsl #2]
}
 8012f5c:	4638      	mov	r0, r7
 8012f5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return (uint8_t)USBD_EMEM;
 8012f62:	2702      	movs	r7, #2
 8012f64:	e7dd      	b.n	8012f22 <USBD_CDC_Init+0x9e>
 8012f66:	bf00      	nop

08012f68 <USBD_CDC_GetOtherSpeedCfgDesc>:
 8012f68:	b570      	push	{r4, r5, r6, lr}
 8012f6a:	2182      	movs	r1, #130	; 0x82
 8012f6c:	4606      	mov	r6, r0
 8012f6e:	480f      	ldr	r0, [pc, #60]	; (8012fac <USBD_CDC_GetOtherSpeedCfgDesc+0x44>)
 8012f70:	f000 fa2a 	bl	80133c8 <USBD_GetEpDesc>
 8012f74:	2101      	movs	r1, #1
 8012f76:	4605      	mov	r5, r0
 8012f78:	480c      	ldr	r0, [pc, #48]	; (8012fac <USBD_CDC_GetOtherSpeedCfgDesc+0x44>)
 8012f7a:	f000 fa25 	bl	80133c8 <USBD_GetEpDesc>
 8012f7e:	2181      	movs	r1, #129	; 0x81
 8012f80:	4604      	mov	r4, r0
 8012f82:	480a      	ldr	r0, [pc, #40]	; (8012fac <USBD_CDC_GetOtherSpeedCfgDesc+0x44>)
 8012f84:	f000 fa20 	bl	80133c8 <USBD_GetEpDesc>
 8012f88:	b10d      	cbz	r5, 8012f8e <USBD_CDC_GetOtherSpeedCfgDesc+0x26>
 8012f8a:	2210      	movs	r2, #16
 8012f8c:	71aa      	strb	r2, [r5, #6]
 8012f8e:	b11c      	cbz	r4, 8012f98 <USBD_CDC_GetOtherSpeedCfgDesc+0x30>
 8012f90:	2100      	movs	r1, #0
 8012f92:	2240      	movs	r2, #64	; 0x40
 8012f94:	7161      	strb	r1, [r4, #5]
 8012f96:	7122      	strb	r2, [r4, #4]
 8012f98:	b118      	cbz	r0, 8012fa2 <USBD_CDC_GetOtherSpeedCfgDesc+0x3a>
 8012f9a:	2100      	movs	r1, #0
 8012f9c:	2240      	movs	r2, #64	; 0x40
 8012f9e:	7141      	strb	r1, [r0, #5]
 8012fa0:	7102      	strb	r2, [r0, #4]
 8012fa2:	2343      	movs	r3, #67	; 0x43
 8012fa4:	4801      	ldr	r0, [pc, #4]	; (8012fac <USBD_CDC_GetOtherSpeedCfgDesc+0x44>)
 8012fa6:	8033      	strh	r3, [r6, #0]
 8012fa8:	bd70      	pop	{r4, r5, r6, pc}
 8012faa:	bf00      	nop
 8012fac:	240080d0 	.word	0x240080d0

08012fb0 <USBD_CDC_RegisterInterface>:
  * @param  fops: CD  Interface callback
  * @retval status
  */
uint8_t USBD_CDC_RegisterInterface(USBD_HandleTypeDef *pdev,
                                   USBD_CDC_ItfTypeDef *fops)
{
 8012fb0:	4603      	mov	r3, r0
  if (fops == NULL)
 8012fb2:	b139      	cbz	r1, 8012fc4 <USBD_CDC_RegisterInterface+0x14>
  {
    return (uint8_t)USBD_FAIL;
  }

  pdev->pUserData[pdev->classId] = fops;
 8012fb4:	f8d0 22d4 	ldr.w	r2, [r0, #724]	; 0x2d4

  return (uint8_t)USBD_OK;
 8012fb8:	2000      	movs	r0, #0
  pdev->pUserData[pdev->classId] = fops;
 8012fba:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8012fbe:	f8c3 12c4 	str.w	r1, [r3, #708]	; 0x2c4
  return (uint8_t)USBD_OK;
 8012fc2:	4770      	bx	lr
    return (uint8_t)USBD_FAIL;
 8012fc4:	2003      	movs	r0, #3
}
 8012fc6:	4770      	bx	lr

08012fc8 <USBD_CDC_SetTxBuffer>:
  * @retval status
  */
uint8_t USBD_CDC_SetTxBuffer(USBD_HandleTypeDef *pdev,
                             uint8_t *pbuff, uint32_t length)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8012fc8:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
 8012fcc:	33b0      	adds	r3, #176	; 0xb0
 8012fce:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]

  if (hcdc == NULL)
 8012fd2:	b12b      	cbz	r3, 8012fe0 <USBD_CDC_SetTxBuffer+0x18>
  }

  hcdc->TxBuffer = pbuff;
  hcdc->TxLength = length;

  return (uint8_t)USBD_OK;
 8012fd4:	2000      	movs	r0, #0
  hcdc->TxBuffer = pbuff;
 8012fd6:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
  hcdc->TxLength = length;
 8012fda:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
  return (uint8_t)USBD_OK;
 8012fde:	4770      	bx	lr
    return (uint8_t)USBD_FAIL;
 8012fe0:	2003      	movs	r0, #3
}
 8012fe2:	4770      	bx	lr

08012fe4 <USBD_CDC_SetRxBuffer>:
  * @param  pbuff: Rx Buffer
  * @retval status
  */
uint8_t USBD_CDC_SetRxBuffer(USBD_HandleTypeDef *pdev, uint8_t *pbuff)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8012fe4:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
 8012fe8:	33b0      	adds	r3, #176	; 0xb0
 8012fea:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]

  if (hcdc == NULL)
 8012fee:	b11b      	cbz	r3, 8012ff8 <USBD_CDC_SetRxBuffer+0x14>
    return (uint8_t)USBD_FAIL;
  }

  hcdc->RxBuffer = pbuff;

  return (uint8_t)USBD_OK;
 8012ff0:	2000      	movs	r0, #0
  hcdc->RxBuffer = pbuff;
 8012ff2:	f8c3 1204 	str.w	r1, [r3, #516]	; 0x204
  return (uint8_t)USBD_OK;
 8012ff6:	4770      	bx	lr
    return (uint8_t)USBD_FAIL;
 8012ff8:	2003      	movs	r0, #3
}
 8012ffa:	4770      	bx	lr

08012ffc <USBD_CDC_TransmitPacket>:
  * @param  pdev: device instance
  * @retval status
  */
uint8_t USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8012ffc:	f8d0 32d4 	ldr.w	r3, [r0, #724]	; 0x2d4
 8013000:	33b0      	adds	r3, #176	; 0xb0
 8013002:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]

#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK);
#endif /* USE_USBD_COMPOSITE */
  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8013006:	b192      	cbz	r2, 801302e <USBD_CDC_TransmitPacket+0x32>
{
 8013008:	b510      	push	{r4, lr}
  {
    return (uint8_t)USBD_FAIL;
  }

  if (hcdc->TxState == 0U)
 801300a:	f8d2 4214 	ldr.w	r4, [r2, #532]	; 0x214
 801300e:	b10c      	cbz	r4, 8013014 <USBD_CDC_TransmitPacket+0x18>
  USBD_StatusTypeDef ret = USBD_BUSY;
 8013010:	2001      	movs	r0, #1

    ret = USBD_OK;
  }

  return (uint8_t)ret;
}
 8013012:	bd10      	pop	{r4, pc}
    hcdc->TxState = 1U;
 8013014:	2301      	movs	r3, #1
    (void)USBD_LL_Transmit(pdev, CDCInEpAdd, hcdc->TxBuffer, hcdc->TxLength);
 8013016:	2181      	movs	r1, #129	; 0x81
    hcdc->TxState = 1U;
 8013018:	f8c2 3214 	str.w	r3, [r2, #532]	; 0x214
    pdev->ep_in[CDCInEpAdd & 0xFU].total_length = hcdc->TxLength;
 801301c:	f8d2 3210 	ldr.w	r3, [r2, #528]	; 0x210
    (void)USBD_LL_Transmit(pdev, CDCInEpAdd, hcdc->TxBuffer, hcdc->TxLength);
 8013020:	f8d2 2208 	ldr.w	r2, [r2, #520]	; 0x208
    pdev->ep_in[CDCInEpAdd & 0xFU].total_length = hcdc->TxLength;
 8013024:	62c3      	str	r3, [r0, #44]	; 0x2c
    (void)USBD_LL_Transmit(pdev, CDCInEpAdd, hcdc->TxBuffer, hcdc->TxLength);
 8013026:	f001 f80b 	bl	8014040 <USBD_LL_Transmit>
    ret = USBD_OK;
 801302a:	4620      	mov	r0, r4
}
 801302c:	bd10      	pop	{r4, pc}
    return (uint8_t)USBD_FAIL;
 801302e:	2003      	movs	r0, #3
}
 8013030:	4770      	bx	lr
 8013032:	bf00      	nop

08013034 <USBD_CDC_ReceivePacket>:
  * @param  pdev: device instance
  * @retval status
  */
uint8_t USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8013034:	f8d0 22d4 	ldr.w	r2, [r0, #724]	; 0x2d4
 8013038:	32b0      	adds	r2, #176	; 0xb0
 801303a:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
{
 801303e:	b510      	push	{r4, lr}
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8013040:	b19a      	cbz	r2, 801306a <USBD_CDC_ReceivePacket+0x36>
  {
    return (uint8_t)USBD_FAIL;
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8013042:	7c04      	ldrb	r4, [r0, #16]
 8013044:	b144      	cbz	r4, 8013058 <USBD_CDC_ReceivePacket+0x24>
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 8013046:	2400      	movs	r4, #0
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8013048:	2340      	movs	r3, #64	; 0x40
 801304a:	f8d2 2204 	ldr.w	r2, [r2, #516]	; 0x204
 801304e:	2101      	movs	r1, #1
 8013050:	f001 f804 	bl	801405c <USBD_LL_PrepareReceive>
}
 8013054:	4620      	mov	r0, r4
 8013056:	bd10      	pop	{r4, pc}
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8013058:	f44f 7300 	mov.w	r3, #512	; 0x200
 801305c:	f8d2 2204 	ldr.w	r2, [r2, #516]	; 0x204
 8013060:	2101      	movs	r1, #1
 8013062:	f000 fffb 	bl	801405c <USBD_LL_PrepareReceive>
}
 8013066:	4620      	mov	r0, r4
 8013068:	bd10      	pop	{r4, pc}
    return (uint8_t)USBD_FAIL;
 801306a:	2403      	movs	r4, #3
}
 801306c:	4620      	mov	r0, r4
 801306e:	bd10      	pop	{r4, pc}

08013070 <USBD_Init>:
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
  USBD_StatusTypeDef ret;

  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 8013070:	b178      	cbz	r0, 8013092 <USBD_Init+0x22>
    pdev->NumClasses = 0;
    pdev->classId = 0;
  }
#else
  /* Unlink previous class*/
  pdev->pClass[0] = NULL;
 8013072:	2300      	movs	r3, #0
 8013074:	f8c0 32b8 	str.w	r3, [r0, #696]	; 0x2b8
  pdev->pUserData[0] = NULL;
 8013078:	f8c0 32c4 	str.w	r3, [r0, #708]	; 0x2c4
#endif /* USE_USBD_COMPOSITE */

  pdev->pConfDesc = NULL;
 801307c:	f8c0 32d0 	str.w	r3, [r0, #720]	; 0x2d0

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 8013080:	b109      	cbz	r1, 8013086 <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 8013082:	f8c0 12b4 	str.w	r1, [r0, #692]	; 0x2b4
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8013086:	2301      	movs	r3, #1
  pdev->id = id;
 8013088:	7002      	strb	r2, [r0, #0]
  pdev->dev_state = USBD_STATE_DEFAULT;
 801308a:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c

  /* Initialize low level driver */
  ret = USBD_LL_Init(pdev);
 801308e:	f000 bf23 	b.w	8013ed8 <USBD_LL_Init>

  return ret;
}
 8013092:	2003      	movs	r0, #3
 8013094:	4770      	bx	lr
 8013096:	bf00      	nop

08013098 <USBD_RegisterClass>:
  * @param  pDevice : Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 8013098:	b510      	push	{r4, lr}
  uint16_t len = 0U;
 801309a:	2300      	movs	r3, #0
{
 801309c:	b082      	sub	sp, #8
  uint16_t len = 0U;
 801309e:	f8ad 3006 	strh.w	r3, [sp, #6]

  if (pclass == NULL)
 80130a2:	b189      	cbz	r1, 80130c8 <USBD_RegisterClass+0x30>
  if (pdev->pClass[pdev->classId]->GetHSConfigDescriptor != NULL)
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetHSConfigDescriptor(&len);
  }
#else /* Default USE_USB_FS */
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
 80130a4:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 80130a6:	4604      	mov	r4, r0
  pdev->pClass[0] = pclass;
 80130a8:	f8c0 12b8 	str.w	r1, [r0, #696]	; 0x2b8
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
 80130ac:	b123      	cbz	r3, 80130b8 <USBD_RegisterClass+0x20>
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetFSConfigDescriptor(&len);
 80130ae:	f10d 0006 	add.w	r0, sp, #6
 80130b2:	4798      	blx	r3
 80130b4:	f8c4 02d0 	str.w	r0, [r4, #720]	; 0x2d0
  }
#endif /* USE_USB_FS */

  /* Increment the NumClasses */
  pdev->NumClasses ++;
 80130b8:	f8d4 32d8 	ldr.w	r3, [r4, #728]	; 0x2d8

  return USBD_OK;
 80130bc:	2000      	movs	r0, #0
  pdev->NumClasses ++;
 80130be:	3301      	adds	r3, #1
 80130c0:	f8c4 32d8 	str.w	r3, [r4, #728]	; 0x2d8
}
 80130c4:	b002      	add	sp, #8
 80130c6:	bd10      	pop	{r4, pc}
    return USBD_FAIL;
 80130c8:	2003      	movs	r0, #3
}
 80130ca:	b002      	add	sp, #8
 80130cc:	bd10      	pop	{r4, pc}
 80130ce:	bf00      	nop

080130d0 <USBD_Start>:
#ifdef USE_USBD_COMPOSITE
  pdev->classId = 0U;
#endif /* USE_USBD_COMPOSITE */

  /* Start the low level driver  */
  return USBD_LL_Start(pdev);
 80130d0:	f000 bf4a 	b.w	8013f68 <USBD_LL_Start>

080130d4 <USBD_SetClassConfig>:
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 80130d4:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 80130d8:	b10b      	cbz	r3, 80130de <USBD_SetClassConfig+0xa>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass[0]->Init(pdev, cfgidx);
 80130da:	681b      	ldr	r3, [r3, #0]
 80130dc:	4718      	bx	r3
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
}
 80130de:	4618      	mov	r0, r3
 80130e0:	4770      	bx	lr
 80130e2:	bf00      	nop

080130e4 <USBD_ClrClassConfig>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status: USBD_StatusTypeDef
  */
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 80130e4:	b508      	push	{r3, lr}
      }
    }
  }
#else
  /* Clear configuration  and De-initialize the Class process */
  if (pdev->pClass[0]->DeInit(pdev, cfgidx) != 0U)
 80130e6:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 80130ea:	685b      	ldr	r3, [r3, #4]
 80130ec:	4798      	blx	r3
  {
    ret = USBD_FAIL;
 80130ee:	2800      	cmp	r0, #0
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
}
 80130f0:	bf18      	it	ne
 80130f2:	2003      	movne	r0, #3
 80130f4:	bd08      	pop	{r3, pc}
 80130f6:	bf00      	nop

080130f8 <USBD_LL_SetupStage>:
  *         Handle the setup stage
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 80130f8:	b538      	push	{r3, r4, r5, lr}
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
 80130fa:	f200 25aa 	addw	r5, r0, #682	; 0x2aa
{
 80130fe:	4604      	mov	r4, r0
  USBD_ParseSetupRequest(&pdev->request, psetup);
 8013100:	4628      	mov	r0, r5
 8013102:	f000 fc19 	bl	8013938 <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;

  pdev->ep0_data_len = pdev->request.wLength;
 8013106:	f8b4 32b0 	ldrh.w	r3, [r4, #688]	; 0x2b0

  switch (pdev->request.bmRequest & 0x1FU)
 801310a:	f894 12aa 	ldrb.w	r1, [r4, #682]	; 0x2aa
  pdev->ep0_state = USBD_EP0_SETUP;
 801310e:	2201      	movs	r2, #1
  pdev->ep0_data_len = pdev->request.wLength;
 8013110:	f8c4 3298 	str.w	r3, [r4, #664]	; 0x298
 8013114:	f001 031f 	and.w	r3, r1, #31
  pdev->ep0_state = USBD_EP0_SETUP;
 8013118:	f8c4 2294 	str.w	r2, [r4, #660]	; 0x294
  switch (pdev->request.bmRequest & 0x1FU)
 801311c:	4293      	cmp	r3, r2
 801311e:	d009      	beq.n	8013134 <USBD_LL_SetupStage+0x3c>
 8013120:	2b02      	cmp	r3, #2
 8013122:	d013      	beq.n	801314c <USBD_LL_SetupStage+0x54>
 8013124:	b163      	cbz	r3, 8013140 <USBD_LL_SetupStage+0x48>
    case USB_REQ_RECIPIENT_ENDPOINT:
      ret = USBD_StdEPReq(pdev, &pdev->request);
      break;

    default:
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 8013126:	4620      	mov	r0, r4
 8013128:	f001 0180 	and.w	r1, r1, #128	; 0x80
      break;
  }

  return ret;
}
 801312c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 8013130:	f000 bf48 	b.w	8013fc4 <USBD_LL_StallEP>
      ret = USBD_StdItfReq(pdev, &pdev->request);
 8013134:	4629      	mov	r1, r5
 8013136:	4620      	mov	r0, r4
}
 8013138:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_StdItfReq(pdev, &pdev->request);
 801313c:	f000 bb0a 	b.w	8013754 <USBD_StdItfReq>
      ret = USBD_StdDevReq(pdev, &pdev->request);
 8013140:	4629      	mov	r1, r5
 8013142:	4620      	mov	r0, r4
}
 8013144:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_StdDevReq(pdev, &pdev->request);
 8013148:	f000 b954 	b.w	80133f4 <USBD_StdDevReq>
      ret = USBD_StdEPReq(pdev, &pdev->request);
 801314c:	4629      	mov	r1, r5
 801314e:	4620      	mov	r0, r4
}
 8013150:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      ret = USBD_StdEPReq(pdev, &pdev->request);
 8013154:	f000 bb40 	b.w	80137d8 <USBD_StdEPReq>

08013158 <USBD_LL_DataOutStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 8013158:	b570      	push	{r4, r5, r6, lr}
 801315a:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret = USBD_OK;
  uint8_t idx;

  if (epnum == 0U)
 801315c:	b931      	cbnz	r1, 801316c <USBD_LL_DataOutStage+0x14>
 801315e:	460b      	mov	r3, r1
  {
    pep = &pdev->ep_out[0];

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 8013160:	f8d0 1294 	ldr.w	r1, [r0, #660]	; 0x294
 8013164:	2903      	cmp	r1, #3
 8013166:	d010      	beq.n	801318a <USBD_LL_DataOutStage+0x32>
      }
    }
  }

  return USBD_OK;
}
 8013168:	2000      	movs	r0, #0
 801316a:	bd70      	pop	{r4, r5, r6, pc}
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801316c:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8013170:	2b03      	cmp	r3, #3
 8013172:	d1f9      	bne.n	8013168 <USBD_LL_DataOutStage+0x10>
        if (pdev->pClass[idx]->DataOut != NULL)
 8013174:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 8013178:	699b      	ldr	r3, [r3, #24]
 801317a:	2b00      	cmp	r3, #0
 801317c:	d0f4      	beq.n	8013168 <USBD_LL_DataOutStage+0x10>
          pdev->classId = idx;
 801317e:	2200      	movs	r2, #0
}
 8013180:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          pdev->classId = idx;
 8013184:	f8c0 22d4 	str.w	r2, [r0, #724]	; 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataOut(pdev, epnum);
 8013188:	4718      	bx	r3
      if (pep->rem_length > pep->maxpacket)
 801318a:	e9d0 1557 	ldrd	r1, r5, [r0, #348]	; 0x15c
 801318e:	42a9      	cmp	r1, r5
 8013190:	d808      	bhi.n	80131a4 <USBD_LL_DataOutStage+0x4c>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8013192:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
 8013196:	2a03      	cmp	r2, #3
 8013198:	d00f      	beq.n	80131ba <USBD_LL_DataOutStage+0x62>
        (void)USBD_CtlSendStatus(pdev);
 801319a:	4620      	mov	r0, r4
 801319c:	f000 fc3e 	bl	8013a1c <USBD_CtlSendStatus>
}
 80131a0:	2000      	movs	r0, #0
 80131a2:	bd70      	pop	{r4, r5, r6, pc}
        pep->rem_length -= pep->maxpacket;
 80131a4:	1b4b      	subs	r3, r1, r5
        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 80131a6:	4611      	mov	r1, r2
 80131a8:	462a      	mov	r2, r5
 80131aa:	429d      	cmp	r5, r3
        pep->rem_length -= pep->maxpacket;
 80131ac:	f8c0 315c 	str.w	r3, [r0, #348]	; 0x15c
        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 80131b0:	bf28      	it	cs
 80131b2:	461a      	movcs	r2, r3
 80131b4:	f000 fc28 	bl	8013a08 <USBD_CtlContinueRx>
 80131b8:	e7d6      	b.n	8013168 <USBD_LL_DataOutStage+0x10>
            if (pdev->pClass[idx]->EP0_RxReady != NULL)
 80131ba:	f8d0 22b8 	ldr.w	r2, [r0, #696]	; 0x2b8
 80131be:	6912      	ldr	r2, [r2, #16]
 80131c0:	2a00      	cmp	r2, #0
 80131c2:	d0ea      	beq.n	801319a <USBD_LL_DataOutStage+0x42>
              pdev->classId = idx;
 80131c4:	f8c0 32d4 	str.w	r3, [r0, #724]	; 0x2d4
              pdev->pClass[idx]->EP0_RxReady(pdev);
 80131c8:	4790      	blx	r2
 80131ca:	e7e6      	b.n	801319a <USBD_LL_DataOutStage+0x42>

080131cc <USBD_LL_DataInStage>:
  * @param  epnum: endpoint index
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 80131cc:	b570      	push	{r4, r5, r6, lr}
 80131ce:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;
  uint8_t idx;

  if (epnum == 0U)
 80131d0:	b959      	cbnz	r1, 80131ea <USBD_LL_DataInStage+0x1e>
  {
    pep = &pdev->ep_in[0];

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 80131d2:	f8d0 3294 	ldr.w	r3, [r0, #660]	; 0x294
 80131d6:	2b02      	cmp	r3, #2
 80131d8:	d016      	beq.n	8013208 <USBD_LL_DataInStage+0x3c>
        (void)USBD_LL_StallEP(pdev, 0x80U);
      }
#endif
    }

    if (pdev->dev_test_mode != 0U)
 80131da:	f894 32a0 	ldrb.w	r3, [r4, #672]	; 0x2a0
 80131de:	b113      	cbz	r3, 80131e6 <USBD_LL_DataInStage+0x1a>
    {
      (void)USBD_RunTestMode(pdev);
      pdev->dev_test_mode = 0U;
 80131e0:	2300      	movs	r3, #0
 80131e2:	f884 32a0 	strb.w	r3, [r4, #672]	; 0x2a0
      }
    }
  }

  return USBD_OK;
}
 80131e6:	2000      	movs	r0, #0
 80131e8:	bd70      	pop	{r4, r5, r6, pc}
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80131ea:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 80131ee:	2b03      	cmp	r3, #3
 80131f0:	d1f9      	bne.n	80131e6 <USBD_LL_DataInStage+0x1a>
        if (pdev->pClass[idx]->DataIn != NULL)
 80131f2:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 80131f6:	695b      	ldr	r3, [r3, #20]
 80131f8:	2b00      	cmp	r3, #0
 80131fa:	d0f4      	beq.n	80131e6 <USBD_LL_DataInStage+0x1a>
          pdev->classId = idx;
 80131fc:	2200      	movs	r2, #0
}
 80131fe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          pdev->classId = idx;
 8013202:	f8c0 22d4 	str.w	r2, [r0, #724]	; 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataIn(pdev, epnum);
 8013206:	4718      	bx	r3
      if (pep->rem_length > pep->maxpacket)
 8013208:	e9d0 3607 	ldrd	r3, r6, [r0, #28]
 801320c:	460d      	mov	r5, r1
 801320e:	42b3      	cmp	r3, r6
 8013210:	d810      	bhi.n	8013234 <USBD_LL_DataInStage+0x68>
        if ((pep->maxpacket == pep->rem_length) &&
 8013212:	d01c      	beq.n	801324e <USBD_LL_DataInStage+0x82>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8013214:	f894 329c 	ldrb.w	r3, [r4, #668]	; 0x29c
 8013218:	2b03      	cmp	r3, #3
 801321a:	d02b      	beq.n	8013274 <USBD_LL_DataInStage+0xa8>
          (void)USBD_LL_StallEP(pdev, 0x80U);
 801321c:	2180      	movs	r1, #128	; 0x80
 801321e:	4620      	mov	r0, r4
 8013220:	f000 fed0 	bl	8013fc4 <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
 8013224:	4620      	mov	r0, r4
 8013226:	f000 fc05 	bl	8013a34 <USBD_CtlReceiveStatus>
    if (pdev->dev_test_mode != 0U)
 801322a:	f894 32a0 	ldrb.w	r3, [r4, #672]	; 0x2a0
 801322e:	2b00      	cmp	r3, #0
 8013230:	d0d9      	beq.n	80131e6 <USBD_LL_DataInStage+0x1a>
 8013232:	e7d5      	b.n	80131e0 <USBD_LL_DataInStage+0x14>
        pep->rem_length -= pep->maxpacket;
 8013234:	1b9b      	subs	r3, r3, r6
        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 8013236:	4611      	mov	r1, r2
        pep->rem_length -= pep->maxpacket;
 8013238:	61c3      	str	r3, [r0, #28]
        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 801323a:	461a      	mov	r2, r3
 801323c:	f000 fbcc 	bl	80139d8 <USBD_CtlContinueSendData>
        (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8013240:	462b      	mov	r3, r5
 8013242:	462a      	mov	r2, r5
 8013244:	4629      	mov	r1, r5
 8013246:	4620      	mov	r0, r4
 8013248:	f000 ff08 	bl	801405c <USBD_LL_PrepareReceive>
 801324c:	e7c5      	b.n	80131da <USBD_LL_DataInStage+0xe>
            (pep->total_length >= pep->maxpacket) &&
 801324e:	6982      	ldr	r2, [r0, #24]
        if ((pep->maxpacket == pep->rem_length) &&
 8013250:	4293      	cmp	r3, r2
 8013252:	d8df      	bhi.n	8013214 <USBD_LL_DataInStage+0x48>
            (pep->total_length >= pep->maxpacket) &&
 8013254:	f8d0 3298 	ldr.w	r3, [r0, #664]	; 0x298
 8013258:	429a      	cmp	r2, r3
 801325a:	d2db      	bcs.n	8013214 <USBD_LL_DataInStage+0x48>
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
 801325c:	460a      	mov	r2, r1
 801325e:	f000 fbbb 	bl	80139d8 <USBD_CtlContinueSendData>
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8013262:	462b      	mov	r3, r5
 8013264:	462a      	mov	r2, r5
 8013266:	4629      	mov	r1, r5
 8013268:	4620      	mov	r0, r4
          pdev->ep0_data_len = 0U;
 801326a:	f8c4 5298 	str.w	r5, [r4, #664]	; 0x298
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 801326e:	f000 fef5 	bl	801405c <USBD_LL_PrepareReceive>
 8013272:	e7b2      	b.n	80131da <USBD_LL_DataInStage+0xe>
            if (pdev->pClass[0]->EP0_TxSent != NULL)
 8013274:	f8d4 32b8 	ldr.w	r3, [r4, #696]	; 0x2b8
 8013278:	68db      	ldr	r3, [r3, #12]
 801327a:	2b00      	cmp	r3, #0
 801327c:	d0ce      	beq.n	801321c <USBD_LL_DataInStage+0x50>
              pdev->classId = 0U;
 801327e:	2200      	movs	r2, #0
              pdev->pClass[0]->EP0_TxSent(pdev);
 8013280:	4620      	mov	r0, r4
              pdev->classId = 0U;
 8013282:	f8c4 22d4 	str.w	r2, [r4, #724]	; 0x2d4
              pdev->pClass[0]->EP0_TxSent(pdev);
 8013286:	4798      	blx	r3
 8013288:	e7c8      	b.n	801321c <USBD_LL_DataInStage+0x50>
 801328a:	bf00      	nop

0801328c <USBD_LL_Reset>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 801328c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USBD_StatusTypeDef ret = USBD_OK;

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
  pdev->ep0_state = USBD_EP0_IDLE;
 801328e:	2100      	movs	r1, #0
  pdev->dev_state = USBD_STATE_DEFAULT;
 8013290:	2201      	movs	r2, #1
      }
    }
  }
#else

  if (pdev->pClass[0] != NULL)
 8013292:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
{
 8013296:	4604      	mov	r4, r0
  pdev->dev_state = USBD_STATE_DEFAULT;
 8013298:	f880 229c 	strb.w	r2, [r0, #668]	; 0x29c
  pdev->dev_config = 0U;
 801329c:	6041      	str	r1, [r0, #4]
  pdev->ep0_state = USBD_EP0_IDLE;
 801329e:	f8c0 1294 	str.w	r1, [r0, #660]	; 0x294
  pdev->dev_remote_wakeup = 0U;
 80132a2:	f8c0 12a4 	str.w	r1, [r0, #676]	; 0x2a4
  pdev->dev_test_mode = 0U;
 80132a6:	f880 12a0 	strb.w	r1, [r0, #672]	; 0x2a0
  if (pdev->pClass[0] != NULL)
 80132aa:	b11b      	cbz	r3, 80132b4 <USBD_LL_Reset+0x28>
  {
    if (pdev->pClass[0]->DeInit != NULL)
 80132ac:	685b      	ldr	r3, [r3, #4]
 80132ae:	b10b      	cbz	r3, 80132b4 <USBD_LL_Reset+0x28>
    {
      if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != USBD_OK)
 80132b0:	4798      	blx	r3
 80132b2:	b9b0      	cbnz	r0, 80132e2 <USBD_LL_Reset+0x56>
  USBD_StatusTypeDef ret = USBD_OK;
 80132b4:	2700      	movs	r7, #0
    }
  }
#endif /* USE_USBD_COMPOSITE */

  /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80132b6:	2340      	movs	r3, #64	; 0x40
 80132b8:	2200      	movs	r2, #0
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 80132ba:	2601      	movs	r6, #1
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80132bc:	4620      	mov	r0, r4

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 80132be:	461d      	mov	r5, r3
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80132c0:	4611      	mov	r1, r2
 80132c2:	f000 fe5f 	bl	8013f84 <USBD_LL_OpenEP>

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80132c6:	2200      	movs	r2, #0
 80132c8:	462b      	mov	r3, r5
 80132ca:	2180      	movs	r1, #128	; 0x80
 80132cc:	4620      	mov	r0, r4
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 80132ce:	f8a4 6164 	strh.w	r6, [r4, #356]	; 0x164
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 80132d2:	f8c4 5160 	str.w	r5, [r4, #352]	; 0x160
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80132d6:	f000 fe55 	bl	8013f84 <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;

  return ret;
}
 80132da:	4638      	mov	r0, r7
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 80132dc:	84a6      	strh	r6, [r4, #36]	; 0x24
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 80132de:	6225      	str	r5, [r4, #32]
}
 80132e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ret = USBD_FAIL;
 80132e2:	2703      	movs	r7, #3
 80132e4:	e7e7      	b.n	80132b6 <USBD_LL_Reset+0x2a>
 80132e6:	bf00      	nop

080132e8 <USBD_LL_SetSpeed>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
 80132e8:	4603      	mov	r3, r0
  pdev->dev_speed = speed;

  return USBD_OK;
}
 80132ea:	2000      	movs	r0, #0
  pdev->dev_speed = speed;
 80132ec:	7419      	strb	r1, [r3, #16]
}
 80132ee:	4770      	bx	lr

080132f0 <USBD_LL_Suspend>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
 80132f0:	4603      	mov	r3, r0
  pdev->dev_old_state = pdev->dev_state;
  pdev->dev_state = USBD_STATE_SUSPENDED;
 80132f2:	2104      	movs	r1, #4

  return USBD_OK;
}
 80132f4:	2000      	movs	r0, #0
  pdev->dev_old_state = pdev->dev_state;
 80132f6:	f893 229c 	ldrb.w	r2, [r3, #668]	; 0x29c
 80132fa:	b2d2      	uxtb	r2, r2
 80132fc:	f883 229d 	strb.w	r2, [r3, #669]	; 0x29d
  pdev->dev_state = USBD_STATE_SUSPENDED;
 8013300:	f883 129c 	strb.w	r1, [r3, #668]	; 0x29c
}
 8013304:	4770      	bx	lr
 8013306:	bf00      	nop

08013308 <USBD_LL_Resume>:
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 8013308:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 801330c:	2b04      	cmp	r3, #4
 801330e:	d104      	bne.n	801331a <USBD_LL_Resume+0x12>
  {
    pdev->dev_state = pdev->dev_old_state;
 8013310:	f890 329d 	ldrb.w	r3, [r0, #669]	; 0x29d
 8013314:	b2db      	uxtb	r3, r3
 8013316:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
  }

  return USBD_OK;
}
 801331a:	2000      	movs	r0, #0
 801331c:	4770      	bx	lr
 801331e:	bf00      	nop

08013320 <USBD_LL_SOF>:
  */

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
  /* The SOF event can be distributed for all classes that support it */
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8013320:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
 8013324:	2a03      	cmp	r2, #3
 8013326:	d001      	beq.n	801332c <USBD_LL_SOF+0xc>
    }
#endif /* USE_USBD_COMPOSITE */
  }

  return USBD_OK;
}
 8013328:	2000      	movs	r0, #0
 801332a:	4770      	bx	lr
{
 801332c:	b508      	push	{r3, lr}
    if (pdev->pClass[0] != NULL)
 801332e:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 8013332:	b113      	cbz	r3, 801333a <USBD_LL_SOF+0x1a>
      if (pdev->pClass[0]->SOF != NULL)
 8013334:	69db      	ldr	r3, [r3, #28]
 8013336:	b103      	cbz	r3, 801333a <USBD_LL_SOF+0x1a>
        (void)pdev->pClass[0]->SOF(pdev);
 8013338:	4798      	blx	r3
}
 801333a:	2000      	movs	r0, #0
 801333c:	bd08      	pop	{r3, pc}
 801333e:	bf00      	nop

08013340 <USBD_LL_IsoINIncomplete>:
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef *pdev,
                                           uint8_t epnum)
{
  if (pdev->pClass[pdev->classId] == NULL)
 8013340:	f8d0 22d4 	ldr.w	r2, [r0, #724]	; 0x2d4
 8013344:	32ae      	adds	r2, #174	; 0xae
 8013346:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 801334a:	b15a      	cbz	r2, 8013364 <USBD_LL_IsoINIncomplete+0x24>
{
 801334c:	b508      	push	{r3, lr}
  {
    return USBD_FAIL;
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801334e:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8013352:	2b03      	cmp	r3, #3
 8013354:	d001      	beq.n	801335a <USBD_LL_IsoINIncomplete+0x1a>
    {
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
    }
  }

  return USBD_OK;
 8013356:	2000      	movs	r0, #0
}
 8013358:	bd08      	pop	{r3, pc}
    if (pdev->pClass[pdev->classId]->IsoINIncomplete != NULL)
 801335a:	6a13      	ldr	r3, [r2, #32]
 801335c:	b123      	cbz	r3, 8013368 <USBD_LL_IsoINIncomplete+0x28>
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
 801335e:	4798      	blx	r3
  return USBD_OK;
 8013360:	2000      	movs	r0, #0
}
 8013362:	bd08      	pop	{r3, pc}
    return USBD_FAIL;
 8013364:	2003      	movs	r0, #3
}
 8013366:	4770      	bx	lr
  return USBD_OK;
 8013368:	4618      	mov	r0, r3
}
 801336a:	bd08      	pop	{r3, pc}

0801336c <USBD_LL_IsoOUTIncomplete>:
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef *pdev,
                                            uint8_t epnum)
{
  if (pdev->pClass[pdev->classId] == NULL)
 801336c:	f8d0 22d4 	ldr.w	r2, [r0, #724]	; 0x2d4
 8013370:	32ae      	adds	r2, #174	; 0xae
 8013372:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 8013376:	b15a      	cbz	r2, 8013390 <USBD_LL_IsoOUTIncomplete+0x24>
{
 8013378:	b508      	push	{r3, lr}
  {
    return USBD_FAIL;
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801337a:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 801337e:	2b03      	cmp	r3, #3
 8013380:	d001      	beq.n	8013386 <USBD_LL_IsoOUTIncomplete+0x1a>
    {
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
    }
  }

  return USBD_OK;
 8013382:	2000      	movs	r0, #0
}
 8013384:	bd08      	pop	{r3, pc}
    if (pdev->pClass[pdev->classId]->IsoOUTIncomplete != NULL)
 8013386:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8013388:	b123      	cbz	r3, 8013394 <USBD_LL_IsoOUTIncomplete+0x28>
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
 801338a:	4798      	blx	r3
  return USBD_OK;
 801338c:	2000      	movs	r0, #0
}
 801338e:	bd08      	pop	{r3, pc}
    return USBD_FAIL;
 8013390:	2003      	movs	r0, #3
}
 8013392:	4770      	bx	lr
  return USBD_OK;
 8013394:	4618      	mov	r0, r3
}
 8013396:	bd08      	pop	{r3, pc}

08013398 <USBD_LL_DevConnected>:
 8013398:	2000      	movs	r0, #0
 801339a:	4770      	bx	lr

0801339c <USBD_LL_DevDisconnected>:
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef *pdev)
{
  USBD_StatusTypeDef   ret = USBD_OK;

  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 801339c:	2101      	movs	r1, #1
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 801339e:	f8d0 22b8 	ldr.w	r2, [r0, #696]	; 0x2b8
  pdev->dev_state = USBD_STATE_DEFAULT;
 80133a2:	f880 129c 	strb.w	r1, [r0, #668]	; 0x29c
  if (pdev->pClass[0] != NULL)
 80133a6:	b142      	cbz	r2, 80133ba <USBD_LL_DevDisconnected+0x1e>
  {
    if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
 80133a8:	6852      	ldr	r2, [r2, #4]
 80133aa:	7901      	ldrb	r1, [r0, #4]
{
 80133ac:	b508      	push	{r3, lr}
    if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
 80133ae:	4790      	blx	r2
 80133b0:	b908      	cbnz	r0, 80133b6 <USBD_LL_DevDisconnected+0x1a>
  USBD_StatusTypeDef   ret = USBD_OK;
 80133b2:	2000      	movs	r0, #0
    }
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
}
 80133b4:	bd08      	pop	{r3, pc}
      ret = USBD_FAIL;
 80133b6:	2003      	movs	r0, #3
}
 80133b8:	bd08      	pop	{r3, pc}
  USBD_StatusTypeDef   ret = USBD_OK;
 80133ba:	2000      	movs	r0, #0
}
 80133bc:	4770      	bx	lr
 80133be:	bf00      	nop

080133c0 <USBD_CoreFindIF>:
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
#endif /* USE_USBD_COMPOSITE */
}
 80133c0:	2000      	movs	r0, #0
 80133c2:	4770      	bx	lr

080133c4 <USBD_CoreFindEP>:
 80133c4:	2000      	movs	r0, #0
 80133c6:	4770      	bx	lr

080133c8 <USBD_GetEpDesc>:
  USBD_DescHeaderTypeDef *pdesc = (USBD_DescHeaderTypeDef *)(void *)pConfDesc;
  USBD_ConfigDescTypeDef *desc = (USBD_ConfigDescTypeDef *)(void *)pConfDesc;
  USBD_EpDescTypeDef *pEpDesc = NULL;
  uint16_t ptr;

  if (desc->wTotalLength > desc->bLength)
 80133c8:	7802      	ldrb	r2, [r0, #0]
 80133ca:	f8b0 c002 	ldrh.w	ip, [r0, #2]
 80133ce:	b293      	uxth	r3, r2
 80133d0:	4594      	cmp	ip, r2
 80133d2:	d803      	bhi.n	80133dc <USBD_GetEpDesc+0x14>
 80133d4:	e00c      	b.n	80133f0 <USBD_GetEpDesc+0x28>
  {
    ptr = desc->bLength;

    while (ptr < desc->wTotalLength)
 80133d6:	459c      	cmp	ip, r3
 80133d8:	d90a      	bls.n	80133f0 <USBD_GetEpDesc+0x28>
  */
USBD_DescHeaderTypeDef *USBD_GetNextDesc(uint8_t *pbuf, uint16_t *ptr)
{
  USBD_DescHeaderTypeDef *pnext = (USBD_DescHeaderTypeDef *)(void *)pbuf;

  *ptr += pnext->bLength;
 80133da:	7802      	ldrb	r2, [r0, #0]
  pnext = (USBD_DescHeaderTypeDef *)(void *)(pbuf + pnext->bLength);
 80133dc:	4410      	add	r0, r2
  *ptr += pnext->bLength;
 80133de:	4413      	add	r3, r2
      if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 80133e0:	7842      	ldrb	r2, [r0, #1]
  *ptr += pnext->bLength;
 80133e2:	b29b      	uxth	r3, r3
      if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 80133e4:	2a05      	cmp	r2, #5
 80133e6:	d1f6      	bne.n	80133d6 <USBD_GetEpDesc+0xe>
        if (pEpDesc->bEndpointAddress == EpAddr)
 80133e8:	7882      	ldrb	r2, [r0, #2]
 80133ea:	428a      	cmp	r2, r1
 80133ec:	d1f3      	bne.n	80133d6 <USBD_GetEpDesc+0xe>
}
 80133ee:	4770      	bx	lr
  USBD_EpDescTypeDef *pEpDesc = NULL;
 80133f0:	2000      	movs	r0, #0
}
 80133f2:	4770      	bx	lr

080133f4 <USBD_StdDevReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdDevReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80133f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80133f6:	780c      	ldrb	r4, [r1, #0]
 80133f8:	b083      	sub	sp, #12
 80133fa:	460e      	mov	r6, r1
 80133fc:	4605      	mov	r5, r0
  USBD_StatusTypeDef ret = USBD_OK;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80133fe:	f004 0460 	and.w	r4, r4, #96	; 0x60
 8013402:	2c20      	cmp	r4, #32
 8013404:	d00e      	beq.n	8013424 <USBD_StdDevReq+0x30>
 8013406:	2c40      	cmp	r4, #64	; 0x40
 8013408:	d00c      	beq.n	8013424 <USBD_StdDevReq+0x30>
 801340a:	b1bc      	cbz	r4, 801343c <USBD_StdDevReq+0x48>
  */
void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
  UNUSED(req);

  (void)USBD_LL_StallEP(pdev, 0x80U);
 801340c:	2180      	movs	r1, #128	; 0x80
 801340e:	4628      	mov	r0, r5
 8013410:	f000 fdd8 	bl	8013fc4 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8013414:	2100      	movs	r1, #0
 8013416:	4628      	mov	r0, r5
  USBD_StatusTypeDef ret = USBD_OK;
 8013418:	460c      	mov	r4, r1
  (void)USBD_LL_StallEP(pdev, 0U);
 801341a:	f000 fdd3 	bl	8013fc4 <USBD_LL_StallEP>
}
 801341e:	4620      	mov	r0, r4
 8013420:	b003      	add	sp, #12
 8013422:	bdf0      	pop	{r4, r5, r6, r7, pc}
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 8013424:	f8d5 32d4 	ldr.w	r3, [r5, #724]	; 0x2d4
 8013428:	4631      	mov	r1, r6
 801342a:	4628      	mov	r0, r5
 801342c:	33ae      	adds	r3, #174	; 0xae
 801342e:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 8013432:	689b      	ldr	r3, [r3, #8]
}
 8013434:	b003      	add	sp, #12
 8013436:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 801343a:	4718      	bx	r3
      switch (req->bRequest)
 801343c:	784b      	ldrb	r3, [r1, #1]
 801343e:	2b09      	cmp	r3, #9
 8013440:	d8e4      	bhi.n	801340c <USBD_StdDevReq+0x18>
 8013442:	a201      	add	r2, pc, #4	; (adr r2, 8013448 <USBD_StdDevReq+0x54>)
 8013444:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8013448:	080134a9 	.word	0x080134a9
 801344c:	080134d7 	.word	0x080134d7
 8013450:	0801340d 	.word	0x0801340d
 8013454:	080134f5 	.word	0x080134f5
 8013458:	0801340d 	.word	0x0801340d
 801345c:	08013517 	.word	0x08013517
 8013460:	0801354f 	.word	0x0801354f
 8013464:	0801340d 	.word	0x0801340d
 8013468:	08013581 	.word	0x08013581
 801346c:	08013471 	.word	0x08013471
  cfgidx = (uint8_t)(req->wValue);
 8013470:	7889      	ldrb	r1, [r1, #2]
 8013472:	4eb3      	ldr	r6, [pc, #716]	; (8013740 <USBD_StdDevReq+0x34c>)
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8013474:	2901      	cmp	r1, #1
  cfgidx = (uint8_t)(req->wValue);
 8013476:	7031      	strb	r1, [r6, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8013478:	f200 8150 	bhi.w	801371c <USBD_StdDevReq+0x328>
  switch (pdev->dev_state)
 801347c:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8013480:	2b02      	cmp	r3, #2
 8013482:	b2df      	uxtb	r7, r3
 8013484:	f000 810e 	beq.w	80136a4 <USBD_StdDevReq+0x2b0>
 8013488:	2f03      	cmp	r7, #3
 801348a:	f000 811f 	beq.w	80136cc <USBD_StdDevReq+0x2d8>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 801348e:	2180      	movs	r1, #128	; 0x80
      ret = USBD_FAIL;
 8013490:	2403      	movs	r4, #3
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8013492:	f000 fd97 	bl	8013fc4 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8013496:	2100      	movs	r1, #0
 8013498:	4628      	mov	r0, r5
 801349a:	f000 fd93 	bl	8013fc4 <USBD_LL_StallEP>
      (void)USBD_ClrClassConfig(pdev, cfgidx);
 801349e:	7831      	ldrb	r1, [r6, #0]
 80134a0:	4628      	mov	r0, r5
 80134a2:	f7ff fe1f 	bl	80130e4 <USBD_ClrClassConfig>
      break;
 80134a6:	e7ba      	b.n	801341e <USBD_StdDevReq+0x2a>
  switch (pdev->dev_state)
 80134a8:	f890 229c 	ldrb.w	r2, [r0, #668]	; 0x29c
 80134ac:	3a01      	subs	r2, #1
 80134ae:	2a02      	cmp	r2, #2
 80134b0:	d826      	bhi.n	8013500 <USBD_StdDevReq+0x10c>
      if (req->wLength != 0x2U)
 80134b2:	88ca      	ldrh	r2, [r1, #6]
 80134b4:	2a02      	cmp	r2, #2
 80134b6:	d123      	bne.n	8013500 <USBD_StdDevReq+0x10c>
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 80134b8:	2101      	movs	r1, #1
      if (pdev->dev_remote_wakeup != 0U)
 80134ba:	f8d0 22a4 	ldr.w	r2, [r0, #676]	; 0x2a4
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 80134be:	60c1      	str	r1, [r0, #12]
      if (pdev->dev_remote_wakeup != 0U)
 80134c0:	b10a      	cbz	r2, 80134c6 <USBD_StdDevReq+0xd2>
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 80134c2:	2203      	movs	r2, #3
 80134c4:	60c2      	str	r2, [r0, #12]
      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 80134c6:	2202      	movs	r2, #2
 80134c8:	f105 010c 	add.w	r1, r5, #12
 80134cc:	4628      	mov	r0, r5
  USBD_StatusTypeDef ret = USBD_OK;
 80134ce:	461c      	mov	r4, r3
      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 80134d0:	f000 fa74 	bl	80139bc <USBD_CtlSendData>
      break;
 80134d4:	e7a3      	b.n	801341e <USBD_StdDevReq+0x2a>
  switch (pdev->dev_state)
 80134d6:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 80134da:	3b01      	subs	r3, #1
 80134dc:	2b02      	cmp	r3, #2
 80134de:	d80f      	bhi.n	8013500 <USBD_StdDevReq+0x10c>
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 80134e0:	884b      	ldrh	r3, [r1, #2]
 80134e2:	2b01      	cmp	r3, #1
 80134e4:	d19b      	bne.n	801341e <USBD_StdDevReq+0x2a>
        pdev->dev_remote_wakeup = 0U;
 80134e6:	2300      	movs	r3, #0
        (void)USBD_CtlSendStatus(pdev);
 80134e8:	4628      	mov	r0, r5
        pdev->dev_remote_wakeup = 0U;
 80134ea:	f8c5 32a4 	str.w	r3, [r5, #676]	; 0x2a4
        (void)USBD_CtlSendStatus(pdev);
 80134ee:	f000 fa95 	bl	8013a1c <USBD_CtlSendStatus>
 80134f2:	e794      	b.n	801341e <USBD_StdDevReq+0x2a>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 80134f4:	884b      	ldrh	r3, [r1, #2]
 80134f6:	2b01      	cmp	r3, #1
 80134f8:	d0f6      	beq.n	80134e8 <USBD_StdDevReq+0xf4>
  else if (req->wValue == USB_FEATURE_TEST_MODE)
 80134fa:	2b02      	cmp	r3, #2
 80134fc:	f000 8107 	beq.w	801370e <USBD_StdDevReq+0x31a>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8013500:	2180      	movs	r1, #128	; 0x80
 8013502:	4628      	mov	r0, r5
 8013504:	f000 fd5e 	bl	8013fc4 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8013508:	2100      	movs	r1, #0
 801350a:	4628      	mov	r0, r5
 801350c:	f000 fd5a 	bl	8013fc4 <USBD_LL_StallEP>
}
 8013510:	4620      	mov	r0, r4
 8013512:	b003      	add	sp, #12
 8013514:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 8013516:	888b      	ldrh	r3, [r1, #4]
 8013518:	2b00      	cmp	r3, #0
 801351a:	d1f1      	bne.n	8013500 <USBD_StdDevReq+0x10c>
 801351c:	88cb      	ldrh	r3, [r1, #6]
 801351e:	2b00      	cmp	r3, #0
 8013520:	d1ee      	bne.n	8013500 <USBD_StdDevReq+0x10c>
 8013522:	884e      	ldrh	r6, [r1, #2]
 8013524:	2e7f      	cmp	r6, #127	; 0x7f
 8013526:	d8eb      	bhi.n	8013500 <USBD_StdDevReq+0x10c>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8013528:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 801352c:	2b03      	cmp	r3, #3
 801352e:	d0e7      	beq.n	8013500 <USBD_StdDevReq+0x10c>
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 8013530:	b2f1      	uxtb	r1, r6
      pdev->dev_address = dev_addr;
 8013532:	f880 129e 	strb.w	r1, [r0, #670]	; 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 8013536:	f000 fd75 	bl	8014024 <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
 801353a:	4628      	mov	r0, r5
 801353c:	f000 fa6e 	bl	8013a1c <USBD_CtlSendStatus>
      if (dev_addr != 0U)
 8013540:	2e00      	cmp	r6, #0
 8013542:	f040 80e0 	bne.w	8013706 <USBD_StdDevReq+0x312>
        pdev->dev_state = USBD_STATE_DEFAULT;
 8013546:	2301      	movs	r3, #1
 8013548:	f885 329c 	strb.w	r3, [r5, #668]	; 0x29c
 801354c:	e767      	b.n	801341e <USBD_StdDevReq+0x2a>
  uint16_t len = 0U;
 801354e:	2300      	movs	r3, #0
  switch (req->wValue >> 8)
 8013550:	884a      	ldrh	r2, [r1, #2]
  uint16_t len = 0U;
 8013552:	f8ad 3006 	strh.w	r3, [sp, #6]
  switch (req->wValue >> 8)
 8013556:	0a13      	lsrs	r3, r2, #8
 8013558:	3b01      	subs	r3, #1
 801355a:	2b06      	cmp	r3, #6
 801355c:	d8d0      	bhi.n	8013500 <USBD_StdDevReq+0x10c>
 801355e:	a101      	add	r1, pc, #4	; (adr r1, 8013564 <USBD_StdDevReq+0x170>)
 8013560:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8013564:	0801360d 	.word	0x0801360d
 8013568:	080135f3 	.word	0x080135f3
 801356c:	0801361d 	.word	0x0801361d
 8013570:	08013501 	.word	0x08013501
 8013574:	08013501 	.word	0x08013501
 8013578:	080135df 	.word	0x080135df
 801357c:	080135a7 	.word	0x080135a7
  if (req->wLength != 1U)
 8013580:	88ca      	ldrh	r2, [r1, #6]
 8013582:	2a01      	cmp	r2, #1
 8013584:	d1bc      	bne.n	8013500 <USBD_StdDevReq+0x10c>
    switch (pdev->dev_state)
 8013586:	f890 129c 	ldrb.w	r1, [r0, #668]	; 0x29c
 801358a:	2902      	cmp	r1, #2
 801358c:	b2cb      	uxtb	r3, r1
 801358e:	f200 8082 	bhi.w	8013696 <USBD_StdDevReq+0x2a2>
 8013592:	2b00      	cmp	r3, #0
 8013594:	f43f af3a 	beq.w	801340c <USBD_StdDevReq+0x18>
        pdev->dev_default_config = 0U;
 8013598:	4601      	mov	r1, r0
 801359a:	2300      	movs	r3, #0
 801359c:	f841 3f08 	str.w	r3, [r1, #8]!
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
 80135a0:	f000 fa0c 	bl	80139bc <USBD_CtlSendData>
        break;
 80135a4:	e73b      	b.n	801341e <USBD_StdDevReq+0x2a>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 80135a6:	7c03      	ldrb	r3, [r0, #16]
 80135a8:	2b00      	cmp	r3, #0
 80135aa:	d1a9      	bne.n	8013500 <USBD_StdDevReq+0x10c>
          pbuf = (uint8_t *)pdev->pClass[0]->GetOtherSpeedConfigDescriptor(&len);
 80135ac:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 80135b0:	f10d 0006 	add.w	r0, sp, #6
 80135b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80135b6:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 80135b8:	2307      	movs	r3, #7
 80135ba:	7043      	strb	r3, [r0, #1]
  if (req->wLength != 0U)
 80135bc:	88f2      	ldrh	r2, [r6, #6]
 80135be:	2a00      	cmp	r2, #0
 80135c0:	d065      	beq.n	801368e <USBD_StdDevReq+0x29a>
    if (len != 0U)
 80135c2:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80135c6:	2b00      	cmp	r3, #0
 80135c8:	d09a      	beq.n	8013500 <USBD_StdDevReq+0x10c>
      len = MIN(len, req->wLength);
 80135ca:	429a      	cmp	r2, r3
      (void)USBD_CtlSendData(pdev, pbuf, len);
 80135cc:	4601      	mov	r1, r0
 80135ce:	4628      	mov	r0, r5
      len = MIN(len, req->wLength);
 80135d0:	bf28      	it	cs
 80135d2:	461a      	movcs	r2, r3
 80135d4:	f8ad 2006 	strh.w	r2, [sp, #6]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 80135d8:	f000 f9f0 	bl	80139bc <USBD_CtlSendData>
 80135dc:	e71f      	b.n	801341e <USBD_StdDevReq+0x2a>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 80135de:	7c03      	ldrb	r3, [r0, #16]
 80135e0:	2b00      	cmp	r3, #0
 80135e2:	d18d      	bne.n	8013500 <USBD_StdDevReq+0x10c>
          pbuf = (uint8_t *)pdev->pClass[0]->GetDeviceQualifierDescriptor(&len);
 80135e4:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 80135e8:	f10d 0006 	add.w	r0, sp, #6
 80135ec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80135ee:	4798      	blx	r3
  if (err != 0U)
 80135f0:	e7e4      	b.n	80135bc <USBD_StdDevReq+0x1c8>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 80135f2:	7c03      	ldrb	r3, [r0, #16]
 80135f4:	2b00      	cmp	r3, #0
 80135f6:	f040 809a 	bne.w	801372e <USBD_StdDevReq+0x33a>
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
 80135fa:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 80135fe:	f10d 0006 	add.w	r0, sp, #6
 8013602:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013604:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8013606:	2302      	movs	r3, #2
 8013608:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 801360a:	e7d7      	b.n	80135bc <USBD_StdDevReq+0x1c8>
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 801360c:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8013610:	f10d 0106 	add.w	r1, sp, #6
 8013614:	7c00      	ldrb	r0, [r0, #16]
 8013616:	681b      	ldr	r3, [r3, #0]
 8013618:	4798      	blx	r3
  if (err != 0U)
 801361a:	e7cf      	b.n	80135bc <USBD_StdDevReq+0x1c8>
      switch ((uint8_t)(req->wValue))
 801361c:	b2d2      	uxtb	r2, r2
 801361e:	2a05      	cmp	r2, #5
 8013620:	f63f af6e 	bhi.w	8013500 <USBD_StdDevReq+0x10c>
 8013624:	e8df f002 	tbb	[pc, r2]
 8013628:	141a2026 	.word	0x141a2026
 801362c:	030e      	.short	0x030e
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 801362e:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8013632:	699b      	ldr	r3, [r3, #24]
 8013634:	2b00      	cmp	r3, #0
 8013636:	f43f af63 	beq.w	8013500 <USBD_StdDevReq+0x10c>
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 801363a:	f10d 0106 	add.w	r1, sp, #6
 801363e:	7c28      	ldrb	r0, [r5, #16]
 8013640:	4798      	blx	r3
  if (err != 0U)
 8013642:	e7bb      	b.n	80135bc <USBD_StdDevReq+0x1c8>
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 8013644:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8013648:	695b      	ldr	r3, [r3, #20]
 801364a:	2b00      	cmp	r3, #0
 801364c:	d1f5      	bne.n	801363a <USBD_StdDevReq+0x246>
 801364e:	e757      	b.n	8013500 <USBD_StdDevReq+0x10c>
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 8013650:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8013654:	691b      	ldr	r3, [r3, #16]
 8013656:	2b00      	cmp	r3, #0
 8013658:	d1ef      	bne.n	801363a <USBD_StdDevReq+0x246>
 801365a:	e751      	b.n	8013500 <USBD_StdDevReq+0x10c>
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 801365c:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8013660:	68db      	ldr	r3, [r3, #12]
 8013662:	2b00      	cmp	r3, #0
 8013664:	d1e9      	bne.n	801363a <USBD_StdDevReq+0x246>
 8013666:	e74b      	b.n	8013500 <USBD_StdDevReq+0x10c>
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 8013668:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 801366c:	689b      	ldr	r3, [r3, #8]
 801366e:	2b00      	cmp	r3, #0
 8013670:	d1e3      	bne.n	801363a <USBD_StdDevReq+0x246>
 8013672:	e745      	b.n	8013500 <USBD_StdDevReq+0x10c>
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 8013674:	f8d0 32b4 	ldr.w	r3, [r0, #692]	; 0x2b4
 8013678:	685b      	ldr	r3, [r3, #4]
 801367a:	2b00      	cmp	r3, #0
 801367c:	d1dd      	bne.n	801363a <USBD_StdDevReq+0x246>
 801367e:	e73f      	b.n	8013500 <USBD_StdDevReq+0x10c>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8013680:	2302      	movs	r3, #2
        pdev->dev_config = cfgidx;
 8013682:	6041      	str	r1, [r0, #4]
  USBD_StatusTypeDef ret = USBD_OK;
 8013684:	460c      	mov	r4, r1
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8013686:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
        (void)USBD_ClrClassConfig(pdev, cfgidx);
 801368a:	f7ff fd2b 	bl	80130e4 <USBD_ClrClassConfig>
        (void)USBD_CtlSendStatus(pdev);
 801368e:	4628      	mov	r0, r5
 8013690:	f000 f9c4 	bl	8013a1c <USBD_CtlSendStatus>
 8013694:	e6c3      	b.n	801341e <USBD_StdDevReq+0x2a>
    switch (pdev->dev_state)
 8013696:	2b03      	cmp	r3, #3
 8013698:	f47f aeb8 	bne.w	801340c <USBD_StdDevReq+0x18>
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 801369c:	1d01      	adds	r1, r0, #4
 801369e:	f000 f98d 	bl	80139bc <USBD_CtlSendData>
        break;
 80136a2:	e6bc      	b.n	801341e <USBD_StdDevReq+0x2a>
      if (cfgidx != 0U)
 80136a4:	2900      	cmp	r1, #0
 80136a6:	d0f2      	beq.n	801368e <USBD_StdDevReq+0x29a>
        pdev->dev_config = cfgidx;
 80136a8:	2101      	movs	r1, #1
 80136aa:	6041      	str	r1, [r0, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 80136ac:	f7ff fd12 	bl	80130d4 <USBD_SetClassConfig>
        if (ret != USBD_OK)
 80136b0:	4604      	mov	r4, r0
 80136b2:	2800      	cmp	r0, #0
 80136b4:	d046      	beq.n	8013744 <USBD_StdDevReq+0x350>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 80136b6:	2180      	movs	r1, #128	; 0x80
 80136b8:	4628      	mov	r0, r5
 80136ba:	f000 fc83 	bl	8013fc4 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 80136be:	2100      	movs	r1, #0
 80136c0:	4628      	mov	r0, r5
 80136c2:	f000 fc7f 	bl	8013fc4 <USBD_LL_StallEP>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 80136c6:	f885 729c 	strb.w	r7, [r5, #668]	; 0x29c
 80136ca:	e6a8      	b.n	801341e <USBD_StdDevReq+0x2a>
      if (cfgidx == 0U)
 80136cc:	2900      	cmp	r1, #0
 80136ce:	d0d7      	beq.n	8013680 <USBD_StdDevReq+0x28c>
      else if (cfgidx != pdev->dev_config)
 80136d0:	6841      	ldr	r1, [r0, #4]
 80136d2:	2901      	cmp	r1, #1
 80136d4:	d0db      	beq.n	801368e <USBD_StdDevReq+0x29a>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 80136d6:	b2c9      	uxtb	r1, r1
 80136d8:	f7ff fd04 	bl	80130e4 <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 80136dc:	7831      	ldrb	r1, [r6, #0]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 80136de:	4628      	mov	r0, r5
        pdev->dev_config = cfgidx;
 80136e0:	6069      	str	r1, [r5, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 80136e2:	f7ff fcf7 	bl	80130d4 <USBD_SetClassConfig>
        if (ret != USBD_OK)
 80136e6:	4606      	mov	r6, r0
 80136e8:	2800      	cmp	r0, #0
 80136ea:	d0d0      	beq.n	801368e <USBD_StdDevReq+0x29a>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 80136ec:	2180      	movs	r1, #128	; 0x80
 80136ee:	4628      	mov	r0, r5
 80136f0:	f000 fc68 	bl	8013fc4 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 80136f4:	2100      	movs	r1, #0
 80136f6:	4628      	mov	r0, r5
 80136f8:	4634      	mov	r4, r6
 80136fa:	f000 fc63 	bl	8013fc4 <USBD_LL_StallEP>
          (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 80136fe:	7929      	ldrb	r1, [r5, #4]
 8013700:	4628      	mov	r0, r5
 8013702:	f7ff fcef 	bl	80130e4 <USBD_ClrClassConfig>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 8013706:	2302      	movs	r3, #2
 8013708:	f885 329c 	strb.w	r3, [r5, #668]	; 0x29c
 801370c:	e687      	b.n	801341e <USBD_StdDevReq+0x2a>
    pdev->dev_test_mode = req->wIndex >> 8;
 801370e:	888b      	ldrh	r3, [r1, #4]
 8013710:	0a1b      	lsrs	r3, r3, #8
 8013712:	f880 32a0 	strb.w	r3, [r0, #672]	; 0x2a0
    (void)USBD_CtlSendStatus(pdev);
 8013716:	f000 f981 	bl	8013a1c <USBD_CtlSendStatus>
 801371a:	e680      	b.n	801341e <USBD_StdDevReq+0x2a>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 801371c:	2180      	movs	r1, #128	; 0x80
    return USBD_FAIL;
 801371e:	2403      	movs	r4, #3
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8013720:	f000 fc50 	bl	8013fc4 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8013724:	2100      	movs	r1, #0
 8013726:	4628      	mov	r0, r5
 8013728:	f000 fc4c 	bl	8013fc4 <USBD_LL_StallEP>
    return USBD_FAIL;
 801372c:	e677      	b.n	801341e <USBD_StdDevReq+0x2a>
          pbuf   = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
 801372e:	f8d0 32b8 	ldr.w	r3, [r0, #696]	; 0x2b8
 8013732:	f10d 0006 	add.w	r0, sp, #6
 8013736:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013738:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 801373a:	2302      	movs	r3, #2
 801373c:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 801373e:	e73d      	b.n	80135bc <USBD_StdDevReq+0x1c8>
 8013740:	24033000 	.word	0x24033000
          (void)USBD_CtlSendStatus(pdev);
 8013744:	4628      	mov	r0, r5
 8013746:	f000 f969 	bl	8013a1c <USBD_CtlSendStatus>
          pdev->dev_state = USBD_STATE_CONFIGURED;
 801374a:	2303      	movs	r3, #3
 801374c:	f885 329c 	strb.w	r3, [r5, #668]	; 0x29c
 8013750:	e665      	b.n	801341e <USBD_StdDevReq+0x2a>
 8013752:	bf00      	nop

08013754 <USBD_StdItfReq>:
{
 8013754:	b538      	push	{r3, r4, r5, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8013756:	780b      	ldrb	r3, [r1, #0]
{
 8013758:	460d      	mov	r5, r1
 801375a:	4604      	mov	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801375c:	f003 0260 	and.w	r2, r3, #96	; 0x60
 8013760:	2a40      	cmp	r2, #64	; 0x40
 8013762:	d00b      	beq.n	801377c <USBD_StdItfReq+0x28>
 8013764:	065b      	lsls	r3, r3, #25
 8013766:	d509      	bpl.n	801377c <USBD_StdItfReq+0x28>
  USBD_StatusTypeDef ret = USBD_OK;
 8013768:	2500      	movs	r5, #0
  (void)USBD_LL_StallEP(pdev, 0x80U);
 801376a:	2180      	movs	r1, #128	; 0x80
 801376c:	f000 fc2a 	bl	8013fc4 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8013770:	4620      	mov	r0, r4
 8013772:	4629      	mov	r1, r5
 8013774:	f000 fc26 	bl	8013fc4 <USBD_LL_StallEP>
}
 8013778:	4628      	mov	r0, r5
 801377a:	bd38      	pop	{r3, r4, r5, pc}
      switch (pdev->dev_state)
 801377c:	f894 329c 	ldrb.w	r3, [r4, #668]	; 0x29c
 8013780:	3b01      	subs	r3, #1
 8013782:	2b02      	cmp	r3, #2
 8013784:	d802      	bhi.n	801378c <USBD_StdItfReq+0x38>
          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 8013786:	7929      	ldrb	r1, [r5, #4]
 8013788:	2901      	cmp	r1, #1
 801378a:	d90a      	bls.n	80137a2 <USBD_StdItfReq+0x4e>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 801378c:	2180      	movs	r1, #128	; 0x80
 801378e:	4620      	mov	r0, r4
 8013790:	f000 fc18 	bl	8013fc4 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8013794:	2100      	movs	r1, #0
 8013796:	4620      	mov	r0, r4
  USBD_StatusTypeDef ret = USBD_OK;
 8013798:	460d      	mov	r5, r1
  (void)USBD_LL_StallEP(pdev, 0U);
 801379a:	f000 fc13 	bl	8013fc4 <USBD_LL_StallEP>
}
 801379e:	4628      	mov	r0, r5
 80137a0:	bd38      	pop	{r3, r4, r5, pc}
            idx = USBD_CoreFindIF(pdev, LOBYTE(req->wIndex));
 80137a2:	4620      	mov	r0, r4
 80137a4:	f7ff fe0c 	bl	80133c0 <USBD_CoreFindIF>
            if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 80137a8:	b990      	cbnz	r0, 80137d0 <USBD_StdItfReq+0x7c>
              if (pdev->pClass[idx]->Setup != NULL)
 80137aa:	f8d4 32b8 	ldr.w	r3, [r4, #696]	; 0x2b8
 80137ae:	689b      	ldr	r3, [r3, #8]
 80137b0:	b173      	cbz	r3, 80137d0 <USBD_StdItfReq+0x7c>
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 80137b2:	4629      	mov	r1, r5
                pdev->classId = idx;
 80137b4:	f8c4 02d4 	str.w	r0, [r4, #724]	; 0x2d4
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 80137b8:	4620      	mov	r0, r4
 80137ba:	4798      	blx	r3
            if ((req->wLength == 0U) && (ret == USBD_OK))
 80137bc:	88eb      	ldrh	r3, [r5, #6]
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 80137be:	4605      	mov	r5, r0
            if ((req->wLength == 0U) && (ret == USBD_OK))
 80137c0:	2b00      	cmp	r3, #0
 80137c2:	d1d9      	bne.n	8013778 <USBD_StdItfReq+0x24>
 80137c4:	2800      	cmp	r0, #0
 80137c6:	d1d7      	bne.n	8013778 <USBD_StdItfReq+0x24>
              (void)USBD_CtlSendStatus(pdev);
 80137c8:	4620      	mov	r0, r4
 80137ca:	f000 f927 	bl	8013a1c <USBD_CtlSendStatus>
 80137ce:	e7d3      	b.n	8013778 <USBD_StdItfReq+0x24>
              ret = USBD_FAIL;
 80137d0:	2503      	movs	r5, #3
}
 80137d2:	4628      	mov	r0, r5
 80137d4:	bd38      	pop	{r3, r4, r5, pc}
 80137d6:	bf00      	nop

080137d8 <USBD_StdEPReq>:
{
 80137d8:	b530      	push	{r4, r5, lr}
 80137da:	460c      	mov	r4, r1
  ep_addr = LOBYTE(req->wIndex);
 80137dc:	888a      	ldrh	r2, [r1, #4]
{
 80137de:	b083      	sub	sp, #12
 80137e0:	4605      	mov	r5, r0
  ep_addr = LOBYTE(req->wIndex);
 80137e2:	7823      	ldrb	r3, [r4, #0]
 80137e4:	b2d1      	uxtb	r1, r2
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80137e6:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80137ea:	2b20      	cmp	r3, #32
 80137ec:	d01e      	beq.n	801382c <USBD_StdEPReq+0x54>
 80137ee:	2b40      	cmp	r3, #64	; 0x40
 80137f0:	d01c      	beq.n	801382c <USBD_StdEPReq+0x54>
 80137f2:	b36b      	cbz	r3, 8013850 <USBD_StdEPReq+0x78>
  (void)USBD_LL_StallEP(pdev, 0x80U);
 80137f4:	2180      	movs	r1, #128	; 0x80
 80137f6:	4628      	mov	r0, r5
 80137f8:	f000 fbe4 	bl	8013fc4 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 80137fc:	2100      	movs	r1, #0
 80137fe:	4628      	mov	r0, r5
 8013800:	f000 fbe0 	bl	8013fc4 <USBD_LL_StallEP>
}
 8013804:	2000      	movs	r0, #0
 8013806:	b003      	add	sp, #12
 8013808:	bd30      	pop	{r4, r5, pc}
          switch (pdev->dev_state)
 801380a:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 801380e:	2b02      	cmp	r3, #2
 8013810:	b2da      	uxtb	r2, r3
 8013812:	d059      	beq.n	80138c8 <USBD_StdEPReq+0xf0>
 8013814:	2a03      	cmp	r2, #3
 8013816:	d1ed      	bne.n	80137f4 <USBD_StdEPReq+0x1c>
              if (req->wValue == USB_FEATURE_EP_HALT)
 8013818:	8863      	ldrh	r3, [r4, #2]
 801381a:	2b00      	cmp	r3, #0
 801381c:	d1f2      	bne.n	8013804 <USBD_StdEPReq+0x2c>
                if ((ep_addr & 0x7FU) != 0x00U)
 801381e:	064b      	lsls	r3, r1, #25
 8013820:	d17e      	bne.n	8013920 <USBD_StdEPReq+0x148>
                (void)USBD_CtlSendStatus(pdev);
 8013822:	4628      	mov	r0, r5
 8013824:	9101      	str	r1, [sp, #4]
 8013826:	f000 f8f9 	bl	8013a1c <USBD_CtlSendStatus>
                idx = USBD_CoreFindEP(pdev, ep_addr);
 801382a:	9901      	ldr	r1, [sp, #4]
 801382c:	4628      	mov	r0, r5
 801382e:	f7ff fdc9 	bl	80133c4 <USBD_CoreFindEP>
                if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8013832:	2800      	cmp	r0, #0
 8013834:	d1e6      	bne.n	8013804 <USBD_StdEPReq+0x2c>
                  if (pdev->pClass[idx]->Setup != NULL)
 8013836:	f8d5 32b8 	ldr.w	r3, [r5, #696]	; 0x2b8
                  pdev->classId = idx;
 801383a:	f8c5 02d4 	str.w	r0, [r5, #724]	; 0x2d4
                  if (pdev->pClass[idx]->Setup != NULL)
 801383e:	689b      	ldr	r3, [r3, #8]
 8013840:	2b00      	cmp	r3, #0
 8013842:	d0df      	beq.n	8013804 <USBD_StdEPReq+0x2c>
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8013844:	4621      	mov	r1, r4
 8013846:	4628      	mov	r0, r5
}
 8013848:	b003      	add	sp, #12
 801384a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 801384e:	4718      	bx	r3
      switch (req->bRequest)
 8013850:	7863      	ldrb	r3, [r4, #1]
 8013852:	2b01      	cmp	r3, #1
 8013854:	d0d9      	beq.n	801380a <USBD_StdEPReq+0x32>
 8013856:	2b03      	cmp	r3, #3
 8013858:	d024      	beq.n	80138a4 <USBD_StdEPReq+0xcc>
 801385a:	2b00      	cmp	r3, #0
 801385c:	d1ca      	bne.n	80137f4 <USBD_StdEPReq+0x1c>
          switch (pdev->dev_state)
 801385e:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 8013862:	2b02      	cmp	r3, #2
 8013864:	b2d8      	uxtb	r0, r3
 8013866:	d038      	beq.n	80138da <USBD_StdEPReq+0x102>
 8013868:	2803      	cmp	r0, #3
 801386a:	d1c3      	bne.n	80137f4 <USBD_StdEPReq+0x1c>
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 801386c:	f001 030f 	and.w	r3, r1, #15
              if ((ep_addr & 0x80U) == 0x80U)
 8013870:	0612      	lsls	r2, r2, #24
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8013872:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8013876:	eb05 0383 	add.w	r3, r5, r3, lsl #2
              if ((ep_addr & 0x80U) == 0x80U)
 801387a:	d43f      	bmi.n	80138fc <USBD_StdEPReq+0x124>
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 801387c:	f8b3 3164 	ldrh.w	r3, [r3, #356]	; 0x164
 8013880:	2b00      	cmp	r3, #0
 8013882:	d0b7      	beq.n	80137f4 <USBD_StdEPReq+0x1c>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8013884:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 8013888:	2414      	movs	r4, #20
 801388a:	fb04 5403 	mla	r4, r4, r3, r5
 801388e:	f504 74aa 	add.w	r4, r4, #340	; 0x154
              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 8013892:	2b00      	cmp	r3, #0
 8013894:	d13e      	bne.n	8013914 <USBD_StdEPReq+0x13c>
                pep->status = 0x0001U;
 8013896:	6023      	str	r3, [r4, #0]
              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8013898:	2202      	movs	r2, #2
 801389a:	4621      	mov	r1, r4
 801389c:	4628      	mov	r0, r5
 801389e:	f000 f88d 	bl	80139bc <USBD_CtlSendData>
              break;
 80138a2:	e7af      	b.n	8013804 <USBD_StdEPReq+0x2c>
          switch (pdev->dev_state)
 80138a4:	f890 329c 	ldrb.w	r3, [r0, #668]	; 0x29c
 80138a8:	2b02      	cmp	r3, #2
 80138aa:	b2da      	uxtb	r2, r3
 80138ac:	d00c      	beq.n	80138c8 <USBD_StdEPReq+0xf0>
 80138ae:	2a03      	cmp	r2, #3
 80138b0:	d1a0      	bne.n	80137f4 <USBD_StdEPReq+0x1c>
              if (req->wValue == USB_FEATURE_EP_HALT)
 80138b2:	8863      	ldrh	r3, [r4, #2]
 80138b4:	b923      	cbnz	r3, 80138c0 <USBD_StdEPReq+0xe8>
                if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 80138b6:	0648      	lsls	r0, r1, #25
 80138b8:	d002      	beq.n	80138c0 <USBD_StdEPReq+0xe8>
 80138ba:	88e3      	ldrh	r3, [r4, #6]
 80138bc:	2b00      	cmp	r3, #0
 80138be:	d036      	beq.n	801392e <USBD_StdEPReq+0x156>
              (void)USBD_CtlSendStatus(pdev);
 80138c0:	4628      	mov	r0, r5
 80138c2:	f000 f8ab 	bl	8013a1c <USBD_CtlSendStatus>
              break;
 80138c6:	e79d      	b.n	8013804 <USBD_StdEPReq+0x2c>
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 80138c8:	064a      	lsls	r2, r1, #25
 80138ca:	d093      	beq.n	80137f4 <USBD_StdEPReq+0x1c>
                (void)USBD_LL_StallEP(pdev, ep_addr);
 80138cc:	f000 fb7a 	bl	8013fc4 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 80138d0:	2180      	movs	r1, #128	; 0x80
 80138d2:	4628      	mov	r0, r5
 80138d4:	f000 fb76 	bl	8013fc4 <USBD_LL_StallEP>
 80138d8:	e794      	b.n	8013804 <USBD_StdEPReq+0x2c>
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 80138da:	0648      	lsls	r0, r1, #25
 80138dc:	d18a      	bne.n	80137f4 <USBD_StdEPReq+0x1c>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 80138de:	0611      	lsls	r1, r2, #24
              pep->status = 0x0000U;
 80138e0:	f04f 0300 	mov.w	r3, #0
              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 80138e4:	f04f 0202 	mov.w	r2, #2
 80138e8:	4628      	mov	r0, r5
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 80138ea:	bf4c      	ite	mi
 80138ec:	f105 0114 	addmi.w	r1, r5, #20
 80138f0:	f505 71aa 	addpl.w	r1, r5, #340	; 0x154
              pep->status = 0x0000U;
 80138f4:	600b      	str	r3, [r1, #0]
              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 80138f6:	f000 f861 	bl	80139bc <USBD_CtlSendData>
              break;
 80138fa:	e783      	b.n	8013804 <USBD_StdEPReq+0x2c>
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 80138fc:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 80138fe:	2b00      	cmp	r3, #0
 8013900:	f43f af78 	beq.w	80137f4 <USBD_StdEPReq+0x1c>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8013904:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 8013908:	1c5c      	adds	r4, r3, #1
 801390a:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 801390e:	eb05 0484 	add.w	r4, r5, r4, lsl #2
 8013912:	e7be      	b.n	8013892 <USBD_StdEPReq+0xba>
              else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
 8013914:	4628      	mov	r0, r5
 8013916:	f000 fb71 	bl	8013ffc <USBD_LL_IsStallEP>
 801391a:	b130      	cbz	r0, 801392a <USBD_StdEPReq+0x152>
                pep->status = 0x0001U;
 801391c:	2301      	movs	r3, #1
 801391e:	e7ba      	b.n	8013896 <USBD_StdEPReq+0xbe>
                  (void)USBD_LL_ClearStallEP(pdev, ep_addr);
 8013920:	9101      	str	r1, [sp, #4]
 8013922:	f000 fb5d 	bl	8013fe0 <USBD_LL_ClearStallEP>
 8013926:	9901      	ldr	r1, [sp, #4]
 8013928:	e77b      	b.n	8013822 <USBD_StdEPReq+0x4a>
                pep->status = 0x0000U;
 801392a:	6020      	str	r0, [r4, #0]
 801392c:	e7b4      	b.n	8013898 <USBD_StdEPReq+0xc0>
                  (void)USBD_LL_StallEP(pdev, ep_addr);
 801392e:	4628      	mov	r0, r5
 8013930:	f000 fb48 	bl	8013fc4 <USBD_LL_StallEP>
 8013934:	e7c4      	b.n	80138c0 <USBD_StdEPReq+0xe8>
 8013936:	bf00      	nop

08013938 <USBD_ParseSetupRequest>:
  req->bmRequest = *(uint8_t *)(pbuff);
 8013938:	780b      	ldrb	r3, [r1, #0]
 801393a:	7003      	strb	r3, [r0, #0]
  req->bRequest = *(uint8_t *)(pbuff);
 801393c:	784b      	ldrb	r3, [r1, #1]
 801393e:	7043      	strb	r3, [r0, #1]
  uint16_t _SwapVal, _Byte1, _Byte2;
  uint8_t *_pbuff = addr;

  _Byte1 = *(uint8_t *)_pbuff;
  _pbuff++;
  _Byte2 = *(uint8_t *)_pbuff;
 8013940:	884b      	ldrh	r3, [r1, #2]
  req->wValue = SWAPBYTE(pbuff);
 8013942:	8043      	strh	r3, [r0, #2]
 8013944:	888b      	ldrh	r3, [r1, #4]
  req->wIndex = SWAPBYTE(pbuff);
 8013946:	8083      	strh	r3, [r0, #4]
 8013948:	88cb      	ldrh	r3, [r1, #6]
  req->wLength = SWAPBYTE(pbuff);
 801394a:	80c3      	strh	r3, [r0, #6]
}
 801394c:	4770      	bx	lr
 801394e:	bf00      	nop

08013950 <USBD_CtlError>:
{
 8013950:	b510      	push	{r4, lr}
 8013952:	4604      	mov	r4, r0
  (void)USBD_LL_StallEP(pdev, 0x80U);
 8013954:	2180      	movs	r1, #128	; 0x80
 8013956:	f000 fb35 	bl	8013fc4 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 801395a:	2100      	movs	r1, #0
 801395c:	4620      	mov	r0, r4
}
 801395e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  (void)USBD_LL_StallEP(pdev, 0U);
 8013962:	f000 bb2f 	b.w	8013fc4 <USBD_LL_StallEP>
 8013966:	bf00      	nop

08013968 <USBD_GetString>:
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
  uint8_t idx = 0U;
  uint8_t *pdesc;

  if (desc == NULL)
 8013968:	b318      	cbz	r0, 80139b2 <USBD_GetString+0x4a>
static uint8_t USBD_GetLen(uint8_t *buf)
{
  uint8_t  len = 0U;
  uint8_t *pbuff = buf;

  while (*pbuff != (uint8_t)'\0')
 801396a:	7803      	ldrb	r3, [r0, #0]
{
 801396c:	b430      	push	{r4, r5}
  while (*pbuff != (uint8_t)'\0')
 801396e:	b30b      	cbz	r3, 80139b4 <USBD_GetString+0x4c>
 8013970:	4604      	mov	r4, r0
 8013972:	f1c0 0c01 	rsb	ip, r0, #1
  {
    len++;
 8013976:	eb04 030c 	add.w	r3, r4, ip
  while (*pbuff != (uint8_t)'\0')
 801397a:	f814 5f01 	ldrb.w	r5, [r4, #1]!
 801397e:	b2db      	uxtb	r3, r3
 8013980:	2d00      	cmp	r5, #0
 8013982:	d1f8      	bne.n	8013976 <USBD_GetString+0xe>
  *len = ((uint16_t)USBD_GetLen(pdesc) * 2U) + 2U;
 8013984:	3301      	adds	r3, #1
 8013986:	005b      	lsls	r3, r3, #1
 8013988:	b2dc      	uxtb	r4, r3
 801398a:	8013      	strh	r3, [r2, #0]
  unicode[idx] = USB_DESC_TYPE_STRING;
 801398c:	2303      	movs	r3, #3
  unicode[idx] = *(uint8_t *)len;
 801398e:	700c      	strb	r4, [r1, #0]
  unicode[idx] = USB_DESC_TYPE_STRING;
 8013990:	704b      	strb	r3, [r1, #1]
  while (*pdesc != (uint8_t)'\0')
 8013992:	7804      	ldrb	r4, [r0, #0]
 8013994:	b15c      	cbz	r4, 80139ae <USBD_GetString+0x46>
  idx++;
 8013996:	2302      	movs	r3, #2
    unicode[idx] = 0U;
 8013998:	2500      	movs	r5, #0
    idx++;
 801399a:	1c5a      	adds	r2, r3, #1
    unicode[idx] = *pdesc;
 801399c:	54cc      	strb	r4, [r1, r3]
    idx++;
 801399e:	3302      	adds	r3, #2
    unicode[idx] = 0U;
 80139a0:	b2d2      	uxtb	r2, r2
    idx++;
 80139a2:	b2db      	uxtb	r3, r3
    unicode[idx] = 0U;
 80139a4:	548d      	strb	r5, [r1, r2]
  while (*pdesc != (uint8_t)'\0')
 80139a6:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 80139aa:	2c00      	cmp	r4, #0
 80139ac:	d1f5      	bne.n	801399a <USBD_GetString+0x32>
}
 80139ae:	bc30      	pop	{r4, r5}
 80139b0:	4770      	bx	lr
 80139b2:	4770      	bx	lr
  while (*pbuff != (uint8_t)'\0')
 80139b4:	2402      	movs	r4, #2
 80139b6:	4623      	mov	r3, r4
 80139b8:	e7e7      	b.n	801398a <USBD_GetString+0x22>
 80139ba:	bf00      	nop

080139bc <USBD_CtlSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
 80139bc:	b510      	push	{r4, lr}
 80139be:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 80139c0:	2402      	movs	r4, #2
{
 80139c2:	460a      	mov	r2, r1
#else
  pdev->ep_in[0].rem_length = len;
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 80139c4:	2100      	movs	r1, #0
  pdev->ep0_state = USBD_EP0_DATA_IN;
 80139c6:	f8c0 4294 	str.w	r4, [r0, #660]	; 0x294
  pdev->ep_in[0].rem_length = len;
 80139ca:	e9c0 3306 	strd	r3, r3, [r0, #24]
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 80139ce:	f000 fb37 	bl	8014040 <USBD_LL_Transmit>

  return USBD_OK;
}
 80139d2:	2000      	movs	r0, #0
 80139d4:	bd10      	pop	{r4, pc}
 80139d6:	bf00      	nop

080139d8 <USBD_CtlContinueSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
 80139d8:	468c      	mov	ip, r1
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 80139da:	2100      	movs	r1, #0
{
 80139dc:	b508      	push	{r3, lr}
 80139de:	4613      	mov	r3, r2
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 80139e0:	4662      	mov	r2, ip
 80139e2:	f000 fb2d 	bl	8014040 <USBD_LL_Transmit>

  return USBD_OK;
}
 80139e6:	2000      	movs	r0, #0
 80139e8:	bd08      	pop	{r3, pc}
 80139ea:	bf00      	nop

080139ec <USBD_CtlPrepareRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint32_t len)
{
 80139ec:	b510      	push	{r4, lr}
 80139ee:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 80139f0:	2403      	movs	r4, #3
{
 80139f2:	460a      	mov	r2, r1
#else
  pdev->ep_out[0].rem_length = len;
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 80139f4:	2100      	movs	r1, #0
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 80139f6:	f8c0 4294 	str.w	r4, [r0, #660]	; 0x294
  pdev->ep_out[0].rem_length = len;
 80139fa:	e9c0 3356 	strd	r3, r3, [r0, #344]	; 0x158
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 80139fe:	f000 fb2d 	bl	801405c <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8013a02:	2000      	movs	r0, #0
 8013a04:	bd10      	pop	{r4, pc}
 8013a06:	bf00      	nop

08013a08 <USBD_CtlContinueRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
 8013a08:	468c      	mov	ip, r1
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8013a0a:	2100      	movs	r1, #0
{
 8013a0c:	b508      	push	{r3, lr}
 8013a0e:	4613      	mov	r3, r2
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8013a10:	4662      	mov	r2, ip
 8013a12:	f000 fb23 	bl	801405c <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8013a16:	2000      	movs	r0, #0
 8013a18:	bd08      	pop	{r3, pc}
 8013a1a:	bf00      	nop

08013a1c <USBD_CtlSendStatus>:
{
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8013a1c:	2300      	movs	r3, #0
{
 8013a1e:	b510      	push	{r4, lr}
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8013a20:	2404      	movs	r4, #4
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8013a22:	461a      	mov	r2, r3
 8013a24:	4619      	mov	r1, r3
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8013a26:	f8c0 4294 	str.w	r4, [r0, #660]	; 0x294
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8013a2a:	f000 fb09 	bl	8014040 <USBD_LL_Transmit>

  return USBD_OK;
}
 8013a2e:	2000      	movs	r0, #0
 8013a30:	bd10      	pop	{r4, pc}
 8013a32:	bf00      	nop

08013a34 <USBD_CtlReceiveStatus>:
{
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8013a34:	2300      	movs	r3, #0
{
 8013a36:	b510      	push	{r4, lr}
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 8013a38:	2405      	movs	r4, #5
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8013a3a:	461a      	mov	r2, r3
 8013a3c:	4619      	mov	r1, r3
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 8013a3e:	f8c0 4294 	str.w	r4, [r0, #660]	; 0x294
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8013a42:	f000 fb0b 	bl	801405c <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8013a46:	2000      	movs	r0, #0
 8013a48:	bd10      	pop	{r4, pc}
 8013a4a:	bf00      	nop

08013a4c <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 8013a4c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */

  /* USER CODE END USB_DEVICE_Init_PreTreatment */

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS) != USBD_OK)
 8013a4e:	2200      	movs	r2, #0
 8013a50:	4919      	ldr	r1, [pc, #100]	; (8013ab8 <MX_USB_DEVICE_Init+0x6c>)
 8013a52:	481a      	ldr	r0, [pc, #104]	; (8013abc <MX_USB_DEVICE_Init+0x70>)
 8013a54:	f7ff fb0c 	bl	8013070 <USBD_Init>
 8013a58:	b988      	cbnz	r0, 8013a7e <MX_USB_DEVICE_Init+0x32>
  {
    Error_Handler();
  }
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC) != USBD_OK)
 8013a5a:	4919      	ldr	r1, [pc, #100]	; (8013ac0 <MX_USB_DEVICE_Init+0x74>)
 8013a5c:	4817      	ldr	r0, [pc, #92]	; (8013abc <MX_USB_DEVICE_Init+0x70>)
 8013a5e:	f7ff fb1b 	bl	8013098 <USBD_RegisterClass>
 8013a62:	b9a0      	cbnz	r0, 8013a8e <MX_USB_DEVICE_Init+0x42>
  {
    Error_Handler();
  }
  if (USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS) != USBD_OK)
 8013a64:	4917      	ldr	r1, [pc, #92]	; (8013ac4 <MX_USB_DEVICE_Init+0x78>)
 8013a66:	4815      	ldr	r0, [pc, #84]	; (8013abc <MX_USB_DEVICE_Init+0x70>)
 8013a68:	f7ff faa2 	bl	8012fb0 <USBD_CDC_RegisterInterface>
 8013a6c:	b9b8      	cbnz	r0, 8013a9e <MX_USB_DEVICE_Init+0x52>
  {
    Error_Handler();
  }
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 8013a6e:	4813      	ldr	r0, [pc, #76]	; (8013abc <MX_USB_DEVICE_Init+0x70>)
 8013a70:	f7ff fb2e 	bl	80130d0 <USBD_Start>
 8013a74:	b9d0      	cbnz	r0, 8013aac <MX_USB_DEVICE_Init+0x60>

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */
  HAL_PWREx_EnableUSBVoltageDetector();

  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 8013a76:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_EnableUSBVoltageDetector();
 8013a7a:	f7fa b929 	b.w	800dcd0 <HAL_PWREx_EnableUSBVoltageDetector>
    Error_Handler();
 8013a7e:	f7f6 fe1b 	bl	800a6b8 <Error_Handler>
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC) != USBD_OK)
 8013a82:	490f      	ldr	r1, [pc, #60]	; (8013ac0 <MX_USB_DEVICE_Init+0x74>)
 8013a84:	480d      	ldr	r0, [pc, #52]	; (8013abc <MX_USB_DEVICE_Init+0x70>)
 8013a86:	f7ff fb07 	bl	8013098 <USBD_RegisterClass>
 8013a8a:	2800      	cmp	r0, #0
 8013a8c:	d0ea      	beq.n	8013a64 <MX_USB_DEVICE_Init+0x18>
    Error_Handler();
 8013a8e:	f7f6 fe13 	bl	800a6b8 <Error_Handler>
  if (USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS) != USBD_OK)
 8013a92:	490c      	ldr	r1, [pc, #48]	; (8013ac4 <MX_USB_DEVICE_Init+0x78>)
 8013a94:	4809      	ldr	r0, [pc, #36]	; (8013abc <MX_USB_DEVICE_Init+0x70>)
 8013a96:	f7ff fa8b 	bl	8012fb0 <USBD_CDC_RegisterInterface>
 8013a9a:	2800      	cmp	r0, #0
 8013a9c:	d0e7      	beq.n	8013a6e <MX_USB_DEVICE_Init+0x22>
    Error_Handler();
 8013a9e:	f7f6 fe0b 	bl	800a6b8 <Error_Handler>
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 8013aa2:	4806      	ldr	r0, [pc, #24]	; (8013abc <MX_USB_DEVICE_Init+0x70>)
 8013aa4:	f7ff fb14 	bl	80130d0 <USBD_Start>
 8013aa8:	2800      	cmp	r0, #0
 8013aaa:	d0e4      	beq.n	8013a76 <MX_USB_DEVICE_Init+0x2a>
    Error_Handler();
 8013aac:	f7f6 fe04 	bl	800a6b8 <Error_Handler>
}
 8013ab0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_EnableUSBVoltageDetector();
 8013ab4:	f7fa b90c 	b.w	800dcd0 <HAL_PWREx_EnableUSBVoltageDetector>
 8013ab8:	24008134 	.word	0x24008134
 8013abc:	24033004 	.word	0x24033004
 8013ac0:	24008098 	.word	0x24008098
 8013ac4:	24008120 	.word	0x24008120

08013ac8 <CDC_DeInit_FS>:
static int8_t CDC_DeInit_FS(void)
{
  /* USER CODE BEGIN 4 */
  return (USBD_OK);
  /* USER CODE END 4 */
}
 8013ac8:	2000      	movs	r0, #0
 8013aca:	4770      	bx	lr

08013acc <CDC_Control_FS>:
    break;
  }

  return (USBD_OK);
  /* USER CODE END 5 */
}
 8013acc:	2000      	movs	r0, #0
 8013ace:	4770      	bx	lr

08013ad0 <CDC_TransmitCplt_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_TransmitCplt_FS(uint8_t *Buf, uint32_t *Len, uint8_t epnum)
{
 8013ad0:	b500      	push	{lr}
 8013ad2:	b085      	sub	sp, #20
  BaseType_t xHigherPriorityTaskWoken;
  xHigherPriorityTaskWoken = pdFALSE;

  Fuzzer_t *pAFLfuzzer = (Fuzzer_t *)AFLfuzzerRegion;

  AFLfuzzer.bTXcomplete = true;
 8013ad4:	2301      	movs	r3, #1
  xHigherPriorityTaskWoken = pdFALSE;
 8013ad6:	2100      	movs	r1, #0
  AFLfuzzer.bTXcomplete = true;
 8013ad8:	4a0c      	ldr	r2, [pc, #48]	; (8013b0c <CDC_TransmitCplt_FS+0x3c>)
  xTaskNotifyIndexedFromISR(AFLfuzzer.xTaskFuzzer,
 8013ada:	a803      	add	r0, sp, #12
  xHigherPriorityTaskWoken = pdFALSE;
 8013adc:	9103      	str	r1, [sp, #12]
  xTaskNotifyIndexedFromISR(AFLfuzzer.xTaskFuzzer,
 8013ade:	e9cd 1000 	strd	r1, r0, [sp]
  AFLfuzzer.bTXcomplete = true;
 8013ae2:	f882 3865 	strb.w	r3, [r2, #2149]	; 0x865
  xTaskNotifyIndexedFromISR(AFLfuzzer.xTaskFuzzer,
 8013ae6:	4619      	mov	r1, r3
 8013ae8:	f8d2 086c 	ldr.w	r0, [r2, #2156]	; 0x86c
 8013aec:	2202      	movs	r2, #2
 8013aee:	f7ef fe33 	bl	8003758 <xTaskGenericNotifyFromISR>
	  	    				1, //index
							2, //value = 2 data TX complete
							eSetBits,
							&xHigherPriorityTaskWoken);

  portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 8013af2:	9b03      	ldr	r3, [sp, #12]
 8013af4:	b12b      	cbz	r3, 8013b02 <CDC_TransmitCplt_FS+0x32>
 8013af6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8013afa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8013afe:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04

  /* USER CODE END 13 */
  return result;
}
 8013b02:	2000      	movs	r0, #0
 8013b04:	b005      	add	sp, #20
 8013b06:	f85d fb04 	ldr.w	pc, [sp], #4
 8013b0a:	bf00      	nop
 8013b0c:	24026000 	.word	0x24026000

08013b10 <CDC_Receive_FS>:
{
 8013b10:	b538      	push	{r3, r4, r5, lr}
 8013b12:	4604      	mov	r4, r0
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 8013b14:	4d05      	ldr	r5, [pc, #20]	; (8013b2c <CDC_Receive_FS+0x1c>)
  FuzzingInputHandler(Buf, Len);
 8013b16:	f7f6 fa75 	bl	800a004 <FuzzingInputHandler>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 8013b1a:	4621      	mov	r1, r4
 8013b1c:	4628      	mov	r0, r5
 8013b1e:	f7ff fa61 	bl	8012fe4 <USBD_CDC_SetRxBuffer>
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
 8013b22:	4628      	mov	r0, r5
 8013b24:	f7ff fa86 	bl	8013034 <USBD_CDC_ReceivePacket>
}
 8013b28:	2000      	movs	r0, #0
 8013b2a:	bd38      	pop	{r3, r4, r5, pc}
 8013b2c:	24033004 	.word	0x24033004

08013b30 <CDC_Init_FS>:
{
 8013b30:	b510      	push	{r4, lr}
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 8013b32:	4c06      	ldr	r4, [pc, #24]	; (8013b4c <CDC_Init_FS+0x1c>)
 8013b34:	2200      	movs	r2, #0
 8013b36:	4906      	ldr	r1, [pc, #24]	; (8013b50 <CDC_Init_FS+0x20>)
 8013b38:	4620      	mov	r0, r4
 8013b3a:	f7ff fa45 	bl	8012fc8 <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 8013b3e:	4905      	ldr	r1, [pc, #20]	; (8013b54 <CDC_Init_FS+0x24>)
 8013b40:	4620      	mov	r0, r4
 8013b42:	f7ff fa4f 	bl	8012fe4 <USBD_CDC_SetRxBuffer>
}
 8013b46:	2000      	movs	r0, #0
 8013b48:	bd10      	pop	{r4, pc}
 8013b4a:	bf00      	nop
 8013b4c:	24033004 	.word	0x24033004
 8013b50:	24033ae0 	.word	0x24033ae0
 8013b54:	240332e0 	.word	0x240332e0

08013b58 <CDC_Transmit_FS>:
{
 8013b58:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
 8013b5a:	4c09      	ldr	r4, [pc, #36]	; (8013b80 <CDC_Transmit_FS+0x28>)
 8013b5c:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
  if (hcdc->TxState != 0){
 8013b60:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8013b64:	b10b      	cbz	r3, 8013b6a <CDC_Transmit_FS+0x12>
}
 8013b66:	2001      	movs	r0, #1
 8013b68:	bd10      	pop	{r4, pc}
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
 8013b6a:	460a      	mov	r2, r1
 8013b6c:	4601      	mov	r1, r0
 8013b6e:	4620      	mov	r0, r4
 8013b70:	f7ff fa2a 	bl	8012fc8 <USBD_CDC_SetTxBuffer>
  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);
 8013b74:	4620      	mov	r0, r4
}
 8013b76:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);
 8013b7a:	f7ff ba3f 	b.w	8012ffc <USBD_CDC_TransmitPacket>
 8013b7e:	bf00      	nop
 8013b80:	24033004 	.word	0x24033004

08013b84 <USBD_FS_DeviceDescriptor>:
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_FS_DeviceDesc);
 8013b84:	2312      	movs	r3, #18
  return USBD_FS_DeviceDesc;
}
 8013b86:	4801      	ldr	r0, [pc, #4]	; (8013b8c <USBD_FS_DeviceDescriptor+0x8>)
  *length = sizeof(USBD_FS_DeviceDesc);
 8013b88:	800b      	strh	r3, [r1, #0]
}
 8013b8a:	4770      	bx	lr
 8013b8c:	24008150 	.word	0x24008150

08013b90 <USBD_FS_LangIDStrDescriptor>:
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
 8013b90:	2304      	movs	r3, #4
  return USBD_LangIDDesc;
}
 8013b92:	4801      	ldr	r0, [pc, #4]	; (8013b98 <USBD_FS_LangIDStrDescriptor+0x8>)
  *length = sizeof(USBD_LangIDDesc);
 8013b94:	800b      	strh	r3, [r1, #0]
}
 8013b96:	4770      	bx	lr
 8013b98:	24008164 	.word	0x24008164

08013b9c <USBD_FS_ManufacturerStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8013b9c:	b510      	push	{r4, lr}
  UNUSED(speed);
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8013b9e:	4c04      	ldr	r4, [pc, #16]	; (8013bb0 <USBD_FS_ManufacturerStrDescriptor+0x14>)
{
 8013ba0:	460a      	mov	r2, r1
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8013ba2:	4804      	ldr	r0, [pc, #16]	; (8013bb4 <USBD_FS_ManufacturerStrDescriptor+0x18>)
 8013ba4:	4621      	mov	r1, r4
 8013ba6:	f7ff fedf 	bl	8013968 <USBD_GetString>
  return USBD_StrDesc;
}
 8013baa:	4620      	mov	r0, r4
 8013bac:	bd10      	pop	{r4, pc}
 8013bae:	bf00      	nop
 8013bb0:	240342e0 	.word	0x240342e0
 8013bb4:	240084d0 	.word	0x240084d0

08013bb8 <USBD_FS_ProductStrDescriptor>:
{
 8013bb8:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8013bba:	4c04      	ldr	r4, [pc, #16]	; (8013bcc <USBD_FS_ProductStrDescriptor+0x14>)
{
 8013bbc:	460a      	mov	r2, r1
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8013bbe:	4804      	ldr	r0, [pc, #16]	; (8013bd0 <USBD_FS_ProductStrDescriptor+0x18>)
 8013bc0:	4621      	mov	r1, r4
 8013bc2:	f7ff fed1 	bl	8013968 <USBD_GetString>
}
 8013bc6:	4620      	mov	r0, r4
 8013bc8:	bd10      	pop	{r4, pc}
 8013bca:	bf00      	nop
 8013bcc:	240342e0 	.word	0x240342e0
 8013bd0:	240084e4 	.word	0x240084e4

08013bd4 <USBD_FS_ConfigStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8013bd4:	b510      	push	{r4, lr}
  if(speed == USBD_SPEED_HIGH)
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8013bd6:	4c04      	ldr	r4, [pc, #16]	; (8013be8 <USBD_FS_ConfigStrDescriptor+0x14>)
{
 8013bd8:	460a      	mov	r2, r1
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8013bda:	4804      	ldr	r0, [pc, #16]	; (8013bec <USBD_FS_ConfigStrDescriptor+0x18>)
 8013bdc:	4621      	mov	r1, r4
 8013bde:	f7ff fec3 	bl	8013968 <USBD_GetString>
  else
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
  }
  return USBD_StrDesc;
}
 8013be2:	4620      	mov	r0, r4
 8013be4:	bd10      	pop	{r4, pc}
 8013be6:	bf00      	nop
 8013be8:	240342e0 	.word	0x240342e0
 8013bec:	240084fc 	.word	0x240084fc

08013bf0 <USBD_FS_InterfaceStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8013bf0:	b510      	push	{r4, lr}
  if(speed == 0)
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8013bf2:	4c04      	ldr	r4, [pc, #16]	; (8013c04 <USBD_FS_InterfaceStrDescriptor+0x14>)
{
 8013bf4:	460a      	mov	r2, r1
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8013bf6:	4804      	ldr	r0, [pc, #16]	; (8013c08 <USBD_FS_InterfaceStrDescriptor+0x18>)
 8013bf8:	4621      	mov	r1, r4
 8013bfa:	f7ff feb5 	bl	8013968 <USBD_GetString>
  else
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
  }
  return USBD_StrDesc;
}
 8013bfe:	4620      	mov	r0, r4
 8013c00:	bd10      	pop	{r4, pc}
 8013c02:	bf00      	nop
 8013c04:	240342e0 	.word	0x240342e0
 8013c08:	24008508 	.word	0x24008508

08013c0c <USBD_FS_SerialStrDescriptor>:
  */
static void Get_SerialNum(void)
{
  uint32_t deviceserial0, deviceserial1, deviceserial2;

  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 8013c0c:	4a46      	ldr	r2, [pc, #280]	; (8013d28 <USBD_FS_SerialStrDescriptor+0x11c>)
  *length = USB_SIZ_STRING_SERIAL;
 8013c0e:	f04f 0c1a 	mov.w	ip, #26
  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 8013c12:	f8d2 0800 	ldr.w	r0, [r2, #2048]	; 0x800
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
  deviceserial2 = *(uint32_t *) DEVICE_ID3;

  deviceserial0 += deviceserial2;
 8013c16:	f8d2 3808 	ldr.w	r3, [r2, #2056]	; 0x808
  *length = USB_SIZ_STRING_SERIAL;
 8013c1a:	f8a1 c000 	strh.w	ip, [r1]

  if (deviceserial0 != 0)
 8013c1e:	18c3      	adds	r3, r0, r3
 8013c20:	d101      	bne.n	8013c26 <USBD_FS_SerialStrDescriptor+0x1a>
}
 8013c22:	4842      	ldr	r0, [pc, #264]	; (8013d2c <USBD_FS_SerialStrDescriptor+0x120>)
 8013c24:	4770      	bx	lr
{
  uint8_t idx = 0;

  for (idx = 0; idx < len; idx++)
  {
    if (((value >> 28)) < 0xA)
 8013c26:	0f18      	lsrs	r0, r3, #28
 8013c28:	f1b3 4f20 	cmp.w	r3, #2684354560	; 0xa0000000
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 8013c2c:	f8d2 1804 	ldr.w	r1, [r2, #2052]	; 0x804
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
    }

    value = value << 4;

    pbuf[2 * idx + 1] = 0;
 8013c30:	f04f 0c00 	mov.w	ip, #0
      pbuf[2 * idx] = (value >> 28) + '0';
 8013c34:	4a3d      	ldr	r2, [pc, #244]	; (8013d2c <USBD_FS_SerialStrDescriptor+0x120>)
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8013c36:	bf2c      	ite	cs
 8013c38:	3037      	addcs	r0, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8013c3a:	3030      	addcc	r0, #48	; 0x30
    pbuf[2 * idx + 1] = 0;
 8013c3c:	f882 c003 	strb.w	ip, [r2, #3]
 8013c40:	f04f 0c00 	mov.w	ip, #0
      pbuf[2 * idx] = (value >> 28) + '0';
 8013c44:	7090      	strb	r0, [r2, #2]
    if (((value >> 28)) < 0xA)
 8013c46:	f3c3 6003 	ubfx	r0, r3, #24, #4
    pbuf[2 * idx + 1] = 0;
 8013c4a:	f882 c005 	strb.w	ip, [r2, #5]
 8013c4e:	f04f 0c00 	mov.w	ip, #0
    if (((value >> 28)) < 0xA)
 8013c52:	2809      	cmp	r0, #9
    pbuf[2 * idx + 1] = 0;
 8013c54:	f882 c007 	strb.w	ip, [r2, #7]
 8013c58:	f04f 0c00 	mov.w	ip, #0
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8013c5c:	bf8c      	ite	hi
 8013c5e:	3037      	addhi	r0, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8013c60:	3030      	addls	r0, #48	; 0x30
    pbuf[2 * idx + 1] = 0;
 8013c62:	f882 c009 	strb.w	ip, [r2, #9]
 8013c66:	f04f 0c00 	mov.w	ip, #0
      pbuf[2 * idx] = (value >> 28) + '0';
 8013c6a:	7110      	strb	r0, [r2, #4]
    if (((value >> 28)) < 0xA)
 8013c6c:	f3c3 5003 	ubfx	r0, r3, #20, #4
    pbuf[2 * idx + 1] = 0;
 8013c70:	f882 c00b 	strb.w	ip, [r2, #11]
 8013c74:	f04f 0c00 	mov.w	ip, #0
    if (((value >> 28)) < 0xA)
 8013c78:	2809      	cmp	r0, #9
    pbuf[2 * idx + 1] = 0;
 8013c7a:	f882 c00d 	strb.w	ip, [r2, #13]
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8013c7e:	bf8c      	ite	hi
 8013c80:	3037      	addhi	r0, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8013c82:	3030      	addls	r0, #48	; 0x30
 8013c84:	7190      	strb	r0, [r2, #6]
    if (((value >> 28)) < 0xA)
 8013c86:	f3c3 4003 	ubfx	r0, r3, #16, #4
 8013c8a:	2809      	cmp	r0, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8013c8c:	bf8c      	ite	hi
 8013c8e:	3037      	addhi	r0, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8013c90:	3030      	addls	r0, #48	; 0x30
 8013c92:	7210      	strb	r0, [r2, #8]
    if (((value >> 28)) < 0xA)
 8013c94:	f3c3 3003 	ubfx	r0, r3, #12, #4
 8013c98:	2809      	cmp	r0, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8013c9a:	bf8c      	ite	hi
 8013c9c:	3037      	addhi	r0, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8013c9e:	3030      	addls	r0, #48	; 0x30
 8013ca0:	7290      	strb	r0, [r2, #10]
    if (((value >> 28)) < 0xA)
 8013ca2:	f3c3 2003 	ubfx	r0, r3, #8, #4
 8013ca6:	2809      	cmp	r0, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8013ca8:	bf8c      	ite	hi
 8013caa:	3037      	addhi	r0, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8013cac:	3030      	addls	r0, #48	; 0x30
 8013cae:	7310      	strb	r0, [r2, #12]
    if (((value >> 28)) < 0xA)
 8013cb0:	f3c3 1003 	ubfx	r0, r3, #4, #4
 8013cb4:	f003 030f 	and.w	r3, r3, #15
 8013cb8:	2809      	cmp	r0, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8013cba:	bf8c      	ite	hi
 8013cbc:	3037      	addhi	r0, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8013cbe:	3030      	addls	r0, #48	; 0x30
    if (((value >> 28)) < 0xA)
 8013cc0:	2b09      	cmp	r3, #9
      pbuf[2 * idx] = (value >> 28) + '0';
 8013cc2:	7390      	strb	r0, [r2, #14]
    pbuf[2 * idx + 1] = 0;
 8013cc4:	f04f 0000 	mov.w	r0, #0
      pbuf[2 * idx] = (value >> 28) + '0';
 8013cc8:	bf94      	ite	ls
 8013cca:	3330      	addls	r3, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8013ccc:	3337      	addhi	r3, #55	; 0x37
    if (((value >> 28)) < 0xA)
 8013cce:	f1b1 4f20 	cmp.w	r1, #2684354560	; 0xa0000000
    pbuf[2 * idx + 1] = 0;
 8013cd2:	73d0      	strb	r0, [r2, #15]
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8013cd4:	7413      	strb	r3, [r2, #16]
    if (((value >> 28)) < 0xA)
 8013cd6:	ea4f 7311 	mov.w	r3, r1, lsr #28
    pbuf[2 * idx + 1] = 0;
 8013cda:	f04f 0000 	mov.w	r0, #0
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8013cde:	bf2c      	ite	cs
 8013ce0:	3337      	addcs	r3, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8013ce2:	3330      	addcc	r3, #48	; 0x30
    pbuf[2 * idx + 1] = 0;
 8013ce4:	7450      	strb	r0, [r2, #17]
 8013ce6:	2000      	movs	r0, #0
      pbuf[2 * idx] = (value >> 28) + '0';
 8013ce8:	7493      	strb	r3, [r2, #18]
    if (((value >> 28)) < 0xA)
 8013cea:	f3c1 6303 	ubfx	r3, r1, #24, #4
    pbuf[2 * idx + 1] = 0;
 8013cee:	74d0      	strb	r0, [r2, #19]
 8013cf0:	2000      	movs	r0, #0
    if (((value >> 28)) < 0xA)
 8013cf2:	2b09      	cmp	r3, #9
    pbuf[2 * idx + 1] = 0;
 8013cf4:	7550      	strb	r0, [r2, #21]
 8013cf6:	f04f 0000 	mov.w	r0, #0
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8013cfa:	bf8c      	ite	hi
 8013cfc:	3337      	addhi	r3, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8013cfe:	3330      	addls	r3, #48	; 0x30
    pbuf[2 * idx + 1] = 0;
 8013d00:	75d0      	strb	r0, [r2, #23]
      pbuf[2 * idx] = (value >> 28) + '0';
 8013d02:	7513      	strb	r3, [r2, #20]
    if (((value >> 28)) < 0xA)
 8013d04:	f3c1 5303 	ubfx	r3, r1, #20, #4
}
 8013d08:	4808      	ldr	r0, [pc, #32]	; (8013d2c <USBD_FS_SerialStrDescriptor+0x120>)
    if (((value >> 28)) < 0xA)
 8013d0a:	2b09      	cmp	r3, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8013d0c:	bf8c      	ite	hi
 8013d0e:	3337      	addhi	r3, #55	; 0x37
      pbuf[2 * idx] = (value >> 28) + '0';
 8013d10:	3330      	addls	r3, #48	; 0x30
 8013d12:	7593      	strb	r3, [r2, #22]
    if (((value >> 28)) < 0xA)
 8013d14:	f3c1 4303 	ubfx	r3, r1, #16, #4
 8013d18:	2b09      	cmp	r3, #9
      pbuf[2 * idx] = (value >> 28) + '0';
 8013d1a:	bf94      	ite	ls
 8013d1c:	3330      	addls	r3, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8013d1e:	3337      	addhi	r3, #55	; 0x37
 8013d20:	7613      	strb	r3, [r2, #24]
    pbuf[2 * idx + 1] = 0;
 8013d22:	2300      	movs	r3, #0
 8013d24:	7653      	strb	r3, [r2, #25]
}
 8013d26:	4770      	bx	lr
 8013d28:	1ff1e000 	.word	0x1ff1e000
 8013d2c:	24008168 	.word	0x24008168

08013d30 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 8013d30:	b530      	push	{r4, r5, lr}
 8013d32:	b0b7      	sub	sp, #220	; 0xdc
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8013d34:	2100      	movs	r1, #0
{
 8013d36:	4604      	mov	r4, r0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8013d38:	22bc      	movs	r2, #188	; 0xbc
 8013d3a:	a807      	add	r0, sp, #28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8013d3c:	9106      	str	r1, [sp, #24]
 8013d3e:	e9cd 1102 	strd	r1, r1, [sp, #8]
 8013d42:	e9cd 1104 	strd	r1, r1, [sp, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8013d46:	f000 fae3 	bl	8014310 <memset>
  if(pcdHandle->Instance==USB_OTG_FS)
 8013d4a:	4b2f      	ldr	r3, [pc, #188]	; (8013e08 <HAL_PCD_MspInit+0xd8>)
 8013d4c:	6822      	ldr	r2, [r4, #0]
 8013d4e:	429a      	cmp	r2, r3
 8013d50:	d001      	beq.n	8013d56 <HAL_PCD_MspInit+0x26>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 8013d52:	b037      	add	sp, #220	; 0xdc
 8013d54:	bd30      	pop	{r4, r5, pc}
    PeriphClkInitStruct.PLL3.PLL3P = 2;
 8013d56:	2302      	movs	r3, #2
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USB;
 8013d58:	f44f 2180 	mov.w	r1, #262144	; 0x40000
    PeriphClkInitStruct.PLL3.PLL3M = 1;
 8013d5c:	2201      	movs	r2, #1
    PeriphClkInitStruct.PLL3.PLL3N = 24;
 8013d5e:	2418      	movs	r4, #24
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USB;
 8013d60:	9107      	str	r1, [sp, #28]
    PeriphClkInitStruct.PLL3.PLL3Q = 4;
 8013d62:	2104      	movs	r1, #4
    PeriphClkInitStruct.PLL3.PLL3P = 2;
 8013d64:	9312      	str	r3, [sp, #72]	; 0x48
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8013d66:	a807      	add	r0, sp, #28
    PeriphClkInitStruct.PLL3.PLL3M = 1;
 8013d68:	9210      	str	r2, [sp, #64]	; 0x40
    PeriphClkInitStruct.PLL3.PLL3RGE = RCC_PLL3VCIRANGE_3;
 8013d6a:	f44f 6240 	mov.w	r2, #3072	; 0xc00
    PeriphClkInitStruct.PLL3.PLL3R = 2;
 8013d6e:	9314      	str	r3, [sp, #80]	; 0x50
    PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLL3;
 8013d70:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
    PeriphClkInitStruct.PLL3.PLL3N = 24;
 8013d74:	9411      	str	r4, [sp, #68]	; 0x44
    PeriphClkInitStruct.PLL3.PLL3Q = 4;
 8013d76:	9113      	str	r1, [sp, #76]	; 0x4c
    PeriphClkInitStruct.PLL3.PLL3RGE = RCC_PLL3VCIRANGE_3;
 8013d78:	9215      	str	r2, [sp, #84]	; 0x54
    PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLL3;
 8013d7a:	9328      	str	r3, [sp, #160]	; 0xa0
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8013d7c:	f7fa fec0 	bl	800eb00 <HAL_RCCEx_PeriphCLKConfig>
 8013d80:	2800      	cmp	r0, #0
 8013d82:	d13e      	bne.n	8013e02 <HAL_PCD_MspInit+0xd2>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8013d84:	4c21      	ldr	r4, [pc, #132]	; (8013e0c <HAL_PCD_MspInit+0xdc>)
    HAL_PWREx_EnableUSBVoltageDetector();
 8013d86:	f7f9 ffa3 	bl	800dcd0 <HAL_PWREx_EnableUSBVoltageDetector>
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG1_FS;
 8013d8a:	220a      	movs	r2, #10
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_11|GPIO_PIN_12;
 8013d8c:	f44f 50c8 	mov.w	r0, #6400	; 0x1900
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8013d90:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_11|GPIO_PIN_12;
 8013d94:	2102      	movs	r1, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8013d96:	2500      	movs	r5, #0
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8013d98:	f043 0301 	orr.w	r3, r3, #1
 8013d9c:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 8013da0:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG1_FS;
 8013da4:	9206      	str	r2, [sp, #24]
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_11|GPIO_PIN_12;
 8013da6:	2200      	movs	r2, #0
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8013da8:	f003 0301 	and.w	r3, r3, #1
 8013dac:	9300      	str	r3, [sp, #0]
 8013dae:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_11|GPIO_PIN_12;
 8013db0:	2300      	movs	r3, #0
 8013db2:	e9cd 0102 	strd	r0, r1, [sp, #8]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8013db6:	a902      	add	r1, sp, #8
 8013db8:	4815      	ldr	r0, [pc, #84]	; (8013e10 <HAL_PCD_MspInit+0xe0>)
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_11|GPIO_PIN_12;
 8013dba:	e9cd 2304 	strd	r2, r3, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8013dbe:	f7f8 fd23 	bl	800c808 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_9;
 8013dc2:	f44f 7200 	mov.w	r2, #512	; 0x200
 8013dc6:	2300      	movs	r3, #0
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8013dc8:	a902      	add	r1, sp, #8
 8013dca:	4811      	ldr	r0, [pc, #68]	; (8013e10 <HAL_PCD_MspInit+0xe0>)
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8013dcc:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Pin = GPIO_PIN_9;
 8013dce:	e9cd 2302 	strd	r2, r3, [sp, #8]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8013dd2:	f7f8 fd19 	bl	800c808 <HAL_GPIO_Init>
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8013dd6:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 5, 0);
 8013dda:	462a      	mov	r2, r5
 8013ddc:	2105      	movs	r1, #5
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8013dde:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 5, 0);
 8013de2:	2065      	movs	r0, #101	; 0x65
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8013de4:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
 8013de8:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
 8013dec:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8013df0:	9301      	str	r3, [sp, #4]
 8013df2:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 5, 0);
 8013df4:	f7f6 ffba 	bl	800ad6c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 8013df8:	2065      	movs	r0, #101	; 0x65
 8013dfa:	f7f6 fff5 	bl	800ade8 <HAL_NVIC_EnableIRQ>
}
 8013dfe:	b037      	add	sp, #220	; 0xdc
 8013e00:	bd30      	pop	{r4, r5, pc}
      Error_Handler();
 8013e02:	f7f6 fc59 	bl	800a6b8 <Error_Handler>
 8013e06:	e7bd      	b.n	8013d84 <HAL_PCD_MspInit+0x54>
 8013e08:	40080000 	.word	0x40080000
 8013e0c:	58024400 	.word	0x58024400
 8013e10:	58020000 	.word	0x58020000

08013e14 <HAL_PCD_SetupStageCallback>:
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8013e14:	f200 41c4 	addw	r1, r0, #1220	; 0x4c4
 8013e18:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8013e1c:	f7ff b96c 	b.w	80130f8 <USBD_LL_SetupStage>

08013e20 <HAL_PCD_DataOutStageCallback>:
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8013e20:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
 8013e24:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8013e28:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8013e2c:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
 8013e30:	f7ff b992 	b.w	8013158 <USBD_LL_DataOutStage>

08013e34 <HAL_PCD_DataInStageCallback>:
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8013e34:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
 8013e38:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8013e3c:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8013e40:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8013e42:	f7ff b9c3 	b.w	80131cc <USBD_LL_DataInStage>
 8013e46:	bf00      	nop

08013e48 <HAL_PCD_SOFCallback>:
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 8013e48:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8013e4c:	f7ff ba68 	b.w	8013320 <USBD_LL_SOF>

08013e50 <HAL_PCD_ResetCallback>:
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  if ( hpcd->Init.speed == PCD_SPEED_HIGH)
 8013e50:	68c1      	ldr	r1, [r0, #12]
{
 8013e52:	b510      	push	{r4, lr}
 8013e54:	4604      	mov	r4, r0
  if ( hpcd->Init.speed == PCD_SPEED_HIGH)
 8013e56:	b111      	cbz	r1, 8013e5e <HAL_PCD_ResetCallback+0xe>
  {
    speed = USBD_SPEED_HIGH;
  }
  else if ( hpcd->Init.speed == PCD_SPEED_FULL)
 8013e58:	2902      	cmp	r1, #2
 8013e5a:	d10a      	bne.n	8013e72 <HAL_PCD_ResetCallback+0x22>
  {
    speed = USBD_SPEED_FULL;
 8013e5c:	2101      	movs	r1, #1
  else
  {
    Error_Handler();
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 8013e5e:	f8d4 0508 	ldr.w	r0, [r4, #1288]	; 0x508
 8013e62:	f7ff fa41 	bl	80132e8 <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8013e66:	f8d4 0508 	ldr.w	r0, [r4, #1288]	; 0x508
}
 8013e6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8013e6e:	f7ff ba0d 	b.w	801328c <USBD_LL_Reset>
    Error_Handler();
 8013e72:	f7f6 fc21 	bl	800a6b8 <Error_Handler>
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
 8013e76:	2101      	movs	r1, #1
 8013e78:	e7f1      	b.n	8013e5e <HAL_PCD_ResetCallback+0xe>
 8013e7a:	bf00      	nop

08013e7c <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8013e7c:	b510      	push	{r4, lr}
 8013e7e:	4604      	mov	r4, r0
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8013e80:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8013e84:	f7ff fa34 	bl	80132f0 <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8013e88:	6822      	ldr	r2, [r4, #0]
 8013e8a:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 8013e8e:	f043 0301 	orr.w	r3, r3, #1
 8013e92:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8013e96:	6a23      	ldr	r3, [r4, #32]
 8013e98:	b123      	cbz	r3, 8013ea4 <HAL_PCD_SuspendCallback+0x28>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8013e9a:	4a03      	ldr	r2, [pc, #12]	; (8013ea8 <HAL_PCD_SuspendCallback+0x2c>)
 8013e9c:	6913      	ldr	r3, [r2, #16]
 8013e9e:	f043 0306 	orr.w	r3, r3, #6
 8013ea2:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 8013ea4:	bd10      	pop	{r4, pc}
 8013ea6:	bf00      	nop
 8013ea8:	e000ed00 	.word	0xe000ed00

08013eac <HAL_PCD_ResumeCallback>:
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8013eac:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8013eb0:	f7ff ba2a 	b.w	8013308 <USBD_LL_Resume>

08013eb4 <HAL_PCD_ISOOUTIncompleteCallback>:
static void PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8013eb4:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8013eb8:	f7ff ba58 	b.w	801336c <USBD_LL_IsoOUTIncomplete>

08013ebc <HAL_PCD_ISOINIncompleteCallback>:
static void PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8013ebc:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8013ec0:	f7ff ba3e 	b.w	8013340 <USBD_LL_IsoINIncomplete>

08013ec4 <HAL_PCD_ConnectCallback>:
static void PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 8013ec4:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8013ec8:	f7ff ba66 	b.w	8013398 <USBD_LL_DevConnected>

08013ecc <HAL_PCD_DisconnectCallback>:
static void PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 8013ecc:	f8d0 0508 	ldr.w	r0, [r0, #1288]	; 0x508
 8013ed0:	f7ff ba64 	b.w	801339c <USBD_LL_DevDisconnected>
 8013ed4:	0000      	movs	r0, r0
	...

08013ed8 <USBD_LL_Init>:
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
  /* Init USB Ip. */
  if (pdev->id == DEVICE_FS) {
 8013ed8:	7802      	ldrb	r2, [r0, #0]
 8013eda:	b10a      	cbz	r2, 8013ee0 <USBD_LL_Init+0x8>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
  /* USER CODE END TxRx_Configuration */
  }
  return USBD_OK;
}
 8013edc:	2000      	movs	r0, #0
 8013ede:	4770      	bx	lr
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8013ee0:	ed9f 7b19 	vldr	d7, [pc, #100]	; 8013f48 <USBD_LL_Init+0x70>
  hpcd_USB_OTG_FS.pData = pdev;
 8013ee4:	4b1e      	ldr	r3, [pc, #120]	; (8013f60 <USBD_LL_Init+0x88>)
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 8013ee6:	491f      	ldr	r1, [pc, #124]	; (8013f64 <USBD_LL_Init+0x8c>)
{
 8013ee8:	b510      	push	{r4, lr}
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8013eea:	ed83 7b06 	vstr	d7, [r3, #24]
 8013eee:	ed9f 7b18 	vldr	d7, [pc, #96]	; 8013f50 <USBD_LL_Init+0x78>
  hpcd_USB_OTG_FS.Init.dev_endpoints = 9;
 8013ef2:	2409      	movs	r4, #9
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 8013ef4:	6019      	str	r1, [r3, #0]
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 8013ef6:	2102      	movs	r1, #2
  hpcd_USB_OTG_FS.pData = pdev;
 8013ef8:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
  pdev->pData = &hpcd_USB_OTG_FS;
 8013efc:	f8c0 32c8 	str.w	r3, [r0, #712]	; 0x2c8
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8013f00:	4618      	mov	r0, r3
  hpcd_USB_OTG_FS.Init.dev_endpoints = 9;
 8013f02:	605c      	str	r4, [r3, #4]
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 8013f04:	631a      	str	r2, [r3, #48]	; 0x30
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8013f06:	ed83 7b08 	vstr	d7, [r3, #32]
 8013f0a:	ed9f 7b13 	vldr	d7, [pc, #76]	; 8013f58 <USBD_LL_Init+0x80>
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 8013f0e:	e9c3 1203 	strd	r1, r2, [r3, #12]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8013f12:	ed83 7b0a 	vstr	d7, [r3, #40]	; 0x28
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8013f16:	f7f8 fe93 	bl	800cc40 <HAL_PCD_Init>
 8013f1a:	b978      	cbnz	r0, 8013f3c <USBD_LL_Init+0x64>
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 8013f1c:	2180      	movs	r1, #128	; 0x80
 8013f1e:	4810      	ldr	r0, [pc, #64]	; (8013f60 <USBD_LL_Init+0x88>)
 8013f20:	f7f9 fe78 	bl	800dc14 <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 8013f24:	2240      	movs	r2, #64	; 0x40
 8013f26:	2100      	movs	r1, #0
 8013f28:	480d      	ldr	r0, [pc, #52]	; (8013f60 <USBD_LL_Init+0x88>)
 8013f2a:	f7f9 fe49 	bl	800dbc0 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 8013f2e:	2280      	movs	r2, #128	; 0x80
 8013f30:	2101      	movs	r1, #1
 8013f32:	480b      	ldr	r0, [pc, #44]	; (8013f60 <USBD_LL_Init+0x88>)
 8013f34:	f7f9 fe44 	bl	800dbc0 <HAL_PCDEx_SetTxFiFo>
}
 8013f38:	2000      	movs	r0, #0
 8013f3a:	bd10      	pop	{r4, pc}
    Error_Handler( );
 8013f3c:	f7f6 fbbc 	bl	800a6b8 <Error_Handler>
 8013f40:	e7ec      	b.n	8013f1c <USBD_LL_Init+0x44>
 8013f42:	bf00      	nop
 8013f44:	f3af 8000 	nop.w
 8013f48:	00000002 	.word	0x00000002
	...
 8013f58:	00000001 	.word	0x00000001
 8013f5c:	00000001 	.word	0x00000001
 8013f60:	240344e0 	.word	0x240344e0
 8013f64:	40080000 	.word	0x40080000

08013f68 <USBD_LL_Start>:
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_Start(pdev->pData);
 8013f68:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
{
 8013f6c:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_Start(pdev->pData);
 8013f6e:	f7f8 fefd 	bl	800cd6c <HAL_PCD_Start>
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
  USBD_StatusTypeDef usb_status = USBD_OK;

  switch (hal_status)
 8013f72:	2803      	cmp	r0, #3
 8013f74:	d802      	bhi.n	8013f7c <USBD_LL_Start+0x14>
 8013f76:	4b02      	ldr	r3, [pc, #8]	; (8013f80 <USBD_LL_Start+0x18>)
 8013f78:	5c18      	ldrb	r0, [r3, r0]
}
 8013f7a:	bd08      	pop	{r3, pc}
  hal_status = HAL_PCD_Start(pdev->pData);
 8013f7c:	2003      	movs	r0, #3
}
 8013f7e:	bd08      	pop	{r3, pc}
 8013f80:	24008518 	.word	0x24008518

08013f84 <USBD_LL_OpenEP>:
{
 8013f84:	4694      	mov	ip, r2
  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8013f86:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
{
 8013f8a:	461a      	mov	r2, r3
 8013f8c:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8013f8e:	4663      	mov	r3, ip
 8013f90:	f7f9 fcc8 	bl	800d924 <HAL_PCD_EP_Open>
  switch (hal_status)
 8013f94:	2803      	cmp	r0, #3
 8013f96:	d802      	bhi.n	8013f9e <USBD_LL_OpenEP+0x1a>
 8013f98:	4b02      	ldr	r3, [pc, #8]	; (8013fa4 <USBD_LL_OpenEP+0x20>)
 8013f9a:	5c18      	ldrb	r0, [r3, r0]
}
 8013f9c:	bd08      	pop	{r3, pc}
  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8013f9e:	2003      	movs	r0, #3
}
 8013fa0:	bd08      	pop	{r3, pc}
 8013fa2:	bf00      	nop
 8013fa4:	24008518 	.word	0x24008518

08013fa8 <USBD_LL_CloseEP>:
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8013fa8:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
{
 8013fac:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8013fae:	f7f9 fcf7 	bl	800d9a0 <HAL_PCD_EP_Close>
  switch (hal_status)
 8013fb2:	2803      	cmp	r0, #3
 8013fb4:	d802      	bhi.n	8013fbc <USBD_LL_CloseEP+0x14>
 8013fb6:	4b02      	ldr	r3, [pc, #8]	; (8013fc0 <USBD_LL_CloseEP+0x18>)
 8013fb8:	5c18      	ldrb	r0, [r3, r0]
}
 8013fba:	bd08      	pop	{r3, pc}
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8013fbc:	2003      	movs	r0, #3
}
 8013fbe:	bd08      	pop	{r3, pc}
 8013fc0:	24008518 	.word	0x24008518

08013fc4 <USBD_LL_StallEP>:
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8013fc4:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
{
 8013fc8:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8013fca:	f7f9 fd79 	bl	800dac0 <HAL_PCD_EP_SetStall>
  switch (hal_status)
 8013fce:	2803      	cmp	r0, #3
 8013fd0:	d802      	bhi.n	8013fd8 <USBD_LL_StallEP+0x14>
 8013fd2:	4b02      	ldr	r3, [pc, #8]	; (8013fdc <USBD_LL_StallEP+0x18>)
 8013fd4:	5c18      	ldrb	r0, [r3, r0]
}
 8013fd6:	bd08      	pop	{r3, pc}
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8013fd8:	2003      	movs	r0, #3
}
 8013fda:	bd08      	pop	{r3, pc}
 8013fdc:	24008518 	.word	0x24008518

08013fe0 <USBD_LL_ClearStallEP>:
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 8013fe0:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
{
 8013fe4:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 8013fe6:	f7f9 fdaf 	bl	800db48 <HAL_PCD_EP_ClrStall>
  switch (hal_status)
 8013fea:	2803      	cmp	r0, #3
 8013fec:	d802      	bhi.n	8013ff4 <USBD_LL_ClearStallEP+0x14>
 8013fee:	4b02      	ldr	r3, [pc, #8]	; (8013ff8 <USBD_LL_ClearStallEP+0x18>)
 8013ff0:	5c18      	ldrb	r0, [r3, r0]
}
 8013ff2:	bd08      	pop	{r3, pc}
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 8013ff4:	2003      	movs	r0, #3
}
 8013ff6:	bd08      	pop	{r3, pc}
 8013ff8:	24008518 	.word	0x24008518

08013ffc <USBD_LL_IsStallEP>:
  if((ep_addr & 0x80) == 0x80)
 8013ffc:	060a      	lsls	r2, r1, #24
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8013ffe:	f8d0 32c8 	ldr.w	r3, [r0, #712]	; 0x2c8
  if((ep_addr & 0x80) == 0x80)
 8014002:	d406      	bmi.n	8014012 <USBD_LL_IsStallEP+0x16>
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 8014004:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
 8014008:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 801400c:	f891 027e 	ldrb.w	r0, [r1, #638]	; 0x27e
}
 8014010:	4770      	bx	lr
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 8014012:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8014016:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
 801401a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 801401e:	f891 003e 	ldrb.w	r0, [r1, #62]	; 0x3e
 8014022:	4770      	bx	lr

08014024 <USBD_LL_SetUSBAddress>:
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8014024:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
{
 8014028:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 801402a:	f7f9 fc65 	bl	800d8f8 <HAL_PCD_SetAddress>
  switch (hal_status)
 801402e:	2803      	cmp	r0, #3
 8014030:	d802      	bhi.n	8014038 <USBD_LL_SetUSBAddress+0x14>
 8014032:	4b02      	ldr	r3, [pc, #8]	; (801403c <USBD_LL_SetUSBAddress+0x18>)
 8014034:	5c18      	ldrb	r0, [r3, r0]
}
 8014036:	bd08      	pop	{r3, pc}
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8014038:	2003      	movs	r0, #3
}
 801403a:	bd08      	pop	{r3, pc}
 801403c:	24008518 	.word	0x24008518

08014040 <USBD_LL_Transmit>:
  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8014040:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
{
 8014044:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8014046:	f7f9 fd13 	bl	800da70 <HAL_PCD_EP_Transmit>
  switch (hal_status)
 801404a:	2803      	cmp	r0, #3
 801404c:	d802      	bhi.n	8014054 <USBD_LL_Transmit+0x14>
 801404e:	4b02      	ldr	r3, [pc, #8]	; (8014058 <USBD_LL_Transmit+0x18>)
 8014050:	5c18      	ldrb	r0, [r3, r0]
}
 8014052:	bd08      	pop	{r3, pc}
  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8014054:	2003      	movs	r0, #3
}
 8014056:	bd08      	pop	{r3, pc}
 8014058:	24008518 	.word	0x24008518

0801405c <USBD_LL_PrepareReceive>:
  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 801405c:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
{
 8014060:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8014062:	f7f9 fcd3 	bl	800da0c <HAL_PCD_EP_Receive>
  switch (hal_status)
 8014066:	2803      	cmp	r0, #3
 8014068:	d802      	bhi.n	8014070 <USBD_LL_PrepareReceive+0x14>
 801406a:	4b02      	ldr	r3, [pc, #8]	; (8014074 <USBD_LL_PrepareReceive+0x18>)
 801406c:	5c18      	ldrb	r0, [r3, r0]
}
 801406e:	bd08      	pop	{r3, pc}
  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8014070:	2003      	movs	r0, #3
}
 8014072:	bd08      	pop	{r3, pc}
 8014074:	24008518 	.word	0x24008518

08014078 <USBD_LL_GetRxDataSize>:
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 8014078:	f8d0 02c8 	ldr.w	r0, [r0, #712]	; 0x2c8
 801407c:	f7f9 bcee 	b.w	800da5c <HAL_PCD_EP_GetRxCount>

08014080 <USBD_static_malloc>:
}
 8014080:	4800      	ldr	r0, [pc, #0]	; (8014084 <USBD_static_malloc+0x4>)
 8014082:	4770      	bx	lr
 8014084:	240349ec 	.word	0x240349ec

08014088 <USBD_static_free>:
}
 8014088:	4770      	bx	lr
 801408a:	bf00      	nop

0801408c <__errno>:
 801408c:	4b01      	ldr	r3, [pc, #4]	; (8014094 <__errno+0x8>)
 801408e:	6818      	ldr	r0, [r3, #0]
 8014090:	4770      	bx	lr
 8014092:	bf00      	nop
 8014094:	24008184 	.word	0x24008184

08014098 <std>:
 8014098:	2300      	movs	r3, #0
 801409a:	b510      	push	{r4, lr}
 801409c:	4604      	mov	r4, r0
 801409e:	e9c0 3300 	strd	r3, r3, [r0]
 80140a2:	e9c0 3304 	strd	r3, r3, [r0, #16]
 80140a6:	6083      	str	r3, [r0, #8]
 80140a8:	8181      	strh	r1, [r0, #12]
 80140aa:	6643      	str	r3, [r0, #100]	; 0x64
 80140ac:	81c2      	strh	r2, [r0, #14]
 80140ae:	6183      	str	r3, [r0, #24]
 80140b0:	4619      	mov	r1, r3
 80140b2:	2208      	movs	r2, #8
 80140b4:	305c      	adds	r0, #92	; 0x5c
 80140b6:	f000 f92b 	bl	8014310 <memset>
 80140ba:	4b05      	ldr	r3, [pc, #20]	; (80140d0 <std+0x38>)
 80140bc:	6263      	str	r3, [r4, #36]	; 0x24
 80140be:	4b05      	ldr	r3, [pc, #20]	; (80140d4 <std+0x3c>)
 80140c0:	62a3      	str	r3, [r4, #40]	; 0x28
 80140c2:	4b05      	ldr	r3, [pc, #20]	; (80140d8 <std+0x40>)
 80140c4:	62e3      	str	r3, [r4, #44]	; 0x2c
 80140c6:	4b05      	ldr	r3, [pc, #20]	; (80140dc <std+0x44>)
 80140c8:	6224      	str	r4, [r4, #32]
 80140ca:	6323      	str	r3, [r4, #48]	; 0x30
 80140cc:	bd10      	pop	{r4, pc}
 80140ce:	bf00      	nop
 80140d0:	080146f1 	.word	0x080146f1
 80140d4:	08014713 	.word	0x08014713
 80140d8:	0801474b 	.word	0x0801474b
 80140dc:	0801476f 	.word	0x0801476f

080140e0 <_cleanup_r>:
 80140e0:	4901      	ldr	r1, [pc, #4]	; (80140e8 <_cleanup_r+0x8>)
 80140e2:	f000 b8af 	b.w	8014244 <_fwalk_reent>
 80140e6:	bf00      	nop
 80140e8:	08014a49 	.word	0x08014a49

080140ec <__sfmoreglue>:
 80140ec:	b570      	push	{r4, r5, r6, lr}
 80140ee:	2268      	movs	r2, #104	; 0x68
 80140f0:	1e4d      	subs	r5, r1, #1
 80140f2:	4355      	muls	r5, r2
 80140f4:	460e      	mov	r6, r1
 80140f6:	f105 0174 	add.w	r1, r5, #116	; 0x74
 80140fa:	f000 f97d 	bl	80143f8 <_malloc_r>
 80140fe:	4604      	mov	r4, r0
 8014100:	b140      	cbz	r0, 8014114 <__sfmoreglue+0x28>
 8014102:	2100      	movs	r1, #0
 8014104:	e9c0 1600 	strd	r1, r6, [r0]
 8014108:	300c      	adds	r0, #12
 801410a:	60a0      	str	r0, [r4, #8]
 801410c:	f105 0268 	add.w	r2, r5, #104	; 0x68
 8014110:	f000 f8fe 	bl	8014310 <memset>
 8014114:	4620      	mov	r0, r4
 8014116:	bd70      	pop	{r4, r5, r6, pc}

08014118 <__sfp_lock_acquire>:
 8014118:	4801      	ldr	r0, [pc, #4]	; (8014120 <__sfp_lock_acquire+0x8>)
 801411a:	f000 b8d8 	b.w	80142ce <__retarget_lock_acquire_recursive>
 801411e:	bf00      	nop
 8014120:	24034c0d 	.word	0x24034c0d

08014124 <__sfp_lock_release>:
 8014124:	4801      	ldr	r0, [pc, #4]	; (801412c <__sfp_lock_release+0x8>)
 8014126:	f000 b8d3 	b.w	80142d0 <__retarget_lock_release_recursive>
 801412a:	bf00      	nop
 801412c:	24034c0d 	.word	0x24034c0d

08014130 <__sinit_lock_acquire>:
 8014130:	4801      	ldr	r0, [pc, #4]	; (8014138 <__sinit_lock_acquire+0x8>)
 8014132:	f000 b8cc 	b.w	80142ce <__retarget_lock_acquire_recursive>
 8014136:	bf00      	nop
 8014138:	24034c0e 	.word	0x24034c0e

0801413c <__sinit_lock_release>:
 801413c:	4801      	ldr	r0, [pc, #4]	; (8014144 <__sinit_lock_release+0x8>)
 801413e:	f000 b8c7 	b.w	80142d0 <__retarget_lock_release_recursive>
 8014142:	bf00      	nop
 8014144:	24034c0e 	.word	0x24034c0e

08014148 <__sinit>:
 8014148:	b510      	push	{r4, lr}
 801414a:	4604      	mov	r4, r0
 801414c:	f7ff fff0 	bl	8014130 <__sinit_lock_acquire>
 8014150:	69a3      	ldr	r3, [r4, #24]
 8014152:	b11b      	cbz	r3, 801415c <__sinit+0x14>
 8014154:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8014158:	f7ff bff0 	b.w	801413c <__sinit_lock_release>
 801415c:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
 8014160:	6523      	str	r3, [r4, #80]	; 0x50
 8014162:	4b13      	ldr	r3, [pc, #76]	; (80141b0 <__sinit+0x68>)
 8014164:	4a13      	ldr	r2, [pc, #76]	; (80141b4 <__sinit+0x6c>)
 8014166:	681b      	ldr	r3, [r3, #0]
 8014168:	62a2      	str	r2, [r4, #40]	; 0x28
 801416a:	42a3      	cmp	r3, r4
 801416c:	bf04      	itt	eq
 801416e:	2301      	moveq	r3, #1
 8014170:	61a3      	streq	r3, [r4, #24]
 8014172:	4620      	mov	r0, r4
 8014174:	f000 f820 	bl	80141b8 <__sfp>
 8014178:	6060      	str	r0, [r4, #4]
 801417a:	4620      	mov	r0, r4
 801417c:	f000 f81c 	bl	80141b8 <__sfp>
 8014180:	60a0      	str	r0, [r4, #8]
 8014182:	4620      	mov	r0, r4
 8014184:	f000 f818 	bl	80141b8 <__sfp>
 8014188:	2200      	movs	r2, #0
 801418a:	60e0      	str	r0, [r4, #12]
 801418c:	2104      	movs	r1, #4
 801418e:	6860      	ldr	r0, [r4, #4]
 8014190:	f7ff ff82 	bl	8014098 <std>
 8014194:	68a0      	ldr	r0, [r4, #8]
 8014196:	2201      	movs	r2, #1
 8014198:	2109      	movs	r1, #9
 801419a:	f7ff ff7d 	bl	8014098 <std>
 801419e:	68e0      	ldr	r0, [r4, #12]
 80141a0:	2202      	movs	r2, #2
 80141a2:	2112      	movs	r1, #18
 80141a4:	f7ff ff78 	bl	8014098 <std>
 80141a8:	2301      	movs	r3, #1
 80141aa:	61a3      	str	r3, [r4, #24]
 80141ac:	e7d2      	b.n	8014154 <__sinit+0xc>
 80141ae:	bf00      	nop
 80141b0:	2400857c 	.word	0x2400857c
 80141b4:	080140e1 	.word	0x080140e1

080141b8 <__sfp>:
 80141b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80141ba:	4607      	mov	r7, r0
 80141bc:	f7ff ffac 	bl	8014118 <__sfp_lock_acquire>
 80141c0:	4b1e      	ldr	r3, [pc, #120]	; (801423c <__sfp+0x84>)
 80141c2:	681e      	ldr	r6, [r3, #0]
 80141c4:	69b3      	ldr	r3, [r6, #24]
 80141c6:	b913      	cbnz	r3, 80141ce <__sfp+0x16>
 80141c8:	4630      	mov	r0, r6
 80141ca:	f7ff ffbd 	bl	8014148 <__sinit>
 80141ce:	3648      	adds	r6, #72	; 0x48
 80141d0:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 80141d4:	3b01      	subs	r3, #1
 80141d6:	d503      	bpl.n	80141e0 <__sfp+0x28>
 80141d8:	6833      	ldr	r3, [r6, #0]
 80141da:	b30b      	cbz	r3, 8014220 <__sfp+0x68>
 80141dc:	6836      	ldr	r6, [r6, #0]
 80141de:	e7f7      	b.n	80141d0 <__sfp+0x18>
 80141e0:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 80141e4:	b9d5      	cbnz	r5, 801421c <__sfp+0x64>
 80141e6:	4b16      	ldr	r3, [pc, #88]	; (8014240 <__sfp+0x88>)
 80141e8:	60e3      	str	r3, [r4, #12]
 80141ea:	f104 0058 	add.w	r0, r4, #88	; 0x58
 80141ee:	6665      	str	r5, [r4, #100]	; 0x64
 80141f0:	f000 f86c 	bl	80142cc <__retarget_lock_init_recursive>
 80141f4:	f7ff ff96 	bl	8014124 <__sfp_lock_release>
 80141f8:	e9c4 5501 	strd	r5, r5, [r4, #4]
 80141fc:	e9c4 5504 	strd	r5, r5, [r4, #16]
 8014200:	6025      	str	r5, [r4, #0]
 8014202:	61a5      	str	r5, [r4, #24]
 8014204:	2208      	movs	r2, #8
 8014206:	4629      	mov	r1, r5
 8014208:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 801420c:	f000 f880 	bl	8014310 <memset>
 8014210:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 8014214:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 8014218:	4620      	mov	r0, r4
 801421a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801421c:	3468      	adds	r4, #104	; 0x68
 801421e:	e7d9      	b.n	80141d4 <__sfp+0x1c>
 8014220:	2104      	movs	r1, #4
 8014222:	4638      	mov	r0, r7
 8014224:	f7ff ff62 	bl	80140ec <__sfmoreglue>
 8014228:	4604      	mov	r4, r0
 801422a:	6030      	str	r0, [r6, #0]
 801422c:	2800      	cmp	r0, #0
 801422e:	d1d5      	bne.n	80141dc <__sfp+0x24>
 8014230:	f7ff ff78 	bl	8014124 <__sfp_lock_release>
 8014234:	230c      	movs	r3, #12
 8014236:	603b      	str	r3, [r7, #0]
 8014238:	e7ee      	b.n	8014218 <__sfp+0x60>
 801423a:	bf00      	nop
 801423c:	2400857c 	.word	0x2400857c
 8014240:	ffff0001 	.word	0xffff0001

08014244 <_fwalk_reent>:
 8014244:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8014248:	4606      	mov	r6, r0
 801424a:	4688      	mov	r8, r1
 801424c:	f100 0448 	add.w	r4, r0, #72	; 0x48
 8014250:	2700      	movs	r7, #0
 8014252:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8014256:	f1b9 0901 	subs.w	r9, r9, #1
 801425a:	d505      	bpl.n	8014268 <_fwalk_reent+0x24>
 801425c:	6824      	ldr	r4, [r4, #0]
 801425e:	2c00      	cmp	r4, #0
 8014260:	d1f7      	bne.n	8014252 <_fwalk_reent+0xe>
 8014262:	4638      	mov	r0, r7
 8014264:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8014268:	89ab      	ldrh	r3, [r5, #12]
 801426a:	2b01      	cmp	r3, #1
 801426c:	d907      	bls.n	801427e <_fwalk_reent+0x3a>
 801426e:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8014272:	3301      	adds	r3, #1
 8014274:	d003      	beq.n	801427e <_fwalk_reent+0x3a>
 8014276:	4629      	mov	r1, r5
 8014278:	4630      	mov	r0, r6
 801427a:	47c0      	blx	r8
 801427c:	4307      	orrs	r7, r0
 801427e:	3568      	adds	r5, #104	; 0x68
 8014280:	e7e9      	b.n	8014256 <_fwalk_reent+0x12>
	...

08014284 <__libc_init_array>:
 8014284:	b570      	push	{r4, r5, r6, lr}
 8014286:	4d0d      	ldr	r5, [pc, #52]	; (80142bc <__libc_init_array+0x38>)
 8014288:	4c0d      	ldr	r4, [pc, #52]	; (80142c0 <__libc_init_array+0x3c>)
 801428a:	1b64      	subs	r4, r4, r5
 801428c:	10a4      	asrs	r4, r4, #2
 801428e:	2600      	movs	r6, #0
 8014290:	42a6      	cmp	r6, r4
 8014292:	d109      	bne.n	80142a8 <__libc_init_array+0x24>
 8014294:	4d0b      	ldr	r5, [pc, #44]	; (80142c4 <__libc_init_array+0x40>)
 8014296:	4c0c      	ldr	r4, [pc, #48]	; (80142c8 <__libc_init_array+0x44>)
 8014298:	f000 ffb8 	bl	801520c <_init>
 801429c:	1b64      	subs	r4, r4, r5
 801429e:	10a4      	asrs	r4, r4, #2
 80142a0:	2600      	movs	r6, #0
 80142a2:	42a6      	cmp	r6, r4
 80142a4:	d105      	bne.n	80142b2 <__libc_init_array+0x2e>
 80142a6:	bd70      	pop	{r4, r5, r6, pc}
 80142a8:	f855 3b04 	ldr.w	r3, [r5], #4
 80142ac:	4798      	blx	r3
 80142ae:	3601      	adds	r6, #1
 80142b0:	e7ee      	b.n	8014290 <__libc_init_array+0xc>
 80142b2:	f855 3b04 	ldr.w	r3, [r5], #4
 80142b6:	4798      	blx	r3
 80142b8:	3601      	adds	r6, #1
 80142ba:	e7f2      	b.n	80142a2 <__libc_init_array+0x1e>
 80142bc:	0801522c 	.word	0x0801522c
 80142c0:	0801522c 	.word	0x0801522c
 80142c4:	0801522c 	.word	0x0801522c
 80142c8:	08015234 	.word	0x08015234

080142cc <__retarget_lock_init_recursive>:
 80142cc:	4770      	bx	lr

080142ce <__retarget_lock_acquire_recursive>:
 80142ce:	4770      	bx	lr

080142d0 <__retarget_lock_release_recursive>:
 80142d0:	4770      	bx	lr
	...

080142d4 <malloc>:
 80142d4:	4b02      	ldr	r3, [pc, #8]	; (80142e0 <malloc+0xc>)
 80142d6:	4601      	mov	r1, r0
 80142d8:	6818      	ldr	r0, [r3, #0]
 80142da:	f000 b88d 	b.w	80143f8 <_malloc_r>
 80142de:	bf00      	nop
 80142e0:	24008184 	.word	0x24008184

080142e4 <free>:
 80142e4:	4b02      	ldr	r3, [pc, #8]	; (80142f0 <free+0xc>)
 80142e6:	4601      	mov	r1, r0
 80142e8:	6818      	ldr	r0, [r3, #0]
 80142ea:	f000 b819 	b.w	8014320 <_free_r>
 80142ee:	bf00      	nop
 80142f0:	24008184 	.word	0x24008184

080142f4 <memcpy>:
 80142f4:	440a      	add	r2, r1
 80142f6:	4291      	cmp	r1, r2
 80142f8:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80142fc:	d100      	bne.n	8014300 <memcpy+0xc>
 80142fe:	4770      	bx	lr
 8014300:	b510      	push	{r4, lr}
 8014302:	f811 4b01 	ldrb.w	r4, [r1], #1
 8014306:	f803 4f01 	strb.w	r4, [r3, #1]!
 801430a:	4291      	cmp	r1, r2
 801430c:	d1f9      	bne.n	8014302 <memcpy+0xe>
 801430e:	bd10      	pop	{r4, pc}

08014310 <memset>:
 8014310:	4402      	add	r2, r0
 8014312:	4603      	mov	r3, r0
 8014314:	4293      	cmp	r3, r2
 8014316:	d100      	bne.n	801431a <memset+0xa>
 8014318:	4770      	bx	lr
 801431a:	f803 1b01 	strb.w	r1, [r3], #1
 801431e:	e7f9      	b.n	8014314 <memset+0x4>

08014320 <_free_r>:
 8014320:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8014322:	2900      	cmp	r1, #0
 8014324:	d044      	beq.n	80143b0 <_free_r+0x90>
 8014326:	f851 3c04 	ldr.w	r3, [r1, #-4]
 801432a:	9001      	str	r0, [sp, #4]
 801432c:	2b00      	cmp	r3, #0
 801432e:	f1a1 0404 	sub.w	r4, r1, #4
 8014332:	bfb8      	it	lt
 8014334:	18e4      	addlt	r4, r4, r3
 8014336:	f000 fc3b 	bl	8014bb0 <__malloc_lock>
 801433a:	4a1e      	ldr	r2, [pc, #120]	; (80143b4 <_free_r+0x94>)
 801433c:	9801      	ldr	r0, [sp, #4]
 801433e:	6813      	ldr	r3, [r2, #0]
 8014340:	b933      	cbnz	r3, 8014350 <_free_r+0x30>
 8014342:	6063      	str	r3, [r4, #4]
 8014344:	6014      	str	r4, [r2, #0]
 8014346:	b003      	add	sp, #12
 8014348:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 801434c:	f000 bc36 	b.w	8014bbc <__malloc_unlock>
 8014350:	42a3      	cmp	r3, r4
 8014352:	d908      	bls.n	8014366 <_free_r+0x46>
 8014354:	6825      	ldr	r5, [r4, #0]
 8014356:	1961      	adds	r1, r4, r5
 8014358:	428b      	cmp	r3, r1
 801435a:	bf01      	itttt	eq
 801435c:	6819      	ldreq	r1, [r3, #0]
 801435e:	685b      	ldreq	r3, [r3, #4]
 8014360:	1949      	addeq	r1, r1, r5
 8014362:	6021      	streq	r1, [r4, #0]
 8014364:	e7ed      	b.n	8014342 <_free_r+0x22>
 8014366:	461a      	mov	r2, r3
 8014368:	685b      	ldr	r3, [r3, #4]
 801436a:	b10b      	cbz	r3, 8014370 <_free_r+0x50>
 801436c:	42a3      	cmp	r3, r4
 801436e:	d9fa      	bls.n	8014366 <_free_r+0x46>
 8014370:	6811      	ldr	r1, [r2, #0]
 8014372:	1855      	adds	r5, r2, r1
 8014374:	42a5      	cmp	r5, r4
 8014376:	d10b      	bne.n	8014390 <_free_r+0x70>
 8014378:	6824      	ldr	r4, [r4, #0]
 801437a:	4421      	add	r1, r4
 801437c:	1854      	adds	r4, r2, r1
 801437e:	42a3      	cmp	r3, r4
 8014380:	6011      	str	r1, [r2, #0]
 8014382:	d1e0      	bne.n	8014346 <_free_r+0x26>
 8014384:	681c      	ldr	r4, [r3, #0]
 8014386:	685b      	ldr	r3, [r3, #4]
 8014388:	6053      	str	r3, [r2, #4]
 801438a:	4421      	add	r1, r4
 801438c:	6011      	str	r1, [r2, #0]
 801438e:	e7da      	b.n	8014346 <_free_r+0x26>
 8014390:	d902      	bls.n	8014398 <_free_r+0x78>
 8014392:	230c      	movs	r3, #12
 8014394:	6003      	str	r3, [r0, #0]
 8014396:	e7d6      	b.n	8014346 <_free_r+0x26>
 8014398:	6825      	ldr	r5, [r4, #0]
 801439a:	1961      	adds	r1, r4, r5
 801439c:	428b      	cmp	r3, r1
 801439e:	bf04      	itt	eq
 80143a0:	6819      	ldreq	r1, [r3, #0]
 80143a2:	685b      	ldreq	r3, [r3, #4]
 80143a4:	6063      	str	r3, [r4, #4]
 80143a6:	bf04      	itt	eq
 80143a8:	1949      	addeq	r1, r1, r5
 80143aa:	6021      	streq	r1, [r4, #0]
 80143ac:	6054      	str	r4, [r2, #4]
 80143ae:	e7ca      	b.n	8014346 <_free_r+0x26>
 80143b0:	b003      	add	sp, #12
 80143b2:	bd30      	pop	{r4, r5, pc}
 80143b4:	24034c10 	.word	0x24034c10

080143b8 <sbrk_aligned>:
 80143b8:	b570      	push	{r4, r5, r6, lr}
 80143ba:	4e0e      	ldr	r6, [pc, #56]	; (80143f4 <sbrk_aligned+0x3c>)
 80143bc:	460c      	mov	r4, r1
 80143be:	6831      	ldr	r1, [r6, #0]
 80143c0:	4605      	mov	r5, r0
 80143c2:	b911      	cbnz	r1, 80143ca <sbrk_aligned+0x12>
 80143c4:	f000 f984 	bl	80146d0 <_sbrk_r>
 80143c8:	6030      	str	r0, [r6, #0]
 80143ca:	4621      	mov	r1, r4
 80143cc:	4628      	mov	r0, r5
 80143ce:	f000 f97f 	bl	80146d0 <_sbrk_r>
 80143d2:	1c43      	adds	r3, r0, #1
 80143d4:	d00a      	beq.n	80143ec <sbrk_aligned+0x34>
 80143d6:	1cc4      	adds	r4, r0, #3
 80143d8:	f024 0403 	bic.w	r4, r4, #3
 80143dc:	42a0      	cmp	r0, r4
 80143de:	d007      	beq.n	80143f0 <sbrk_aligned+0x38>
 80143e0:	1a21      	subs	r1, r4, r0
 80143e2:	4628      	mov	r0, r5
 80143e4:	f000 f974 	bl	80146d0 <_sbrk_r>
 80143e8:	3001      	adds	r0, #1
 80143ea:	d101      	bne.n	80143f0 <sbrk_aligned+0x38>
 80143ec:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 80143f0:	4620      	mov	r0, r4
 80143f2:	bd70      	pop	{r4, r5, r6, pc}
 80143f4:	24034c14 	.word	0x24034c14

080143f8 <_malloc_r>:
 80143f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80143fc:	1ccd      	adds	r5, r1, #3
 80143fe:	f025 0503 	bic.w	r5, r5, #3
 8014402:	3508      	adds	r5, #8
 8014404:	2d0c      	cmp	r5, #12
 8014406:	bf38      	it	cc
 8014408:	250c      	movcc	r5, #12
 801440a:	2d00      	cmp	r5, #0
 801440c:	4607      	mov	r7, r0
 801440e:	db01      	blt.n	8014414 <_malloc_r+0x1c>
 8014410:	42a9      	cmp	r1, r5
 8014412:	d905      	bls.n	8014420 <_malloc_r+0x28>
 8014414:	230c      	movs	r3, #12
 8014416:	603b      	str	r3, [r7, #0]
 8014418:	2600      	movs	r6, #0
 801441a:	4630      	mov	r0, r6
 801441c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8014420:	4e2e      	ldr	r6, [pc, #184]	; (80144dc <_malloc_r+0xe4>)
 8014422:	f000 fbc5 	bl	8014bb0 <__malloc_lock>
 8014426:	6833      	ldr	r3, [r6, #0]
 8014428:	461c      	mov	r4, r3
 801442a:	bb34      	cbnz	r4, 801447a <_malloc_r+0x82>
 801442c:	4629      	mov	r1, r5
 801442e:	4638      	mov	r0, r7
 8014430:	f7ff ffc2 	bl	80143b8 <sbrk_aligned>
 8014434:	1c43      	adds	r3, r0, #1
 8014436:	4604      	mov	r4, r0
 8014438:	d14d      	bne.n	80144d6 <_malloc_r+0xde>
 801443a:	6834      	ldr	r4, [r6, #0]
 801443c:	4626      	mov	r6, r4
 801443e:	2e00      	cmp	r6, #0
 8014440:	d140      	bne.n	80144c4 <_malloc_r+0xcc>
 8014442:	6823      	ldr	r3, [r4, #0]
 8014444:	4631      	mov	r1, r6
 8014446:	4638      	mov	r0, r7
 8014448:	eb04 0803 	add.w	r8, r4, r3
 801444c:	f000 f940 	bl	80146d0 <_sbrk_r>
 8014450:	4580      	cmp	r8, r0
 8014452:	d13a      	bne.n	80144ca <_malloc_r+0xd2>
 8014454:	6821      	ldr	r1, [r4, #0]
 8014456:	3503      	adds	r5, #3
 8014458:	1a6d      	subs	r5, r5, r1
 801445a:	f025 0503 	bic.w	r5, r5, #3
 801445e:	3508      	adds	r5, #8
 8014460:	2d0c      	cmp	r5, #12
 8014462:	bf38      	it	cc
 8014464:	250c      	movcc	r5, #12
 8014466:	4629      	mov	r1, r5
 8014468:	4638      	mov	r0, r7
 801446a:	f7ff ffa5 	bl	80143b8 <sbrk_aligned>
 801446e:	3001      	adds	r0, #1
 8014470:	d02b      	beq.n	80144ca <_malloc_r+0xd2>
 8014472:	6823      	ldr	r3, [r4, #0]
 8014474:	442b      	add	r3, r5
 8014476:	6023      	str	r3, [r4, #0]
 8014478:	e00e      	b.n	8014498 <_malloc_r+0xa0>
 801447a:	6822      	ldr	r2, [r4, #0]
 801447c:	1b52      	subs	r2, r2, r5
 801447e:	d41e      	bmi.n	80144be <_malloc_r+0xc6>
 8014480:	2a0b      	cmp	r2, #11
 8014482:	d916      	bls.n	80144b2 <_malloc_r+0xba>
 8014484:	1961      	adds	r1, r4, r5
 8014486:	42a3      	cmp	r3, r4
 8014488:	6025      	str	r5, [r4, #0]
 801448a:	bf18      	it	ne
 801448c:	6059      	strne	r1, [r3, #4]
 801448e:	6863      	ldr	r3, [r4, #4]
 8014490:	bf08      	it	eq
 8014492:	6031      	streq	r1, [r6, #0]
 8014494:	5162      	str	r2, [r4, r5]
 8014496:	604b      	str	r3, [r1, #4]
 8014498:	4638      	mov	r0, r7
 801449a:	f104 060b 	add.w	r6, r4, #11
 801449e:	f000 fb8d 	bl	8014bbc <__malloc_unlock>
 80144a2:	f026 0607 	bic.w	r6, r6, #7
 80144a6:	1d23      	adds	r3, r4, #4
 80144a8:	1af2      	subs	r2, r6, r3
 80144aa:	d0b6      	beq.n	801441a <_malloc_r+0x22>
 80144ac:	1b9b      	subs	r3, r3, r6
 80144ae:	50a3      	str	r3, [r4, r2]
 80144b0:	e7b3      	b.n	801441a <_malloc_r+0x22>
 80144b2:	6862      	ldr	r2, [r4, #4]
 80144b4:	42a3      	cmp	r3, r4
 80144b6:	bf0c      	ite	eq
 80144b8:	6032      	streq	r2, [r6, #0]
 80144ba:	605a      	strne	r2, [r3, #4]
 80144bc:	e7ec      	b.n	8014498 <_malloc_r+0xa0>
 80144be:	4623      	mov	r3, r4
 80144c0:	6864      	ldr	r4, [r4, #4]
 80144c2:	e7b2      	b.n	801442a <_malloc_r+0x32>
 80144c4:	4634      	mov	r4, r6
 80144c6:	6876      	ldr	r6, [r6, #4]
 80144c8:	e7b9      	b.n	801443e <_malloc_r+0x46>
 80144ca:	230c      	movs	r3, #12
 80144cc:	603b      	str	r3, [r7, #0]
 80144ce:	4638      	mov	r0, r7
 80144d0:	f000 fb74 	bl	8014bbc <__malloc_unlock>
 80144d4:	e7a1      	b.n	801441a <_malloc_r+0x22>
 80144d6:	6025      	str	r5, [r4, #0]
 80144d8:	e7de      	b.n	8014498 <_malloc_r+0xa0>
 80144da:	bf00      	nop
 80144dc:	24034c10 	.word	0x24034c10

080144e0 <iprintf>:
 80144e0:	b40f      	push	{r0, r1, r2, r3}
 80144e2:	4b0a      	ldr	r3, [pc, #40]	; (801450c <iprintf+0x2c>)
 80144e4:	b513      	push	{r0, r1, r4, lr}
 80144e6:	681c      	ldr	r4, [r3, #0]
 80144e8:	b124      	cbz	r4, 80144f4 <iprintf+0x14>
 80144ea:	69a3      	ldr	r3, [r4, #24]
 80144ec:	b913      	cbnz	r3, 80144f4 <iprintf+0x14>
 80144ee:	4620      	mov	r0, r4
 80144f0:	f7ff fe2a 	bl	8014148 <__sinit>
 80144f4:	ab05      	add	r3, sp, #20
 80144f6:	9a04      	ldr	r2, [sp, #16]
 80144f8:	68a1      	ldr	r1, [r4, #8]
 80144fa:	9301      	str	r3, [sp, #4]
 80144fc:	4620      	mov	r0, r4
 80144fe:	f000 fb8d 	bl	8014c1c <_vfiprintf_r>
 8014502:	b002      	add	sp, #8
 8014504:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8014508:	b004      	add	sp, #16
 801450a:	4770      	bx	lr
 801450c:	24008184 	.word	0x24008184

08014510 <_puts_r>:
 8014510:	b570      	push	{r4, r5, r6, lr}
 8014512:	460e      	mov	r6, r1
 8014514:	4605      	mov	r5, r0
 8014516:	b118      	cbz	r0, 8014520 <_puts_r+0x10>
 8014518:	6983      	ldr	r3, [r0, #24]
 801451a:	b90b      	cbnz	r3, 8014520 <_puts_r+0x10>
 801451c:	f7ff fe14 	bl	8014148 <__sinit>
 8014520:	69ab      	ldr	r3, [r5, #24]
 8014522:	68ac      	ldr	r4, [r5, #8]
 8014524:	b913      	cbnz	r3, 801452c <_puts_r+0x1c>
 8014526:	4628      	mov	r0, r5
 8014528:	f7ff fe0e 	bl	8014148 <__sinit>
 801452c:	4b2c      	ldr	r3, [pc, #176]	; (80145e0 <_puts_r+0xd0>)
 801452e:	429c      	cmp	r4, r3
 8014530:	d120      	bne.n	8014574 <_puts_r+0x64>
 8014532:	686c      	ldr	r4, [r5, #4]
 8014534:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8014536:	07db      	lsls	r3, r3, #31
 8014538:	d405      	bmi.n	8014546 <_puts_r+0x36>
 801453a:	89a3      	ldrh	r3, [r4, #12]
 801453c:	0598      	lsls	r0, r3, #22
 801453e:	d402      	bmi.n	8014546 <_puts_r+0x36>
 8014540:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8014542:	f7ff fec4 	bl	80142ce <__retarget_lock_acquire_recursive>
 8014546:	89a3      	ldrh	r3, [r4, #12]
 8014548:	0719      	lsls	r1, r3, #28
 801454a:	d51d      	bpl.n	8014588 <_puts_r+0x78>
 801454c:	6923      	ldr	r3, [r4, #16]
 801454e:	b1db      	cbz	r3, 8014588 <_puts_r+0x78>
 8014550:	3e01      	subs	r6, #1
 8014552:	68a3      	ldr	r3, [r4, #8]
 8014554:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8014558:	3b01      	subs	r3, #1
 801455a:	60a3      	str	r3, [r4, #8]
 801455c:	bb39      	cbnz	r1, 80145ae <_puts_r+0x9e>
 801455e:	2b00      	cmp	r3, #0
 8014560:	da38      	bge.n	80145d4 <_puts_r+0xc4>
 8014562:	4622      	mov	r2, r4
 8014564:	210a      	movs	r1, #10
 8014566:	4628      	mov	r0, r5
 8014568:	f000 f906 	bl	8014778 <__swbuf_r>
 801456c:	3001      	adds	r0, #1
 801456e:	d011      	beq.n	8014594 <_puts_r+0x84>
 8014570:	250a      	movs	r5, #10
 8014572:	e011      	b.n	8014598 <_puts_r+0x88>
 8014574:	4b1b      	ldr	r3, [pc, #108]	; (80145e4 <_puts_r+0xd4>)
 8014576:	429c      	cmp	r4, r3
 8014578:	d101      	bne.n	801457e <_puts_r+0x6e>
 801457a:	68ac      	ldr	r4, [r5, #8]
 801457c:	e7da      	b.n	8014534 <_puts_r+0x24>
 801457e:	4b1a      	ldr	r3, [pc, #104]	; (80145e8 <_puts_r+0xd8>)
 8014580:	429c      	cmp	r4, r3
 8014582:	bf08      	it	eq
 8014584:	68ec      	ldreq	r4, [r5, #12]
 8014586:	e7d5      	b.n	8014534 <_puts_r+0x24>
 8014588:	4621      	mov	r1, r4
 801458a:	4628      	mov	r0, r5
 801458c:	f000 f958 	bl	8014840 <__swsetup_r>
 8014590:	2800      	cmp	r0, #0
 8014592:	d0dd      	beq.n	8014550 <_puts_r+0x40>
 8014594:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 8014598:	6e63      	ldr	r3, [r4, #100]	; 0x64
 801459a:	07da      	lsls	r2, r3, #31
 801459c:	d405      	bmi.n	80145aa <_puts_r+0x9a>
 801459e:	89a3      	ldrh	r3, [r4, #12]
 80145a0:	059b      	lsls	r3, r3, #22
 80145a2:	d402      	bmi.n	80145aa <_puts_r+0x9a>
 80145a4:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80145a6:	f7ff fe93 	bl	80142d0 <__retarget_lock_release_recursive>
 80145aa:	4628      	mov	r0, r5
 80145ac:	bd70      	pop	{r4, r5, r6, pc}
 80145ae:	2b00      	cmp	r3, #0
 80145b0:	da04      	bge.n	80145bc <_puts_r+0xac>
 80145b2:	69a2      	ldr	r2, [r4, #24]
 80145b4:	429a      	cmp	r2, r3
 80145b6:	dc06      	bgt.n	80145c6 <_puts_r+0xb6>
 80145b8:	290a      	cmp	r1, #10
 80145ba:	d004      	beq.n	80145c6 <_puts_r+0xb6>
 80145bc:	6823      	ldr	r3, [r4, #0]
 80145be:	1c5a      	adds	r2, r3, #1
 80145c0:	6022      	str	r2, [r4, #0]
 80145c2:	7019      	strb	r1, [r3, #0]
 80145c4:	e7c5      	b.n	8014552 <_puts_r+0x42>
 80145c6:	4622      	mov	r2, r4
 80145c8:	4628      	mov	r0, r5
 80145ca:	f000 f8d5 	bl	8014778 <__swbuf_r>
 80145ce:	3001      	adds	r0, #1
 80145d0:	d1bf      	bne.n	8014552 <_puts_r+0x42>
 80145d2:	e7df      	b.n	8014594 <_puts_r+0x84>
 80145d4:	6823      	ldr	r3, [r4, #0]
 80145d6:	250a      	movs	r5, #10
 80145d8:	1c5a      	adds	r2, r3, #1
 80145da:	6022      	str	r2, [r4, #0]
 80145dc:	701d      	strb	r5, [r3, #0]
 80145de:	e7db      	b.n	8014598 <_puts_r+0x88>
 80145e0:	2400853c 	.word	0x2400853c
 80145e4:	2400855c 	.word	0x2400855c
 80145e8:	2400851c 	.word	0x2400851c

080145ec <puts>:
 80145ec:	4b02      	ldr	r3, [pc, #8]	; (80145f8 <puts+0xc>)
 80145ee:	4601      	mov	r1, r0
 80145f0:	6818      	ldr	r0, [r3, #0]
 80145f2:	f7ff bf8d 	b.w	8014510 <_puts_r>
 80145f6:	bf00      	nop
 80145f8:	24008184 	.word	0x24008184

080145fc <cleanup_glue>:
 80145fc:	b538      	push	{r3, r4, r5, lr}
 80145fe:	460c      	mov	r4, r1
 8014600:	6809      	ldr	r1, [r1, #0]
 8014602:	4605      	mov	r5, r0
 8014604:	b109      	cbz	r1, 801460a <cleanup_glue+0xe>
 8014606:	f7ff fff9 	bl	80145fc <cleanup_glue>
 801460a:	4621      	mov	r1, r4
 801460c:	4628      	mov	r0, r5
 801460e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8014612:	f7ff be85 	b.w	8014320 <_free_r>
	...

08014618 <_reclaim_reent>:
 8014618:	4b2c      	ldr	r3, [pc, #176]	; (80146cc <_reclaim_reent+0xb4>)
 801461a:	681b      	ldr	r3, [r3, #0]
 801461c:	4283      	cmp	r3, r0
 801461e:	b570      	push	{r4, r5, r6, lr}
 8014620:	4604      	mov	r4, r0
 8014622:	d051      	beq.n	80146c8 <_reclaim_reent+0xb0>
 8014624:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8014626:	b143      	cbz	r3, 801463a <_reclaim_reent+0x22>
 8014628:	68db      	ldr	r3, [r3, #12]
 801462a:	2b00      	cmp	r3, #0
 801462c:	d14a      	bne.n	80146c4 <_reclaim_reent+0xac>
 801462e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8014630:	6819      	ldr	r1, [r3, #0]
 8014632:	b111      	cbz	r1, 801463a <_reclaim_reent+0x22>
 8014634:	4620      	mov	r0, r4
 8014636:	f7ff fe73 	bl	8014320 <_free_r>
 801463a:	6961      	ldr	r1, [r4, #20]
 801463c:	b111      	cbz	r1, 8014644 <_reclaim_reent+0x2c>
 801463e:	4620      	mov	r0, r4
 8014640:	f7ff fe6e 	bl	8014320 <_free_r>
 8014644:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8014646:	b111      	cbz	r1, 801464e <_reclaim_reent+0x36>
 8014648:	4620      	mov	r0, r4
 801464a:	f7ff fe69 	bl	8014320 <_free_r>
 801464e:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8014650:	b111      	cbz	r1, 8014658 <_reclaim_reent+0x40>
 8014652:	4620      	mov	r0, r4
 8014654:	f7ff fe64 	bl	8014320 <_free_r>
 8014658:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 801465a:	b111      	cbz	r1, 8014662 <_reclaim_reent+0x4a>
 801465c:	4620      	mov	r0, r4
 801465e:	f7ff fe5f 	bl	8014320 <_free_r>
 8014662:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8014664:	b111      	cbz	r1, 801466c <_reclaim_reent+0x54>
 8014666:	4620      	mov	r0, r4
 8014668:	f7ff fe5a 	bl	8014320 <_free_r>
 801466c:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 801466e:	b111      	cbz	r1, 8014676 <_reclaim_reent+0x5e>
 8014670:	4620      	mov	r0, r4
 8014672:	f7ff fe55 	bl	8014320 <_free_r>
 8014676:	6da1      	ldr	r1, [r4, #88]	; 0x58
 8014678:	b111      	cbz	r1, 8014680 <_reclaim_reent+0x68>
 801467a:	4620      	mov	r0, r4
 801467c:	f7ff fe50 	bl	8014320 <_free_r>
 8014680:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8014682:	b111      	cbz	r1, 801468a <_reclaim_reent+0x72>
 8014684:	4620      	mov	r0, r4
 8014686:	f7ff fe4b 	bl	8014320 <_free_r>
 801468a:	69a3      	ldr	r3, [r4, #24]
 801468c:	b1e3      	cbz	r3, 80146c8 <_reclaim_reent+0xb0>
 801468e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8014690:	4620      	mov	r0, r4
 8014692:	4798      	blx	r3
 8014694:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8014696:	b1b9      	cbz	r1, 80146c8 <_reclaim_reent+0xb0>
 8014698:	4620      	mov	r0, r4
 801469a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 801469e:	f7ff bfad 	b.w	80145fc <cleanup_glue>
 80146a2:	5949      	ldr	r1, [r1, r5]
 80146a4:	b941      	cbnz	r1, 80146b8 <_reclaim_reent+0xa0>
 80146a6:	3504      	adds	r5, #4
 80146a8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80146aa:	2d80      	cmp	r5, #128	; 0x80
 80146ac:	68d9      	ldr	r1, [r3, #12]
 80146ae:	d1f8      	bne.n	80146a2 <_reclaim_reent+0x8a>
 80146b0:	4620      	mov	r0, r4
 80146b2:	f7ff fe35 	bl	8014320 <_free_r>
 80146b6:	e7ba      	b.n	801462e <_reclaim_reent+0x16>
 80146b8:	680e      	ldr	r6, [r1, #0]
 80146ba:	4620      	mov	r0, r4
 80146bc:	f7ff fe30 	bl	8014320 <_free_r>
 80146c0:	4631      	mov	r1, r6
 80146c2:	e7ef      	b.n	80146a4 <_reclaim_reent+0x8c>
 80146c4:	2500      	movs	r5, #0
 80146c6:	e7ef      	b.n	80146a8 <_reclaim_reent+0x90>
 80146c8:	bd70      	pop	{r4, r5, r6, pc}
 80146ca:	bf00      	nop
 80146cc:	24008184 	.word	0x24008184

080146d0 <_sbrk_r>:
 80146d0:	b538      	push	{r3, r4, r5, lr}
 80146d2:	4d06      	ldr	r5, [pc, #24]	; (80146ec <_sbrk_r+0x1c>)
 80146d4:	2300      	movs	r3, #0
 80146d6:	4604      	mov	r4, r0
 80146d8:	4608      	mov	r0, r1
 80146da:	602b      	str	r3, [r5, #0]
 80146dc:	f7f6 fa8c 	bl	800abf8 <_sbrk>
 80146e0:	1c43      	adds	r3, r0, #1
 80146e2:	d102      	bne.n	80146ea <_sbrk_r+0x1a>
 80146e4:	682b      	ldr	r3, [r5, #0]
 80146e6:	b103      	cbz	r3, 80146ea <_sbrk_r+0x1a>
 80146e8:	6023      	str	r3, [r4, #0]
 80146ea:	bd38      	pop	{r3, r4, r5, pc}
 80146ec:	24034c18 	.word	0x24034c18

080146f0 <__sread>:
 80146f0:	b510      	push	{r4, lr}
 80146f2:	460c      	mov	r4, r1
 80146f4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80146f8:	f000 fd54 	bl	80151a4 <_read_r>
 80146fc:	2800      	cmp	r0, #0
 80146fe:	bfab      	itete	ge
 8014700:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8014702:	89a3      	ldrhlt	r3, [r4, #12]
 8014704:	181b      	addge	r3, r3, r0
 8014706:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 801470a:	bfac      	ite	ge
 801470c:	6563      	strge	r3, [r4, #84]	; 0x54
 801470e:	81a3      	strhlt	r3, [r4, #12]
 8014710:	bd10      	pop	{r4, pc}

08014712 <__swrite>:
 8014712:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8014716:	461f      	mov	r7, r3
 8014718:	898b      	ldrh	r3, [r1, #12]
 801471a:	05db      	lsls	r3, r3, #23
 801471c:	4605      	mov	r5, r0
 801471e:	460c      	mov	r4, r1
 8014720:	4616      	mov	r6, r2
 8014722:	d505      	bpl.n	8014730 <__swrite+0x1e>
 8014724:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8014728:	2302      	movs	r3, #2
 801472a:	2200      	movs	r2, #0
 801472c:	f000 f9c8 	bl	8014ac0 <_lseek_r>
 8014730:	89a3      	ldrh	r3, [r4, #12]
 8014732:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8014736:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 801473a:	81a3      	strh	r3, [r4, #12]
 801473c:	4632      	mov	r2, r6
 801473e:	463b      	mov	r3, r7
 8014740:	4628      	mov	r0, r5
 8014742:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8014746:	f000 b869 	b.w	801481c <_write_r>

0801474a <__sseek>:
 801474a:	b510      	push	{r4, lr}
 801474c:	460c      	mov	r4, r1
 801474e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8014752:	f000 f9b5 	bl	8014ac0 <_lseek_r>
 8014756:	1c43      	adds	r3, r0, #1
 8014758:	89a3      	ldrh	r3, [r4, #12]
 801475a:	bf15      	itete	ne
 801475c:	6560      	strne	r0, [r4, #84]	; 0x54
 801475e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8014762:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8014766:	81a3      	strheq	r3, [r4, #12]
 8014768:	bf18      	it	ne
 801476a:	81a3      	strhne	r3, [r4, #12]
 801476c:	bd10      	pop	{r4, pc}

0801476e <__sclose>:
 801476e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8014772:	f000 b8d3 	b.w	801491c <_close_r>
	...

08014778 <__swbuf_r>:
 8014778:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801477a:	460e      	mov	r6, r1
 801477c:	4614      	mov	r4, r2
 801477e:	4605      	mov	r5, r0
 8014780:	b118      	cbz	r0, 801478a <__swbuf_r+0x12>
 8014782:	6983      	ldr	r3, [r0, #24]
 8014784:	b90b      	cbnz	r3, 801478a <__swbuf_r+0x12>
 8014786:	f7ff fcdf 	bl	8014148 <__sinit>
 801478a:	4b21      	ldr	r3, [pc, #132]	; (8014810 <__swbuf_r+0x98>)
 801478c:	429c      	cmp	r4, r3
 801478e:	d12b      	bne.n	80147e8 <__swbuf_r+0x70>
 8014790:	686c      	ldr	r4, [r5, #4]
 8014792:	69a3      	ldr	r3, [r4, #24]
 8014794:	60a3      	str	r3, [r4, #8]
 8014796:	89a3      	ldrh	r3, [r4, #12]
 8014798:	071a      	lsls	r2, r3, #28
 801479a:	d52f      	bpl.n	80147fc <__swbuf_r+0x84>
 801479c:	6923      	ldr	r3, [r4, #16]
 801479e:	b36b      	cbz	r3, 80147fc <__swbuf_r+0x84>
 80147a0:	6923      	ldr	r3, [r4, #16]
 80147a2:	6820      	ldr	r0, [r4, #0]
 80147a4:	1ac0      	subs	r0, r0, r3
 80147a6:	6963      	ldr	r3, [r4, #20]
 80147a8:	b2f6      	uxtb	r6, r6
 80147aa:	4283      	cmp	r3, r0
 80147ac:	4637      	mov	r7, r6
 80147ae:	dc04      	bgt.n	80147ba <__swbuf_r+0x42>
 80147b0:	4621      	mov	r1, r4
 80147b2:	4628      	mov	r0, r5
 80147b4:	f000 f948 	bl	8014a48 <_fflush_r>
 80147b8:	bb30      	cbnz	r0, 8014808 <__swbuf_r+0x90>
 80147ba:	68a3      	ldr	r3, [r4, #8]
 80147bc:	3b01      	subs	r3, #1
 80147be:	60a3      	str	r3, [r4, #8]
 80147c0:	6823      	ldr	r3, [r4, #0]
 80147c2:	1c5a      	adds	r2, r3, #1
 80147c4:	6022      	str	r2, [r4, #0]
 80147c6:	701e      	strb	r6, [r3, #0]
 80147c8:	6963      	ldr	r3, [r4, #20]
 80147ca:	3001      	adds	r0, #1
 80147cc:	4283      	cmp	r3, r0
 80147ce:	d004      	beq.n	80147da <__swbuf_r+0x62>
 80147d0:	89a3      	ldrh	r3, [r4, #12]
 80147d2:	07db      	lsls	r3, r3, #31
 80147d4:	d506      	bpl.n	80147e4 <__swbuf_r+0x6c>
 80147d6:	2e0a      	cmp	r6, #10
 80147d8:	d104      	bne.n	80147e4 <__swbuf_r+0x6c>
 80147da:	4621      	mov	r1, r4
 80147dc:	4628      	mov	r0, r5
 80147de:	f000 f933 	bl	8014a48 <_fflush_r>
 80147e2:	b988      	cbnz	r0, 8014808 <__swbuf_r+0x90>
 80147e4:	4638      	mov	r0, r7
 80147e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80147e8:	4b0a      	ldr	r3, [pc, #40]	; (8014814 <__swbuf_r+0x9c>)
 80147ea:	429c      	cmp	r4, r3
 80147ec:	d101      	bne.n	80147f2 <__swbuf_r+0x7a>
 80147ee:	68ac      	ldr	r4, [r5, #8]
 80147f0:	e7cf      	b.n	8014792 <__swbuf_r+0x1a>
 80147f2:	4b09      	ldr	r3, [pc, #36]	; (8014818 <__swbuf_r+0xa0>)
 80147f4:	429c      	cmp	r4, r3
 80147f6:	bf08      	it	eq
 80147f8:	68ec      	ldreq	r4, [r5, #12]
 80147fa:	e7ca      	b.n	8014792 <__swbuf_r+0x1a>
 80147fc:	4621      	mov	r1, r4
 80147fe:	4628      	mov	r0, r5
 8014800:	f000 f81e 	bl	8014840 <__swsetup_r>
 8014804:	2800      	cmp	r0, #0
 8014806:	d0cb      	beq.n	80147a0 <__swbuf_r+0x28>
 8014808:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 801480c:	e7ea      	b.n	80147e4 <__swbuf_r+0x6c>
 801480e:	bf00      	nop
 8014810:	2400853c 	.word	0x2400853c
 8014814:	2400855c 	.word	0x2400855c
 8014818:	2400851c 	.word	0x2400851c

0801481c <_write_r>:
 801481c:	b538      	push	{r3, r4, r5, lr}
 801481e:	4d07      	ldr	r5, [pc, #28]	; (801483c <_write_r+0x20>)
 8014820:	4604      	mov	r4, r0
 8014822:	4608      	mov	r0, r1
 8014824:	4611      	mov	r1, r2
 8014826:	2200      	movs	r2, #0
 8014828:	602a      	str	r2, [r5, #0]
 801482a:	461a      	mov	r2, r3
 801482c:	f7f6 f9c8 	bl	800abc0 <_write>
 8014830:	1c43      	adds	r3, r0, #1
 8014832:	d102      	bne.n	801483a <_write_r+0x1e>
 8014834:	682b      	ldr	r3, [r5, #0]
 8014836:	b103      	cbz	r3, 801483a <_write_r+0x1e>
 8014838:	6023      	str	r3, [r4, #0]
 801483a:	bd38      	pop	{r3, r4, r5, pc}
 801483c:	24034c18 	.word	0x24034c18

08014840 <__swsetup_r>:
 8014840:	4b32      	ldr	r3, [pc, #200]	; (801490c <__swsetup_r+0xcc>)
 8014842:	b570      	push	{r4, r5, r6, lr}
 8014844:	681d      	ldr	r5, [r3, #0]
 8014846:	4606      	mov	r6, r0
 8014848:	460c      	mov	r4, r1
 801484a:	b125      	cbz	r5, 8014856 <__swsetup_r+0x16>
 801484c:	69ab      	ldr	r3, [r5, #24]
 801484e:	b913      	cbnz	r3, 8014856 <__swsetup_r+0x16>
 8014850:	4628      	mov	r0, r5
 8014852:	f7ff fc79 	bl	8014148 <__sinit>
 8014856:	4b2e      	ldr	r3, [pc, #184]	; (8014910 <__swsetup_r+0xd0>)
 8014858:	429c      	cmp	r4, r3
 801485a:	d10f      	bne.n	801487c <__swsetup_r+0x3c>
 801485c:	686c      	ldr	r4, [r5, #4]
 801485e:	89a3      	ldrh	r3, [r4, #12]
 8014860:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8014864:	0719      	lsls	r1, r3, #28
 8014866:	d42c      	bmi.n	80148c2 <__swsetup_r+0x82>
 8014868:	06dd      	lsls	r5, r3, #27
 801486a:	d411      	bmi.n	8014890 <__swsetup_r+0x50>
 801486c:	2309      	movs	r3, #9
 801486e:	6033      	str	r3, [r6, #0]
 8014870:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 8014874:	81a3      	strh	r3, [r4, #12]
 8014876:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 801487a:	e03e      	b.n	80148fa <__swsetup_r+0xba>
 801487c:	4b25      	ldr	r3, [pc, #148]	; (8014914 <__swsetup_r+0xd4>)
 801487e:	429c      	cmp	r4, r3
 8014880:	d101      	bne.n	8014886 <__swsetup_r+0x46>
 8014882:	68ac      	ldr	r4, [r5, #8]
 8014884:	e7eb      	b.n	801485e <__swsetup_r+0x1e>
 8014886:	4b24      	ldr	r3, [pc, #144]	; (8014918 <__swsetup_r+0xd8>)
 8014888:	429c      	cmp	r4, r3
 801488a:	bf08      	it	eq
 801488c:	68ec      	ldreq	r4, [r5, #12]
 801488e:	e7e6      	b.n	801485e <__swsetup_r+0x1e>
 8014890:	0758      	lsls	r0, r3, #29
 8014892:	d512      	bpl.n	80148ba <__swsetup_r+0x7a>
 8014894:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8014896:	b141      	cbz	r1, 80148aa <__swsetup_r+0x6a>
 8014898:	f104 0344 	add.w	r3, r4, #68	; 0x44
 801489c:	4299      	cmp	r1, r3
 801489e:	d002      	beq.n	80148a6 <__swsetup_r+0x66>
 80148a0:	4630      	mov	r0, r6
 80148a2:	f7ff fd3d 	bl	8014320 <_free_r>
 80148a6:	2300      	movs	r3, #0
 80148a8:	6363      	str	r3, [r4, #52]	; 0x34
 80148aa:	89a3      	ldrh	r3, [r4, #12]
 80148ac:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 80148b0:	81a3      	strh	r3, [r4, #12]
 80148b2:	2300      	movs	r3, #0
 80148b4:	6063      	str	r3, [r4, #4]
 80148b6:	6923      	ldr	r3, [r4, #16]
 80148b8:	6023      	str	r3, [r4, #0]
 80148ba:	89a3      	ldrh	r3, [r4, #12]
 80148bc:	f043 0308 	orr.w	r3, r3, #8
 80148c0:	81a3      	strh	r3, [r4, #12]
 80148c2:	6923      	ldr	r3, [r4, #16]
 80148c4:	b94b      	cbnz	r3, 80148da <__swsetup_r+0x9a>
 80148c6:	89a3      	ldrh	r3, [r4, #12]
 80148c8:	f403 7320 	and.w	r3, r3, #640	; 0x280
 80148cc:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80148d0:	d003      	beq.n	80148da <__swsetup_r+0x9a>
 80148d2:	4621      	mov	r1, r4
 80148d4:	4630      	mov	r0, r6
 80148d6:	f000 f92b 	bl	8014b30 <__smakebuf_r>
 80148da:	89a0      	ldrh	r0, [r4, #12]
 80148dc:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80148e0:	f010 0301 	ands.w	r3, r0, #1
 80148e4:	d00a      	beq.n	80148fc <__swsetup_r+0xbc>
 80148e6:	2300      	movs	r3, #0
 80148e8:	60a3      	str	r3, [r4, #8]
 80148ea:	6963      	ldr	r3, [r4, #20]
 80148ec:	425b      	negs	r3, r3
 80148ee:	61a3      	str	r3, [r4, #24]
 80148f0:	6923      	ldr	r3, [r4, #16]
 80148f2:	b943      	cbnz	r3, 8014906 <__swsetup_r+0xc6>
 80148f4:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 80148f8:	d1ba      	bne.n	8014870 <__swsetup_r+0x30>
 80148fa:	bd70      	pop	{r4, r5, r6, pc}
 80148fc:	0781      	lsls	r1, r0, #30
 80148fe:	bf58      	it	pl
 8014900:	6963      	ldrpl	r3, [r4, #20]
 8014902:	60a3      	str	r3, [r4, #8]
 8014904:	e7f4      	b.n	80148f0 <__swsetup_r+0xb0>
 8014906:	2000      	movs	r0, #0
 8014908:	e7f7      	b.n	80148fa <__swsetup_r+0xba>
 801490a:	bf00      	nop
 801490c:	24008184 	.word	0x24008184
 8014910:	2400853c 	.word	0x2400853c
 8014914:	2400855c 	.word	0x2400855c
 8014918:	2400851c 	.word	0x2400851c

0801491c <_close_r>:
 801491c:	b538      	push	{r3, r4, r5, lr}
 801491e:	4d06      	ldr	r5, [pc, #24]	; (8014938 <_close_r+0x1c>)
 8014920:	2300      	movs	r3, #0
 8014922:	4604      	mov	r4, r0
 8014924:	4608      	mov	r0, r1
 8014926:	602b      	str	r3, [r5, #0]
 8014928:	f7f6 f958 	bl	800abdc <_close>
 801492c:	1c43      	adds	r3, r0, #1
 801492e:	d102      	bne.n	8014936 <_close_r+0x1a>
 8014930:	682b      	ldr	r3, [r5, #0]
 8014932:	b103      	cbz	r3, 8014936 <_close_r+0x1a>
 8014934:	6023      	str	r3, [r4, #0]
 8014936:	bd38      	pop	{r3, r4, r5, pc}
 8014938:	24034c18 	.word	0x24034c18

0801493c <__sflush_r>:
 801493c:	898a      	ldrh	r2, [r1, #12]
 801493e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8014942:	4605      	mov	r5, r0
 8014944:	0710      	lsls	r0, r2, #28
 8014946:	460c      	mov	r4, r1
 8014948:	d458      	bmi.n	80149fc <__sflush_r+0xc0>
 801494a:	684b      	ldr	r3, [r1, #4]
 801494c:	2b00      	cmp	r3, #0
 801494e:	dc05      	bgt.n	801495c <__sflush_r+0x20>
 8014950:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8014952:	2b00      	cmp	r3, #0
 8014954:	dc02      	bgt.n	801495c <__sflush_r+0x20>
 8014956:	2000      	movs	r0, #0
 8014958:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801495c:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 801495e:	2e00      	cmp	r6, #0
 8014960:	d0f9      	beq.n	8014956 <__sflush_r+0x1a>
 8014962:	2300      	movs	r3, #0
 8014964:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8014968:	682f      	ldr	r7, [r5, #0]
 801496a:	602b      	str	r3, [r5, #0]
 801496c:	d032      	beq.n	80149d4 <__sflush_r+0x98>
 801496e:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8014970:	89a3      	ldrh	r3, [r4, #12]
 8014972:	075a      	lsls	r2, r3, #29
 8014974:	d505      	bpl.n	8014982 <__sflush_r+0x46>
 8014976:	6863      	ldr	r3, [r4, #4]
 8014978:	1ac0      	subs	r0, r0, r3
 801497a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 801497c:	b10b      	cbz	r3, 8014982 <__sflush_r+0x46>
 801497e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8014980:	1ac0      	subs	r0, r0, r3
 8014982:	2300      	movs	r3, #0
 8014984:	4602      	mov	r2, r0
 8014986:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8014988:	6a21      	ldr	r1, [r4, #32]
 801498a:	4628      	mov	r0, r5
 801498c:	47b0      	blx	r6
 801498e:	1c43      	adds	r3, r0, #1
 8014990:	89a3      	ldrh	r3, [r4, #12]
 8014992:	d106      	bne.n	80149a2 <__sflush_r+0x66>
 8014994:	6829      	ldr	r1, [r5, #0]
 8014996:	291d      	cmp	r1, #29
 8014998:	d82c      	bhi.n	80149f4 <__sflush_r+0xb8>
 801499a:	4a2a      	ldr	r2, [pc, #168]	; (8014a44 <__sflush_r+0x108>)
 801499c:	40ca      	lsrs	r2, r1
 801499e:	07d6      	lsls	r6, r2, #31
 80149a0:	d528      	bpl.n	80149f4 <__sflush_r+0xb8>
 80149a2:	2200      	movs	r2, #0
 80149a4:	6062      	str	r2, [r4, #4]
 80149a6:	04d9      	lsls	r1, r3, #19
 80149a8:	6922      	ldr	r2, [r4, #16]
 80149aa:	6022      	str	r2, [r4, #0]
 80149ac:	d504      	bpl.n	80149b8 <__sflush_r+0x7c>
 80149ae:	1c42      	adds	r2, r0, #1
 80149b0:	d101      	bne.n	80149b6 <__sflush_r+0x7a>
 80149b2:	682b      	ldr	r3, [r5, #0]
 80149b4:	b903      	cbnz	r3, 80149b8 <__sflush_r+0x7c>
 80149b6:	6560      	str	r0, [r4, #84]	; 0x54
 80149b8:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80149ba:	602f      	str	r7, [r5, #0]
 80149bc:	2900      	cmp	r1, #0
 80149be:	d0ca      	beq.n	8014956 <__sflush_r+0x1a>
 80149c0:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80149c4:	4299      	cmp	r1, r3
 80149c6:	d002      	beq.n	80149ce <__sflush_r+0x92>
 80149c8:	4628      	mov	r0, r5
 80149ca:	f7ff fca9 	bl	8014320 <_free_r>
 80149ce:	2000      	movs	r0, #0
 80149d0:	6360      	str	r0, [r4, #52]	; 0x34
 80149d2:	e7c1      	b.n	8014958 <__sflush_r+0x1c>
 80149d4:	6a21      	ldr	r1, [r4, #32]
 80149d6:	2301      	movs	r3, #1
 80149d8:	4628      	mov	r0, r5
 80149da:	47b0      	blx	r6
 80149dc:	1c41      	adds	r1, r0, #1
 80149de:	d1c7      	bne.n	8014970 <__sflush_r+0x34>
 80149e0:	682b      	ldr	r3, [r5, #0]
 80149e2:	2b00      	cmp	r3, #0
 80149e4:	d0c4      	beq.n	8014970 <__sflush_r+0x34>
 80149e6:	2b1d      	cmp	r3, #29
 80149e8:	d001      	beq.n	80149ee <__sflush_r+0xb2>
 80149ea:	2b16      	cmp	r3, #22
 80149ec:	d101      	bne.n	80149f2 <__sflush_r+0xb6>
 80149ee:	602f      	str	r7, [r5, #0]
 80149f0:	e7b1      	b.n	8014956 <__sflush_r+0x1a>
 80149f2:	89a3      	ldrh	r3, [r4, #12]
 80149f4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80149f8:	81a3      	strh	r3, [r4, #12]
 80149fa:	e7ad      	b.n	8014958 <__sflush_r+0x1c>
 80149fc:	690f      	ldr	r7, [r1, #16]
 80149fe:	2f00      	cmp	r7, #0
 8014a00:	d0a9      	beq.n	8014956 <__sflush_r+0x1a>
 8014a02:	0793      	lsls	r3, r2, #30
 8014a04:	680e      	ldr	r6, [r1, #0]
 8014a06:	bf08      	it	eq
 8014a08:	694b      	ldreq	r3, [r1, #20]
 8014a0a:	600f      	str	r7, [r1, #0]
 8014a0c:	bf18      	it	ne
 8014a0e:	2300      	movne	r3, #0
 8014a10:	eba6 0807 	sub.w	r8, r6, r7
 8014a14:	608b      	str	r3, [r1, #8]
 8014a16:	f1b8 0f00 	cmp.w	r8, #0
 8014a1a:	dd9c      	ble.n	8014956 <__sflush_r+0x1a>
 8014a1c:	6a21      	ldr	r1, [r4, #32]
 8014a1e:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8014a20:	4643      	mov	r3, r8
 8014a22:	463a      	mov	r2, r7
 8014a24:	4628      	mov	r0, r5
 8014a26:	47b0      	blx	r6
 8014a28:	2800      	cmp	r0, #0
 8014a2a:	dc06      	bgt.n	8014a3a <__sflush_r+0xfe>
 8014a2c:	89a3      	ldrh	r3, [r4, #12]
 8014a2e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8014a32:	81a3      	strh	r3, [r4, #12]
 8014a34:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8014a38:	e78e      	b.n	8014958 <__sflush_r+0x1c>
 8014a3a:	4407      	add	r7, r0
 8014a3c:	eba8 0800 	sub.w	r8, r8, r0
 8014a40:	e7e9      	b.n	8014a16 <__sflush_r+0xda>
 8014a42:	bf00      	nop
 8014a44:	20400001 	.word	0x20400001

08014a48 <_fflush_r>:
 8014a48:	b538      	push	{r3, r4, r5, lr}
 8014a4a:	690b      	ldr	r3, [r1, #16]
 8014a4c:	4605      	mov	r5, r0
 8014a4e:	460c      	mov	r4, r1
 8014a50:	b913      	cbnz	r3, 8014a58 <_fflush_r+0x10>
 8014a52:	2500      	movs	r5, #0
 8014a54:	4628      	mov	r0, r5
 8014a56:	bd38      	pop	{r3, r4, r5, pc}
 8014a58:	b118      	cbz	r0, 8014a62 <_fflush_r+0x1a>
 8014a5a:	6983      	ldr	r3, [r0, #24]
 8014a5c:	b90b      	cbnz	r3, 8014a62 <_fflush_r+0x1a>
 8014a5e:	f7ff fb73 	bl	8014148 <__sinit>
 8014a62:	4b14      	ldr	r3, [pc, #80]	; (8014ab4 <_fflush_r+0x6c>)
 8014a64:	429c      	cmp	r4, r3
 8014a66:	d11b      	bne.n	8014aa0 <_fflush_r+0x58>
 8014a68:	686c      	ldr	r4, [r5, #4]
 8014a6a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8014a6e:	2b00      	cmp	r3, #0
 8014a70:	d0ef      	beq.n	8014a52 <_fflush_r+0xa>
 8014a72:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8014a74:	07d0      	lsls	r0, r2, #31
 8014a76:	d404      	bmi.n	8014a82 <_fflush_r+0x3a>
 8014a78:	0599      	lsls	r1, r3, #22
 8014a7a:	d402      	bmi.n	8014a82 <_fflush_r+0x3a>
 8014a7c:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8014a7e:	f7ff fc26 	bl	80142ce <__retarget_lock_acquire_recursive>
 8014a82:	4628      	mov	r0, r5
 8014a84:	4621      	mov	r1, r4
 8014a86:	f7ff ff59 	bl	801493c <__sflush_r>
 8014a8a:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8014a8c:	07da      	lsls	r2, r3, #31
 8014a8e:	4605      	mov	r5, r0
 8014a90:	d4e0      	bmi.n	8014a54 <_fflush_r+0xc>
 8014a92:	89a3      	ldrh	r3, [r4, #12]
 8014a94:	059b      	lsls	r3, r3, #22
 8014a96:	d4dd      	bmi.n	8014a54 <_fflush_r+0xc>
 8014a98:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8014a9a:	f7ff fc19 	bl	80142d0 <__retarget_lock_release_recursive>
 8014a9e:	e7d9      	b.n	8014a54 <_fflush_r+0xc>
 8014aa0:	4b05      	ldr	r3, [pc, #20]	; (8014ab8 <_fflush_r+0x70>)
 8014aa2:	429c      	cmp	r4, r3
 8014aa4:	d101      	bne.n	8014aaa <_fflush_r+0x62>
 8014aa6:	68ac      	ldr	r4, [r5, #8]
 8014aa8:	e7df      	b.n	8014a6a <_fflush_r+0x22>
 8014aaa:	4b04      	ldr	r3, [pc, #16]	; (8014abc <_fflush_r+0x74>)
 8014aac:	429c      	cmp	r4, r3
 8014aae:	bf08      	it	eq
 8014ab0:	68ec      	ldreq	r4, [r5, #12]
 8014ab2:	e7da      	b.n	8014a6a <_fflush_r+0x22>
 8014ab4:	2400853c 	.word	0x2400853c
 8014ab8:	2400855c 	.word	0x2400855c
 8014abc:	2400851c 	.word	0x2400851c

08014ac0 <_lseek_r>:
 8014ac0:	b538      	push	{r3, r4, r5, lr}
 8014ac2:	4d07      	ldr	r5, [pc, #28]	; (8014ae0 <_lseek_r+0x20>)
 8014ac4:	4604      	mov	r4, r0
 8014ac6:	4608      	mov	r0, r1
 8014ac8:	4611      	mov	r1, r2
 8014aca:	2200      	movs	r2, #0
 8014acc:	602a      	str	r2, [r5, #0]
 8014ace:	461a      	mov	r2, r3
 8014ad0:	f7f6 f890 	bl	800abf4 <_lseek>
 8014ad4:	1c43      	adds	r3, r0, #1
 8014ad6:	d102      	bne.n	8014ade <_lseek_r+0x1e>
 8014ad8:	682b      	ldr	r3, [r5, #0]
 8014ada:	b103      	cbz	r3, 8014ade <_lseek_r+0x1e>
 8014adc:	6023      	str	r3, [r4, #0]
 8014ade:	bd38      	pop	{r3, r4, r5, pc}
 8014ae0:	24034c18 	.word	0x24034c18

08014ae4 <__swhatbuf_r>:
 8014ae4:	b570      	push	{r4, r5, r6, lr}
 8014ae6:	460e      	mov	r6, r1
 8014ae8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8014aec:	2900      	cmp	r1, #0
 8014aee:	b096      	sub	sp, #88	; 0x58
 8014af0:	4614      	mov	r4, r2
 8014af2:	461d      	mov	r5, r3
 8014af4:	da08      	bge.n	8014b08 <__swhatbuf_r+0x24>
 8014af6:	f9b6 300c 	ldrsh.w	r3, [r6, #12]
 8014afa:	2200      	movs	r2, #0
 8014afc:	602a      	str	r2, [r5, #0]
 8014afe:	061a      	lsls	r2, r3, #24
 8014b00:	d410      	bmi.n	8014b24 <__swhatbuf_r+0x40>
 8014b02:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8014b06:	e00e      	b.n	8014b26 <__swhatbuf_r+0x42>
 8014b08:	466a      	mov	r2, sp
 8014b0a:	f000 fb5d 	bl	80151c8 <_fstat_r>
 8014b0e:	2800      	cmp	r0, #0
 8014b10:	dbf1      	blt.n	8014af6 <__swhatbuf_r+0x12>
 8014b12:	9a01      	ldr	r2, [sp, #4]
 8014b14:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 8014b18:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 8014b1c:	425a      	negs	r2, r3
 8014b1e:	415a      	adcs	r2, r3
 8014b20:	602a      	str	r2, [r5, #0]
 8014b22:	e7ee      	b.n	8014b02 <__swhatbuf_r+0x1e>
 8014b24:	2340      	movs	r3, #64	; 0x40
 8014b26:	2000      	movs	r0, #0
 8014b28:	6023      	str	r3, [r4, #0]
 8014b2a:	b016      	add	sp, #88	; 0x58
 8014b2c:	bd70      	pop	{r4, r5, r6, pc}
	...

08014b30 <__smakebuf_r>:
 8014b30:	898b      	ldrh	r3, [r1, #12]
 8014b32:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8014b34:	079d      	lsls	r5, r3, #30
 8014b36:	4606      	mov	r6, r0
 8014b38:	460c      	mov	r4, r1
 8014b3a:	d507      	bpl.n	8014b4c <__smakebuf_r+0x1c>
 8014b3c:	f104 0347 	add.w	r3, r4, #71	; 0x47
 8014b40:	6023      	str	r3, [r4, #0]
 8014b42:	6123      	str	r3, [r4, #16]
 8014b44:	2301      	movs	r3, #1
 8014b46:	6163      	str	r3, [r4, #20]
 8014b48:	b002      	add	sp, #8
 8014b4a:	bd70      	pop	{r4, r5, r6, pc}
 8014b4c:	ab01      	add	r3, sp, #4
 8014b4e:	466a      	mov	r2, sp
 8014b50:	f7ff ffc8 	bl	8014ae4 <__swhatbuf_r>
 8014b54:	9900      	ldr	r1, [sp, #0]
 8014b56:	4605      	mov	r5, r0
 8014b58:	4630      	mov	r0, r6
 8014b5a:	f7ff fc4d 	bl	80143f8 <_malloc_r>
 8014b5e:	b948      	cbnz	r0, 8014b74 <__smakebuf_r+0x44>
 8014b60:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8014b64:	059a      	lsls	r2, r3, #22
 8014b66:	d4ef      	bmi.n	8014b48 <__smakebuf_r+0x18>
 8014b68:	f023 0303 	bic.w	r3, r3, #3
 8014b6c:	f043 0302 	orr.w	r3, r3, #2
 8014b70:	81a3      	strh	r3, [r4, #12]
 8014b72:	e7e3      	b.n	8014b3c <__smakebuf_r+0xc>
 8014b74:	4b0d      	ldr	r3, [pc, #52]	; (8014bac <__smakebuf_r+0x7c>)
 8014b76:	62b3      	str	r3, [r6, #40]	; 0x28
 8014b78:	89a3      	ldrh	r3, [r4, #12]
 8014b7a:	6020      	str	r0, [r4, #0]
 8014b7c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8014b80:	81a3      	strh	r3, [r4, #12]
 8014b82:	9b00      	ldr	r3, [sp, #0]
 8014b84:	6163      	str	r3, [r4, #20]
 8014b86:	9b01      	ldr	r3, [sp, #4]
 8014b88:	6120      	str	r0, [r4, #16]
 8014b8a:	b15b      	cbz	r3, 8014ba4 <__smakebuf_r+0x74>
 8014b8c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8014b90:	4630      	mov	r0, r6
 8014b92:	f000 fb2b 	bl	80151ec <_isatty_r>
 8014b96:	b128      	cbz	r0, 8014ba4 <__smakebuf_r+0x74>
 8014b98:	89a3      	ldrh	r3, [r4, #12]
 8014b9a:	f023 0303 	bic.w	r3, r3, #3
 8014b9e:	f043 0301 	orr.w	r3, r3, #1
 8014ba2:	81a3      	strh	r3, [r4, #12]
 8014ba4:	89a0      	ldrh	r0, [r4, #12]
 8014ba6:	4305      	orrs	r5, r0
 8014ba8:	81a5      	strh	r5, [r4, #12]
 8014baa:	e7cd      	b.n	8014b48 <__smakebuf_r+0x18>
 8014bac:	080140e1 	.word	0x080140e1

08014bb0 <__malloc_lock>:
 8014bb0:	4801      	ldr	r0, [pc, #4]	; (8014bb8 <__malloc_lock+0x8>)
 8014bb2:	f7ff bb8c 	b.w	80142ce <__retarget_lock_acquire_recursive>
 8014bb6:	bf00      	nop
 8014bb8:	24034c0c 	.word	0x24034c0c

08014bbc <__malloc_unlock>:
 8014bbc:	4801      	ldr	r0, [pc, #4]	; (8014bc4 <__malloc_unlock+0x8>)
 8014bbe:	f7ff bb87 	b.w	80142d0 <__retarget_lock_release_recursive>
 8014bc2:	bf00      	nop
 8014bc4:	24034c0c 	.word	0x24034c0c

08014bc8 <__sfputc_r>:
 8014bc8:	6893      	ldr	r3, [r2, #8]
 8014bca:	3b01      	subs	r3, #1
 8014bcc:	2b00      	cmp	r3, #0
 8014bce:	b410      	push	{r4}
 8014bd0:	6093      	str	r3, [r2, #8]
 8014bd2:	da08      	bge.n	8014be6 <__sfputc_r+0x1e>
 8014bd4:	6994      	ldr	r4, [r2, #24]
 8014bd6:	42a3      	cmp	r3, r4
 8014bd8:	db01      	blt.n	8014bde <__sfputc_r+0x16>
 8014bda:	290a      	cmp	r1, #10
 8014bdc:	d103      	bne.n	8014be6 <__sfputc_r+0x1e>
 8014bde:	f85d 4b04 	ldr.w	r4, [sp], #4
 8014be2:	f7ff bdc9 	b.w	8014778 <__swbuf_r>
 8014be6:	6813      	ldr	r3, [r2, #0]
 8014be8:	1c58      	adds	r0, r3, #1
 8014bea:	6010      	str	r0, [r2, #0]
 8014bec:	7019      	strb	r1, [r3, #0]
 8014bee:	4608      	mov	r0, r1
 8014bf0:	f85d 4b04 	ldr.w	r4, [sp], #4
 8014bf4:	4770      	bx	lr

08014bf6 <__sfputs_r>:
 8014bf6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014bf8:	4606      	mov	r6, r0
 8014bfa:	460f      	mov	r7, r1
 8014bfc:	4614      	mov	r4, r2
 8014bfe:	18d5      	adds	r5, r2, r3
 8014c00:	42ac      	cmp	r4, r5
 8014c02:	d101      	bne.n	8014c08 <__sfputs_r+0x12>
 8014c04:	2000      	movs	r0, #0
 8014c06:	e007      	b.n	8014c18 <__sfputs_r+0x22>
 8014c08:	f814 1b01 	ldrb.w	r1, [r4], #1
 8014c0c:	463a      	mov	r2, r7
 8014c0e:	4630      	mov	r0, r6
 8014c10:	f7ff ffda 	bl	8014bc8 <__sfputc_r>
 8014c14:	1c43      	adds	r3, r0, #1
 8014c16:	d1f3      	bne.n	8014c00 <__sfputs_r+0xa>
 8014c18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08014c1c <_vfiprintf_r>:
 8014c1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014c20:	460d      	mov	r5, r1
 8014c22:	b09d      	sub	sp, #116	; 0x74
 8014c24:	4614      	mov	r4, r2
 8014c26:	4698      	mov	r8, r3
 8014c28:	4606      	mov	r6, r0
 8014c2a:	b118      	cbz	r0, 8014c34 <_vfiprintf_r+0x18>
 8014c2c:	6983      	ldr	r3, [r0, #24]
 8014c2e:	b90b      	cbnz	r3, 8014c34 <_vfiprintf_r+0x18>
 8014c30:	f7ff fa8a 	bl	8014148 <__sinit>
 8014c34:	4b89      	ldr	r3, [pc, #548]	; (8014e5c <_vfiprintf_r+0x240>)
 8014c36:	429d      	cmp	r5, r3
 8014c38:	d11b      	bne.n	8014c72 <_vfiprintf_r+0x56>
 8014c3a:	6875      	ldr	r5, [r6, #4]
 8014c3c:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8014c3e:	07d9      	lsls	r1, r3, #31
 8014c40:	d405      	bmi.n	8014c4e <_vfiprintf_r+0x32>
 8014c42:	89ab      	ldrh	r3, [r5, #12]
 8014c44:	059a      	lsls	r2, r3, #22
 8014c46:	d402      	bmi.n	8014c4e <_vfiprintf_r+0x32>
 8014c48:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8014c4a:	f7ff fb40 	bl	80142ce <__retarget_lock_acquire_recursive>
 8014c4e:	89ab      	ldrh	r3, [r5, #12]
 8014c50:	071b      	lsls	r3, r3, #28
 8014c52:	d501      	bpl.n	8014c58 <_vfiprintf_r+0x3c>
 8014c54:	692b      	ldr	r3, [r5, #16]
 8014c56:	b9eb      	cbnz	r3, 8014c94 <_vfiprintf_r+0x78>
 8014c58:	4629      	mov	r1, r5
 8014c5a:	4630      	mov	r0, r6
 8014c5c:	f7ff fdf0 	bl	8014840 <__swsetup_r>
 8014c60:	b1c0      	cbz	r0, 8014c94 <_vfiprintf_r+0x78>
 8014c62:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8014c64:	07dc      	lsls	r4, r3, #31
 8014c66:	d50e      	bpl.n	8014c86 <_vfiprintf_r+0x6a>
 8014c68:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8014c6c:	b01d      	add	sp, #116	; 0x74
 8014c6e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8014c72:	4b7b      	ldr	r3, [pc, #492]	; (8014e60 <_vfiprintf_r+0x244>)
 8014c74:	429d      	cmp	r5, r3
 8014c76:	d101      	bne.n	8014c7c <_vfiprintf_r+0x60>
 8014c78:	68b5      	ldr	r5, [r6, #8]
 8014c7a:	e7df      	b.n	8014c3c <_vfiprintf_r+0x20>
 8014c7c:	4b79      	ldr	r3, [pc, #484]	; (8014e64 <_vfiprintf_r+0x248>)
 8014c7e:	429d      	cmp	r5, r3
 8014c80:	bf08      	it	eq
 8014c82:	68f5      	ldreq	r5, [r6, #12]
 8014c84:	e7da      	b.n	8014c3c <_vfiprintf_r+0x20>
 8014c86:	89ab      	ldrh	r3, [r5, #12]
 8014c88:	0598      	lsls	r0, r3, #22
 8014c8a:	d4ed      	bmi.n	8014c68 <_vfiprintf_r+0x4c>
 8014c8c:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8014c8e:	f7ff fb1f 	bl	80142d0 <__retarget_lock_release_recursive>
 8014c92:	e7e9      	b.n	8014c68 <_vfiprintf_r+0x4c>
 8014c94:	2300      	movs	r3, #0
 8014c96:	9309      	str	r3, [sp, #36]	; 0x24
 8014c98:	2320      	movs	r3, #32
 8014c9a:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8014c9e:	f8cd 800c 	str.w	r8, [sp, #12]
 8014ca2:	2330      	movs	r3, #48	; 0x30
 8014ca4:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 8014e68 <_vfiprintf_r+0x24c>
 8014ca8:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8014cac:	f04f 0901 	mov.w	r9, #1
 8014cb0:	4623      	mov	r3, r4
 8014cb2:	469a      	mov	sl, r3
 8014cb4:	f813 2b01 	ldrb.w	r2, [r3], #1
 8014cb8:	b10a      	cbz	r2, 8014cbe <_vfiprintf_r+0xa2>
 8014cba:	2a25      	cmp	r2, #37	; 0x25
 8014cbc:	d1f9      	bne.n	8014cb2 <_vfiprintf_r+0x96>
 8014cbe:	ebba 0b04 	subs.w	fp, sl, r4
 8014cc2:	d00b      	beq.n	8014cdc <_vfiprintf_r+0xc0>
 8014cc4:	465b      	mov	r3, fp
 8014cc6:	4622      	mov	r2, r4
 8014cc8:	4629      	mov	r1, r5
 8014cca:	4630      	mov	r0, r6
 8014ccc:	f7ff ff93 	bl	8014bf6 <__sfputs_r>
 8014cd0:	3001      	adds	r0, #1
 8014cd2:	f000 80aa 	beq.w	8014e2a <_vfiprintf_r+0x20e>
 8014cd6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8014cd8:	445a      	add	r2, fp
 8014cda:	9209      	str	r2, [sp, #36]	; 0x24
 8014cdc:	f89a 3000 	ldrb.w	r3, [sl]
 8014ce0:	2b00      	cmp	r3, #0
 8014ce2:	f000 80a2 	beq.w	8014e2a <_vfiprintf_r+0x20e>
 8014ce6:	2300      	movs	r3, #0
 8014ce8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8014cec:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8014cf0:	f10a 0a01 	add.w	sl, sl, #1
 8014cf4:	9304      	str	r3, [sp, #16]
 8014cf6:	9307      	str	r3, [sp, #28]
 8014cf8:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8014cfc:	931a      	str	r3, [sp, #104]	; 0x68
 8014cfe:	4654      	mov	r4, sl
 8014d00:	2205      	movs	r2, #5
 8014d02:	f814 1b01 	ldrb.w	r1, [r4], #1
 8014d06:	4858      	ldr	r0, [pc, #352]	; (8014e68 <_vfiprintf_r+0x24c>)
 8014d08:	f7f4 f9aa 	bl	8009060 <memchr>
 8014d0c:	9a04      	ldr	r2, [sp, #16]
 8014d0e:	b9d8      	cbnz	r0, 8014d48 <_vfiprintf_r+0x12c>
 8014d10:	06d1      	lsls	r1, r2, #27
 8014d12:	bf44      	itt	mi
 8014d14:	2320      	movmi	r3, #32
 8014d16:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8014d1a:	0713      	lsls	r3, r2, #28
 8014d1c:	bf44      	itt	mi
 8014d1e:	232b      	movmi	r3, #43	; 0x2b
 8014d20:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8014d24:	f89a 3000 	ldrb.w	r3, [sl]
 8014d28:	2b2a      	cmp	r3, #42	; 0x2a
 8014d2a:	d015      	beq.n	8014d58 <_vfiprintf_r+0x13c>
 8014d2c:	9a07      	ldr	r2, [sp, #28]
 8014d2e:	4654      	mov	r4, sl
 8014d30:	2000      	movs	r0, #0
 8014d32:	f04f 0c0a 	mov.w	ip, #10
 8014d36:	4621      	mov	r1, r4
 8014d38:	f811 3b01 	ldrb.w	r3, [r1], #1
 8014d3c:	3b30      	subs	r3, #48	; 0x30
 8014d3e:	2b09      	cmp	r3, #9
 8014d40:	d94e      	bls.n	8014de0 <_vfiprintf_r+0x1c4>
 8014d42:	b1b0      	cbz	r0, 8014d72 <_vfiprintf_r+0x156>
 8014d44:	9207      	str	r2, [sp, #28]
 8014d46:	e014      	b.n	8014d72 <_vfiprintf_r+0x156>
 8014d48:	eba0 0308 	sub.w	r3, r0, r8
 8014d4c:	fa09 f303 	lsl.w	r3, r9, r3
 8014d50:	4313      	orrs	r3, r2
 8014d52:	9304      	str	r3, [sp, #16]
 8014d54:	46a2      	mov	sl, r4
 8014d56:	e7d2      	b.n	8014cfe <_vfiprintf_r+0xe2>
 8014d58:	9b03      	ldr	r3, [sp, #12]
 8014d5a:	1d19      	adds	r1, r3, #4
 8014d5c:	681b      	ldr	r3, [r3, #0]
 8014d5e:	9103      	str	r1, [sp, #12]
 8014d60:	2b00      	cmp	r3, #0
 8014d62:	bfbb      	ittet	lt
 8014d64:	425b      	neglt	r3, r3
 8014d66:	f042 0202 	orrlt.w	r2, r2, #2
 8014d6a:	9307      	strge	r3, [sp, #28]
 8014d6c:	9307      	strlt	r3, [sp, #28]
 8014d6e:	bfb8      	it	lt
 8014d70:	9204      	strlt	r2, [sp, #16]
 8014d72:	7823      	ldrb	r3, [r4, #0]
 8014d74:	2b2e      	cmp	r3, #46	; 0x2e
 8014d76:	d10c      	bne.n	8014d92 <_vfiprintf_r+0x176>
 8014d78:	7863      	ldrb	r3, [r4, #1]
 8014d7a:	2b2a      	cmp	r3, #42	; 0x2a
 8014d7c:	d135      	bne.n	8014dea <_vfiprintf_r+0x1ce>
 8014d7e:	9b03      	ldr	r3, [sp, #12]
 8014d80:	1d1a      	adds	r2, r3, #4
 8014d82:	681b      	ldr	r3, [r3, #0]
 8014d84:	9203      	str	r2, [sp, #12]
 8014d86:	2b00      	cmp	r3, #0
 8014d88:	bfb8      	it	lt
 8014d8a:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
 8014d8e:	3402      	adds	r4, #2
 8014d90:	9305      	str	r3, [sp, #20]
 8014d92:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 8014e78 <_vfiprintf_r+0x25c>
 8014d96:	7821      	ldrb	r1, [r4, #0]
 8014d98:	2203      	movs	r2, #3
 8014d9a:	4650      	mov	r0, sl
 8014d9c:	f7f4 f960 	bl	8009060 <memchr>
 8014da0:	b140      	cbz	r0, 8014db4 <_vfiprintf_r+0x198>
 8014da2:	2340      	movs	r3, #64	; 0x40
 8014da4:	eba0 000a 	sub.w	r0, r0, sl
 8014da8:	fa03 f000 	lsl.w	r0, r3, r0
 8014dac:	9b04      	ldr	r3, [sp, #16]
 8014dae:	4303      	orrs	r3, r0
 8014db0:	3401      	adds	r4, #1
 8014db2:	9304      	str	r3, [sp, #16]
 8014db4:	f814 1b01 	ldrb.w	r1, [r4], #1
 8014db8:	482c      	ldr	r0, [pc, #176]	; (8014e6c <_vfiprintf_r+0x250>)
 8014dba:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8014dbe:	2206      	movs	r2, #6
 8014dc0:	f7f4 f94e 	bl	8009060 <memchr>
 8014dc4:	2800      	cmp	r0, #0
 8014dc6:	d03f      	beq.n	8014e48 <_vfiprintf_r+0x22c>
 8014dc8:	4b29      	ldr	r3, [pc, #164]	; (8014e70 <_vfiprintf_r+0x254>)
 8014dca:	bb1b      	cbnz	r3, 8014e14 <_vfiprintf_r+0x1f8>
 8014dcc:	9b03      	ldr	r3, [sp, #12]
 8014dce:	3307      	adds	r3, #7
 8014dd0:	f023 0307 	bic.w	r3, r3, #7
 8014dd4:	3308      	adds	r3, #8
 8014dd6:	9303      	str	r3, [sp, #12]
 8014dd8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8014dda:	443b      	add	r3, r7
 8014ddc:	9309      	str	r3, [sp, #36]	; 0x24
 8014dde:	e767      	b.n	8014cb0 <_vfiprintf_r+0x94>
 8014de0:	fb0c 3202 	mla	r2, ip, r2, r3
 8014de4:	460c      	mov	r4, r1
 8014de6:	2001      	movs	r0, #1
 8014de8:	e7a5      	b.n	8014d36 <_vfiprintf_r+0x11a>
 8014dea:	2300      	movs	r3, #0
 8014dec:	3401      	adds	r4, #1
 8014dee:	9305      	str	r3, [sp, #20]
 8014df0:	4619      	mov	r1, r3
 8014df2:	f04f 0c0a 	mov.w	ip, #10
 8014df6:	4620      	mov	r0, r4
 8014df8:	f810 2b01 	ldrb.w	r2, [r0], #1
 8014dfc:	3a30      	subs	r2, #48	; 0x30
 8014dfe:	2a09      	cmp	r2, #9
 8014e00:	d903      	bls.n	8014e0a <_vfiprintf_r+0x1ee>
 8014e02:	2b00      	cmp	r3, #0
 8014e04:	d0c5      	beq.n	8014d92 <_vfiprintf_r+0x176>
 8014e06:	9105      	str	r1, [sp, #20]
 8014e08:	e7c3      	b.n	8014d92 <_vfiprintf_r+0x176>
 8014e0a:	fb0c 2101 	mla	r1, ip, r1, r2
 8014e0e:	4604      	mov	r4, r0
 8014e10:	2301      	movs	r3, #1
 8014e12:	e7f0      	b.n	8014df6 <_vfiprintf_r+0x1da>
 8014e14:	ab03      	add	r3, sp, #12
 8014e16:	9300      	str	r3, [sp, #0]
 8014e18:	462a      	mov	r2, r5
 8014e1a:	4b16      	ldr	r3, [pc, #88]	; (8014e74 <_vfiprintf_r+0x258>)
 8014e1c:	a904      	add	r1, sp, #16
 8014e1e:	4630      	mov	r0, r6
 8014e20:	f3af 8000 	nop.w
 8014e24:	4607      	mov	r7, r0
 8014e26:	1c78      	adds	r0, r7, #1
 8014e28:	d1d6      	bne.n	8014dd8 <_vfiprintf_r+0x1bc>
 8014e2a:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8014e2c:	07d9      	lsls	r1, r3, #31
 8014e2e:	d405      	bmi.n	8014e3c <_vfiprintf_r+0x220>
 8014e30:	89ab      	ldrh	r3, [r5, #12]
 8014e32:	059a      	lsls	r2, r3, #22
 8014e34:	d402      	bmi.n	8014e3c <_vfiprintf_r+0x220>
 8014e36:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8014e38:	f7ff fa4a 	bl	80142d0 <__retarget_lock_release_recursive>
 8014e3c:	89ab      	ldrh	r3, [r5, #12]
 8014e3e:	065b      	lsls	r3, r3, #25
 8014e40:	f53f af12 	bmi.w	8014c68 <_vfiprintf_r+0x4c>
 8014e44:	9809      	ldr	r0, [sp, #36]	; 0x24
 8014e46:	e711      	b.n	8014c6c <_vfiprintf_r+0x50>
 8014e48:	ab03      	add	r3, sp, #12
 8014e4a:	9300      	str	r3, [sp, #0]
 8014e4c:	462a      	mov	r2, r5
 8014e4e:	4b09      	ldr	r3, [pc, #36]	; (8014e74 <_vfiprintf_r+0x258>)
 8014e50:	a904      	add	r1, sp, #16
 8014e52:	4630      	mov	r0, r6
 8014e54:	f000 f880 	bl	8014f58 <_printf_i>
 8014e58:	e7e4      	b.n	8014e24 <_vfiprintf_r+0x208>
 8014e5a:	bf00      	nop
 8014e5c:	2400853c 	.word	0x2400853c
 8014e60:	2400855c 	.word	0x2400855c
 8014e64:	2400851c 	.word	0x2400851c
 8014e68:	24008580 	.word	0x24008580
 8014e6c:	2400858a 	.word	0x2400858a
 8014e70:	00000000 	.word	0x00000000
 8014e74:	08014bf7 	.word	0x08014bf7
 8014e78:	24008586 	.word	0x24008586

08014e7c <_printf_common>:
 8014e7c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014e80:	4616      	mov	r6, r2
 8014e82:	4699      	mov	r9, r3
 8014e84:	688a      	ldr	r2, [r1, #8]
 8014e86:	690b      	ldr	r3, [r1, #16]
 8014e88:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8014e8c:	4293      	cmp	r3, r2
 8014e8e:	bfb8      	it	lt
 8014e90:	4613      	movlt	r3, r2
 8014e92:	6033      	str	r3, [r6, #0]
 8014e94:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8014e98:	4607      	mov	r7, r0
 8014e9a:	460c      	mov	r4, r1
 8014e9c:	b10a      	cbz	r2, 8014ea2 <_printf_common+0x26>
 8014e9e:	3301      	adds	r3, #1
 8014ea0:	6033      	str	r3, [r6, #0]
 8014ea2:	6823      	ldr	r3, [r4, #0]
 8014ea4:	0699      	lsls	r1, r3, #26
 8014ea6:	bf42      	ittt	mi
 8014ea8:	6833      	ldrmi	r3, [r6, #0]
 8014eaa:	3302      	addmi	r3, #2
 8014eac:	6033      	strmi	r3, [r6, #0]
 8014eae:	6825      	ldr	r5, [r4, #0]
 8014eb0:	f015 0506 	ands.w	r5, r5, #6
 8014eb4:	d106      	bne.n	8014ec4 <_printf_common+0x48>
 8014eb6:	f104 0a19 	add.w	sl, r4, #25
 8014eba:	68e3      	ldr	r3, [r4, #12]
 8014ebc:	6832      	ldr	r2, [r6, #0]
 8014ebe:	1a9b      	subs	r3, r3, r2
 8014ec0:	42ab      	cmp	r3, r5
 8014ec2:	dc26      	bgt.n	8014f12 <_printf_common+0x96>
 8014ec4:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 8014ec8:	1e13      	subs	r3, r2, #0
 8014eca:	6822      	ldr	r2, [r4, #0]
 8014ecc:	bf18      	it	ne
 8014ece:	2301      	movne	r3, #1
 8014ed0:	0692      	lsls	r2, r2, #26
 8014ed2:	d42b      	bmi.n	8014f2c <_printf_common+0xb0>
 8014ed4:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8014ed8:	4649      	mov	r1, r9
 8014eda:	4638      	mov	r0, r7
 8014edc:	47c0      	blx	r8
 8014ede:	3001      	adds	r0, #1
 8014ee0:	d01e      	beq.n	8014f20 <_printf_common+0xa4>
 8014ee2:	6823      	ldr	r3, [r4, #0]
 8014ee4:	68e5      	ldr	r5, [r4, #12]
 8014ee6:	6832      	ldr	r2, [r6, #0]
 8014ee8:	f003 0306 	and.w	r3, r3, #6
 8014eec:	2b04      	cmp	r3, #4
 8014eee:	bf08      	it	eq
 8014ef0:	1aad      	subeq	r5, r5, r2
 8014ef2:	68a3      	ldr	r3, [r4, #8]
 8014ef4:	6922      	ldr	r2, [r4, #16]
 8014ef6:	bf0c      	ite	eq
 8014ef8:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8014efc:	2500      	movne	r5, #0
 8014efe:	4293      	cmp	r3, r2
 8014f00:	bfc4      	itt	gt
 8014f02:	1a9b      	subgt	r3, r3, r2
 8014f04:	18ed      	addgt	r5, r5, r3
 8014f06:	2600      	movs	r6, #0
 8014f08:	341a      	adds	r4, #26
 8014f0a:	42b5      	cmp	r5, r6
 8014f0c:	d11a      	bne.n	8014f44 <_printf_common+0xc8>
 8014f0e:	2000      	movs	r0, #0
 8014f10:	e008      	b.n	8014f24 <_printf_common+0xa8>
 8014f12:	2301      	movs	r3, #1
 8014f14:	4652      	mov	r2, sl
 8014f16:	4649      	mov	r1, r9
 8014f18:	4638      	mov	r0, r7
 8014f1a:	47c0      	blx	r8
 8014f1c:	3001      	adds	r0, #1
 8014f1e:	d103      	bne.n	8014f28 <_printf_common+0xac>
 8014f20:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8014f24:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8014f28:	3501      	adds	r5, #1
 8014f2a:	e7c6      	b.n	8014eba <_printf_common+0x3e>
 8014f2c:	18e1      	adds	r1, r4, r3
 8014f2e:	1c5a      	adds	r2, r3, #1
 8014f30:	2030      	movs	r0, #48	; 0x30
 8014f32:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8014f36:	4422      	add	r2, r4
 8014f38:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8014f3c:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8014f40:	3302      	adds	r3, #2
 8014f42:	e7c7      	b.n	8014ed4 <_printf_common+0x58>
 8014f44:	2301      	movs	r3, #1
 8014f46:	4622      	mov	r2, r4
 8014f48:	4649      	mov	r1, r9
 8014f4a:	4638      	mov	r0, r7
 8014f4c:	47c0      	blx	r8
 8014f4e:	3001      	adds	r0, #1
 8014f50:	d0e6      	beq.n	8014f20 <_printf_common+0xa4>
 8014f52:	3601      	adds	r6, #1
 8014f54:	e7d9      	b.n	8014f0a <_printf_common+0x8e>
	...

08014f58 <_printf_i>:
 8014f58:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8014f5c:	7e0f      	ldrb	r7, [r1, #24]
 8014f5e:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8014f60:	2f78      	cmp	r7, #120	; 0x78
 8014f62:	4691      	mov	r9, r2
 8014f64:	4680      	mov	r8, r0
 8014f66:	460c      	mov	r4, r1
 8014f68:	469a      	mov	sl, r3
 8014f6a:	f101 0243 	add.w	r2, r1, #67	; 0x43
 8014f6e:	d807      	bhi.n	8014f80 <_printf_i+0x28>
 8014f70:	2f62      	cmp	r7, #98	; 0x62
 8014f72:	d80a      	bhi.n	8014f8a <_printf_i+0x32>
 8014f74:	2f00      	cmp	r7, #0
 8014f76:	f000 80d8 	beq.w	801512a <_printf_i+0x1d2>
 8014f7a:	2f58      	cmp	r7, #88	; 0x58
 8014f7c:	f000 80a3 	beq.w	80150c6 <_printf_i+0x16e>
 8014f80:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8014f84:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 8014f88:	e03a      	b.n	8015000 <_printf_i+0xa8>
 8014f8a:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 8014f8e:	2b15      	cmp	r3, #21
 8014f90:	d8f6      	bhi.n	8014f80 <_printf_i+0x28>
 8014f92:	a101      	add	r1, pc, #4	; (adr r1, 8014f98 <_printf_i+0x40>)
 8014f94:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8014f98:	08014ff1 	.word	0x08014ff1
 8014f9c:	08015005 	.word	0x08015005
 8014fa0:	08014f81 	.word	0x08014f81
 8014fa4:	08014f81 	.word	0x08014f81
 8014fa8:	08014f81 	.word	0x08014f81
 8014fac:	08014f81 	.word	0x08014f81
 8014fb0:	08015005 	.word	0x08015005
 8014fb4:	08014f81 	.word	0x08014f81
 8014fb8:	08014f81 	.word	0x08014f81
 8014fbc:	08014f81 	.word	0x08014f81
 8014fc0:	08014f81 	.word	0x08014f81
 8014fc4:	08015111 	.word	0x08015111
 8014fc8:	08015035 	.word	0x08015035
 8014fcc:	080150f3 	.word	0x080150f3
 8014fd0:	08014f81 	.word	0x08014f81
 8014fd4:	08014f81 	.word	0x08014f81
 8014fd8:	08015133 	.word	0x08015133
 8014fdc:	08014f81 	.word	0x08014f81
 8014fe0:	08015035 	.word	0x08015035
 8014fe4:	08014f81 	.word	0x08014f81
 8014fe8:	08014f81 	.word	0x08014f81
 8014fec:	080150fb 	.word	0x080150fb
 8014ff0:	682b      	ldr	r3, [r5, #0]
 8014ff2:	1d1a      	adds	r2, r3, #4
 8014ff4:	681b      	ldr	r3, [r3, #0]
 8014ff6:	602a      	str	r2, [r5, #0]
 8014ff8:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8014ffc:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8015000:	2301      	movs	r3, #1
 8015002:	e0a3      	b.n	801514c <_printf_i+0x1f4>
 8015004:	6820      	ldr	r0, [r4, #0]
 8015006:	6829      	ldr	r1, [r5, #0]
 8015008:	0606      	lsls	r6, r0, #24
 801500a:	f101 0304 	add.w	r3, r1, #4
 801500e:	d50a      	bpl.n	8015026 <_printf_i+0xce>
 8015010:	680e      	ldr	r6, [r1, #0]
 8015012:	602b      	str	r3, [r5, #0]
 8015014:	2e00      	cmp	r6, #0
 8015016:	da03      	bge.n	8015020 <_printf_i+0xc8>
 8015018:	232d      	movs	r3, #45	; 0x2d
 801501a:	4276      	negs	r6, r6
 801501c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8015020:	485e      	ldr	r0, [pc, #376]	; (801519c <_printf_i+0x244>)
 8015022:	230a      	movs	r3, #10
 8015024:	e019      	b.n	801505a <_printf_i+0x102>
 8015026:	680e      	ldr	r6, [r1, #0]
 8015028:	602b      	str	r3, [r5, #0]
 801502a:	f010 0f40 	tst.w	r0, #64	; 0x40
 801502e:	bf18      	it	ne
 8015030:	b236      	sxthne	r6, r6
 8015032:	e7ef      	b.n	8015014 <_printf_i+0xbc>
 8015034:	682b      	ldr	r3, [r5, #0]
 8015036:	6820      	ldr	r0, [r4, #0]
 8015038:	1d19      	adds	r1, r3, #4
 801503a:	6029      	str	r1, [r5, #0]
 801503c:	0601      	lsls	r1, r0, #24
 801503e:	d501      	bpl.n	8015044 <_printf_i+0xec>
 8015040:	681e      	ldr	r6, [r3, #0]
 8015042:	e002      	b.n	801504a <_printf_i+0xf2>
 8015044:	0646      	lsls	r6, r0, #25
 8015046:	d5fb      	bpl.n	8015040 <_printf_i+0xe8>
 8015048:	881e      	ldrh	r6, [r3, #0]
 801504a:	4854      	ldr	r0, [pc, #336]	; (801519c <_printf_i+0x244>)
 801504c:	2f6f      	cmp	r7, #111	; 0x6f
 801504e:	bf0c      	ite	eq
 8015050:	2308      	moveq	r3, #8
 8015052:	230a      	movne	r3, #10
 8015054:	2100      	movs	r1, #0
 8015056:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 801505a:	6865      	ldr	r5, [r4, #4]
 801505c:	60a5      	str	r5, [r4, #8]
 801505e:	2d00      	cmp	r5, #0
 8015060:	bfa2      	ittt	ge
 8015062:	6821      	ldrge	r1, [r4, #0]
 8015064:	f021 0104 	bicge.w	r1, r1, #4
 8015068:	6021      	strge	r1, [r4, #0]
 801506a:	b90e      	cbnz	r6, 8015070 <_printf_i+0x118>
 801506c:	2d00      	cmp	r5, #0
 801506e:	d04d      	beq.n	801510c <_printf_i+0x1b4>
 8015070:	4615      	mov	r5, r2
 8015072:	fbb6 f1f3 	udiv	r1, r6, r3
 8015076:	fb03 6711 	mls	r7, r3, r1, r6
 801507a:	5dc7      	ldrb	r7, [r0, r7]
 801507c:	f805 7d01 	strb.w	r7, [r5, #-1]!
 8015080:	4637      	mov	r7, r6
 8015082:	42bb      	cmp	r3, r7
 8015084:	460e      	mov	r6, r1
 8015086:	d9f4      	bls.n	8015072 <_printf_i+0x11a>
 8015088:	2b08      	cmp	r3, #8
 801508a:	d10b      	bne.n	80150a4 <_printf_i+0x14c>
 801508c:	6823      	ldr	r3, [r4, #0]
 801508e:	07de      	lsls	r6, r3, #31
 8015090:	d508      	bpl.n	80150a4 <_printf_i+0x14c>
 8015092:	6923      	ldr	r3, [r4, #16]
 8015094:	6861      	ldr	r1, [r4, #4]
 8015096:	4299      	cmp	r1, r3
 8015098:	bfde      	ittt	le
 801509a:	2330      	movle	r3, #48	; 0x30
 801509c:	f805 3c01 	strble.w	r3, [r5, #-1]
 80150a0:	f105 35ff 	addle.w	r5, r5, #4294967295	; 0xffffffff
 80150a4:	1b52      	subs	r2, r2, r5
 80150a6:	6122      	str	r2, [r4, #16]
 80150a8:	f8cd a000 	str.w	sl, [sp]
 80150ac:	464b      	mov	r3, r9
 80150ae:	aa03      	add	r2, sp, #12
 80150b0:	4621      	mov	r1, r4
 80150b2:	4640      	mov	r0, r8
 80150b4:	f7ff fee2 	bl	8014e7c <_printf_common>
 80150b8:	3001      	adds	r0, #1
 80150ba:	d14c      	bne.n	8015156 <_printf_i+0x1fe>
 80150bc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80150c0:	b004      	add	sp, #16
 80150c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80150c6:	4835      	ldr	r0, [pc, #212]	; (801519c <_printf_i+0x244>)
 80150c8:	f881 7045 	strb.w	r7, [r1, #69]	; 0x45
 80150cc:	6829      	ldr	r1, [r5, #0]
 80150ce:	6823      	ldr	r3, [r4, #0]
 80150d0:	f851 6b04 	ldr.w	r6, [r1], #4
 80150d4:	6029      	str	r1, [r5, #0]
 80150d6:	061d      	lsls	r5, r3, #24
 80150d8:	d514      	bpl.n	8015104 <_printf_i+0x1ac>
 80150da:	07df      	lsls	r7, r3, #31
 80150dc:	bf44      	itt	mi
 80150de:	f043 0320 	orrmi.w	r3, r3, #32
 80150e2:	6023      	strmi	r3, [r4, #0]
 80150e4:	b91e      	cbnz	r6, 80150ee <_printf_i+0x196>
 80150e6:	6823      	ldr	r3, [r4, #0]
 80150e8:	f023 0320 	bic.w	r3, r3, #32
 80150ec:	6023      	str	r3, [r4, #0]
 80150ee:	2310      	movs	r3, #16
 80150f0:	e7b0      	b.n	8015054 <_printf_i+0xfc>
 80150f2:	6823      	ldr	r3, [r4, #0]
 80150f4:	f043 0320 	orr.w	r3, r3, #32
 80150f8:	6023      	str	r3, [r4, #0]
 80150fa:	2378      	movs	r3, #120	; 0x78
 80150fc:	4828      	ldr	r0, [pc, #160]	; (80151a0 <_printf_i+0x248>)
 80150fe:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8015102:	e7e3      	b.n	80150cc <_printf_i+0x174>
 8015104:	0659      	lsls	r1, r3, #25
 8015106:	bf48      	it	mi
 8015108:	b2b6      	uxthmi	r6, r6
 801510a:	e7e6      	b.n	80150da <_printf_i+0x182>
 801510c:	4615      	mov	r5, r2
 801510e:	e7bb      	b.n	8015088 <_printf_i+0x130>
 8015110:	682b      	ldr	r3, [r5, #0]
 8015112:	6826      	ldr	r6, [r4, #0]
 8015114:	6961      	ldr	r1, [r4, #20]
 8015116:	1d18      	adds	r0, r3, #4
 8015118:	6028      	str	r0, [r5, #0]
 801511a:	0635      	lsls	r5, r6, #24
 801511c:	681b      	ldr	r3, [r3, #0]
 801511e:	d501      	bpl.n	8015124 <_printf_i+0x1cc>
 8015120:	6019      	str	r1, [r3, #0]
 8015122:	e002      	b.n	801512a <_printf_i+0x1d2>
 8015124:	0670      	lsls	r0, r6, #25
 8015126:	d5fb      	bpl.n	8015120 <_printf_i+0x1c8>
 8015128:	8019      	strh	r1, [r3, #0]
 801512a:	2300      	movs	r3, #0
 801512c:	6123      	str	r3, [r4, #16]
 801512e:	4615      	mov	r5, r2
 8015130:	e7ba      	b.n	80150a8 <_printf_i+0x150>
 8015132:	682b      	ldr	r3, [r5, #0]
 8015134:	1d1a      	adds	r2, r3, #4
 8015136:	602a      	str	r2, [r5, #0]
 8015138:	681d      	ldr	r5, [r3, #0]
 801513a:	6862      	ldr	r2, [r4, #4]
 801513c:	2100      	movs	r1, #0
 801513e:	4628      	mov	r0, r5
 8015140:	f7f3 ff8e 	bl	8009060 <memchr>
 8015144:	b108      	cbz	r0, 801514a <_printf_i+0x1f2>
 8015146:	1b40      	subs	r0, r0, r5
 8015148:	6060      	str	r0, [r4, #4]
 801514a:	6863      	ldr	r3, [r4, #4]
 801514c:	6123      	str	r3, [r4, #16]
 801514e:	2300      	movs	r3, #0
 8015150:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8015154:	e7a8      	b.n	80150a8 <_printf_i+0x150>
 8015156:	6923      	ldr	r3, [r4, #16]
 8015158:	462a      	mov	r2, r5
 801515a:	4649      	mov	r1, r9
 801515c:	4640      	mov	r0, r8
 801515e:	47d0      	blx	sl
 8015160:	3001      	adds	r0, #1
 8015162:	d0ab      	beq.n	80150bc <_printf_i+0x164>
 8015164:	6823      	ldr	r3, [r4, #0]
 8015166:	079b      	lsls	r3, r3, #30
 8015168:	d413      	bmi.n	8015192 <_printf_i+0x23a>
 801516a:	68e0      	ldr	r0, [r4, #12]
 801516c:	9b03      	ldr	r3, [sp, #12]
 801516e:	4298      	cmp	r0, r3
 8015170:	bfb8      	it	lt
 8015172:	4618      	movlt	r0, r3
 8015174:	e7a4      	b.n	80150c0 <_printf_i+0x168>
 8015176:	2301      	movs	r3, #1
 8015178:	4632      	mov	r2, r6
 801517a:	4649      	mov	r1, r9
 801517c:	4640      	mov	r0, r8
 801517e:	47d0      	blx	sl
 8015180:	3001      	adds	r0, #1
 8015182:	d09b      	beq.n	80150bc <_printf_i+0x164>
 8015184:	3501      	adds	r5, #1
 8015186:	68e3      	ldr	r3, [r4, #12]
 8015188:	9903      	ldr	r1, [sp, #12]
 801518a:	1a5b      	subs	r3, r3, r1
 801518c:	42ab      	cmp	r3, r5
 801518e:	dcf2      	bgt.n	8015176 <_printf_i+0x21e>
 8015190:	e7eb      	b.n	801516a <_printf_i+0x212>
 8015192:	2500      	movs	r5, #0
 8015194:	f104 0619 	add.w	r6, r4, #25
 8015198:	e7f5      	b.n	8015186 <_printf_i+0x22e>
 801519a:	bf00      	nop
 801519c:	24008591 	.word	0x24008591
 80151a0:	240085a2 	.word	0x240085a2

080151a4 <_read_r>:
 80151a4:	b538      	push	{r3, r4, r5, lr}
 80151a6:	4d07      	ldr	r5, [pc, #28]	; (80151c4 <_read_r+0x20>)
 80151a8:	4604      	mov	r4, r0
 80151aa:	4608      	mov	r0, r1
 80151ac:	4611      	mov	r1, r2
 80151ae:	2200      	movs	r2, #0
 80151b0:	602a      	str	r2, [r5, #0]
 80151b2:	461a      	mov	r2, r3
 80151b4:	f7f5 fcf6 	bl	800aba4 <_read>
 80151b8:	1c43      	adds	r3, r0, #1
 80151ba:	d102      	bne.n	80151c2 <_read_r+0x1e>
 80151bc:	682b      	ldr	r3, [r5, #0]
 80151be:	b103      	cbz	r3, 80151c2 <_read_r+0x1e>
 80151c0:	6023      	str	r3, [r4, #0]
 80151c2:	bd38      	pop	{r3, r4, r5, pc}
 80151c4:	24034c18 	.word	0x24034c18

080151c8 <_fstat_r>:
 80151c8:	b538      	push	{r3, r4, r5, lr}
 80151ca:	4d07      	ldr	r5, [pc, #28]	; (80151e8 <_fstat_r+0x20>)
 80151cc:	2300      	movs	r3, #0
 80151ce:	4604      	mov	r4, r0
 80151d0:	4608      	mov	r0, r1
 80151d2:	4611      	mov	r1, r2
 80151d4:	602b      	str	r3, [r5, #0]
 80151d6:	f7f5 fd05 	bl	800abe4 <_fstat>
 80151da:	1c43      	adds	r3, r0, #1
 80151dc:	d102      	bne.n	80151e4 <_fstat_r+0x1c>
 80151de:	682b      	ldr	r3, [r5, #0]
 80151e0:	b103      	cbz	r3, 80151e4 <_fstat_r+0x1c>
 80151e2:	6023      	str	r3, [r4, #0]
 80151e4:	bd38      	pop	{r3, r4, r5, pc}
 80151e6:	bf00      	nop
 80151e8:	24034c18 	.word	0x24034c18

080151ec <_isatty_r>:
 80151ec:	b538      	push	{r3, r4, r5, lr}
 80151ee:	4d06      	ldr	r5, [pc, #24]	; (8015208 <_isatty_r+0x1c>)
 80151f0:	2300      	movs	r3, #0
 80151f2:	4604      	mov	r4, r0
 80151f4:	4608      	mov	r0, r1
 80151f6:	602b      	str	r3, [r5, #0]
 80151f8:	f7f5 fcfa 	bl	800abf0 <_isatty>
 80151fc:	1c43      	adds	r3, r0, #1
 80151fe:	d102      	bne.n	8015206 <_isatty_r+0x1a>
 8015200:	682b      	ldr	r3, [r5, #0]
 8015202:	b103      	cbz	r3, 8015206 <_isatty_r+0x1a>
 8015204:	6023      	str	r3, [r4, #0]
 8015206:	bd38      	pop	{r3, r4, r5, pc}
 8015208:	24034c18 	.word	0x24034c18

0801520c <_init>:
 801520c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801520e:	bf00      	nop
 8015210:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8015212:	bc08      	pop	{r3}
 8015214:	469e      	mov	lr, r3
 8015216:	4770      	bx	lr

08015218 <_fini>:
 8015218:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801521a:	bf00      	nop
 801521c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801521e:	bc08      	pop	{r3}
 8015220:	469e      	mov	lr, r3
 8015222:	4770      	bx	lr
